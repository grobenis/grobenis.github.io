<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode每日打卡 5-11~17</title>
    <url>/2020/05/13/2020-05-11-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>本周打卡题目如下：</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></td>
<td>中等</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>
<li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> d = x;</span><br><span class="line">            <span class="keyword">long</span> N = n;</span><br><span class="line">            <span class="keyword">if</span>(N&lt;<span class="number">0</span>)&#123; d = <span class="number">1</span>/d; N*= <span class="number">-1</span>;&#125;</span><br><span class="line">            <span class="keyword">while</span>(N&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mo = N%<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(mo==<span class="number">1</span>) res*=d;</span><br><span class="line">                N/=<span class="number">2</span>;</span><br><span class="line">                d*=d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li><code>push(x)</code> —— 将元素 x 推入栈中。</li>
<li><code>pop()</code> —— 删除栈顶的元素。</li>
<li><code>top()</code> —— 获取栈顶元素。</li>
<li><code>getMin()</code> —— 检索栈中的最小元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minst;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st.push(x);</span><br><span class="line">        <span class="keyword">if</span>(minst.empty())</span><br><span class="line">            minst.push(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            minst.push(<span class="built_in">min</span>(x,minst.top()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        st.pop();</span><br><span class="line">        minst.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minst.top();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。 </p>
<p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            ret.push_back(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.front(); q.pop();</span><br><span class="line">                ret.back().push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)</span><br><span class="line">            a^=n;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1 :"></a><strong>示例 1 :</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>

<p><strong>说明 :</strong></p>
<ol>
<li>数组的长度为 [1, 20,000]。</li>
<li>数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li>
</ol>
<h3 id="我的解法：暴力"><a href="#我的解法：暴力" class="headerlink" title="我的解法：暴力"></a>我的解法：暴力</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> h = i;h&lt;=j;h++)</span><br><span class="line">                    sum+=nums[h];</span><br><span class="line">                <span class="keyword">if</span>(sum == k)</span><br><span class="line">                    res++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法：哈希"><a href="#官方解法：哈希" class="headerlink" title="官方解法：哈希"></a>官方解法：哈希</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x:nums) &#123;</span><br><span class="line">            pre += x;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) </span><br><span class="line">                count += mp[pre - k];</span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度</strong>：O(n)，其中 n 为数组的长度。我们遍历数组的时间复杂度为 O(n)，中间利用哈希表查询删除的复杂度均为 O(1)，因此总时间复杂度为 O(n)。</p>
<p><strong>空间复杂度</strong>：O(n)，其中 n 为数组的长度。哈希表在最坏情况下可能有 n 个不同的键值，因此需要 O(n) 的空间复杂度。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡5-4~10</title>
    <url>/2020/05/04/2020-05-03-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>本周打卡题目如下：</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></td>
<td>困难</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">983. 最低票价</a></td>
<td>困难</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">572. 另一个树的子树</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></td>
<td>中等</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>假设你总是可以到达数组的最后一个位置。</p>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">steps</span><span class="params">(len,INT_MAX)</span></span>;</span><br><span class="line">        steps[len<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=nums[i]&amp;&amp;((i+j)&lt;len);j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(steps[i+j]!=INT_MAX)    </span><br><span class="line">                    steps[i] = <span class="built_in">min</span>(steps[i],steps[i+j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>会超时</p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(n^2)$，其中 n 是数组长度。有两层嵌套循环，在最坏的情况下，例如数组中的所有元素都是 1，position 需要遍历数组中的每个位置，对于 position 的每个值都有一次循环。</p>
<p>空间复杂度：$O(1)$。</p>
<h3 id="方法二：正向查找可到达的最大位置"><a href="#方法二：正向查找可到达的最大位置" class="headerlink" title="方法二：正向查找可到达的最大位置"></a>方法二：正向查找可到达的最大位置</h3><p>方法一虽然直观，但是时间复杂度比较高，有没有办法降低时间复杂度呢？</p>
<p>如果我们「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。</p>
<p>例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。</p>
<p>从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。</p>
<p><img src="/2020/05/04/2020-05-03-LeetCode-CheckDaily/45_fig1.png" alt="x"></p>
<p>在具体的实现中，我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。</p>
<p>在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxPos = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), <span class="built_in">end</span> = <span class="number">0</span>, <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxPos &gt;= i) &#123;</span><br><span class="line">                maxPos = <span class="built_in">max</span>(maxPos, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="built_in">end</span>) &#123;</span><br><span class="line">                    <span class="built_in">end</span> = maxPos;</span><br><span class="line">                    ++<span class="built_in">step</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)，其中 n 是数组长度。</p>
<p>空间复杂度：O(1)。</p>
<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>思路：设置上界下界进行判断即可；需要注意的是，要对边界值的设置需要注意一点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> MINVAL_FLAG = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> MAXVAL_FLAG = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==INT_MIN &amp;&amp; MINVAL_FLAG) MINVAL_FLAG = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==INT_MAX &amp;&amp; MAXVAL_FLAG) MAXVAL_FLAG = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;left,INT_MIN,root-&gt;val)&amp;&amp; helper(root-&gt;right,root-&gt;val,INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root,<span class="keyword">int</span> minval,<span class="keyword">int</span> maxval)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">' '</span>&lt;&lt;minval&lt;&lt;<span class="string">' '</span>&lt;&lt;maxval&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(minval==root-&gt;val||maxval==root-&gt;val)</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val==INT_MIN &amp;&amp; MINVAL_FLAG&amp;&amp;root-&gt;val&lt;maxval)</span><br><span class="line">                    MINVAL_FLAG = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val==INT_MAX &amp;&amp; MAXVAL_FLAG &amp;&amp;root-&gt;val &gt; minval)</span><br><span class="line">                    MAXVAL_FLAG = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(minval&gt;root-&gt;val||maxval&lt;root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;left,minval,<span class="built_in">min</span>(root-&gt;val,maxval))&amp;&amp;helper(root-&gt;right,<span class="built_in">max</span>(minval,root-&gt;val),maxval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">long</span> <span class="keyword">long</span> lower, <span class="keyword">long</span> <span class="keyword">long</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：中序遍历"><a href="#方法二：中序遍历" class="headerlink" title="方法二：中序遍历"></a>方法二：中序遍历</h4><p><strong>思路和算法</strong></p>
<p>基于方法一中提及的性质，我们可以进一步知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。</p>
<p>可能由读者不知道中序遍历是什么，我们这里简单提及一下，中序遍历是二叉树的一种遍历方式，它先遍历左子树，再遍历根节点，最后遍历右子树。而我们二叉搜索树保证了左子树的节点的值均小于根节点的值，根节点的值均小于右子树的值，因此中序遍历以后得到的序列一定是升序序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> inorder = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() || root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root);</span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (root -&gt; val &lt;= inorder) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            inorder = root -&gt; val;</span><br><span class="line">            root = root -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="983-最低票价"><a href="#983-最低票价" class="headerlink" title="983. 最低票价"></a><a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">983. 最低票价</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 <code>days</code> 的数组给出。每一项是一个从 <code>1</code> 到 <code>365</code> 的整数。</p>
<p>火车票有三种不同的销售方式：</p>
<ul>
<li>一张为期一天的通行证售价为 <code>costs[0]</code> 美元；</li>
<li>一张为期七天的通行证售价为 <code>costs[1]</code> 美元；</li>
<li>一张为期三十天的通行证售价为 <code>costs[2]</code> 美元。</li>
</ul>
<p>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
<p>返回你想要完成在给定的列表 <code>days</code> 中列出的每一天的旅行所需要的最低消费。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：days &#x3D; [1,4,6,7,8,20], costs &#x3D; [2,7,15]</span><br><span class="line">输出：11</span><br><span class="line">解释： </span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 1 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 1 天生效。</span><br><span class="line">在第 3 天，你花了 costs[1] &#x3D; $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。</span><br><span class="line">在第 20 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 20 天生效。</span><br><span class="line">你总共花了 $11，并完成了你计划的每一天旅行。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：days &#x3D; [1,2,3,4,5,6,7,8,9,10,30,31], costs &#x3D; [2,7,15]</span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： </span><br><span class="line">在第 1 天，你花了 costs[2] &#x3D; $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。</span><br><span class="line">在第 31 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 </span><br><span class="line">你总共花了 $17，并完成了你计划的每一天旅行。</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ol>
<li><code>1 &lt;= days.length &lt;= 365</code></li>
<li><code>1 &lt;= days[i] &lt;= 365</code></li>
<li><code>days</code> 按顺序严格递增</li>
<li><code>costs.length == 3</code></li>
<li><code>1 &lt;= costs[i] &lt;= 1000</code></li>
</ol>
<h4 id="方法一：记忆化搜索（日期变量型）"><a href="#方法一：记忆化搜索（日期变量型）" class="headerlink" title="方法一：记忆化搜索（日期变量型）"></a>方法一：记忆化搜索（日期变量型）</h4><h5 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a><strong>思路和算法</strong></h5><p>我们用 $\textit{dp}(i)$ 来表示从第 i天开始到一年的结束，我们需要花的钱。考虑到一张通行证可以让我们在「接下来」的若干天进行旅行，所以我们「从后往前」倒着进行动态规划。</p>
<p>对于一年中的任意一天：</p>
<ul>
<li><p>如果这一天不是必须出行的日期，那我们可以贪心地选择不买。这是因为如果今天不用出行，那么也不必购买通行证，并且通行证越晚买越好。所以有 $\textit{dp}(i) = \textit{dp}(i + 1)$；</p>
</li>
<li><p>如果这一天是必须出行的日期，我们可以选择买 1，7 或 30天的通行证。若我们购买了 j天的通行证，那么接下来的 j - 1天，我们都不再需要购买通行证，只需要考虑第 i + j天及以后即可。因此，我们有</p>
<p>$\textit{dp}(i) = \min{\textit{cost}(j) + \textit{dp}(i + j)}, \quad j \in {1, 7, 30}$</p>
<p>其中 $\textit{cost}(j)$表示 j天通行证的价格。为什么我们只需要考虑第 i+j天及以后呢？这里和第一条的贪心思路是一样的，如果我们需要购买通行证，那么一定越晚买越好，在握着一张有效的通行证的时候购买其它的通行证显然是不划算的。</p>
</li>
</ul>
<p>由于我们是倒着进行动态规划的，因此我们可以使用记忆化搜索，减少代码的编写难度。我们使用一个长度为 366366 的数组（因为天数是 <code>[1, 365][1,365]</code>，而数组的下标是从 0开始的）存储所有的动态规划结果，这样所有的 $\textit{dp}(i)$ 只会被计算一次（和普通的动态规划相同），时间复杂度不会增大。</p>
<p>最终的答案记为 $\textit{dp}(1)$。</p>
<h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; dayset;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; costs;</span><br><span class="line">    <span class="keyword">int</span> memo[<span class="number">366</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;costs = costs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d: days) &#123;</span><br><span class="line">            dayset.insert(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(memo, <span class="number">-1</span>, <span class="keyword">sizeof</span>(memo));</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">365</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dayset.count(i)) &#123;</span><br><span class="line">            memo[i] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp(i + <span class="number">1</span>) + costs[<span class="number">0</span>], dp(i + <span class="number">7</span>) + costs[<span class="number">1</span>]), dp(i + <span class="number">30</span>) + costs[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            memo[i] = dp(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(W)，其中 W = 365是旅行计划中日期的最大值，我们需要计算 W个解，而每个解最多需要查询 3个其他的解，因此计算量为 $O(3 * W)=O(W)$。</li>
<li>空间复杂度：O(W），我们需要长度为 O(W)的数组来存储所有的解。</li>
</ul>
<h4 id="方法二：记忆化搜索（窗口变量型）"><a href="#方法二：记忆化搜索（窗口变量型）" class="headerlink" title="方法二：记忆化搜索（窗口变量型）"></a>方法二：记忆化搜索（窗口变量型）</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h5><p>方法一需要遍历一年中所有的天数，无论 $\textit{days}$的长度是多少。</p>
<p>但是观察方法一的递推式，我们可以看到，如果我们查询 $\textit{dp}(i)$，而第 i天我们又不需要出行的话，那么 $\textit{dp}$ 函数会一直向后计算$ \textit{dp}(i + 1) = \textit{dp}(i + 2) = \textit{dp}(i + 3)$ 一直到一年结束或者有一天我们需要出行为止。那么我们其实可以直接跳过这些不需要出行的日期，直接找到下一个需要出行的日期。</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h5><p>现在，我们令 $\textit{dp}(i)$ 表示能够完成从第 $\textit{days}[i]$ 天到最后的旅行计划的最小花费（注意，不再是第 i 天到最后的最小花费）。令 $j_1$ 是满足 $\textit{days}[j_1] &gt;= \textit{days}[i] + 1$ 的最小下标，$j_7$是满足 $\textit{days}[j_7] &gt;= \textit{days}[i] + 7$ 的最小下标， $j_{30}$ 是满足 $\textit{days}[j_{30}] &gt;= \textit{days}[i] + 30$ 的最小下标，那么就有：<br>$$<br>dp(i)=min(dp(j_1 )+costs[0],dp(j_7)+costs[1],dp(j_30)+costs[2])<br>$$</p>
<h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; days, costs;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line">    <span class="keyword">int</span> durations[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;days = days;</span><br><span class="line">        <span class="keyword">this</span>-&gt;costs = costs;</span><br><span class="line">        memo.assign(days.<span class="built_in">size</span>(), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= days.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; days.<span class="built_in">size</span>() &amp;&amp; days[j] &lt; days[i] + durations[k]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[i] = <span class="built_in">min</span>(memo[i], dp(j) + costs[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N是出行日期的数量，我们需要计算 N 个解，而计算每个解的过程中最多将指针挪动 30步，计算量为 O(30 * N)=O(N)。</li>
<li>空间复杂度：O(N)，我们需要长度为 O(N) 的数组来存储所有的解。</li>
</ul>
<h2 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">572. 另一个树的子树</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个非空二叉树 <strong>s</strong> 和 <strong>t</strong>，检验 <strong>s</strong> 中是否包含和 <strong>t</strong> 具有相同结构和节点值的子树。<strong>s</strong> 的一个子树包括 <strong>s</strong> 的一个节点和这个节点的所有子孙。<strong>s</strong> 也可以看做它自身的一棵子树。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><p>给定的树 s:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>给定的树 t：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>返回 <strong>true</strong>，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><p>给定的树 s：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br><span class="line">   &#x2F;</span><br><span class="line">  0</span><br></pre></td></tr></table></figure>

<p>给定的树 t：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>返回 <strong>false</strong>。</p>
<h3 id="我的解法：暴力匹配"><a href="#我的解法：暴力匹配" class="headerlink" title="我的解法：暴力匹配"></a>我的解法：暴力匹配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span>||t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(isSubtree(s-&gt;left,t))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(isSubtree(s-&gt;right,t))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;s-&gt;val&lt;&lt;' '&lt;&lt;t-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val==t-&gt;val)</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left||t-&gt;right)</span><br><span class="line">                <span class="keyword">return</span> issame(s-&gt;left,t-&gt;left)&amp;&amp;issame(s-&gt;right,t-&gt;right);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> !s-&gt;left&amp;&amp;!s-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">issame</span><span class="params">(TreeNode* s, TreeNode* t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span>&amp;&amp;t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span>||t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val==t-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> issame(s-&gt;left,t-&gt;left)&amp;&amp;issame(s-&gt;right,t-&gt;right);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：DFS-序列上做串匹配"><a href="#方法二：DFS-序列上做串匹配" class="headerlink" title="方法二：DFS 序列上做串匹配"></a>方法二：DFS 序列上做串匹配</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>这个方法需要我们先了解一个「小套路」：一棵子树上的点在 DFS 序列（即先序遍历）中是连续的。了解了这个「小套路」之后，我们可以确定解决这个问题的方向就是：把 s和 t 先转换成 DFS 序，然后看 t 的 DFS 序是否是 s 的 DFS 序的「子串」。</p>
<p>这样做正确吗？ 假设 s由两个点组成，1 是根，2 是 1 的左孩子；tt 也由两个点组成，1是根，2 是 1的右孩子。这样一来 s 和 t 的 DFS 序相同，可是 t 并不是 s 的某一棵子树。由此可见「s 的 DFS 序包含 t的 DFS 序」是「t 是 ss 子树」的 必要不充分条件，所以单纯这样做是不正确的。</p>
<p>为了解决这个问题，我们可以引入两个空值 lNull 和 rNull，当一个节点的左孩子或者右孩子为空的时候，就插入这两个空值，这样 DFS 序列就唯一对应一棵树。处理完之后，就可以通过判断 「s 的 DFS 序包含 tt的 DFS 序」来判断答案。</p>
<p>在判断「s 的 DFS 序包含 t 的 DFS 序」的时候，可以暴力匹配，也可以使用 KMP 或者 Rabin-Karp 算法，在使用 Rabin-Karp 算法的时候，要注意串中可能有负值。</p>
<p>这里给出用 KMP 判断的代码实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="keyword">int</span>(<span class="number">1E9</span>) + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> vis[MAX_N];</span><br><span class="line">    <span class="keyword">int</span> p[MAX_N], tot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span>; tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) p[++tot] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt; MAX_N; ++j) &#123;</span><br><span class="line">                vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> f, s; <span class="comment">// f 为哈希值 | s 为子树大小</span></span><br><span class="line">        Status(<span class="keyword">int</span> f_ = <span class="number">0</span>, <span class="keyword">int</span> s_ = <span class="number">0</span>) </span><br><span class="line">            : f(f_), s(s_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; hS, hT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *o, <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; &amp;h)</span> </span>&#123;</span><br><span class="line">        h[o] = Status(o-&gt;val, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!o-&gt;left &amp;&amp; !o-&gt;right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;left) &#123;</span><br><span class="line">            dfs(o-&gt;left, h);</span><br><span class="line">            h[o].s += h[o-&gt;left].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">31L</span>L * h[o-&gt;left].f * p[h[o-&gt;left].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;right) &#123;</span><br><span class="line">            dfs(o-&gt;right, h);</span><br><span class="line">            h[o].s += h[o-&gt;right].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">179L</span>L * h[o-&gt;right].f * p[h[o-&gt;right].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        getPrime();</span><br><span class="line">        dfs(s, hS);</span><br><span class="line">        dfs(t, hT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tHash = hT[t].f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[k, v]: hS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.f == tHash) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h3 id="方法三：哈希"><a href="#方法三：哈希" class="headerlink" title="方法三：哈希"></a>方法三：哈希</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="keyword">int</span>(<span class="number">1E9</span>) + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> vis[MAX_N];</span><br><span class="line">    <span class="keyword">int</span> p[MAX_N], tot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span>; tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) p[++tot] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt; MAX_N; ++j) &#123;</span><br><span class="line">                vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> f, s; <span class="comment">// f 为哈希值 | s 为子树大小</span></span><br><span class="line">        Status(<span class="keyword">int</span> f_ = <span class="number">0</span>, <span class="keyword">int</span> s_ = <span class="number">0</span>) </span><br><span class="line">            : f(f_), s(s_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; hS, hT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *o, <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; &amp;h)</span> </span>&#123;</span><br><span class="line">        h[o] = Status(o-&gt;val, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!o-&gt;left &amp;&amp; !o-&gt;right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;left) &#123;</span><br><span class="line">            dfs(o-&gt;left, h);</span><br><span class="line">            h[o].s += h[o-&gt;left].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">31L</span>L * h[o-&gt;left].f * p[h[o-&gt;left].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;right) &#123;</span><br><span class="line">            dfs(o-&gt;right, h);</span><br><span class="line">            h[o].s += h[o-&gt;right].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">179L</span>L * h[o-&gt;right].f * p[h[o-&gt;right].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        getPrime();</span><br><span class="line">        dfs(s, hS);</span><br><span class="line">        dfs(t, hT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tHash = hT[t].f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[k, v]: hS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.f == tHash) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h4 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h4><p><strong>思路：动态规划</strong></p>
<p>状态转移方程<br>$$<br>dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(rows==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(rows,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;rows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>]-<span class="string">'0'</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;cols;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i]-<span class="string">'0'</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;rows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;cols;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">'1'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]))+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;dp[i][j]&lt;&lt;' ';</span></span><br><span class="line">                    res = <span class="built_in">max</span>(res,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>(), columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 遇到一个 1 作为正方形的左上角</span></span><br><span class="line">                    maxSide = <span class="built_in">max</span>(maxSide, <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 计算可能的最大正方形边长</span></span><br><span class="line">                    <span class="keyword">int</span> currentMaxSide = <span class="built_in">min</span>(rows - i, columns - j);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; currentMaxSide; k++) &#123;</span><br><span class="line">                        <span class="comment">// 判断新增的一行一列是否均为 1</span></span><br><span class="line">                        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + k][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[i + k][j + m] == <span class="string">'0'</span> || matrix[i + m][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                            maxSide = <span class="built_in">max</span>(maxSide, k + <span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></h2><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<h5 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h5 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><p>二分查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = x;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(((<span class="keyword">long</span>)mid*mid&lt;=x)&amp;&amp;((<span class="keyword">long</span>)(mid+<span class="number">1</span>)*(mid+<span class="number">1</span>)&gt;x)) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">long</span>)mid*mid&gt;x)</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(\log x)$，即为二分查找需要的次数。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h3 id="其它解法1-袖珍计算器法"><a href="#其它解法1-袖珍计算器法" class="headerlink" title="其它解法1: 袖珍计算器法"></a>其它解法1: 袖珍计算器法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">exp</span>(<span class="number">0.5</span> * <span class="built_in">log</span>(x));</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)(ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法2-牛顿迭代"><a href="#其它解法2-牛顿迭代" class="headerlink" title="其它解法2: 牛顿迭代"></a>其它解法2: 牛顿迭代</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> C = x, x0 = x;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> xi = <span class="number">0.5</span> * (x0 + C / x0);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(x0 - xi) &lt; <span class="number">1e-7</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x0 = xi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(x0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="/2020/05/04/2020-05-03-LeetCode-CheckDaily/D:%5CProject%5Cblog%5Csource_posts%5C2020-05-03-LeetCode-CheckDaily%5Cbinarytree.png" alt="img"></p>
<h4 id="示例-1-3"><a href="#示例-1-3" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-3"><a href="#示例-2-3" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h3 id="我的解法-4"><a href="#我的解法-4" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==p-&gt;val||root-&gt;val==q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(hasptr(root-&gt;left,p)&amp;&amp;hasptr(root-&gt;left,q))</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">if</span>(hasptr(root-&gt;right,p)&amp;&amp;hasptr(root-&gt;right,q))</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">return</span> root;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasptr</span><span class="params">(TreeNode* root, TreeNode* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==p-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> hasptr(root-&gt;left,p)||hasptr(root-&gt;right,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> lson = dfs(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">bool</span> rson = dfs(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，因此时间复杂度为 O(N)。</li>
<li>空间复杂度：O(N) ，其中 N 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O(N)。</li>
</ul>
<h4 id="方法二：存储父节点"><a href="#方法二：存储父节点" class="headerlink" title="方法二：存储父节点"></a>方法二：存储父节点</h4><p><strong>思路</strong></p>
<p>我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 <code>p</code> 结点开始不断往上跳，并记录已经访问过的节点，再从 <code>q</code> 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。</p>
<p><strong>算法</strong></p>
<ol>
<li>从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。</li>
<li>从 <code>p</code> 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。</li>
<li>同样，我们再从 <code>q</code> 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 <code>p</code> 和 <code>q</code> 的深度最深的公共祖先，即 LCA 节点。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, TreeNode*&gt; fa;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fa[root-&gt;left-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fa[root-&gt;right-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        fa[root-&gt;val] = <span class="literal">nullptr</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vis[p-&gt;val] = <span class="literal">true</span>;</span><br><span class="line">            p = fa[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[q-&gt;val]) <span class="keyword">return</span> q;</span><br><span class="line">            q = fa[q-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N是二叉树的节点数。二叉树的所有节点有且只会被访问一次，从 <code>p</code> 和 <code>q</code> 节点往上跳经过的祖先节点个数不会超过 N，因此总的时间复杂度为 O(N)。</li>
<li>空间复杂度：O(N)，其中 N是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O(N)，哈希表存储每个节点的父节点也需要 O(N) 的空间复杂度，因此最后总的空间复杂度为 O(N)。</li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第187场周赛</title>
    <url>/2020/05/03/2020-05-03-LeetCode-Contest-187/</url>
    <content><![CDATA[<p>本周参加周赛，战况不行，两题选手，排名<code>1084 / 3108</code></p>
<table>
<thead>
<tr>
<th>题目</th>
<th align="center">分值</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/destination-city/" target="_blank" rel="noopener">5400. 旅行终点站</a></td>
<td align="center">3</td>
<td align="center">简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/" target="_blank" rel="noopener">5401. 是否所有 1 都至少相隔 k 个元素</a></td>
<td align="center">4</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">5402. 绝对差不超过限制的最长连续子数组</a></td>
<td align="center">5</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/" target="_blank" rel="noopener">5403. 有序矩阵中的第 k 个最小数组和</a></td>
<td align="center">7</td>
<td align="center">困难</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="5400-旅行终点站"><a href="#5400-旅行终点站" class="headerlink" title="5400. 旅行终点站"></a><a href="https://leetcode-cn.com/problems/destination-city/" target="_blank" rel="noopener">5400. 旅行终点站</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityAi, cityBi]</code> 表示该线路将会从 <code>cityAi</code> 直接前往 <code>cityBi</code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市<em>。</em></p>
<p>题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]]</span><br><span class="line">输出：&quot;Sao Paulo&quot; </span><br><span class="line">解释：从 &quot;London&quot; 出发，最后抵达终点站 &quot;Sao Paulo&quot; 。本次旅行的路线是 &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot; 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;,&quot;B&quot;],[&quot;C&quot;,&quot;A&quot;]]</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">解释：所有可能的线路是：</span><br><span class="line">&quot;D&quot; -&gt; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;A&quot;. </span><br><span class="line">显然，旅行终点站是 &quot;A&quot; 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;A&quot;,&quot;Z&quot;]]</span><br><span class="line">输出：&quot;Z&quot;</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= paths.length &lt;= 100</code></li>
<li><code>paths[i].length == 2</code></li>
<li><code>1 &lt;= cityAi.length, cityBi.length &lt;= 10</code></li>
<li><code>cityAi != cityBi</code></li>
<li>所有字符串均由大小写英文字母和空格字符组成。</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="思路：使用哈希表一直套娃，套完了就是终点"><a href="#思路：使用哈希表一直套娃，套完了就是终点" class="headerlink" title="思路：使用哈希表一直套娃，套完了就是终点"></a>思路：使用哈希表一直套娃，套完了就是终点</h4><h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">destCity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:paths)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[p[<span class="number">0</span>]] = p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.<span class="built_in">find</span>(p[<span class="number">0</span>])==<span class="built_in">set</span>.<span class="built_in">end</span>()) <span class="built_in">set</span>.insert(p[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.<span class="built_in">find</span>(p[<span class="number">1</span>])==<span class="built_in">set</span>.<span class="built_in">end</span>()) <span class="built_in">set</span>.insert(p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v=<span class="built_in">set</span>.<span class="built_in">begin</span>();v!=<span class="built_in">set</span>.<span class="built_in">end</span>();v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(*v)==<span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> *v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">destCity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; vis;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : paths)</span><br><span class="line">            vis.insert(p[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : paths)</span><br><span class="line">            <span class="keyword">if</span> (vis.<span class="built_in">find</span>(p[<span class="number">1</span>]) == vis.<span class="built_in">end</span>()) <span class="keyword">return</span> p[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"send me offer plz"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：Gary_coding</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/destination-city/solution/c-zhong-gui-zhong-ju-de-32msjie-fa-set-by-gary_cod/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h2 id="5401-是否所有-1-都至少相隔-k-个元素"><a href="#5401-是否所有-1-都至少相隔-k-个元素" class="headerlink" title="5401. 是否所有 1 都至少相隔 k 个元素"></a><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/" target="_blank" rel="noopener">5401. 是否所有 1 都至少相隔 k 个元素</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>nums</code> 以及整数 <code>k</code>。如果所有 <code>1</code> 都至少相隔 <code>k</code> 个元素，则返回 <code>True</code> ；否则，返回 <code>False</code> 。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><p><img src="/2020/05/03/2020-05-03-LeetCode-Contest-187/sample_1_1791.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,0,1,0,0,1], k &#x3D; 2</span><br><span class="line">输出：true</span><br><span class="line">解释：每个 1 都至少相隔 2 个元素。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><p><strong><img src="/2020/05/03/2020-05-03-LeetCode-Contest-187/2020-05-03-LeetCode-Contest-187%5Csample_2_1791.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,1,0,1], k &#x3D; 2</span><br><span class="line">输出：false</span><br><span class="line">解释：第二个 1 和第三个 1 之间只隔了 1 个元素。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1], k &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,1], k &#x3D; 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h4 id="提示：-1"><a href="#提示：-1" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>0 &lt;= k &lt;= nums.length</code></li>
<li><code>nums[i]</code> 的值为 <code>0</code> 或 <code>1</code></li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kLengthApart</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastone = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lastone&gt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-lastone&lt;=k)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                lastone = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5402-绝对差不超过限制的最长连续子数组"><a href="#5402-绝对差不超过限制的最长连续子数组" class="headerlink" title="5402. 绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">5402. 绝对差不超过限制的最长连续子数组</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code> <em>。</em></p>
<p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p>
<h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [8,2,4,7], limit &#x3D; 4</span><br><span class="line">输出：2 </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[8] 最大绝对差 |8-8| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[8,2] 最大绝对差 |8-2| &#x3D; 6 &gt; 4. </span><br><span class="line">[8,2,4] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[8,2,4,7] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[2] 最大绝对差 |2-2| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[2,4] 最大绝对差 |2-4| &#x3D; 2 &lt;&#x3D; 4.</span><br><span class="line">[2,4,7] 最大绝对差 |2-7| &#x3D; 5 &gt; 4.</span><br><span class="line">[4] 最大绝对差 |4-4| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[4,7] 最大绝对差 |4-7| &#x3D; 3 &lt;&#x3D; 4.</span><br><span class="line">[7] 最大绝对差 |7-7| &#x3D; 0 &lt;&#x3D; 4. </span><br><span class="line">因此，满足题意的最长子数组的长度为 2 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">输出：4 </span><br><span class="line">解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| &#x3D; 5 &lt;&#x3D; 5 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<h4 id="提示：-2"><a href="#提示：-2" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>0 &lt;= limit &lt;= 10^9</code></li>
</ul>
<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+res;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> a = getmax(nums,i,j);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(a)&lt;=limit)</span><br><span class="line">                    res = <span class="built_in">max</span>(res,j-i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getmax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l,<span class="keyword">int</span> r )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxn = nums[l];</span><br><span class="line">        <span class="keyword">int</span> minn = nums[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxn = <span class="built_in">max</span>(maxn,nums[i]);</span><br><span class="line">            minn = <span class="built_in">min</span>(minn,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn-minn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>暴力解法 会超时</p>
<h3 id="大佬优秀解法"><a href="#大佬优秀解法" class="headerlink" title="大佬优秀解法"></a>大佬优秀解法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>使用滑动窗口保持符合条件的子数组，记录最长长度</li>
<li>怎样确定子数组是否符合条件，需要知道两个关键数据<ol start="21">
<li>子数组中的最大值</li>
<li>子数组中的最小值</li>
</ol>
</li>
<li>需要对滑入窗口的数据记录，滑出的数据删除，并且使这些记录方便的算出最大值和最小值<br>\31. 使用 <code>map</code> / <code>multiset</code> 可以在滑入滑出的时候方便的增减对应数据<br>\32. 同时 <code>map</code> / <code>multiset</code> 本身是有序的，可以方便的找出最大值最小值</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int longestSubarray(vector&lt;int&gt;&amp; nums, int limit) &#123;</span><br><span class="line">    map&lt;int, int&gt; m;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; nums.size(); j++) &#123;</span><br><span class="line">        m[nums[j]]++;</span><br><span class="line">        while (m.rbegin()-&gt;first - m.begin()-&gt;first &gt; limit) &#123;</span><br><span class="line">            m[nums[i]]--;</span><br><span class="line">            if (m[nums[i]] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                m.erase(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans &#x3D; max(ans, j - i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            s.insert(nums[j]);</span><br><span class="line">            <span class="keyword">while</span> (*s.rbegin() - *s.<span class="built_in">begin</span>() &gt; limit) &#123;</span><br><span class="line">                s.erase(s.<span class="built_in">find</span>(nums[i]));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">作者：ikaruga</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution/longest-continuous-subarray-by-ikaruga/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="5403-有序矩阵中的第-k-个最小数组和"><a href="#5403-有序矩阵中的第-k-个最小数组和" class="headerlink" title="5403. 有序矩阵中的第 k 个最小数组和"></a><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/" target="_blank" rel="noopener">5403. 有序矩阵中的第 k 个最小数组和</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个 <code>m * n</code> 的矩阵 <code>mat</code>，以及一个整数 <code>k</code> ，矩阵中的每一行都以非递减的顺序排列。</p>
<p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 <strong>最小</strong> 数组和。</p>
<h4 id="示例-1：-3"><a href="#示例-1：-3" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,3,11],[2,4,6]], k &#x3D; 5</span><br><span class="line">输出：7</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-3"><a href="#示例-2：-3" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,3,11],[2,4,6]], k &#x3D; 9</span><br><span class="line">输出：17</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-3"><a href="#示例-3：-3" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,10,10],[1,4,5],[2,3,6]], k &#x3D; 7</span><br><span class="line">输出：9</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,1,10],[2,2,9]], k &#x3D; 7</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>

<h4 id="提示：-3"><a href="#提示：-3" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat.length[i]</code></li>
<li><code>1 &lt;= m, n &lt;= 40</code></li>
<li><code>1 &lt;= k &lt;= min(200, n ^ m)</code></li>
<li><code>1 &lt;= mat[i][j] &lt;= 5000</code></li>
<li><code>mat[i]</code> 是一个非递减数组</li>
</ul>
<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>解题思路</p>
<ul>
<li>将“求前<code>m</code>行的第<code>k</code>个最小数组和”按动态规划的思路划分成子问题：已知前<code>m-1</code>行的最小数组和的<strong>列表</strong>，求前<code>m</code>行的第<code>k</code>个最小数组和。</li>
<li>例如，<code>mat = [[1,10,10],[1,4,5],[2,3,6]]</code>，<code>k = 7</code>。已知前两行的最小数组和<code>last_row = [2,5,6,11,11,14,14,15,15]</code>。我们截取<code>last_row</code>的前<code>k</code>个元素（因为后面的元素不再有竞争力），<code>last_row = [2,5,6,11,11,14,14]</code>。然后遍历第三行的每个元素，与<code>last_row</code>的每个元素求和，排序+截取后得到<code>new_row = [4, 5, 7, 8, 8, 8, 9]</code>。返回第<code>k</code>个元素即可。</li>
</ul>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：$O(m*max(n, klog(k))$。遍历每行，时间复杂度为$O(m)$。对于每一行，遍历每一列的元素为$O(n)$，对该行求出的数组和排序的复杂度为$O(klog(k))$。</li>
<li>空间复杂度：$O(k)$。每行都要存储一个长度不超过<code>k</code>的”数组和”列表。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, mat: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">        last_row = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat)):</span><br><span class="line">            new_row = [] </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(mat[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> last_row:</span><br><span class="line">                    new_row.append(p + mat[i][j])</span><br><span class="line">            new_row.sort()</span><br><span class="line">            <span class="keyword">if</span> len(new_row) &gt; k:</span><br><span class="line">                last_row = new_row[ :k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                last_row = new_row</span><br><span class="line">        <span class="keyword">return</span> last_row[k - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>可以先看下<a href="https://leetcode-cn.com/problems/ugly-number-ii/solution/1-zui-xiao-dui-2-dong-tai-gui-hua-san-zhi-zhen-pyt/" target="_blank" rel="noopener">264. 丑数 II</a>这道题。T264的最小堆解法：每次从堆中弹出最小的丑数，然后把该丑数能生成的新的丑数push入堆。</li>
<li>本题也很相似，每次从堆中弹出最小的数组和<code>curr_sum</code>和对应的指针<code>pointers</code>，然后轮流将指针<code>pointers</code>的每个索引向后移动一位，生成新的<code>new_sum</code>，加入堆中。</li>
</ul>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><ul>
<li>最小堆存储的是<code>[curr_sum, pointers]</code>二元组，<code>pointers</code>是指针数组，<code>curr_sum</code>是该<code>pointers</code>指向的元素的和。初始化<code>pointers</code>全为0，求出相应的<code>curr_sum</code>，并将其入堆。</li>
<li>重复下列步骤k次<ul>
<li>从堆中pop出<code>curr_sum</code>和<code>pointers</code>。</li>
<li>遍历<code>pointers</code>的每个索引，将该索引加一，求出新的和，如果没有出现过，push入堆。</li>
</ul>
</li>
</ul>
<h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><ul>
<li>以<code>mat = [[1,10,10],[1,4,5],[2,3,6]]</code>，<code>k = 7</code>为例，初始化<code>pointers = (0, 0, 0)</code>，<code>curr_sum = 4</code>，哈希表<code>seen</code>加入<code>(0, 0, 0)</code></li>
<li>从堆中pop出最小和，<code>pointers = (0, 0, 0)</code>，<code>curr_sum = 4</code>。新生成<code>[13, (1, 0, 0)]</code>,<code>[7, (0, 1, 0)]</code>，<code>[5, (0, 0, 1)]</code>，在<code>seen</code>中做好标记，然后将三者入堆。重复该步骤<code>k</code>次。</li>
</ul>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度：O(kmlog(k))<em>O</em>(<em>k<strong>m</strong>l<strong>o</strong>g</em>(<em>k</em>))。执行<code>k</code>次循环：每次循环时，出堆操作，是O(log(k)))<em>O</em>(<em>l<strong>o</strong>g</em>(<em>k</em>)))；每次出堆后，要生成<code>m</code>个新的数组和，是O(n)<em>O</em>(<em>n</em>)；将新生成的的数组和入队，是O(logk)<em>O</em>(<em>l<strong>o</strong>g**k</em>)。所以总的是O(k * (log(k) + m * log(k))) = O(kmlog(k)))<em>O</em>(<em>k</em>∗(<em>l<strong>o</strong>g</em>(<em>k</em>)+<em>m</em>∗<em>l<strong>o</strong>g</em>(<em>k</em>)))=<em>O</em>(<em>k<strong>m</strong>l<strong>o</strong>g</em>(<em>k</em>)))</li>
<li>空间复杂度：O(km^2)<em>O</em>(<em>k*<em>m</em>2)。堆中的元素个数不会超过<code>km</code>个，每个的空间是O(m)*O</em>(<em>m</em>)</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, mat, k: int)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(mat), len(mat[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 初始化指针</span></span><br><span class="line">        pointers = [<span class="number">0</span>] * m </span><br><span class="line">        <span class="comment"># 初始化heap</span></span><br><span class="line">        heap = []</span><br><span class="line">        curr_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            curr_sum += mat[i][<span class="number">0</span>]</span><br><span class="line">        heapq.heappush(heap, [curr_sum, tuple(pointers)])</span><br><span class="line">        <span class="comment"># 初始化seen</span></span><br><span class="line">        seen = set()</span><br><span class="line">        seen.add(tuple(pointers))</span><br><span class="line">        <span class="comment"># 执行k次</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="comment"># 从堆中pop出curr_sum(最小数组和)和pointers(指针数组)</span></span><br><span class="line">            curr_sum, pointers = heapq.heappop(heap)</span><br><span class="line">            <span class="comment"># 每个指针轮流后移一位，将new_sum(新的数组和)和new_pointers(新的指针数组)push入堆</span></span><br><span class="line">            <span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(pointers):</span><br><span class="line">                <span class="keyword">if</span> j &lt; n - <span class="number">1</span>:</span><br><span class="line">                    new_pointers = list(pointers)</span><br><span class="line">                    new_pointers[i] = j + <span class="number">1</span></span><br><span class="line">                    new_pointers = tuple(new_pointers)</span><br><span class="line">                    <span class="keyword">if</span> new_pointers <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                        new_sum = curr_sum + mat[i][j + <span class="number">1</span>]- mat[i][j]</span><br><span class="line">                        heapq.heappush(heap, [new_sum, new_pointers])</span><br><span class="line">                        seen.add(new_pointers)</span><br><span class="line">        <span class="keyword">return</span> curr_sum</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>周赛</tag>
        <tag>刷题</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第186场周赛</title>
    <url>/2020/05/03/2020-05-03-LeetCode-Contest-186/</url>
    <content><![CDATA[<p>上周参加周赛，战况还行，排名<code>367 / 3107</code></p>
<table>
<thead>
<tr>
<th>题目</th>
<th align="center">分值</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string/" target="_blank" rel="noopener">1422. 分割字符串的最大得分</a></td>
<td align="center">3</td>
<td align="center">简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">1423. 可获得的最大点数</a></td>
<td align="center">4</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">1424. 对角线遍历 II</a></td>
<td align="center">5</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/constrained-subsequence-sum/" target="_blank" rel="noopener">1425. 带限制的子序列和</a></td>
<td align="center">6</td>
<td align="center">困难</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="1422-分割字符串的最大得分"><a href="#1422-分割字符串的最大得分" class="headerlink" title="1422. 分割字符串的最大得分"></a><a href="https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string/" target="_blank" rel="noopener">1422. 分割字符串的最大得分</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个由若干 0 和 1 组成的字符串 <code>s</code> ，请你计算并返回将该字符串分割成两个 <strong>非空</strong> 子字符串（即 <strong>左</strong> 子字符串和 <strong>右</strong> 子字符串）所能获得的最大得分。</p>
<p>「分割字符串的得分」为 <strong>左</strong> 子字符串中 <strong>0</strong> 的数量加上 <strong>右</strong> 子字符串中 <strong>1</strong> 的数量。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;011101&quot;</span><br><span class="line">输出：5 </span><br><span class="line">解释：</span><br><span class="line">将字符串 s 划分为两个非空子字符串的可行方案有：</span><br><span class="line">左子字符串 &#x3D; &quot;0&quot; 且 右子字符串 &#x3D; &quot;11101&quot;，得分 &#x3D; 1 + 4 &#x3D; 5 </span><br><span class="line">左子字符串 &#x3D; &quot;01&quot; 且 右子字符串 &#x3D; &quot;1101&quot;，得分 &#x3D; 1 + 3 &#x3D; 4 </span><br><span class="line">左子字符串 &#x3D; &quot;011&quot; 且 右子字符串 &#x3D; &quot;101&quot;，得分 &#x3D; 1 + 2 &#x3D; 3 </span><br><span class="line">左子字符串 &#x3D; &quot;0111&quot; 且 右子字符串 &#x3D; &quot;01&quot;，得分 &#x3D; 1 + 1 &#x3D; 2 </span><br><span class="line">左子字符串 &#x3D; &quot;01110&quot; 且 右子字符串 &#x3D; &quot;1&quot;，得分 &#x3D; 2 + 1 &#x3D; 3</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;00111&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：当 左子字符串 &#x3D; &quot;00&quot; 且 右子字符串 &#x3D; &quot;111&quot; 时，我们得到最大得分 &#x3D; 2 + 3 &#x3D; 5</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1111&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= s.length &lt;= 500</code></li>
<li>字符串 <code>s</code> 仅由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成。</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp0</span><span class="params">(len,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp1</span><span class="params">(len,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        &#123;           </span><br><span class="line">            dp0[i] = (i==<span class="number">0</span>? <span class="number">0</span> : dp0[i<span class="number">-1</span>]) + (s[i]==<span class="string">'0'</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// dp1[len-1-i] = (i==0? 0 :dp1[len-i]) +(s[i]=='1'?1:0);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len <span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            dp1[i] = (i==len<span class="number">-1</span>?<span class="number">0</span>:dp1[i+<span class="number">1</span>])+(s[i]==<span class="string">'1'</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;dp0[i]&lt;&lt;' '&lt;&lt;dp1[i+1]&lt;&lt;endl;</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,dp0[i]+dp1[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1423-可获得的最大点数"><a href="#1423-可获得的最大点数" class="headerlink" title="1423. 可获得的最大点数"></a><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">1423. 可获得的最大点数</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p>
<p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p>
<p>你的点数就是你拿到手中的所有卡牌的点数之和。</p>
<p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,2,3,4,5,6,1], k &#x3D; 3</span><br><span class="line">输出：12</span><br><span class="line">解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 &#x3D; 12 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [2,2,2], k &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [9,7,7,9,7,7,9], k &#x3D; 7</span><br><span class="line">输出：55</span><br><span class="line">解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,1000,1], k &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,79,80,1,1,1,200,1], k &#x3D; 3</span><br><span class="line">输出：202</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= cardPoints.length &lt;= 10^5</code></li>
<li><code>1 &lt;= cardPoints[i] &lt;= 10^4</code></li>
<li><code>1 &lt;= k &lt;= cardPoints.length</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = cardPoints.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> n:cardPoints)</span><br><span class="line">                sum+=n;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">leftk</span><span class="params">(k+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightk</span><span class="params">(k+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;k+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            leftk[i]=leftk[i<span class="number">-1</span>]+cardPoints[i<span class="number">-1</span>];</span><br><span class="line">            rightk[i] = rightk[i<span class="number">-1</span>]+cardPoints[len-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res,leftk[i]+rightk[k-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            sum += cardPoints[i];</span><br><span class="line">        <span class="keyword">int</span> n = cardPoints.<span class="built_in">size</span>(), ans = sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            sum = sum - cardPoints[k - <span class="number">1</span> - i] + cardPoints[n - <span class="number">1</span> - i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1424-对角线遍历-II"><a href="#1424-对角线遍历-II" class="headerlink" title="1424. 对角线遍历 II"></a><a href="https://leetcode-cn.com/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">1424. 对角线遍历 II</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个列表 <code>nums</code> ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 <code>nums</code> 中对角线上的整数。 </p>
<h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><p><strong><img src="/2020/05/03/2020-05-03-LeetCode-Contest-186/sample_1_1784.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,4,2,7,5,3,8,6,9]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><p><strong><img src="/2020/05/03/2020-05-03-LeetCode-Contest-186/sample_2_1784.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]</span><br><span class="line">输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [[1,2,3],[4],[5,6,7],[8],[9,10,11]]</span><br><span class="line">输出：[1,4,2,5,3,8,6,9,7,10,11]</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [[1,2,3,4,5,6]]</span><br><span class="line">输出：[1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i].length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i][j] &lt;= 10^9</code></li>
<li><code>nums</code> 中最多有 <code>10^5</code> 个数字。</li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//保存各个数组的长度</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; flag=nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            l[i] = nums[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//队列</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        flag[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> row = tmp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> col = tmp[<span class="number">1</span>];</span><br><span class="line">            res.push_back(nums[row][col]);</span><br><span class="line">            <span class="keyword">if</span>(row+<span class="number">1</span>&lt;nums.<span class="built_in">size</span>()&amp;&amp;col&lt;l[row+<span class="number">1</span>]&amp;&amp;flag[row+<span class="number">1</span>][col])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(&#123;row+<span class="number">1</span>,col&#125;);</span><br><span class="line">                flag[row+<span class="number">1</span>][col] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(col+<span class="number">1</span>&lt;l[row]&amp;&amp;flag[row][col+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(&#123;row,col+<span class="number">1</span>&#125;);</span><br><span class="line">                flag[row][col+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化写法：</p>
<p><strong>思路</strong></p>
<ol>
<li>正常遍历</li>
<li>根据顺序，每条对角线肯定是最后的元素先入栈</li>
<li>使用一个堆栈（代码里使用了 vector）来记录每条对角线的元素</li>
<li>最后整合到一起</li>
<li>缺点，可能很慢</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = i + j;</span><br><span class="line">                <span class="keyword">if</span> (k == st.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    st.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                st[k].push_back(nums[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : st) &#123;</span><br><span class="line">            ans.insert(ans.<span class="built_in">end</span>(), s.rbegin(), s.rend());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">作者：ikaruga</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/diagonal-traverse-ii/solution/diagonal-traverse-ii-by-ikaruga/</span></span><br><span class="line">来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="1425-带限制的子序列和"><a href="#1425-带限制的子序列和" class="headerlink" title="1425. 带限制的子序列和"></a><a href="https://leetcode-cn.com/problems/constrained-subsequence-sum/" target="_blank" rel="noopener">1425. 带限制的子序列和</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <strong>非空</strong> 子序列元素和的最大值，子序列需要满足：子序列中每两个 <strong>相邻</strong> 的整数 <code>nums[i]</code> 和 <code>nums[j]</code> ，它们在原数组中的下标 <code>i</code> 和 <code>j</code> 满足 <code>i &lt; j</code> 且 <code>j - i &lt;= k</code> 。</p>
<p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。 </p>
<h4 id="示例-1：-3"><a href="#示例-1：-3" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,2,-10,5,20], k &#x3D; 2</span><br><span class="line">输出：37</span><br><span class="line">解释：子序列为 [10, 2, 5, 20] 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-3"><a href="#示例-2：-3" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,-2,-3], k &#x3D; 1</span><br><span class="line">输出：-1</span><br><span class="line">解释：子序列必须是非空的，所以我们选择最大的数字。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,-2,-10,-5,20], k &#x3D; 2</span><br><span class="line">输出：23</span><br><span class="line">解释：子序列为 [10, -2, -5, 20] 。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><p>思路：<br>结合了动态规划和滑动窗口的思想(239题)。<br>首先定义动态规划转移方程,dp[i]表示以i数字结尾的最大子序列，则转移方程为：<br>$$ dp[i]=max(dp[i-j]+nums[i],nums[i]) 其中 j=1,2…k$$<br>如果直接遍历i的前k个值，然后取最大值会超时，所以我们需要用一个结构来维持前k个值的大小顺序，从而直接获取前k个最大的值，这就回归到了239题的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">constrainedSubsetSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">        sta.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[sta.front()]+nums[i],nums[i]);</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">            <span class="keyword">if</span>(i-sta.front()==k) sta.pop_front();</span><br><span class="line">            <span class="keyword">while</span>(!sta.empty()&amp;&amp;dp[sta.back()]&lt;dp[i]) sta.pop_back();</span><br><span class="line">            sta.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>周赛</tag>
        <tag>刷题</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeeCode每日打卡4-27~5.3</title>
    <url>/2020/04/30/2020-04-30-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>本周打卡题目如下：</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题56 - I. 数组中数字出现的次数</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></td>
<td>困难</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">202. 快乐数</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></td>
<td>简单</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(nums,left,right,target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">            <span class="keyword">return</span> nums[left]==target?left:<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">int</span> l = helper(nums,left,mid<span class="number">-1</span>,target);</span><br><span class="line">        <span class="keyword">return</span> l==<span class="number">-1</span>?helper(nums,mid+<span class="number">1</span>,right,target):l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：二分搜索"><a href="#方法一：二分搜索" class="headerlink" title="方法一：二分搜索"></a>方法一：二分搜索</h4><p><strong>思路和算法</strong></p>
<p>题目要求算法时间复杂度必须是 $O(\log n)$的级别，这提示我们可以使用二分搜索的方法。但是数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分搜索吗？答案是可以的。可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 <code>6</code> 这个位置分开以后数组变成了 <code>[4, 5, 6]</code> 和 <code>[7, 0, 1, 2]</code> 两个部分，其中左边 <code>[4, 5, 6]</code> 这个部分的数组是有序的，其他也是如此。这启示我们可以在常规二分搜索的时候查看当前 <code>mid</code> 为分割位置分割出来的两个部分 <code>[l, mid]</code> 和 <code>[mid + 1, r]</code> 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分搜索的上下界，因为我们能够根据有序的那部分判断出 <code>target</code> 在不在这个部分：</p>
<ul>
<li>如果 <code>[l, mid - 1]</code> 是有序数组，且 <code>target</code> 的大小满足$ [\textit{nums}[l],\textit{nums}[mid]))$，则我们应该将搜索范围缩小至 <code>[l, mid - 1]</code>，否则在 <code>[mid + 1, r]</code> 中寻找。</li>
<li>如果 <code>[mid, r]</code> 是有序数组，且 <code>target</code> 的大小满足 $(\textit{nums}[mid+1],\textit{nums}[r])$，则我们应该将搜索范围缩小至 <code>[mid + 1, r]</code>，否则在 <code>[l, mid - 1]</code> 中寻找。</li>
</ul>
<p><img src="/2020/04/30/2020-04-30-LeetCode-CheckDaily/33_fig1.png" alt="fig1"></p>
<p>需要注意的是，二分的写法有很多种，所以在判断 <code>target</code> 大小与有序部分的关系的时候可能会出现细节上的差别。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度： $O(\log n)$，其中 n 为$ \textit{nums}[]$ 数组的大小。整个算法时间复杂度即为二分搜索的时间复杂度 $O(\log n)$。</li>
<li>空间复杂度： $O(1)$ 。我们只需要常数级别的空间存放变量。</li>
</ul>
<h2 id="面试题56-I-数组中数字出现的次数"><a href="#面试题56-I-数组中数字出现的次数" class="headerlink" title="面试题56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题56 - I. 数组中数字出现的次数</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>

<p> <strong>限制：</strong></p>
<ul>
<li><code>2 &lt;= nums &lt;= 10000</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : nums)</span><br><span class="line">            s ^= n;</span><br><span class="line">        <span class="keyword">int</span> k = s &amp; (-s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &amp; k)&#123;</span><br><span class="line">                res[<span class="number">0</span>]^=num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[<span class="number">1</span>]^=num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="1095-山脉数组中查找目标值"><a href="#1095-山脉数组中查找目标值" class="headerlink" title="1095. 山脉数组中查找目标值"></a><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>（这是一个 <strong>交互式问题</strong> ）</p>
<p>给你一个 <strong>山脉数组</strong> <code>mountainArr</code>，请你返回能够使得 <code>mountainArr.get(index)</code> <strong>等于</strong> <code>target</code> <strong>最小</strong> 的下标 <code>index</code> 值。如果不存在这样的下标 <code>index</code>，就请返回 <code>-1</code>。 </p>
<p>何为山脉数组？如果数组 <code>A</code> 是一个山脉数组的话，那它满足如下条件：</p>
<p><strong>首先</strong>，<code>A.length &gt;= 3</code></p>
<p><strong>其次</strong>，在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 <code>i</code> 使得：</p>
<ul>
<li><p><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></p>
</li>
<li><p><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></p>
<p>你将 <strong>不能直接访问该山脉数组</strong>，必须通过 <code>MountainArray</code> 接口来获取数据：</p>
</li>
<li><p><code>MountainArray.get(k)</code> - 会返回数组中索引为<code>k</code> 的元素（下标从 0 开始）</p>
</li>
<li><p><code>MountainArray.length()</code> - 会返回该数组的长度</p>
</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：array &#x3D; [1,2,3,4,5,3,1], target &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：array &#x3D; [0,1,2,4,2,1], target &#x3D; 3</span><br><span class="line">输出：-1</span><br><span class="line">解释：3 在数组中没有出现，返回 -1。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= mountain_arr.length() &lt;= 10000</code></li>
<li><code>0 &lt;= target &lt;= 10^9</code></li>
<li><code>0 &lt;= mountain_arr.get(index) &lt;= 10^9</code></li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray &amp;mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = MountainArray.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">peek</span> = findPeek(mountainArr,left,right);</span><br><span class="line">        <span class="keyword">return</span> helper(mountainArr,left,right,target);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(MountainArray &amp;mountainArr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(left=right)</span><br><span class="line">            <span class="keyword">return</span> mountainArr.<span class="built_in">get</span>(left)==target?left:<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midval = mountainArr.<span class="built_in">get</span>(mid);</span><br><span class="line">        <span class="keyword">if</span>(midval==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftval = mountainArr.<span class="built_in">get</span>(left);</span><br><span class="line">        <span class="keyword">if</span>(leftval==target)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rightval = mountainArr.<span class="built_in">get</span>(right);</span><br><span class="line">        <span class="keyword">if</span>(rightval==target)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeek</span><span class="params">(MountainArray &amp;mountainArr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(m+<span class="number">1</span>&lt;= right &amp;&amp; mountainArr.<span class="built_in">get</span>(mid)&lt;mountainArr.<span class="built_in">get</span>(mid+<span class="number">1</span>))</span><br><span class="line">                l = m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r= m;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：二分查找-1"><a href="#方法一：二分查找-1" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(MountainArray &amp;mountain, <span class="keyword">int</span> target, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> key(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">        target = key(target);</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = key(mountain.<span class="built_in">get</span>(mid));</span><br><span class="line">            <span class="keyword">if</span> (cur == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur &lt; target)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray &amp;mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = mountainArr.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mountainArr.<span class="built_in">get</span>(mid) &lt; mountainArr.<span class="built_in">get</span>(mid + <span class="number">1</span>))</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> peak = l;</span><br><span class="line">        <span class="keyword">int</span> index = binary_search(mountainArr, target, <span class="number">0</span>, peak, [](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span>&#123;<span class="keyword">return</span> x;&#125;);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        <span class="keyword">return</span> binary_search(mountainArr, target, peak + <span class="number">1</span>, mountainArr.length() - <span class="number">1</span>, [](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span>&#123;<span class="keyword">return</span> -x;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。如果 <strong>可以变为</strong> 1，那么这个数就是快乐数。</p>
<p>如果 <code>n</code> 是快乐数就返回 <code>True</code> ；不是，则返回 <code>False</code> 。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-2"><a href="#官方解法-2" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：用-HashSet-检测循环"><a href="#方法一：用-HashSet-检测循环" class="headerlink" title="方法一：用 HashSet 检测循环"></a>方法一：用 HashSet 检测循环</h4><p>我们可以先举几个例子。我们从 77 开始。则下一个数字是 4949（因为 7^2=4972=49），然后下一个数字是 9797（因为 4^2+9^2=9742+92=97）。我们可以不断重复该的过程，直到我们得到 11。因为我们得到了 11，我们知道 77 是一个快乐数，函数应该返回 <code>true</code>。</p>
<p><img src="/2020/04/30/2020-04-30-LeetCode-CheckDaily/202_fig1.png" alt="fig1"></p>
<p>再举一个例子，让我们从 116116 开始。通过反复通过平方和计算下一个数字，我们最终得到 5858，再继续计算之后，我们又回到 5858。由于我们回到了一个已经计算过的数字，可以知道有一个循环，因此不可能达到 11。所以对于 116116，函数应该返回 <code>false</code>。</p>
<p><img src="/2020/04/30/2020-04-30-LeetCode-CheckDaily/202_fig2.png" alt="fig2"></p>
<p>根据我们的探索，我们猜测会有以下三种可能。</p>
<ol>
<li>最终会得到 1。</li>
<li>最终会进入循环。</li>
<li>值会越来越大，最后接近无穷大。</li>
</ol>
<p>第三个情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到 11 呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。</p>
<table>
<thead>
<tr>
<th>Digits</th>
<th align="center">Largest</th>
<th align="right">Next</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">9</td>
<td align="right">81</td>
</tr>
<tr>
<td>2</td>
<td align="center">99</td>
<td align="right">162</td>
</tr>
<tr>
<td>3</td>
<td align="center">999</td>
<td align="right">243</td>
</tr>
<tr>
<td>4</td>
<td align="center">9999</td>
<td align="right">324</td>
</tr>
<tr>
<td>13</td>
<td align="center">9999999999999</td>
<td align="right">1053</td>
</tr>
</tbody></table>
<p>对于 33 位数的数字，它不可能大于 243243。这意味着它要么被困在 243243 以下的循环内，要么跌到 11。44 位或 44 位以上的数字在每一步都会丢失一位，直到降到 33 位为止。所以我们知道，最坏的情况下，算法可能会在 243243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 11。但它不会无限期地进行下去，所以我们排除第三种选择。</p>
<p>即使在代码中你不需要处理第三种情况，你仍然需要理解为什么它永远不会发生，这样你就可以证明为什么你不处理它。</p>
<p><strong>算法：</strong></p>
<p>算法分为两部分，我们需要设计和编写代码。</p>
<ol>
<li>给一个数字 n，它的下一个数字是什么？</li>
<li>按照一系列的数字来判断我们是否进入了一个循环。</li>
</ol>
<p>第 1 部分我们按照题目的要求做数位分离，求平方和。</p>
<p>第 2 部分可以使用 HashSet 完成。每次生成链中的下一个数字时，我们都会检查它是否已经在 HashSet 中。</p>
<ul>
<li>如果它不在 HashSet 中，我们应该添加它。</li>
<li>如果它在 HashSet 中，这意味着我们处于一个循环中，因此应该返回 <code>false</code>。</li>
</ul>
<p>我们使用 HashSet 而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集中需要 O(1) 的时间，而对于其他数据结构，则需要 O(n)的时间。选择正确的数据结构是解决这些问题的关键部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private int getNext(int n) &#123;</span><br><span class="line">        int totalSum &#x3D; 0;</span><br><span class="line">        while (n &gt; 0) &#123;</span><br><span class="line">            int d &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            totalSum +&#x3D; d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        return totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsHappy(int n) &#123;</span><br><span class="line">        HashSet &lt;int&gt; seen &#x3D; new HashSet&lt;int&gt;();</span><br><span class="line">        while (n !&#x3D; 1 &amp;&amp; !seen.Contains(n)) &#123;</span><br><span class="line">            seen.Add(n);</span><br><span class="line">            n &#x3D; getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        return n &#x3D;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>确定这个问题的时间复杂度对于一个 “简单” 级别的问题来说是一个挑战。如果您对这些问题还不熟悉，可以尝试只计算 <code>getNext(n)</code> 函数的时间复杂度。</p>
<ul>
<li><p>时间复杂度：</p>
<p>$O(243 \cdot 3 + \log n + \log\log n + \log\log\log n)=O(\log n)$.</p>
<ul>
<li><p>查找给定数字的下一个值的成本为$O(\log n)$，因为我们正在处理数字中的每位数字，而数字中的位数由 $\log n$给定。</p>
</li>
<li><p>要计算出总的时间复杂度，我们需要仔细考虑循环中有多少个数字，它们有多大。</p>
</li>
<li><p>我们在上面确定，一旦一个数字低于 243，它就不可能回到 243 以上。因此，我们就可以用 243以下最长循环的长度来代替 243，不过，因为常数无论如何都无关紧要，所以我们不会担心它。</p>
</li>
<li><p>对于高于 243 的 n，我们需要考虑循环中每个数高于 243 的成本。通过数学运算，我们可以证明在最坏的情况下，这些成本将是 $O(\log n) + O(\log \log n) + O(\log \log \log n)$。幸运的是，$O(\log n)$ 是占主导地位的部分，而其他部分相比之下都很小（总的来说，它们的总和小于$\log n$），所以我们可以忽略它们。</p>
</li>
</ul>
</li>
<li><p>空间复杂度：$O(\log n)$。与时间复杂度密切相关的是衡量我们放入 HashSet 中的数字以及它们有多大的指标。对于足够大的 n，大部分空间将由 n 本身占用。我们可以很容易地优化到 $O(243 \cdot 3) = O(1)$，方法是只保存集合中小于 243 的数字，因为对于较高的数字，无论如何都不可能返回到它们。</p>
</li>
</ul>
<h4 id="方法二：快慢指针法"><a href="#方法二：快慢指针法" class="headerlink" title="方法二：快慢指针法"></a>方法二：快慢指针法</h4><p>通过反复调用 <code>getNext(n)</code> 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。<code>next</code> 指针是通过调用 <code>getNext(n)</code> 函数获得。</p>
<p>意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的快的称为 “乌龟”，跑得快的称为 “兔子”。</p>
<p>不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。</p>
<p><img src="/2020/04/30/2020-04-30-LeetCode-CheckDaily/1.jpg" alt="img"><strong>算法：</strong></p>
<p>我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 <code>getNext(n)</code> 函数的嵌套调用）。如果 <code>n</code> 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。如果 <code>n</code> 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int getNext(int n) &#123;</span><br><span class="line">        int totalSum &#x3D; 0;</span><br><span class="line">        while (n &gt; 0) &#123;</span><br><span class="line">            int d &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            totalSum +&#x3D; d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        return totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsHappy(int n) &#123;</span><br><span class="line">        int slowRunner &#x3D; n;</span><br><span class="line">        int fastRunner &#x3D; getNext(n);</span><br><span class="line">        while (fastRunner !&#x3D; 1 &amp;&amp; slowRunner !&#x3D; fastRunner) &#123;</span><br><span class="line">            slowRunner &#x3D; getNext(slowRunner);</span><br><span class="line">            fastRunner &#x3D; getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        return fastRunner &#x3D;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(\log n)$，该分析建立在对前一种方法的分析的基础上，但是这次我们需要跟踪两个指针而不是一个指针来分析，以及在它们相遇前需要绕着这个循环走多少次。<ul>
<li>如果没有循环，那么快跑者将先到达 1，慢跑者将到达链表中的一半。我们知道最坏的情况下，成本是 $O(2 \cdot \log n) = O(\log n)$。</li>
<li>一旦两个指针都在循环中，在每个循环中，快跑者将离慢跑者更近一步。一旦快跑者落后慢跑者一步，他们就会在下一步相遇。假设循环中有 k个数字。如果他们的起点是相隔 k-1的位置（这是他们可以开始的最远的距离），那么快跑者需要 k-1步才能到达慢跑者，这对于我们的目的来说也是不变的。因此，主操作仍然在计算起始 n 的下一个值，即 $O(\log n)$。</li>
</ul>
</li>
<li>空间复杂度：$O(1)$，对于这种方法，我们不需要哈希集来检测循环。指针需要常数的额外空间。</li>
</ul>
<h4 id="方法三：数学"><a href="#方法三：数学" class="headerlink" title="方法三：数学"></a>方法三：数学</h4><p>前两种方法是面试中应该想到的。第三种方法不是你在面试中会写的，而是针对对数学好奇的人，因为它很有趣。下一个值可能比自己大的最大数字是什么？根据我们之前的分析，我们知道它必须低于 243。因此，我们知道任何循环都必须包含小于 243 的数字，用这么小的数字，编写一个能找到所有周期的强力程序并不困难。如果这样做，您会发现只有一个循环：$4 \rightarrow 16 \rightarrow 37 \rightarrow 58 \rightarrow 89 \rightarrow 145 \rightarrow 42 \rightarrow 20 \rightarrow 4$。所有其他数字都在进入这个循环的链上，或者在进入 11 的链上。因此，我们可以硬编码一个包含这些数字的散列集，如果我们达到其中一个数字，那么我们就知道在循环中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int getNext(int n) &#123;</span><br><span class="line">        int totalSum &#x3D; 0;</span><br><span class="line">        while (n &gt; 0) &#123;</span><br><span class="line">            int d &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            totalSum +&#x3D; d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        return totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsHappy(int n) &#123;</span><br><span class="line">        HashSet&lt;int&gt; cycleMembers &#x3D;</span><br><span class="line">            new HashSet&lt;int&gt;(new int[8] &#123;4, 16, 37, 58, 89, 145, 42, 20&#125;);</span><br><span class="line"></span><br><span class="line">        while (n !&#x3D; 1 &amp;&amp; !cycleMembers.Contains(n)) &#123;</span><br><span class="line">            n &#x3D; getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        return n &#x3D;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(\log n)$。</li>
<li>空间复杂度：$O(1)$，我们没有保留我们所遇到的数字的历史记录。硬编码哈希集的大小是固定的。</li>
</ul>
<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> ListNode;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;=l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1) p-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2) p-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-3"><a href="#官方解法-3" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p>我们可以如下递归地定义两个链表里的 <code>merge</code> 操作（忽略边界情况，比如空链表等）：<br>$$<br>\begin{cases}<br>list1[0] + merge(list1[1:], list2) &amp; list1[0] &lt; list2[0] \<br>list2[0] + merge(list1, list2[1:]) &amp; otherwise<br>\end{cases}<br>$$<br>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并。</p>
<p><strong>算法</strong></p>
<p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p>
<p>如果 <code>l1</code> 或者 <code>l2</code> 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 <code>l1</code> 或者 <code>l2</code> 的头节点（直到至少有一个链表为空），函数 <code>mergeTwoList</code> 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。</li>
<li>空间复杂度：O(n + m)，其中 n和 m分别为两个链表的长度。递归调用 <code>mergeTwoLists</code> 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 <code>mergeTwoLists</code> 函数最多调用 n+m次，因此空间复杂度为 O(n+m)。</li>
</ul>
<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-4"><a href="#我的解法-4" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(ch)==<span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>.insert(ch);</span><br><span class="line">                res = <span class="built_in">max</span>(res,i-left+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(s[left]!=s[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">map</span>.erase(s[left++]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a><strong>进阶:</strong></h4><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p>
<h3 id="我的解法-5"><a href="#我的解法-5" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res ;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">                res = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">                res = <span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-4"><a href="#官方解法-4" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> lSum, rSum, mSum, iSum;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Status <span class="title">pushUp</span><span class="params">(Status l, Status r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iSum = l.iSum + r.iSum;</span><br><span class="line">        <span class="keyword">int</span> lSum = <span class="built_in">max</span>(l.lSum, l.iSum + r.lSum);</span><br><span class="line">        <span class="keyword">int</span> rSum = <span class="built_in">max</span>(r.rSum, r.iSum + l.rSum);</span><br><span class="line">        <span class="keyword">int</span> mSum = <span class="built_in">max</span>(<span class="built_in">max</span>(l.mSum, r.mSum), l.rSum + r.lSum);</span><br><span class="line">        <span class="keyword">return</span> (Status) &#123;lSum, rSum, mSum, iSum&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Status <span class="title">get</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (Status) &#123;a[l], a[l], a[l], a[l]&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Status lSub = <span class="built_in">get</span>(a, l, m);</span><br><span class="line">        Status rSub = <span class="built_in">get</span>(a, m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> pushUp(lSub, rSub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>).mSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>假设序列 <code>a</code>的长度为 <code>n</code>。</p>
<p><strong>时间复杂度</strong>：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界为 $O(\log n)$，这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O(\sum_{i = 1}^{\log n} 2^{i - 1}) = O(n)$，故渐进时间复杂度为$O(n)$。<br>空间复杂度：递归会使用 $O(\log n)$ 的栈空间，故渐进空间复杂度为 $O(\log n)$。</p>
<p><strong>题外话</strong><br>「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？</p>
<p>对于这道题而言，确实是如此的。但是仔细观察「方法二」，它不仅可以解决区间<code>[0, n - 1]</code>，还可以用于解决任意的子区间 <code>[l, r]</code>的问题。如果我们把 <code>[0, n - 1]</code> 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一颗真正的树之后，我们就可以在 $O(\log n)$ 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 $O(\log n)$ 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构——线段树。</p>
<h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值</span></span><br><span class="line">        <span class="keyword">int</span> result = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> numsSize = <span class="keyword">int</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            result = <span class="built_in">max</span>(result, sum);</span><br><span class="line">            <span class="comment">//如果sum &lt; 0，重新开始找子序串</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>堆与优先队列</title>
    <url>/2020/04/23/2020-04-23-Cpp-heap/</url>
    <content><![CDATA[<p>堆（heaps）是一种特殊的数据组织方式，<a href="http://c.biancheng.net/stl/" target="_blank" rel="noopener">STL</a> 中的 priority_queue 容器适配器底层就是采用堆来组织数据存储的。为了弄明白堆是什么，首先要搞清楚什么是树存储结构。</p>
<p>本节就来学习C++中点的堆于优先队列。</p>
<a id="more"></a>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>  堆（heap）是一种非常重要的数据结构（这里我们讨论的是二叉堆），它是一棵满足特定条件的完全二叉树，堆的定义如下：</p>
<p>堆是一棵树完全二叉树，对于该完全二叉树中的每一个结点x，其关键字大于等于(或小于等于）其左右孩子结点，而其左右子树均为一个二叉堆。</p>
<p>在上述的定义中，若堆中父亲结点关键字的值大于等于孩子结点，则称该堆为大顶堆；若堆中父亲结点关键子的值小于等于孩子结点，则称该堆为小顶堆。</p>
<p>由于堆是一棵完全二叉树，所以我们可以很轻易地用一个数组存储堆中的每一个元素，并且由子结点访问到其父亲结点和由父亲结点访问到其子结点</p>
<p>堆是一种用于查找最大值/最小值的二叉树<br>支持添加/减少数据，添加/删除的复杂度是O(logn)，查找的复杂度是O(1)<br>堆的结构：</p>
<p>大根堆：顾名思义，根结点的值比两个子结点都大.<br>小根堆：顾名思义，根节点的值比两个子结点都小.<br>堆中结点序号：若根节点序号为1，则根节点的左结点为2（1<em>2），右结点为3（1</em>2+1）。堆的全部结点均满足该性质.</p>
<h4 id="STL基本操作"><a href="#STL基本操作" class="headerlink" title="STL基本操作"></a>STL基本操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">size</span>(); <span class="comment">//返回堆内元素个数。</span></span><br><span class="line">a.empty();<span class="comment">//如果堆为空，返回真，否则返回假。</span></span><br><span class="line">a.top();<span class="comment">//返回堆顶元素。</span></span><br><span class="line">a.pop();<span class="comment">//删除堆顶元素，自动整理。</span></span><br><span class="line">a.push(x);<span class="comment">//插入一个元素x，自动整理。</span></span><br></pre></td></tr></table></figure>



<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>先来回顾一下<strong>队列</strong>，队列是一种先进先出（FIFO）的数据结构，它的本质是一个线性表，只能在表的一端插入值，在表的另一端删除值。</p>
<ul>
<li>队尾（rear）：允许插入的一端；</li>
<li>队头（front）：允许删除的一端。</li>
</ul>
<img src="/2020/04/23/2020-04-23-Cpp-heap/image-20200426101423861.png" alt="image-20200426101423861" style="zoom:50%;">

<p>优先队列也是一种队列，与队列不同的是，优先队列不再遵循先入先出的原则，而是分成了两种情况：</p>
<ul>
<li>最大优先队列，无论入队顺序，当前最大的元素优先出队。</li>
<li>最小优先队列，无论入队顺序，当前最小的元素优先出队。</li>
</ul>
<p>对于最小优先队列，队列中的每个元素都有一个权值，权值小的优先出队。假如我们将自身的数值作为权值，那么最小优先队列中较小的数会排在队列的前面，当加入一个新值 <code>3</code> 时，<code>3</code> 会在队列中处于合适的位置。</p>
<p>当进行出队操作时，每次会从队首弹出队列中最小的元素：<br><img src="/2020/04/23/2020-04-23-Cpp-heap/image-20200426101437274.png" alt="image-20200426101437274" style="zoom: 67%;"></p>
<p>最大优先队列则与之相反，最先弹出队列中最大的元素。</p>
<p>事实上，优先队列的本质上是一个堆，它是一棵完全二叉树，分为小顶堆和大顶堆：</p>
<ul>
<li>小顶堆是每一个根节点小于左右子节点的完全二叉树，堆顶元素最小，对应最小优先队列；</li>
<li>大顶堆是每一个根节点大于左右子节点的完全二叉树，堆顶元素最大，对应最大优先队列；</li>
</ul>
<p>由于删除堆顶元素时的时间复杂度为 $O(\log N)$，因此在优先队列中入队和出队操作的时间复杂度也是 $O(\log N)$。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><h4 id="面试题41-数据流中的中位数"><a href="#面试题41-数据流中的中位数" class="headerlink" title="面试题41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">面试题41. 数据流中的中位数</a></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian() - 返回目前所有元素的中位数。</li>
</ul>
<h6 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure>

<h6 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure>

<h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><h6 id="思路：使用堆和优先队列"><a href="#思路：使用堆和优先队列" class="headerlink" title="思路：使用堆和优先队列"></a><strong>思路：使用堆和优先队列</strong></h6><p>我们将中位数左边的数保存在大顶堆中，右边的数保存在小顶堆中。这样我们可以在O(1) 时间内得到中位数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; lo;                              <span class="comment">// 大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; hi;   <span class="comment">// 小顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Adds a number into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lo.push(num);                                    <span class="comment">// 加到大顶堆</span></span><br><span class="line"></span><br><span class="line">        hi.push(lo.top());                               <span class="comment">// 平衡</span></span><br><span class="line">        lo.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lo.<span class="built_in">size</span>() &lt; hi.<span class="built_in">size</span>()) &#123;                     <span class="comment">// 维护两个堆元素个数</span></span><br><span class="line">            lo.push(hi.top());</span><br><span class="line">            hi.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the median of current data stream</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lo.<span class="built_in">size</span>() &gt; hi.<span class="built_in">size</span>() ? (<span class="keyword">double</span>) lo.top() : (lo.top() + hi.top()) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：O(logn)。堆插入和删除需要O(logn)，查找中位数需要 O(1)。<br>空间复杂度：O(n)。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优先队列</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-20~26</title>
    <url>/2020/04/22/2020-04-22-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>本周打卡题目如下：</p>
<table>
<thead>
<tr>
<th>题目</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币</a></td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a></td>
<td align="center">困难</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></td>
<td align="center">困难</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(col==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flag</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag[i][j]&amp;&amp;grid[i][j]==<span class="string">'1'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">                    q.push(&#123;i,j&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = q.front();</span><br><span class="line">                        q.pop();</span><br><span class="line">                        flag[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">int</span> nx,ny;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            nx = vec[<span class="number">0</span>]+dx[k];</span><br><span class="line">                            ny = vec[<span class="number">1</span>]+dy[k];</span><br><span class="line">                            <span class="keyword">if</span>(<span class="number">0</span>&lt;=nx&amp;&amp;nx&lt;row&amp;&amp;<span class="number">0</span>&lt;=ny&amp;&amp;ny&lt;col&amp;&amp;grid[nx][ny]==<span class="string">'1'</span>&amp;&amp;flag[nx][ny])</span><br><span class="line">                            &#123;</span><br><span class="line">                                q.push(&#123;nx,ny&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; neighbors;</span><br><span class="line">                    neighbors.push(&#123;r, c&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (!neighbors.empty()) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> rc = neighbors.front();</span><br><span class="line">                        neighbors.pop();</span><br><span class="line">                        <span class="keyword">int</span> row = rc.first, col = rc.second;</span><br><span class="line">                        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row<span class="number">-1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row<span class="number">-1</span>, col&#125;);</span><br><span class="line">                            grid[row<span class="number">-1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; nr &amp;&amp; grid[row+<span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row+<span class="number">1</span>, col&#125;);</span><br><span class="line">                            grid[row+<span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col<span class="number">-1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col<span class="number">-1</span>&#125;);</span><br><span class="line">                            grid[row][col<span class="number">-1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nc &amp;&amp; grid[row][col+<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col+<span class="number">1</span>&#125;);</span><br><span class="line">                            grid[row][col+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248. 统计「优美子数组」"></a><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。</p>
<p>如果某个 <strong>连续</strong> 子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p>
<p>请返回这个数组中「优美子数组」的数目。 </p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,1,1], k &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,4,6], k &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line">解释：数列中不包含任何奇数，所以不存在优美子数组。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,1,2,2,1,2,2,2], k &#x3D; 2</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">            cnt += nums[++r] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n &amp;&amp; cnt &lt; k) cnt += nums[++r] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> k_cnt_right_begin = r;</span><br><span class="line">            <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n &amp;&amp; !(nums[r + <span class="number">1</span>] &amp; <span class="number">1</span>)) ++r;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; cnt == k) &#123;</span><br><span class="line">                ans += r - k_cnt_right_begin + <span class="number">1</span>;</span><br><span class="line">                cnt -= nums[l++] &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root)   </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> lastlevel=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> nextlevel = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* p = q.front();</span><br><span class="line">            lastlevel--;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                nextlevel++;</span><br><span class="line">                q.push(p-&gt;left); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                nextlevel++;</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lastlevel==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(p-&gt;val);</span><br><span class="line">                lastlevel = nextlevel;</span><br><span class="line">                nextlevel = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a><strong>示例1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入: n &#x3D; 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure>

<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a><strong>示例2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入: n &#x3D; 10</span><br><span class="line"> 输出：4</span><br><span class="line"> 解释: 有四种方式可以凑成总金额:</span><br><span class="line">10&#x3D;10</span><br><span class="line">10&#x3D;5+5</span><br><span class="line">10&#x3D;5+1+1+1+1+1</span><br><span class="line">10&#x3D;1+1+1+1+1+1+1+1+1+1</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>注意:</p>
<p>你可以假设：</p>
<ul>
<li>0 &lt;= n (总金额) &lt;= 1000000</li>
</ul>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p><strong>思路</strong></p>
<p>首先考虑一个朴素的方法，我们用 $f(i, v)$ 来表示前 i 种面值的硬币构成面值为 v 的方案数量，用 $c_i$来表示第 i 种面值的硬币的面值。</p>
<p>我们可以从 $f(i - 1, v - 0 \times c_i),f(i - 1, v - 1 \times c_i), f(i - 1, v - 2 \times c_i) \cdots f(i - 1, v - k \times c_i) $转移得到，它们表示第 i个面值的硬币选 $0, 1, 2 \cdots k $个的时候，构成面值为 <code>v</code> 的方案数量，其中 <code>k</code>为满足 $v - k \times c_i \geq 0$的最大整数。于是我们可以推导出这样的动态规划转移方程：<br>$$<br>f(i, v) = \sum_{j = 0}^{k} f(i - 1, v - j \times c_i) , , ,k = \lfloor \frac{v}{c_i} \rfloor<br>$$<br><strong>这个方程表示什么意思呢？</strong> 这个方程表示前<code>i</code>种硬币，构成面值<code>v</code> 的方案数量由前 <code>i - 1</code>种面值构成的一些面值的方案数量决定。我们可以考虑 $c_i$取多少个，$c_i$可以取 0 个、1 个、2 个……最大可以取 $\lfloor \frac{v}{c_i} \rfloor$ 个，那么前 i 种硬币，构成面值 v 的方案数量就是如下项的累加：前 $i - 1$ 种硬币构成面值$v$的方案数量（表示不取 $c_i$），前 $i - 1$种硬币构成面值$ v - c_i$的方案数量（表示取 1 个 $c_i$），前 $i - 1$种硬币构成面值$ v - 2 \times c_i $的方案数量（表示取 2个$c_i$），前 $i - 1$ 种硬币构成面值 $v - \lfloor \frac{v}{c_i} \rfloor \times c_i$的方案数量（表示取$ \lfloor \frac{v}{c_i} \rfloor$个 $c_i$）。</p>
<p><strong>举个例子。</strong> 假设这里 $c = {1, 5, 10, 25}$，在 $i = 4 $的时候，$c_i = 25$（假设下标从 1 开始），如果我们要求前 44 种面值构成 90的方案数量，可以这么写：</p>
<p>$f(4, 90) = f(3, 90) + f(3, 90 - 25) + f(3, 90 - 2 \times 25) + f(3, 90 - 3 \times 25)$</p>
<p>这里最多取 3 个 25，所以等式右边一共有四项，分别代表取 0、1、2、3 个 25，即从前 3 种面值构成 90、90 - 25、$90 - 2 \times 25$、$90 - 3 \times 25$四个状态中进行选择。</p>
<p>在实现这样一个转移方程的时候，i 的取值有 4 种，v的取值有$n + 1$ 种，所以状态总数是 $4(n + 1)$，我们需要用到 $O(4 \times (n + 1))$ 的空间代价来存取状态。对于每一个状态，我们需要在区间 <code>[0, k]</code> 枚举 j，所以计算单个状态的时间代价是 $O(\lfloor \frac{v}{c_i} \rfloor)$，所以总的时间代价是 $O(4 \times (n + 1) \times \lfloor \frac{v}{c_i} \rfloor)$。于是我们就可以用三重循环来实现这个朴素的转移方程。</p>
<p><strong>考虑优化方法。</strong></p>
<p><strong>第一步考虑优化时间复杂度。</strong> 我们可以把求和式展开书写：</p>
<p>$f(i, v) = f(i - 1, v) + \color{red}{ f(i - 1, v - c_i) + f(i - 1, v - 2 c_i) \cdots f(i - 1, v - k c_i) }$</p>
<p>共 k + 1 项，其中 $k = \lfloor \frac{v}{c_i} \rfloor$。那么我们可以得到使用 $v - c_i$ 替换 v，得到：</p>
<p>$f(i, v - c_i) = \color{red}{ f(i - 1, v - c_i) + f(i - 1, v - 2 c_i) + f(i - 1, v - 3 c_i) \cdots f(i - 1, v - k c_i) }$</p>
<p>共 k<em>k</em> 项。注意到上面两个方程中标成红色的 k项是完全相同的，于是我们可以用下面式子的左半部分 $f(i, v - c_i)$ 等价替换上面式子红色的 k项，得到化简后的转移方程：</p>
<p>$f(i, v) = f(i - 1, v) + f(i, v - c_i)$</p>
<p>这样我们就可以把原来的三重循环变成两重循环，求解每个状态的时间代价是 <strong>O(1)</strong>，总的时间代价为 $O(4 \times (n + 1))$。</p>
<p><strong>第二步考虑优化空间复杂度。</strong> 朴素实现的时候我们需要一个 $4 \times (n + 1)$的二维数组。观察方程 $f(i, v) = f(i - 1, c_i) + f(i, v - c_i)$，更新二维数组的第 i行只和第 i - 1相关，我们不关心 $[0, i - 2]$行，于是我们可以用「滚动数组」思想来优化这个过程。实现的方法有两种。</p>
<ul>
<li>用两个一维数组来实现转移：通过 i 和 i - 1 的奇偶性相反来实现，即当求到第 i行那一轮的时候，把第 $({i \bmod 2}) {\rm , xor ,} 1$ 行当作是 $i - 1$行，这样就只需要两行，循环利用。</li>
<li>用一个一维数组来实现转移：我们用数组 $F[0 \cdots n]$ 表示，我们在第$i$ 轮计算之前 $i - 1$轮的答案保存在 F 数组中，$F[v]$保存的是 $i - 1$ 轮 $f(i - 1, v)$ 的值，在第 i轮计算结束后，它将保存 $f(i, v)$的值。假设第二维从小到大更新，因为 $f(i, v)$只和 $f(i, v - c_i)$ 和 $f(i - 1, v)$ 相关，在计算 $f(i, v)$ 但是还没有更新 $F[v]$ 值的时候，$F[v]$ 保存的是上一轮的答案 $f(i - 1, v)$，而 $F[0 \cdots v - 1]$ 中保存的是 $f(i, v’), v’ \in [0, v - 1]$ 的值，$f(i, v - c_i)$包含在其中，所以这么做是可行的。<strong>代码中给出了这种方法的实现，如果这里看不懂可以结合代码。</strong></li>
</ul>
<p>这样一来，空间代价就可以从 $O(4 \times (n + 1))$ 变成 $O(2 \times (n + 1))$ 或者 $O(n + 1)$。</p>
<p><strong>其实这个问题是两个非常经典的问题的组合，其一是「完全背包问题」，其二是「背包方案数问题」，如果读者感兴趣的话可以自行阅读《背包九讲》。掌握了这些常见的背包问题的模型，你对动态规划的理解将更进一步。</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; coins = &#123;25,10,5,1&#125;;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coins = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:coins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = c;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i] =(f[i]+ f[i-c])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题51-数组中的逆序对"><a href="#面试题51-数组中的逆序对" class="headerlink" title="面试题51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<h4 id="限制："><a href="#限制：" class="headerlink" title="限制："></a><strong>限制：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="暴力法（超时）"><a href="#暴力法（超时）" class="headerlink" title="暴力法（超时）"></a>暴力法（超时）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                count+=nums[i]&gt;nums[j]?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：归并排序"><a href="#方法一：归并排序" class="headerlink" title="方法一：归并排序"></a>方法一：归并排序</h4><p><strong>预备知识</strong></p>
<p>「归并排序」是分治思想的典型应用，它包含这样三个步骤：</p>
<ul>
<li><strong>分解：</strong> 待排序的区间为 <code>[l, r][*l*,*r*]</code>，令 $m = \lfloor \frac{l + r}{2} \rfloor⌋$，我们把<code>[l, r]</code> 分成 <code>[l, m]</code>和 <code>[m + 1, r]</code>.</li>
<li><strong>解决：</strong> 使用归并排序递归地排序两个子序列</li>
<li><strong>合并：</strong> 把两个已经排好序的子序列 <code>[l, m]</code>和 <code>[m + 1, r]</code>合并起来</li>
</ul>
<p>在待排序序列长度为 1的时候，递归开始「回升」，因为我们默认长度为 1 的序列是排好序的。</p>
<p><strong>思路</strong></p>
<p>那么求逆序对和归并排序又有什么关系呢？关键就在于「归并」当中「并」的过程。我们通过一个实例来看看。假设我们有两个已排序的序列等待合并，分别是 $L = { 8, 12, 16, 22, 100 } $和 $R = { 9, 26, 55, 64, 91 }$。一开始我们用指针 <code>lPtr = 0</code> 指向 L<em>L</em> 的首部，<code>rPtr = 0</code> 指向 R<em>R</em> 的头部。记已经合并好的部分为 M<em>M</em>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; []</span><br><span class="line">     |                          |</span><br><span class="line">   lPtr                       rPtr</span><br></pre></td></tr></table></figure>

<p>我们发现 <code>lPtr</code> 指向的元素小于 <code>rPtr</code> 指向的元素，于是把 <code>lPtr</code> 指向的元素放入答案，并把 <code>lPtr</code> 后移一位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8]</span><br><span class="line">        |                       |</span><br><span class="line">      lPtr                     rPtr</span><br></pre></td></tr></table></figure>

<p>这个时候我们把左边的 8 加入了答案，我们发现右边没有数比 8 小，所以 8 对逆序对总数的「贡献」为 0。</p>
<p>接着我们继续合并，把 9 加入了答案，此时 <code>lPtr</code> 指向 12，<code>rPtr</code> 指向 26。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8, 9]</span><br><span class="line">        |                          |</span><br><span class="line">       lPtr                       rPtr</span><br></pre></td></tr></table></figure>

<p>此时 <code>lPtr</code> 比 <code>rPtr</code> 小，把 <code>lPtr</code> 对应的数加入答案，并考虑它对逆序对总数的贡献为 <code>rPtr</code> 相对 R<em>R</em> 首位置的偏移 1（即右边只有一个数比 12 小，所以只有它和 12 构成逆序对），以此类推。</p>
<p>我们发现用这种「算贡献」的思想在合并的过程中计算逆序对的数量的时候，只在 <code>lPtr</code> 右移的时候计算，是基于这样的事实：当前 <code>lPtr</code> 指向的数字比 <code>rPtr</code> 小，但是比 R<em>R</em> 中 <code>[0 ... rPtr - 1]</code> 的其他数字大，<code>[0 ... rPtr - 1]</code> 的其他数字本应当排在 <code>lPtr</code> 对应数字的左边，但是它排在了右边，所以这里就贡献了 <code>rPtr</code> 个逆序对。</p>
<p>利用这个思路，我们可以写出如下代码。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, pos = l;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp[pos] = nums[i];</span><br><span class="line">                ++i;</span><br><span class="line">                inv_count += (j - (mid + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[pos] = nums[j];</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= mid; ++k) &#123;</span><br><span class="line">            tmp[pos++] = nums[k];</span><br><span class="line">            inv_count += (j - (mid + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= r; ++k) &#123;</span><br><span class="line">            tmp[pos++] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        copy(tmp.<span class="built_in">begin</span>() + l, tmp.<span class="built_in">begin</span>() + r + <span class="number">1</span>, nums.<span class="built_in">begin</span>() + l);</span><br><span class="line">        <span class="keyword">return</span> inv_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums, tmp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong></p>
<p>记序列长度为 n。</p>
<ul>
<li>时间复杂度：同归并排序 $O(n \log n)$。</li>
<li>空间复杂度：同归并排序 $O(n)$，因为归并排序需要用到一个临时数组。</li>
</ul>
<h4 id="方法二：离散化树状数组"><a href="#方法二：离散化树状数组" class="headerlink" title="方法二：离散化树状数组"></a>方法二：离散化树状数组</h4><p><strong>预备知识</strong></p>
<p>「树状数组」是一种可以动态维护序列前缀和的数据结构，它的功能是：</p>
<ul>
<li><strong>单点更新 <code>update(i, v)</code>：</strong> 把序列 i<em>i</em> 位置的数加上一个值 v，这题 v = 1</li>
<li><strong>区间查询 <code>query(i)</code>：</strong> 查询序列 $[1 \cdots i]$ 区间的区间和，即 i位置的前缀和</li>
</ul>
<p>修改和查询的时间代价都是 $O(\log n)$，其中 $n$为需要维护前缀和的序列的长度。</p>
<p><strong>思路</strong></p>
<p>记题目给定的序列为 a，我们规定 $a_i$的取值集合为 a的「值域」。我们用桶来表示值域中的每一个数，桶中记录这些数字出现的次数。假设$a = {5, 5, 2, 3, 6}$，那么遍历这个序列得到的桶是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index  -&gt;  1 2 3 4 5 6 7 8 9</span><br><span class="line">value  -&gt;  0 1 1 0 2 1 0 0 0</span><br></pre></td></tr></table></figure>

<p>我们可以看出它第 i - 1 位的前缀和表示「有多少个数比 i小」。那么我们可以从后往前遍历序列 a，记当前遍历到的元素为 $a_i$，我们把 $a_i$对应的桶的值自增 1，把 i - 1 位置的前缀和加入到答案中算贡献。为什么这么做是对的呢，因为我们在循环的过程中，我们把原序列分成了两部分，后半部部分已经遍历过（已入桶），前半部分是待遍历的（未入桶），那么我们求到的 i - 1 位置的前缀和就是「已入桶」的元素中比 $a_i$大的元素的总和，而这些元素在原序列中排在 $a_i$的后面，但它们本应该排在 $a_i$ 的前面，这样就形成了逆序对。</p>
<p>我们显然可以用数组来实现这个桶，可问题是如果 $a_i$中有很大的元素，比如 $10^9$，我们就要开一个大小为 $10^9$ 的桶，内存中是存不下的。这个桶数组中很多位置是 0，有效位置是稀疏的，我们要想一个办法让有效的位置全聚集到一起，减少无效位置的出现，这个时候我们就需要用到一个方法——离散化。</p>
<p>离散化一个序列的前提是我们只关心这个序列里面元素的相对大小，而不关心绝对大小（即只关心元素在序列中的排名）；离散化的目的是让原来分布零散的值聚集到一起，减少空间浪费。那么如何获得元素排名呢，我们可以对原序列排序后去重，对于每一个 $a_i$ 通过二分查找的方式计算排名作为离散化之后的值。当然这里也可以不去重，不影响排名。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BIT(<span class="keyword">int</span> _n): n(_n), tree(_n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            ret += tree[x];</span><br><span class="line">            x -= lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            ++tree[x];</span><br><span class="line">            x += lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = nums;</span><br><span class="line">        <span class="comment">// 离散化</span></span><br><span class="line">        sort(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; num: nums) &#123;</span><br><span class="line">            num = lower_bound(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), num) - tmp.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 树状数组统计逆序对</span></span><br><span class="line">        <span class="function">BIT <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans += <span class="built_in">bit</span>.query(nums[i] - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">bit</span>.update(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：离散化的过程中使用了时间代价为 $O(n \log n)$的排序，单次二分的时间代价为 $O(\log n)$，一共有 n次，总时间代价为 $O(n \log n)$；循环执行 n次，每次进行$O(\log n)$的修改和 $O(\log n)$的查找，总时间代价为 $O(n \log n)$。故渐进时间复杂度为 $O(n \log n)$。</li>
<li>空间复杂度：树状数组需要使用长度为 n的数组作为辅助空间，故渐进空间复杂度为 O(n)。</li>
</ul>
<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-4"><a href="#我的解法-4" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) &#123;res.push_back(&#123;nums[<span class="number">0</span>]&#125;); <span class="keyword">return</span> res;&#125;</span><br><span class="line">        <span class="keyword">int</span> le = nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        nums.pop_back();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; lres = permute(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> r:lres)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;= r.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = r;</span><br><span class="line">                tmp.insert(tmp.<span class="built_in">begin</span>()+i,<span class="number">1</span>,le);</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-5"><a href="#我的解法-5" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="逐个合并，暴力解法"><a href="#逐个合并，暴力解法" class="headerlink" title="逐个合并，暴力解法"></a>逐个合并，暴力解法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode *head = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:lists)</span><br><span class="line">        &#123;</span><br><span class="line">            head = merge(head,p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode *p1,ListNode*p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p1||!p2)</span><br><span class="line">            <span class="keyword">return</span> p1==<span class="literal">nullptr</span>?p2:p1;</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p1&amp;&amp;p2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val&lt;=p2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = p1;</span><br><span class="line">                p1=p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = p2;</span><br><span class="line">                p2=p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = p1==<span class="literal">nullptr</span>?p2:p1;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(k^2n)$</p>
<p>空间复杂度：$O(1)$</p>
<h3 id="官方解法-2"><a href="#官方解法-2" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法二：分治合并"><a href="#方法二：分治合并" class="headerlink" title="方法二：分治合并"></a>方法二：分治合并</h4><p>考虑优化方法一，用分治的方法进行合并。</p>
<p>将 k 个链表配对并将同一对中的链表合并；<br>第一轮合并以后， k 个链表被合并成了 $\frac{k}{2} $  个链表，平均长度为 $\frac{2n}{k} $ ，然后是 $\frac{k}{4} $  个链表， $\frac{k}{8} $<br>  个链表等等；重复这一过程，直到我们得到了最终的有序链表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!a) || (!b)) <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = aPtr; aPtr = aPtr-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = bPtr; bPtr = bPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = (aPtr ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(<span class="built_in">vector</span> &lt;ListNode*&gt; &amp;lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法三：使用优先队列合并"><a href="#方法三：使用优先队列合并" class="headerlink" title="方法三：使用优先队列合并"></a>方法三：使用优先队列合并</h4><p>这个方法和前两种方法的思路有所不同，我们需要维护当前每个链表没有被合并的元素的最前面一个，kk 个链表就最多有 kk 个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *ptr;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Status &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> val &gt; rhs.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue &lt;Status&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node: lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node) q.push(&#123;node-&gt;val, node&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head, *tail = &amp;head;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.top(); q.pop();</span><br><span class="line">            tail-&gt;next = f.ptr; </span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (f.ptr-&gt;next) q.push(&#123;f.ptr-&gt;next-&gt;val, f.ptr-&gt;next&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第185场周赛</title>
    <url>/2020/04/19/2020-04-19-LeetCode-Contest-185/</url>
    <content><![CDATA[<p>今日参加周赛，战况惨烈，排名<code>1486 / 5002</code></p>
<table>
<thead>
<tr>
<th>题目</th>
<th align="center">分值</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/reformat-the-string/" target="_blank" rel="noopener">5388. 重新格式化字符串</a></td>
<td align="center">3</td>
<td align="center">简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/" target="_blank" rel="noopener">5389. 点菜展示表</a></td>
<td align="center">4</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking/" target="_blank" rel="noopener">5390. 数青蛙</a></td>
<td align="center">5</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/" target="_blank" rel="noopener">5391. 生成数组</a></td>
<td align="center">6</td>
<td align="center">困难</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="5388-重新t格式化字符串"><a href="#5388-重新t格式化字符串" class="headerlink" title="5388. 重新t格式化字符串"></a><a href="https://leetcode-cn.com/problems/reformat-the-string/" target="_blank" rel="noopener">5388. 重新t格式化字符串</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个混合了数字和字母的字符串 <code>s</code>，其中的字母均为小写英文字母。</p>
<p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p>
<p>请你返回 <strong>重新格式化后</strong> 的字符串；如果无法按要求重新格式化，则返回一个 <strong>空字符串</strong> 。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a0b1c2&quot;</span><br><span class="line">输出：&quot;0a1b2c&quot;</span><br><span class="line">解释：&quot;0a1b2c&quot; 中任意两个相邻字符的类型都不同。 &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; 也是满足题目要求的答案。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1229857369&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：&quot;1229857369&quot; 中只有数字，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;covid2019&quot;</span><br><span class="line">输出：&quot;c2o0v1i9d&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a><strong>示例 5：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ab123&quot;</span><br><span class="line">输出：&quot;1a2b3&quot;</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 仅由小写英文字母和/或数字组成。</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reformat</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; num;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; alp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>)</span><br><span class="line">                num.push(ch);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                alp.push(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n =alp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(m-n)&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">if</span>(num.<span class="built_in">size</span>()&gt;alp.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ch = num.top();</span><br><span class="line">            res.append(<span class="number">1</span>,ch);</span><br><span class="line">            num.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!alp.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ch = alp.top();</span><br><span class="line">            res.append(<span class="number">1</span>,ch);</span><br><span class="line">            alp.pop();</span><br><span class="line">            <span class="keyword">if</span>(!num.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                ch = num.top();</span><br><span class="line">                res.append(<span class="number">1</span>,ch);</span><br><span class="line">                num.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5389-点菜展示表"><a href="#5389-点菜展示表" class="headerlink" title="5389. 点菜展示表"></a><a href="https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/" target="_blank" rel="noopener">5389. 点菜展示表</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个数组 <code>orders</code>，表示客户在餐厅中完成的订单，确切地说， <code>orders[i]=[customerNamei,tableNumberi,foodItemi]</code> ，其中 <code>customerNamei</code> 是客户的姓名，<code>tableNumberi</code> 是客户所在餐桌的桌号，而 <code>foodItemi</code> 是客户点的餐品名称。</p>
<p>请你返回该餐厅的 <strong>点菜展示表</strong> <em>。</em>在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p>
<p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：orders &#x3D; [[&quot;David&quot;,&quot;3&quot;,&quot;Ceviche&quot;],[&quot;Corina&quot;,&quot;10&quot;,&quot;Beef Burrito&quot;],[&quot;David&quot;,&quot;3&quot;,&quot;Fried Chicken&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Water&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Ceviche&quot;],[&quot;Rous&quot;,&quot;3&quot;,&quot;Ceviche&quot;]]</span><br><span class="line">输出：[[&quot;Table&quot;,&quot;Beef Burrito&quot;,&quot;Ceviche&quot;,&quot;Fried Chicken&quot;,&quot;Water&quot;],[&quot;3&quot;,&quot;0&quot;,&quot;2&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;5&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],[&quot;10&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]] </span><br><span class="line">解释：</span><br><span class="line">点菜展示表如下所示：</span><br><span class="line">Table,Beef Burrito,Ceviche,Fried Chicken,Water</span><br><span class="line">3    ,0           ,2      ,1            ,0</span><br><span class="line">5    ,0           ,1      ,0            ,1</span><br><span class="line">10   ,1           ,0      ,0            ,0</span><br><span class="line">对于餐桌 3：David 点了 &quot;Ceviche&quot; 和 &quot;Fried Chicken&quot;，而 Rous 点了 &quot;Ceviche&quot;</span><br><span class="line">而餐桌 5：Carla 点了 &quot;Water&quot; 和 &quot;Ceviche&quot;</span><br><span class="line">餐桌 10：Corina 点了 &quot;Beef Burrito&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：orders &#x3D; [[&quot;James&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Ratesh&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Amadeus&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Adam&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;],[&quot;Brianna&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;]]</span><br><span class="line">输出：[[&quot;Table&quot;,&quot;Canadian Waffles&quot;,&quot;Fried Chicken&quot;],[&quot;1&quot;,&quot;2&quot;,&quot;0&quot;],[&quot;12&quot;,&quot;0&quot;,&quot;3&quot;]] </span><br><span class="line">解释：</span><br><span class="line">对于餐桌 1：Adam 和 Brianna 都点了 &quot;Canadian Waffles&quot;</span><br><span class="line">而餐桌 12：James, Ratesh 和 Amadeus 都点了 &quot;Fried Chicken&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：orders &#x3D; [[&quot;Laura&quot;,&quot;2&quot;,&quot;Bean Burrito&quot;],[&quot;Jhon&quot;,&quot;2&quot;,&quot;Beef Burrito&quot;],[&quot;Melissa&quot;,&quot;2&quot;,&quot;Soda&quot;]]</span><br><span class="line">输出：[[&quot;Table&quot;,&quot;Bean Burrito&quot;,&quot;Beef Burrito&quot;,&quot;Soda&quot;],[&quot;2&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= orders.length &lt;= 5 * 10^4</code></li>
<li><code>orders[i].length == 3</code></li>
<li><code>1 &lt;= customerNamei.length, foodItemi.length &lt;= 20</code></li>
<li><code>customerNamei</code> 和 <code>foodItemi</code> 由大小写英文字母及空格字符 <code>&#39; &#39;</code> 组成。</li>
<li><code>tableNumberi</code> 是 <code>1</code> 到 <code>500</code> 范围内的整数。</li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="哈希表-排序"><a href="#哈希表-排序" class="headerlink" title="哈希表+排序"></a>哈希表+排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>; <span class="comment">//桌号 菜 分数</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">set</span>;<span class="comment">//菜</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">displayTable</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; orders)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> gu:orders)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[gu[<span class="number">1</span>]][gu[<span class="number">2</span>]]++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.<span class="built_in">find</span>(gu[<span class="number">2</span>])==<span class="built_in">set</span>.<span class="built_in">end</span>())</span><br><span class="line">                <span class="built_in">set</span>.insert(gu[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">        tmp.push_back(<span class="string">"Table"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter=<span class="built_in">set</span>.<span class="built_in">begin</span>();iter!=<span class="built_in">set</span>.<span class="built_in">end</span>();iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.push_back(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(tmp.<span class="built_in">begin</span>()+<span class="number">1</span>,tmp.<span class="built_in">end</span>());</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter=<span class="built_in">map</span>.<span class="built_in">begin</span>();iter!=<span class="built_in">map</span>.<span class="built_in">end</span>();iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp1;</span><br><span class="line">            tmp1.push_back(iter-&gt;first);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;tmp.<span class="built_in">size</span>();i++)</span><br><span class="line">                tmp1.push_back(to_string(<span class="built_in">map</span>[iter-&gt;first][tmp[i]]));</span><br><span class="line">            res.push_back(tmp1);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.<span class="built_in">begin</span>()+<span class="number">1</span>,res.<span class="built_in">end</span>(),compare);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; a,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = stoi(a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> n2 = stoi(b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> n1&lt;n2; <span class="comment">//如果是从小到大，将"&gt;"变成“&lt;”即可；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5390-数青蛙"><a href="#5390-数青蛙" class="headerlink" title="5390. 数青蛙"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking/" target="_blank" rel="noopener">5390. 数青蛙</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 <code>croakOfFrogs</code>，它表示不同青蛙发出的蛙鸣声（字符串 “croak” ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 <code>croakOfFrogs</code> 中会混合多个 “croak” <em>。</em>请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。</p>
<p><strong>注意：</strong>要想发出蛙鸣 “croak”，青蛙必须 <strong>依序</strong> 输出 <code>‘c’, ’r’, ’o’, ’a’, ’k’</code> 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。</p>
<p>如果字符串 <code>croakOfFrogs</code> 不是由若干有效的 “croak” 字符混合而成，请返回 <code>-1</code> 。</p>
<h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：croakOfFrogs &#x3D; &quot;croakcroak&quot;</span><br><span class="line">输出：1 </span><br><span class="line">解释：一只青蛙 “呱呱” 两次</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：croakOfFrogs &#x3D; &quot;crcoakroak&quot;</span><br><span class="line">输出：2 </span><br><span class="line">解释：最少需要两只青蛙，“呱呱” 声用黑体标注</span><br><span class="line">第一只青蛙 &quot;crcoakroak&quot;</span><br><span class="line">第二只青蛙 &quot;crcoakroak&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：croakOfFrogs &#x3D; &quot;croakcrook&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：给出的字符串不是 &quot;croak&quot; 的有效组合。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：croakOfFrogs &#x3D; &quot;croakcroa&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= croakOfFrogs.length &lt;= 10^5</code></li>
<li>字符串中的字符只有 <code>&#39;c&#39;</code>, <code>&#39;r&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;a&#39;</code> 或者 <code>&#39;k&#39;</code></li>
</ul>
<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="1-通过队列来模拟需要的青蛙数量"><a href="#1-通过队列来模拟需要的青蛙数量" class="headerlink" title="1. 通过队列来模拟需要的青蛙数量"></a>1. 通过队列来模拟需要的青蛙数量</h4><p><strong>思路</strong></p>
<p>需要叫的时候就抓过来一只青蛙，叫完了就放走，统计队里里存在青蛙的最大数量</p>
<p>遍历字符串，现存的字符串中字符串数量 c &gt;= r &gt;= o &gt;= a &gt;= k<br>当遇到字符 c 时我们就往队列里加入一个青蛙，当遇到字符 k时我们就从队列里释放掉一个青蛙，同时把croak从计数的map中去掉<br>这样队列里曾经的最大的大小就是需要青蛙的数量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberOfFrogs</span><span class="params">(<span class="keyword">String</span> croakOfFrogs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curWokrerCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;Character, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">String</span> seq = <span class="string">"croak"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : croakOfFrogs.toCharArray()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(ch, <span class="built_in">map</span>.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!checkSeq(<span class="built_in">map</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'c'</span>) &#123;</span><br><span class="line">            curWokrerCount++;</span><br><span class="line">            res = Math.<span class="built_in">max</span>(res, curWokrerCount);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'k'</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : seq.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>.<span class="built_in">get</span>(c) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">map</span>.<span class="built_in">put</span>(c, <span class="built_in">map</span>.<span class="built_in">get</span>(c) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            curWokrerCount--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curWokrerCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkSeq</span><span class="params">(Map&lt;Character, Integer&gt; <span class="built_in">map</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cc = <span class="built_in">map</span>.getOrDefault(<span class="string">'c'</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rc = <span class="built_in">map</span>.getOrDefault(<span class="string">'r'</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> oc = <span class="built_in">map</span>.getOrDefault(<span class="string">'o'</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ac = <span class="built_in">map</span>.getOrDefault(<span class="string">'a'</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> kc = <span class="built_in">map</span>.getOrDefault(<span class="string">'k'</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cc &gt;= rc &amp;&amp; rc &gt;= oc &amp;&amp; oc &gt;= ac &amp;&amp; ac &gt;= kc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//作者：bigpotato-3</span></span><br><span class="line"><span class="comment">//链接：https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking/solution/tong-guo-dui-lie-lai-mo-ni-xu-yao-de-qing-wa-shu-l/</span></span><br><span class="line"><span class="comment">//来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-维护croak的个数"><a href="#2-维护croak的个数" class="headerlink" title="2. 维护croak的个数"></a>2. 维护croak的个数</h4><p><strong>思路</strong></p>
<p>维护croak的个数，如果遇到当前字母，则肯定是由前面字母过来，前面字母数-1。<br>如遇到r，则必是c-&gt;r，所以c–<br>k代表结尾，其实也是青蛙的起始（一次喊叫结束），所以遇到c的时候，先去消耗k，没有k了，需要新青蛙，答案+1</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberOfFrogs</span><span class="params">(<span class="keyword">String</span> croakOfFrogs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c,r,o,a,k;</span><br><span class="line">        c = <span class="number">0</span>; r = <span class="number">0</span>; o = <span class="number">0</span>; a = <span class="number">0</span>;k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> []chars = croakOfFrogs.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chars[i] == <span class="string">'c'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k &gt; <span class="number">0</span>)&#123;k--;&#125;<span class="keyword">else</span>&#123;res++;&#125;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(chars[i] == <span class="string">'r'</span>)&#123;</span><br><span class="line">                c--;r++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(chars[i] == <span class="string">'o'</span>)&#123;</span><br><span class="line">                r--;o++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(chars[i] == <span class="string">'a'</span>)&#123;</span><br><span class="line">                o--;a++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(chars[i] == <span class="string">'k'</span>)&#123;</span><br><span class="line">                a--;k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c &lt; <span class="number">0</span> || r &lt; <span class="number">0</span> || o &lt; <span class="number">0</span> || a &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c != <span class="number">0</span> || r != <span class="number">0</span> || o != <span class="number">0</span> || a != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">作者：imcover</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/minimum-number-of-frogs-croaking/solution/cai-ji-gong-xian-ge-chun-onzuo-fa-by-imcover/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h2 id="5391-生成数组"><a href="#5391-生成数组" class="headerlink" title="5391. 生成数组"></a><a href="https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/" target="_blank" rel="noopener">5391. 生成数组</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你三个整数 <code>n</code>、<code>m</code> 和 <code>k</code> 。下图描述的算法用于找出正整数数组中最大的元素。</p>
<p><img src="/2020/04/19/2020-04-19-LeetCode-Contest-185/e.png" alt="img"></p>
<p>请你生成一个具有下述属性的数组 <code>arr</code> ：</p>
<ul>
<li><code>arr</code> 中有 <code>n</code> 个整数。</li>
<li><code>1 &lt;= arr[i] &lt;= m</code> 其中 <code>(0 &lt;= i &lt; n)</code> 。</li>
<li>将上面提到的算法应用于 <code>arr</code> ，<code>search_cost</code> 的值等于 <code>k</code> 。</li>
</ul>
<p>返回上述条件下生成数组 <code>arr</code> 的 <strong>方法数</strong> ，由于答案可能会很大，所以 <strong>必须</strong> 对 <code>10^9 + 7</code> 取余。</p>
<h4 id="示例-1：-3"><a href="#示例-1：-3" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, m &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：6</span><br><span class="line">解释：可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-3"><a href="#示例-2：-3" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5, m &#x3D; 2, k &#x3D; 3</span><br><span class="line">输出：0</span><br><span class="line">解释：没有数组可以满足上述条件</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 9, m &#x3D; 1, k &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-2"><a href="#示例-4：-2" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 50, m &#x3D; 100, k &#x3D; 25</span><br><span class="line">输出：34549172</span><br><span class="line">解释：不要忘了对 1000000007 取余</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 37, m &#x3D; 17, k &#x3D; 7</span><br><span class="line">输出：418930126</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 50</code></li>
<li><code>1 &lt;= m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= n</code></li>
</ul>
<h3 id="其它解法-1"><a href="#其它解法-1" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>dp[i][j][k]</code>表示长度为i，最大值为j，<code>search_cost</code>为k的方案数。对于第i+1个数字x，如果x 大于 j,那么<code>dp[i + 1][x][k + 1] += dp[i][j][k]</code>, 否则<code>dp[i + 1][j][k] += dp[i][j][k]</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfArrays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp[n + <span class="number">1</span>][<span class="number">105</span>][k + <span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= k; l++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= m; r++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(r &gt; j)&#123;</span><br><span class="line">                            dp[i + <span class="number">1</span>][r][l + <span class="number">1</span>] += dp[i][j][l];</span><br><span class="line">                            dp[i + <span class="number">1</span>][r][l + <span class="number">1</span>] %= mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            dp[i + <span class="number">1</span>][j][l] += dp[i][j][l];</span><br><span class="line">                            dp[i + <span class="number">1</span>][j][l] %= mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            ans += dp[n][i][k];</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：PerfectSen</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/solution/5391-sheng-cheng-shu-zu-by-perfectsen/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>周赛</tag>
        <tag>刷题</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第24场双周赛</title>
    <url>/2020/04/19/2020-04-19-LeetCode-Double-Contest24/</url>
    <content><![CDATA[<p>LeetCode 第24场双周赛 战绩<code>616/1898</code></p>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>5372. 逐步求和得到正数的最小值</td>
<td>简单</td>
</tr>
<tr>
<td>5373. 和为 K 的最少斐波那契数字数目</td>
<td>中等</td>
</tr>
<tr>
<td>5374. 长度为 n 的开心字符串中字典序第 k 小的字符串</td>
<td>中等</td>
</tr>
<tr>
<td>5375. 恢复数组</td>
<td>困难</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="5372-逐步求和得到正数的最小值"><a href="#5372-逐步求和得到正数的最小值" class="headerlink" title="5372. 逐步求和得到正数的最小值"></a>5372. 逐步求和得到正数的最小值</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> 。你可以选定任意的 <strong>正数</strong> startValue 作为初始值。</p>
<p>你需要从左到右遍历 <code>nums</code> 数组，并将 startValue 依次累加上 <code>nums</code> 数组中的值。</p>
<p>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 <strong>正数</strong> 作为 startValue 。 </p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-3,2,-3,4,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：如果你选择 startValue &#x3D; 4，在第三次累加时，和小于 1 。</span><br><span class="line">                累加求和</span><br><span class="line">                startValue &#x3D; 4 | startValue &#x3D; 5 | nums</span><br><span class="line">                  (4 -3 ) &#x3D; 1  | (5 -3 ) &#x3D; 2    |  -3</span><br><span class="line">                  (1 +2 ) &#x3D; 3  | (2 +2 ) &#x3D; 4    |   2</span><br><span class="line">                  (3 -3 ) &#x3D; 0  | (4 -3 ) &#x3D; 1    |  -3</span><br><span class="line">                  (0 +4 ) &#x3D; 4  | (1 +4 ) &#x3D; 5    |   4</span><br><span class="line">                  (4 +2 ) &#x3D; 6  | (5 +2 ) &#x3D; 7    |   2</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：最小的 startValue 需要是正数。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,-2,-3]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStartValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            res += n;</span><br><span class="line">            <span class="keyword">if</span>(res&lt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s += <span class="number">1</span> - res;</span><br><span class="line">                res = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5373-和为-K-的最少斐波那契数字数目"><a href="#5373-和为-K-的最少斐波那契数字数目" class="headerlink" title="5373. 和为 K 的最少斐波那契数字数目"></a>5373. 和为 K 的最少斐波那契数字数目</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你数字 <code>k</code> ，请你返回和为 <code>k</code> 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p>
<p>斐波那契数字定义为：</p>
<ul>
<li><code>F1 = 1</code></li>
<li><code>F2 = 1</code></li>
<li><code>Fn = Fn-1 + Fn-2</code> ， 其中 n &gt; 2 。</li>
</ul>
<p>数据保证对于给定的 <code>k</code> ，一定能找到可行解。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：k &#x3D; 7</span><br><span class="line">输出：2 </span><br><span class="line">解释：斐波那契数字为：1，1，2，3，5，8，13，……</span><br><span class="line">对于 k &#x3D; 7 ，我们可以得到 2 + 5 &#x3D; 7 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：k &#x3D; 10</span><br><span class="line">输出：2 </span><br><span class="line">解释：对于 k &#x3D; 10 ，我们可以得到 2 + 8 &#x3D; 10 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：k &#x3D; 19</span><br><span class="line">输出：3 </span><br><span class="line">解释：对于 k &#x3D; 19 ，我们可以得到 1 + 5 + 13 &#x3D; 19 。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= 10^9</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fn;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinFibonacciNumbers</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fn.<span class="built_in">size</span>()==<span class="number">0</span>) </span><br><span class="line">            <span class="built_in">end</span> = born(k)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">end</span>&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fn[<span class="built_in">end</span>]==k)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fn[<span class="built_in">end</span>]&lt;k)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">end</span>--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findMinFibonacciNumbers(k-fn[<span class="built_in">end</span>])+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">born</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        fn.push_back(<span class="number">1</span>);</span><br><span class="line">        fn.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(fn[i<span class="number">-2</span>]+fn[i<span class="number">-1</span>]&lt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            fn.push_back(fn[i<span class="number">-2</span>]+fn[i<span class="number">-1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5374-长度为-n-的开心字符串中字典序第-k-小的字符串"><a href="#5374-长度为-n-的开心字符串中字典序第-k-小的字符串" class="headerlink" title="5374. 长度为 n 的开心字符串中字典序第 k 小的字符串"></a>5374. 长度为 n 的开心字符串中字典序第 k 小的字符串</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个 「开心字符串」定义为：</p>
<ul>
<li>仅包含小写字母 <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>.</li>
<li>对所有在 <code>1</code> 到 <code>s.length - 1</code> 之间的 <code>i</code> ，满足 <code>s[i] != s[i + 1]</code> （字符串的下标从 1 开始）。</li>
</ul>
<p>比方说，字符串 <strong>“abc”</strong>，<strong>“ac”，”b”</strong> 和 <strong>“abcbabcbcb”</strong> 都是开心字符串，但是 <strong>“aa”</strong>，<strong>“baa”</strong> 和 <strong>“ababbc”</strong> 都不是开心字符串。</p>
<p>给你两个整数 <code>n</code> 和 <code>k</code> ，你需要将长度为 <code>n</code> 的所有开心字符串按字典序排序。</p>
<p>请你返回排序后的第 k 个开心字符串，如果长度为 <code>n</code> 的开心字符串少于 <code>k</code> 个，那么请你返回 <strong>空字符串</strong> 。</p>
<h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1, k &#x3D; 3</span><br><span class="line">输出：&quot;c&quot;</span><br><span class="line">解释：列表 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 包含了所有长度为 1 的开心字符串。按照字典序排序后第三个字符串为 &quot;c&quot; 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1, k &#x3D; 4</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：长度为 1 的开心字符串只有 3 个。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3, k &#x3D; 9</span><br><span class="line">输出：&quot;cab&quot;</span><br><span class="line">解释：长度为 3 的开心字符串总共有 12 个 [&quot;aba&quot;, &quot;abc&quot;, &quot;aca&quot;, &quot;acb&quot;, &quot;bab&quot;, &quot;bac&quot;, &quot;bca&quot;, &quot;bcb&quot;, &quot;cab&quot;, &quot;cac&quot;, &quot;cba&quot;, &quot;cbc&quot;] 。第 9 个字符串为 &quot;cab&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, k &#x3D; 7</span><br><span class="line">输出：&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a><strong>示例 5：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 10, k &#x3D; 100</span><br><span class="line">输出：&quot;abacbabacb&quot;</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10</code></li>
<li><code>1 &lt;= k &lt;= 100</code></li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getHappyString</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">        tmp = generate(n<span class="number">-1</span>,<span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">            res.push_back(str);</span><br><span class="line">        tmp = generate(n<span class="number">-1</span>,<span class="string">'b'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">            res.push_back(str);</span><br><span class="line">        tmp = generate(n<span class="number">-1</span>,<span class="string">'c'</span>);        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">            res.push_back(str);</span><br><span class="line">        </span><br><span class="line">        sort(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());    </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;<span class="string">' '</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>()&gt;=k?res[k<span class="number">-1</span>]:<span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t.append(<span class="number">1</span>,ch);</span><br><span class="line">            <span class="keyword">return</span> &#123;t&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'a'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = generate(n<span class="number">-1</span>,<span class="string">'b'</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">                res.push_back(<span class="string">"a"</span>+str);    </span><br><span class="line">            tmp = generate(n<span class="number">-1</span>,<span class="string">'c'</span>);        </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">            res.push_back(<span class="string">"a"</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'b'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = generate(n<span class="number">-1</span>,<span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">                res.push_back(<span class="string">"b"</span>+str);    </span><br><span class="line">            tmp = generate(n<span class="number">-1</span>,<span class="string">'c'</span>);        </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">            res.push_back(<span class="string">"b"</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'c'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = generate(n<span class="number">-1</span>,<span class="string">'b'</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">                res.push_back(<span class="string">"c"</span>+str);    </span><br><span class="line">            tmp = generate(n<span class="number">-1</span>,<span class="string">'a'</span>);        </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">            res.push_back(<span class="string">"c"</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其它解法：</p>
<h2 id="5375-恢复数组"><a href="#5375-恢复数组" class="headerlink" title="5375. 恢复数组"></a>5375. 恢复数组</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 <code>[1, k]</code> 之间，且数组中的数字都没有前导 0 。</p>
<p>给你字符串 <code>s</code> 和整数 <code>k</code> 。可能会有多种不同的数组恢复结果。</p>
<p>按照上述程序，请你返回所有可能输出字符串 <code>s</code> 的数组方案数。</p>
<p>由于数组方案数可能会很大，请你返回它对 <code>10^9 + 7</code> <strong>取余</strong> 后的结果。</p>
<h4 id="示例-1：-3"><a href="#示例-1：-3" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1000&quot;, k &#x3D; 10000</span><br><span class="line">输出：1</span><br><span class="line">解释：唯一一种可能的数组方案是 [1000]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-3"><a href="#示例-2：-3" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1000&quot;, k &#x3D; 10</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在任何数组方案满足所有整数都 &gt;&#x3D; 1 且 &lt;&#x3D; 10 同时输出结果为 s 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-3"><a href="#示例-3：-3" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1317&quot;, k &#x3D; 2000</span><br><span class="line">输出：8</span><br><span class="line">解释：可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7]</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;2020&quot;, k &#x3D; 30</span><br><span class="line">输出：1</span><br><span class="line">解释：唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 &gt; 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-5：-1"><a href="#示例-5：-1" class="headerlink" title="示例 5："></a><strong>示例 5：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1234567890&quot;, k &#x3D; 90</span><br><span class="line">输出：34</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code>.</li>
<li><code>s</code> 只包含数字且不包含前导 0 。</li>
<li><code>1 &lt;= k &lt;= 10^9</code>.</li>
</ul>
<p>其它解法</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>周赛</tag>
        <tag>刷题</tag>
        <tag>双周赛</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每天打卡4-18~21</title>
    <url>/2020/04/18/2020-04-18-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>最近今日打卡题目如下：</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/count-the-repetitions/" target="_blank" rel="noopener">466. 统计重复个数</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></td>
<td>中等</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p>
<p><img src="/2020/04/18/2020-04-18-LeetCode-CheckDaily/question_11.jpg" alt="img"></p>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res,(right-left)*<span class="built_in">min</span>(<span class="built_in">height</span>[right],<span class="built_in">height</span>[left]));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">height</span>[right]&gt;=<span class="built_in">height</span>[left])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="466-统计重复个数"><a href="#466-统计重复个数" class="headerlink" title="466. 统计重复个数"></a><a href="https://leetcode-cn.com/problems/count-the-repetitions/" target="_blank" rel="noopener">466. 统计重复个数</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>由 n 个连接的字符串 s 组成字符串 S，记作 <code>S = [s,n]</code>。例如，<code>[&quot;abc&quot;,3]</code>=“abcabcabc”。</p>
<p>如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，”abc” 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。</p>
<p>现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 106 和 1 ≤ n2 ≤ 106。现在考虑字符串 S1 和 S2，其中 <code>S1=[s1,n1]</code> 、<code>S2=[s2,n2]</code> 。</p>
<p>请你找出一个可以满足使<code>[S2,M]</code> 从 <code>S1</code> 获得的最大整数 M 。</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">s1 &#x3D;&quot;acb&quot;,n1 &#x3D; 4</span><br><span class="line">s2 &#x3D;&quot;ab&quot;,n2 &#x3D; 2</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：找出循环节"><a href="#方法一：找出循环节" class="headerlink" title="方法一：找出循环节"></a>方法一：找出循环节</h4><p><strong>思路</strong></p>
<p>由于题目中的 <code>n1</code> 和 <code>n2</code> 都很大，因此我们无法真正把 <code>S1 = [s1, n1]</code> 和 <code>S2 = [s2, n2]</code> 都显式地表示出来。由于这两个字符串都是不断循环的，因此我们可以考虑找出 <code>s2</code> 在 <code>S1</code> 中出现的循环节，如果我们找到了循环节，那么我们就可以很快算出 <code>s2</code> 在 <code>S1</code> 中出现了多少次了。</p>
<p>有些读者可能对循环节这个概念会有些陌生，这个概念我们可以类比无限循环小数，如果从小数部分的某一位起向右进行到某一位止的一节数字「循环」出现，首尾衔接，称这种小数为「无限循环小数」，这一节数字称为「无限循环小数」。比如对于 <code>3.56789789789...</code> 这个无限循环小数，它的小数部分就是以 <code>789</code> 为一个「循环节」在无限循环，且开头可能会有部分不循环的部分，这个数字中即为 <code>56</code>。</p>
<p>那么回到这题，我们可以将不断循环的 <code>s2</code> 组成的字符串类比作上面小数部分，去找是否存在一个子串，即「循环节」，满足不断在 <code>S2</code> 中循环，且这个循环节能对应固定数量的 <code>s1</code> 。如下图所示，在第一次出现后，<code>S2</code> 的子串 <code>bdadc</code> 构成一个循环节：之后 <code>bdadc</code> 的每次出现都需要有相应的两段 <code>s1</code>。</p>
<p><img src="/2020/04/18/2020-04-18-LeetCode-CheckDaily/466_fig1.png" alt="fig1"></p>
<p>当我们找出循环节后，我们即可知道一个循环节内包含 <code>s1</code> 的数量，以及在循环节出现前的 <code>s1</code> 的数量，这样就可以在 O(1)<em>O</em>(1) 的时间内，通过简单的运算求出 <code>s2</code> 在 <code>S1</code> 中出现的次数了。当然，由于 <code>S1</code> 中 <code>s1</code> 的数量 <code>n1</code> 是有限的，因此可能会存在循环节最后一个部分没有完全匹配，如上图最后会单独剩一个 <code>s1</code> 出来无法完全匹配完循环节，这部分我们需要单独拿出来遍历处理统计。</p>
<p>有些读者可能会怀疑循环节是否一定存在，这里我们给出的答案是肯定的，根据<a href="https://baike.baidu.com/item/鸽笼" target="_blank" rel="noopener">鸽笼原理</a>，我们最多只要找过 <code>|s2| + 1</code> 个 <code>s1</code>，就一定会出现循环节。</p>
<p><strong>算法</strong></p>
<p>我们设计一个哈希表 <code>recall</code> ：哈希表 <code>recall</code> 以 <code>s2</code> 字符串的下标 <code>index</code> 为索引，存储匹配至第 <code>s1cnt</code> 个 <code>s1</code> 的末尾，当前匹配到第 <code>s2cnt</code> 个 <code>s2</code> 中的第 <code>index</code> 个字符时， 已经匹配过的<code>s1</code> 的个数 <code>s1cnt</code> 和 <code>s2</code> 的个数 <code>s2cnt</code> 。</p>
<p>我们在每次遍历至 <code>s1</code> 的末尾时根据当前匹配到的 <code>s2</code> 中的位置 <code>index</code> 查看哈希表中的对应位置，如果哈希表中对应的位置 <code>index</code> 已经存储元素，则说明我们找到了循环节。循环节的长度可以用当前已经匹配的 <code>s1</code> 与 <code>s2</code> 的数量减去上次出现时经过的数量（即哈希表中存储的值）来得到。</p>
<p>然后我们就可以通过简单的运算求出所有构成循环节的 <code>s2</code> 的数量，对于不参与循环节部分的 <code>s1</code>，直接遍历计算即可，具体实现以及一些细节边界的处理请看下文的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxRepetitions</span><span class="params">(<span class="built_in">string</span> s1, <span class="keyword">int</span> n1, <span class="built_in">string</span> s2, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s1cnt = <span class="number">0</span>, index = <span class="number">0</span>, s2cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// recall 是我们用来找循环节的变量，它是一个哈希映射</span></span><br><span class="line">        <span class="comment">// 我们如何找循环节？假设我们遍历了 s1cnt 个 s1，此时匹配到了第 s2cnt 个 s2 中的第 index 个字符</span></span><br><span class="line">        <span class="comment">// 如果我们之前遍历了 s1cnt' 个 s1 时，匹配到的是第 s2cnt' 个 s2 中同样的第 index 个字符，那么就有循环节了</span></span><br><span class="line">        <span class="comment">// 我们用 (s1cnt', s2cnt', index) 和 (s1cnt, s2cnt, index) 表示两次包含相同 index 的匹配结果</span></span><br><span class="line">        <span class="comment">// 那么哈希映射中的键就是 index，值就是 (s1cnt', s2cnt') 这个二元组</span></span><br><span class="line">        <span class="comment">// 循环节就是；</span></span><br><span class="line">        <span class="comment">//    - 前 s1cnt' 个 s1 包含了 s2cnt' 个 s2</span></span><br><span class="line">        <span class="comment">//    - 以后的每 (s1cnt - s1cnt') 个 s1 包含了 (s2cnt - s2cnt') 个 s2</span></span><br><span class="line">        <span class="comment">// 那么还会剩下 (n1 - s1cnt') % (s1cnt - s1cnt') 个 s1, 我们对这些与 s2 进行暴力匹配</span></span><br><span class="line">        <span class="comment">// 注意 s2 要从第 index 个字符开始匹配</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; recall;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pre_loop, in_loop;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 我们多遍历一个 s1，看看能不能找到循环节</span></span><br><span class="line">            ++s1cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch: s1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == s2[index]) &#123;</span><br><span class="line">                    index += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (index == s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                        ++s2cnt;</span><br><span class="line">                        index = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还没有找到循环节，所有的 s1 就用完了</span></span><br><span class="line">            <span class="keyword">if</span> (s1cnt == n1) &#123;</span><br><span class="line">                <span class="keyword">return</span> s2cnt / n2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 出现了之前的 index，表示找到了循环节</span></span><br><span class="line">            <span class="keyword">if</span> (recall.count(index)) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [s1cnt_prime, s2cnt_prime] = recall[index];</span><br><span class="line">                <span class="comment">// 前 s1cnt' 个 s1 包含了 s2cnt' 个 s2</span></span><br><span class="line">                pre_loop = &#123;s1cnt_prime, s2cnt_prime&#125;;</span><br><span class="line">                <span class="comment">// 以后的每 (s1cnt - s1cnt') 个 s1 包含了 (s2cnt - s2cnt') 个 s2</span></span><br><span class="line">                in_loop = &#123;s1cnt - s1cnt_prime, s2cnt - s2cnt_prime&#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                recall[index] = &#123;s1cnt, s2cnt&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ans 存储的是 S1 包含的 s2 的数量，考虑的之前的 pre_loop 和 in_loop</span></span><br><span class="line">        <span class="keyword">int</span> ans = pre_loop.second + (n1 - pre_loop.first) / in_loop.first * in_loop.second;</span><br><span class="line">        <span class="comment">// S1 的末尾还剩下一些 s1，我们暴力进行匹配</span></span><br><span class="line">        <span class="keyword">int</span> rest = (n1 - pre_loop.first) % in_loop.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rest; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch: s1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == s2[index]) &#123;</span><br><span class="line">                    ++index;</span><br><span class="line">                    <span class="keyword">if</span> (index == s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                        ++ans;</span><br><span class="line">                        index = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// S1 包含 ans 个 s2，那么就包含 ans / n2 个 S2</span></span><br><span class="line">        <span class="keyword">return</span> ans / n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<code>O(|s1|*|s2|)</code>。我们最多找过 <code>|s2| + 1</code> 个 <code>s1</code>，就可以找到循环节，最坏情况下需要遍历的字符数量级为 <code>O(|s1|*|s2|)*</code>。</li>
<li>空间复杂度：<code>O(|s2|)</code>。我们建立的哈希表大小等于 <code>s2</code> 的长度。</li>
</ul>
<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(col==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flag</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag[i][j]&amp;&amp;grid[i][j]==<span class="string">'1'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">                    q.push(&#123;i,j&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = q.front();</span><br><span class="line">                        q.pop();</span><br><span class="line">                        flag[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">int</span> nx,ny;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            nx = vec[<span class="number">0</span>]+dx[k];</span><br><span class="line">                            ny = vec[<span class="number">1</span>]+dy[k];</span><br><span class="line">                            <span class="keyword">if</span>(<span class="number">0</span>&lt;=nx&amp;&amp;nx&lt;row&amp;&amp;<span class="number">0</span>&lt;=ny&amp;&amp;ny&lt;col&amp;&amp;grid[nx][ny]==<span class="string">'1'</span>&amp;&amp;flag[nx][ny])</span><br><span class="line">                            &#123;</span><br><span class="line">                                q.push(&#123;nx,ny&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化一点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; neighbors;</span><br><span class="line">                    neighbors.push(&#123;r, c&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (!neighbors.empty()) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> rc = neighbors.front();</span><br><span class="line">                        neighbors.pop();</span><br><span class="line">                        <span class="keyword">int</span> row = rc.first, col = rc.second;</span><br><span class="line">                        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row<span class="number">-1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row<span class="number">-1</span>, col&#125;);</span><br><span class="line">                            grid[row<span class="number">-1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; nr &amp;&amp; grid[row+<span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row+<span class="number">1</span>, col&#125;);</span><br><span class="line">                            grid[row+<span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col<span class="number">-1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col<span class="number">-1</span>&#125;);</span><br><span class="line">                            grid[row][col<span class="number">-1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nc &amp;&amp; grid[row][col+<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col+<span class="number">1</span>&#125;);</span><br><span class="line">                            grid[row][col+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c] == <span class="string">'1'</span>) dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>) dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>] == <span class="string">'1'</span>) dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>) dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">作者：LeetCode</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：O(MN)，其中 MM 和 NN 分别为行数和列数。</p>
<p>空间复杂度：O(MN)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 MN。</p>
<h2 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248. 统计「优美子数组」"></a><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。</p>
<p>如果某个 <strong>连续</strong> 子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p>
<p>请返回这个数组中「优美子数组」的数目。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,1,1], k &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,4,6], k &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line">解释：数列中不包含任何奇数，所以不存在优美子数组。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,1,2,2,1,2,2,2], k &#x3D; 2</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">            cnt += nums[++r] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n &amp;&amp; cnt &lt; k) cnt += nums[++r] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> k_cnt_right_begin = r;</span><br><span class="line">            <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n &amp;&amp; !(nums[r + <span class="number">1</span>] &amp; <span class="number">1</span>)) ++r;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; cnt == k) &#123;</span><br><span class="line">                ans += r - k_cnt_right_begin + <span class="number">1</span>;</span><br><span class="line">                cnt -= nums[l++] &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根号</p>
<h4 id="方法一：数学"><a href="#方法一：数学" class="headerlink" title="方法一：数学"></a>方法一：数学</h4><p><strong>思路和算法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numberOfSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n &#x3D; (int)nums.size();</span><br><span class="line">        int odd[n + 2], ans &#x3D; 0, cnt &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] &amp; 1) odd[++cnt] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        odd[0] &#x3D; -1, odd[++cnt] &#x3D; n;</span><br><span class="line">        for (int i &#x3D; 1; i + k &lt;&#x3D; cnt; ++i) &#123;</span><br><span class="line">            ans +&#x3D; (odd[i] - odd[i - 1]) * (odd[i + k] - odd[i + k - 1]); </span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h4 id="方法二：前缀和-差分"><a href="#方法二：前缀和-差分" class="headerlink" title="方法二：前缀和 + 差分"></a>方法二：前缀和 + 差分</h4><p><strong>思路和算法</strong></p>
<p>考虑以 i结尾的「优美子数组」个数，我们需要统计符合条件的下标 j的个数，其中 $0\leq j\leq i$且$ [j..i]$这个子数组里的奇数个数恰好为 k 。如果枚举$ [0..i]$里所有的下标来判断是否符合条件，那么复杂度将会达到 <code>O(n^2)</code> ，无法通过所有测试用例，因此我们需要优化枚举的时间复杂度。</p>
<p>我们定义 $\textit{pre}[i]$ 为<code>[0..i]</code>中奇数的个数，则 $\textit{pre}[i]$可以由$\textit{pre}[i-1]$递推而来，即：</p>
<p>$\textit{pre}[i]=\textit{pre}[i-1]+(\textit{nums}[i]&amp;1)$</p>
<p>那么<code>[j..i]</code>这个子数组里的奇数个数恰好为 k，这个条件我们可以转化为</p>
<p>$\textit{pre}[i]-\textit{pre}[j-1]==k$</p>
<p>简单移项可得符合条件的下标 j<em>j</em> 需要满足</p>
<p>$\textit{pre}[j-1] == \textit{pre}[i] - k$</p>
<p>所以我们考虑以 i结尾的「优美子数组」个数时只要统计有多少个奇数个数为 $\textit{pre}[i]-k$ 的 $\textit{pre}[j]$ 即可。我们只要建立频次数组 $\textit{cnt}$ 记录$ \textit{pre}[i]$出现的次数，从左往右边更新 $\textit{cnt}$边计算答案，那么以 $i$结尾的答案 $\textit{cnt}[\textit{pre}[i]-k]$即可 <code>O(1)</code> 得到。最后的答案即为所有下标结尾的「优美子数组」个数之和。</p>
<p>需要注意的是，从左往右边更新x边计算的时候已经保证了$\textit{cnt}[\textit{pre}[i]-k]$里记录的 $\textit{pre}[j]$ 的下标范围是 $0\leq j\leq i$ 。同时，由于$\textit{pre}[i]$的计算只与前一项的答案有关，因此我们可以不用建立 $\textit{pre}$ 数组，直接用 $\textit{odd}$变量来记录 $pre[i-1]$的答案即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        cnt.resize(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            odd += nums[i] &amp; <span class="number">1</span>;</span><br><span class="line">            ans += odd &gt;= k ? cnt[odd - k] : <span class="number">0</span>;</span><br><span class="line">            cnt[odd] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，</li>
<li>空间复杂度：O(n)，</li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 位运算</title>
    <url>/2020/04/15/2020-04-15-Cpp-Bit/</url>
    <content><![CDATA[<p>本节主要学习C++中的位运算。</p>
<p>位运算符列表如下：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>位求反</td>
<td>~expr</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1 &lt;&lt; expr2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>expr1 &gt;&gt; expr2</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>expr1 &amp; expr2</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>expr1 ^ expr2</td>
</tr>
<tr>
<td>|</td>
<td>位或</td>
<td>expr1 | expr2</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="C-位运算"><a href="#C-位运算" class="headerlink" title="C++ 位运算"></a>C++ 位运算</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>位是数据存储的最小单位。在 计算机中的二进制数系统中，位，简记为b,也称为比特，每个0或1就是一个位(bit)。</p>
<h3 id="经典用法"><a href="#经典用法" class="headerlink" title="经典用法"></a>经典用法</h3><h4 id="1-求二进制中1的个数"><a href="#1-求二进制中1的个数" class="headerlink" title="1. 求二进制中1的个数"></a>1. 求二进制中1的个数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">n&amp;n<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-把-data上调至8-的倍数，同理，也可以改成16，32…的倍数。"><a href="#2-把-data上调至8-的倍数，同理，也可以改成16，32…的倍数。" class="headerlink" title="2. 把 data上调至8 的倍数，同理，也可以改成16，32…的倍数。"></a>2. 把 data上调至8 的倍数，同理，也可以改成16，32…的倍数。</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(data + <span class="number">8</span> - <span class="number">1</span>） &amp; (<span class="number">8</span> - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-取int的最值"><a href="#3-取int的最值" class="headerlink" title="3. 取int的最值"></a>3. 取int的最值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>;<span class="comment">//int的最大值</span></span><br><span class="line">(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);<span class="comment">//int的最小值</span></span><br><span class="line">((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span>&lt;&lt;<span class="number">63</span>)<span class="number">-1</span>;<span class="comment">//long long的最大值</span></span><br><span class="line">((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span>&lt;&lt;<span class="number">63</span>);<span class="comment">//long long的最小值</span></span><br></pre></td></tr></table></figure>

<h4 id="4-判断两个数符号是否相同"><a href="#4-判断两个数符号是否相同" class="headerlink" title="4. 判断两个数符号是否相同"></a>4. 判断两个数符号是否相同</h4><p>  这个也很简单，二进制第一位表示符号，所以符号相同就为0（正数），符号不同就为1（负数）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">n^m&gt;=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="5-判断正负"><a href="#5-判断正负" class="headerlink" title="5. 判断正负"></a>5. 判断正负</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n&gt;&gt;31</span><br></pre></td></tr></table></figure>

<h3 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h3><h4 id="1-交换两个数"><a href="#1-交换两个数" class="headerlink" title="1. 交换两个数"></a>1. 交换两个数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a^=b;</span><br><span class="line">b^=a;</span><br><span class="line">a^=b;</span><br></pre></td></tr></table></figure>

<h4 id="2-对这个数二进制的第m位进行处理（从低位到高位）"><a href="#2-对这个数二进制的第m位进行处理（从低位到高位）" class="headerlink" title="2. 对这个数二进制的第m位进行处理（从低位到高位）"></a>2. 对这个数二进制的第m位进行处理（从低位到高位）</h4><p>​    首先为了得到第m位的值，肯定是要将这个数右移(m-1)位，然后为了将其他多余的数清零，我们再进行&amp;1的操作，就可以将第m位提取出来了。如果是想改变第m位的值，那么就不能对这个数进行移动，因为这样会改变这个数的值。所以我们要对1向左移(m-1)位，然后再进行操作更改。如果要将第m位变成1，那么就n|(1&lt;&lt;(m-1))，这样就可以保证其余位不变改变第m位。如果要将第m位变为0，那么就n&amp;~(1&lt;&lt;(m-1))，因为取反后就能得到除了第m位为0其余位都为1的一个数，这样再进行按位与计算就可以只改变第m位的值了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(n&gt;&gt;(m<span class="number">-1</span>))&amp;<span class="number">1</span>;<span class="comment">//取n的二进制的第m位</span></span><br><span class="line">n|(<span class="number">1</span>&lt;&lt;(m<span class="number">-1</span>));<span class="comment">//将n的二进制的第m位改为1</span></span><br><span class="line">n&amp;~(<span class="number">1</span>&lt;&lt;(m<span class="number">-1</span>));<span class="comment">//将n的二进制的第m位改为0</span></span><br></pre></td></tr></table></figure>

<h4 id="3-统计1的个数"><a href="#3-统计1的个数" class="headerlink" title="3. 统计1的个数"></a>3. 统计1的个数</h4><h5 id="1-普通算法"><a href="#1-普通算法" class="headerlink" title="1.普通算法"></a>1.普通算法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitcount1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cou=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">		&#123;</span><br><span class="line">			cou++;</span><br><span class="line">		&#125;</span><br><span class="line">		flag=flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cou;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-快速算法"><a href="#2-快速算法" class="headerlink" title="2. 快速算法"></a>2. 快速算法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitcount2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cou=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">		cou++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cou;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每天打卡4-15~17</title>
    <url>/2020/04/15/2020-04-15-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener">542. 01 矩阵</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></td>
<td>中等</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="542-01-矩阵"><a href="#542-01-矩阵" class="headerlink" title="542. 01 矩阵"></a><a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener">542. 01 矩阵</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p>
<p>两个相邻元素间的距离为 1 。</p>
<p><strong>示例 1:</strong><br>输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong><br>输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 2 1</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> INITMAX = <span class="number">9999</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">updateMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,INITMAX))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flag</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">1</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col ;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(&#123;i,j&#125;);</span><br><span class="line">                    flag[i][j] = <span class="number">0</span>;</span><br><span class="line">                    res[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> dir:dirs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = p[<span class="number">0</span>]+dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> ny = p[<span class="number">1</span>]+dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>( <span class="number">0</span> &lt;= nx &amp;&amp; nx&lt;row &amp;&amp; <span class="number">0</span>&lt;=ny &amp;&amp; ny&lt;col &amp;&amp; flag[nx][ny] )</span><br><span class="line">                &#123;</span><br><span class="line">                    flag[nx][ny] = <span class="number">0</span>;</span><br><span class="line">                    res[nx][ny] = res[p[<span class="number">0</span>]][p[<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">                    q.push(&#123;nx,ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="排序-合并"><a href="#排序-合并" class="headerlink" title="排序+合并"></a>排序+合并</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= start &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= <span class="built_in">end</span> &amp;&amp; intervals[i][<span class="number">1</span>] &gt;= <span class="built_in">end</span> )</span><br><span class="line">                <span class="built_in">end</span> = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; <span class="built_in">end</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back( &#123;start,<span class="built_in">end</span>&#125; );</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                <span class="built_in">end</span> = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(&#123;start,<span class="built_in">end</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=<span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">end</span> = <span class="built_in">max</span>(<span class="built_in">end</span>,start+nums[start]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">end</span>&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            start = <span class="built_in">min</span>(start+<span class="number">1</span>,<span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">if</span>((start&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>)||(<span class="built_in">end</span>==start&amp;&amp;nums[start]==<span class="number">0</span>)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>OPENCV重要函数</title>
    <url>/2020/04/14/2020-04-14-OPENCV-Function/</url>
    <content><![CDATA[<p>本节用来总结SLAM学习过程中，用到的重要的opencv函数</p>
<a id="more"></a>

<h3 id="CalcopticalFlowPyrLK"><a href="#CalcopticalFlowPyrLK" class="headerlink" title="CalcopticalFlowPyrLK()"></a>CalcopticalFlowPyrLK()</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>使用具有金字塔的迭代Lucas-Kanade方法计算稀疏特征集的光流。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::calcOpticalFlowPyrLK</span>	<span class="params">(	</span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray 	prevImg,</span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray 	nextImg,</span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray 	prevPts,</span></span></span><br><span class="line"><span class="function"><span class="params">    InputOutputArray 	nextPts,</span></span></span><br><span class="line"><span class="function"><span class="params">    OutputArray 	status,</span></span></span><br><span class="line"><span class="function"><span class="params">    OutputArray 	err,</span></span></span><br><span class="line"><span class="function"><span class="params">    Size 	winSize = Size(<span class="number">21</span>, <span class="number">21</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> 	maxLevel = <span class="number">3</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    TermCriteria 	criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, <span class="number">30</span>, <span class="number">0.01</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> 	flags = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> 	minEigThreshold = <span class="number">1e-4</span> </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>prevImg ：buildOpticalFlowPyramid构造的第一个8位输入图像或金字塔。</li>
<li>nextImg ：与prevImg相同大小和相同类型的第二个输入图像或金字塔</li>
<li>prevPts ：需要找到流的2D点的矢量(vector of 2D points for which the flow needs to be found;);点坐标必须是单精度浮点数。</li>
<li>nextPts ：输出二维点的矢量（具有单精度浮点坐标），包含第二图像中输入特征的计算新位置;当传递OPTFLOW_USE_INITIAL_FLOW标志时，向量必须与输入中的大小相同。</li>
<li>status ：输出状态向量（无符号字符）;如果找到相应特征的流，则向量的每个元素设置为1，否则设置为0。</li>
<li>err ：输出错误的矢量; 向量的每个元素都设置为相应特征的错误，错误度量的类型可以在flags参数中设置; 如果未找到流，则未定义错误（使用status参数查找此类情况）。</li>
<li>winSize ：每个金字塔等级的搜索窗口的winSize大小。</li>
<li>maxLevel ：基于0的最大金字塔等级数;如果设置为0，则不使用金字塔（单级），如果设置为1，则使用两个级别，依此类推;如果将金字塔传递给输入，那么算法将使用与金字塔一样多的级别，但不超过maxLevel。</li>
<li>criteria ：参数，指定迭代搜索算法的终止条件（在指定的最大迭代次数criteria.maxCount之后或当搜索窗口移动小于criteria.epsilon时）。</li>
<li>flags ：操作标志：</li>
<li>OPTFLOW_USE_INITIAL_FLOW：使用初始估计，存储在nextPts中;如果未设置标志，则将prevPts复制到nextPts并将其视为初始估计。</li>
<li>OPTFLOW_LK_GET_MIN_EIGENVALS：使用最小特征值作为误差测量（参见minEigThreshold描述）;如果没有设置标志，则将原稿周围的色块和移动点之间的L1距离除以窗口中的像素数，用作误差测量。</li>
<li>minEigThreshold ：算法计算光流方程的2x2正常矩阵的最小特征值，除以窗口中的像素数;如果此值小于minEigThreshold，则过滤掉相应的功能并且不处理其流程，因此它允许删除坏点并获得性能提升。<br>该函数实现了金字塔中Lucas-Kanade光流的稀疏迭代版本。</li>
</ul>
<h3 id="cv-circle"><a href="#cv-circle" class="headerlink" title="cv::circle()"></a>cv::circle()</h3><h4 id="功能：画圆"><a href="#功能：画圆" class="headerlink" title="功能：画圆"></a>功能：画圆</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">circle</span><span class="params">(CV_IN_OUT Mat&amp; img, Point center, <span class="keyword">int</span> radius, <span class="keyword">const</span> Scalar&amp; color, <span class="keyword">int</span> thickness=<span class="number">1</span>, <span class="keyword">int</span> lineType=<span class="number">8</span>, <span class="keyword">int</span> shift=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>img：图像，单通道多通道都行，不需要特殊要求</li>
<li>center：画圆的圆心坐标</li>
<li>radius：圆的半径</li>
<li>color：设定圆的颜色，比如用CV_RGB(255, 0,0)设置为红色， CV_RGB(255, 255,255)设置为白色，CV_RGB(0, 0,0)设置为黑色 </li>
<li>thickness：为设置圆线条的粗细，值越大则线条越粗，为负数则是填充效果</li>
</ul>
<h3 id="goodFeaturesToTrack"><a href="#goodFeaturesToTrack" class="headerlink" title="goodFeaturesToTrack"></a>goodFeaturesToTrack</h3><p>  <em>_image：8位或32位浮点型输入图像，单通道</em></p>
<p>  <em>_corners：保存检测出的角点</em></p>
<p>  <em>maxCorners：角点数目最大值，如果实际检测的角点超过此值，则只返回前maxCorners个强角点</em></p>
<p>  <em>qualityLevel：角点的品质因子</em></p>
<p>  <em>minDistance：对于初选出的角点而言，如果在其周围minDistance范围内存在其他更强角点，则将此角点删除</em></p>
<p>  <em>_mask：指定感兴趣区，如不需在整幅图上寻找角点，则用此参数指定ROI</em></p>
<p>  <em>blockSize：计算协方差矩阵时的窗口大小</em></p>
<p>  <em>useHarrisDetector：指示是否使用Harris角点检测，如不指定，则计算shi-tomasi角点</em></p>
<p>  harrisK：Harris角点检测需要的k值 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::goodFeaturesToTrack(cur_img, n_pts, MAX_CNT - cur_pts.<span class="built_in">size</span>(), <span class="number">0.01</span>, MIN_DIST, mask); <span class="comment">//VINS_Fusion中的应用</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 优先队列</title>
    <url>/2020/04/14/2020-04-14-C-priority-queue/</url>
    <content><![CDATA[<p>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。本节来介绍C++中的优先队列。</p>
<a id="more"></a>

<p>优先队列是0个或多个元素的集合,每个元素都有一个优先权或值,对优先队列执行的操作有1) 查找;2) 插入一个新元素;3) 删除.在最小优先队列(min priority queue)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行.</p>
<p>最大优先权队列的<a href="https://baike.baidu.com/item/抽象数据类型" target="_blank" rel="noopener">抽象数据类型</a>描述下所示,最小优先队列的抽象数据类型描述与之类似,只需将最大改为最小即可.</p>
<h2 id="一、相关定义"><a href="#一、相关定义" class="headerlink" title="一、相关定义"></a>一、相关定义</h2><p>优先队列容器与队列一样，只能从队尾插入元素，从队首删除元素。但是它有一个特性，就是队列中最大的元素总是位于队首，所以出队时，并非按照先进先出的原则进行，而是将当前队列中最大的元素出队。这点类似于给队列里的元素进行了由大到小的顺序排序。元素的比较规则默认按元素值由大到小排序，可以重载“&lt;”操作符来重新定义比较规则。</p>
<p>优先级队列可以用向量(vector)或双向队列(deque)来实现(注意list container不能用来实现queue，因为list的迭代器不是任意存取iterator，而pop中用到堆排序时是要求randomaccess iterator 的!)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;vector&lt;int&gt;, less&lt;int&gt; &gt; pq1; 　　　 &#x2F;&#x2F; 使用递增less&lt;int&gt;函数对象排序</span><br><span class="line">priority_queue&lt;deque&lt;int&gt;, greater&lt;int&gt; &gt; pq2; 　　&#x2F;&#x2F; 使用递减greater&lt;int&gt;函数对象排序</span><br></pre></td></tr></table></figure>


<p>其成员函数有“判空(empty)” 、“尺寸(Size)” 、“栈顶元素(top)” 、“压栈(push)” 、“弹栈(pop)”等。</p>
<h2 id="二、priority-queue"><a href="#二、priority-queue" class="headerlink" title="二、priority_queue"></a>二、priority_queue</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>首先要包含头文件<code>#include</code></strong>, 他和<code>queue</code>不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。</p>
<p>优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><blockquote>
<p>和队列基本操作相同:</p>
<ul>
<li>top()           访问队头元素</li>
<li>empty()      队列是否为空</li>
<li>size()          返回队列内元素个数</li>
<li>push()        插入元素到队尾 (并排序)</li>
<li>emplace() 原地构造一个元素并插入队列</li>
<li>pop()         弹出队头元素</li>
<li>swap()       交换内容</li>
</ul>
</blockquote>
<h3 id="头文件："><a href="#头文件：" class="headerlink" title="头文件："></a>头文件：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;queue&gt;</span><br></pre></td></tr></table></figure>

<h3 id="声明方式："><a href="#声明方式：" class="headerlink" title="声明方式："></a>声明方式：</h3><h4 id="1、普通方法："><a href="#1、普通方法：" class="headerlink" title="1、普通方法："></a>1、普通方法：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;  　　　　　　　　　　　  <span class="comment">//通过操作，按照元素从大到小的顺序出队</span></span><br><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q; <span class="comment">//通过操作，按照元素从小到大的顺序出队</span></span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br></pre></td></tr></table></figure>

<h4 id="2、自定义优先级："><a href="#2、自定义优先级：" class="headerlink" title="2、自定义优先级："></a>2、自定义优先级：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">　　<span class="function"><span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>   </span></span><br><span class="line"><span class="function">　　</span>&#123;     </span><br><span class="line">　　　　 <span class="keyword">return</span>　x &gt; y;　　 <span class="comment">// x小的优先级高    //也可以写成其他方式，如： return p[x] &gt; p[y];表示p[i]小的优先级高</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; q;  <span class="comment">//定义方法</span></span><br><span class="line"><span class="comment">//其中，第二个参数为容器类型。第三个参数为比较函数。</span></span><br></pre></td></tr></table></figure>

<h4 id="3、结构体声明方式："><a href="#3、结构体声明方式：" class="headerlink" title="3、结构体声明方式："></a>3、结构体声明方式：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>   </span><br><span class="line">　　<span class="keyword">int</span> x, y; </span><br><span class="line">　　<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a, node b)  </span><br><span class="line">　　&#123;     </span><br><span class="line">　　　　<span class="keyword">return</span> a.x &gt; b.x;  <span class="comment">//结构体中，x小的优先级高   </span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt;q;  <span class="comment">//定义方法</span></span><br><span class="line"><span class="comment">// 在该结构中，y为值, x为优先级。</span></span><br><span class="line"><span class="comment">// 通过自定义operator&lt;操作符来比较元素中的优先级。</span></span><br><span class="line"><span class="comment">// 在重载”&lt;”时，最好不要重载”&gt;”，可能会发生编译错误</span></span><br></pre></td></tr></table></figure>

<h2 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h2><h3 id="1、基本类型优先队列的例子："><a href="#1、基本类型优先队列的例子：" class="headerlink" title="1、基本类型优先队列的例子："></a><strong>1、基本类型优先队列的例子：</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//      这里一定要有空格，不然成了右移运算符↓↓</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="built_in">string</span>&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        a.push(i);</span><br><span class="line">        c.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!c.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        c.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    b.push(<span class="string">"abc"</span>);</span><br><span class="line">    b.push(<span class="string">"abcd"</span>);</span><br><span class="line">    b.push(<span class="string">"cbd"</span>);</span><br><span class="line">    <span class="keyword">while</span> (!b.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        b.pop();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 2 1 0&#96;&#96;0 1 2 3 4&#96;&#96;cbd abcd abc&#96;&#96;请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<h3 id="2、用pair做优先队列元素的例子："><a href="#2、用pair做优先队列元素的例子：" class="headerlink" title="2、用pair做优先队列元素的例子："></a><strong>2、用pair做优先队列元素的例子：</strong></h3><p>规则：pair的比较，先比较第一个元素，第一个相等比较第二个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//      这里一定要有空格，不然成了右移运算符↓↓</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="built_in">string</span>&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        a.push(i);</span><br><span class="line">        c.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!c.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        c.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    b.push(<span class="string">"abc"</span>);</span><br><span class="line">    b.push(<span class="string">"abcd"</span>);</span><br><span class="line">    b.push(<span class="string">"cbd"</span>);</span><br><span class="line">    <span class="keyword">while</span> (!b.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        b.pop();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 5&#96;&#96;1 3&#96;&#96;1 2&#96;&#96;请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<h3 id="3、用自定义类型做优先队列元素的例子"><a href="#3、用自定义类型做优先队列元素的例子" class="headerlink" title="3、用自定义类型做优先队列元素的例子"></a><strong>3、用自定义类型做优先队列元素的例子</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp1</span> //运算符重载&lt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    int x;</span></span><br><span class="line"><span class="class">    tmp1(int a) &#123;x = a;&#125;</span></span><br><span class="line"><span class="class">    bool operator&lt;(const tmp1&amp; a) const</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return x &lt; a.x; //大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//方法2</span></span><br><span class="line"><span class="class">struct tmp2 //重写仿函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    bool operator() (tmp1 a, tmp1 b) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return a.x &lt; b.x; //大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">int main() </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    tmp1 a(1);</span></span><br><span class="line"><span class="class">    tmp1 b(2);</span></span><br><span class="line"><span class="class">    tmp1 c(3);</span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1&gt; d;</span></span><br><span class="line"><span class="class">    d.push(b);</span></span><br><span class="line"><span class="class">    d.push(c);</span></span><br><span class="line"><span class="class">    d.push(a);</span></span><br><span class="line"><span class="class">    while (!d.empty()) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        cout &lt;&lt; d.top().x &lt;&lt; '\n';</span></span><br><span class="line"><span class="class">        d.pop();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span></span><br><span class="line"><span class="class">    f.push(b);</span></span><br><span class="line"><span class="class">    f.push(c);</span></span><br><span class="line"><span class="class">    f.push(a);</span></span><br><span class="line"><span class="class">    while (!f.empty()) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        cout &lt;&lt; f.top().x &lt;&lt; '\n';</span></span><br><span class="line"><span class="class">        f.pop();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;3&#96;</span><br><span class="line">&#96;2&#96;</span><br><span class="line">&#96;1&#96; </span><br><span class="line"></span><br><span class="line">&#96;3&#96;</span><br><span class="line">&#96;2&#96;</span><br><span class="line">&#96;1&#96;</span><br><span class="line"></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<p> 参考资料</p>
<p>[1] <a href="https://www.cnblogs.com/huashanqingzhu/p/11040390.html" target="_blank" rel="noopener">c++优先队列(priority_queue)用法详解</a></p>
<p>[2] [C++STL——优先队列](<a href="https://www.cnblogs.com/xzxl/p/7266404.html）" target="_blank" rel="noopener">https://www.cnblogs.com/xzxl/p/7266404.html）</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-14</title>
    <url>/2020/04/13/2020-04-13-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>355.设计推特</td>
<td>中等</td>
</tr>
<tr>
<td>2</td>
<td>面试题56 - II. 数组中数字出现的次数 II</td>
<td>中等</td>
</tr>
<tr>
<td>3</td>
<td>面试题64. 求1+2+…+n</td>
<td>中等</td>
</tr>
<tr>
<td>4</td>
<td>两数相加</td>
<td>中等</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="355-设计推特"><a href="#355-设计推特" class="headerlink" title="355. 设计推特"></a>355. 设计推特</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：</p>
<ol>
<li><strong>postTweet(userId, tweetId)</strong>: 创建一条新的推文</li>
<li><strong>getNewsFeed(userId)</strong>: 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。</li>
<li><strong>follow(followerId, followeeId)</strong>: 关注一个用户</li>
<li><strong>unfollow(followerId, followeeId)</strong>: 取消关注一个用户</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Twitter twitter &#x3D; new Twitter();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户1发送了一条新推文 (用户id &#x3D; 1, 推文id &#x3D; 5).</span><br><span class="line">twitter.postTweet(1, 5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.</span><br><span class="line">twitter.getNewsFeed(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户1关注了用户2.</span><br><span class="line">twitter.follow(1, 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户2发送了一个新推文 (推文id &#x3D; 6).</span><br><span class="line">twitter.postTweet(2, 6);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -&gt; [6, 5].</span><br><span class="line">&#x2F;&#x2F; 推文id6应当在推文id5之前，因为它是在5之后发送的.</span><br><span class="line">twitter.getNewsFeed(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户1取消关注了用户2.</span><br><span class="line">twitter.unfollow(1, 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.</span><br><span class="line">&#x2F;&#x2F; 因为用户1已经不再关注用户2.</span><br><span class="line">twitter.getNewsFeed(1);</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>用了四个哈希表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; followmap; <span class="comment">//每个用户有一个订阅列表</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; timemap;   <span class="comment">//每条推文对应的时间</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; postermap; <span class="comment">//每个推文对应的人</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; timeline;  <span class="comment">//每个时间对应的推文</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Twitter() &#123;</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Compose a new tweet. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        time++;</span><br><span class="line">        timemap[tweetId]=time;</span><br><span class="line">        timeline[time] = tweetId;</span><br><span class="line">        postermap[tweetId] = userId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        time++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> t = time;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(postermap[timeline[t]]==userId||(followmap[userId].<span class="built_in">find</span>(postermap[timeline[t]])!=followmap[userId].<span class="built_in">end</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(timeline[t]);</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">10</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            t--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        time++;</span><br><span class="line">        <span class="keyword">if</span>(followmap.<span class="built_in">find</span>(followerId)==followmap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            followmap[followerId] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        followmap[followerId].insert(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        time++;</span><br><span class="line">        followmap[followerId].erase(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="哈希表-链表"><a href="#哈希表-链表" class="headerlink" title="哈希表+链表"></a>哈希表+链表</h4><p>根据题意我们知道，对于每个推特用户，我们需要存储他关注的用户 Id，以及自己发的推文 Id 的集合，为了使每个操作的复杂度尽可能的低，我们需要根据操作来决定存储这些信息的数据结构。注意，由于题目中没有说明用户的 Id 是否连续，所以我们需要用一个以用户 Id 为索引的哈希表来存储用户的信息。</p>
<p>对于操作 3 和操作 4，我们只需要用一个哈希表存储，即可实现插入和删除的时间复杂度都为 <code>O(1)</code>。</p>
<p>对于操作 1 和操作 2，由于操作 2 要知道此用户关注的人和用户自己发出的最近十条推文，因此我们可以考虑对每个用户用链表存储发送的推文。每次创建推文的时候我们在链表头插入，这样能保证链表里存储的推文的时间是从最近到最久的。那么对于操作 2，问题其实就等价于有若干个有序的链表，我们需要找到它们合起来最近的十条推文。由于链表里存储的数据都是有序的，所以我们将这些链表进行线性归并即可得到最近的十条推文。这个操作与 23. 合并K个排序链表 基本等同。</p>
<p><img src="/2020/04/13/2020-04-13-LeetCode-CheckDaily/355_fig1.png" alt="fig1"></p>
<p>如果我们直接照搬「合并K个排序链表」的解法来进行合并，那么无疑会造成空间的部分浪费，因为这个题目不要求你展示用户的所有推文，所以我们只要动态维护用户的链表，存储最近的 recentMax 个推文 Id 即可（题目中的 recentMax 为 10）。那么对于操作 1，当发现链表的节点数等于 recentMax 时，我们按题意删除链表末尾的元素，再插入最新的推文 Id。对于操作 2，在两个链表进行线性归并的时候，只要已合并的数量等于 recentMax，代表已经找到这两个链表合起来后最近的 recentMax 条推文，直接结束合并即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="comment">// 哈希表存储关注人的 Id</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; followee;</span><br><span class="line">        <span class="comment">// 用链表存储 tweetId</span></span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; tweet;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// getNewsFeed 检索的推文的上限以及 tweetId 的时间戳</span></span><br><span class="line">    <span class="keyword">int</span> recentMax, time;</span><br><span class="line">    <span class="comment">// tweetId 对应发送的时间</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tweetTime;</span><br><span class="line">    <span class="comment">// 每个用户存储的信息</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node&gt; user;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Twitter() &#123;</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">        recentMax = <span class="number">10</span>;</span><br><span class="line">        user.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        user[userId].followee.<span class="built_in">clear</span>();</span><br><span class="line">        user[userId].tweet.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (user.<span class="built_in">find</span>(userId) == user.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            init(userId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 达到限制，剔除链表末尾元素</span></span><br><span class="line">        <span class="keyword">if</span> (user[userId].tweet.<span class="built_in">size</span>() == recentMax) &#123;</span><br><span class="line">            user[userId].tweet.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        user[userId].tweet.push_front(tweetId);</span><br><span class="line">        tweetTime[tweetId] = ++time;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans; ans.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = user[userId].tweet.<span class="built_in">begin</span>(); it != user[userId].tweet.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            ans.emplace_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> followeeId: user[userId].followee) &#123;</span><br><span class="line">            <span class="keyword">if</span> (followeeId == userId) <span class="keyword">continue</span>; <span class="comment">// 可能出现自己关注自己的情况</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; res.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = user[followeeId].tweet.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 线性归并</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; (<span class="keyword">int</span>)ans.<span class="built_in">size</span>() &amp;&amp; it != user[followeeId].tweet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tweetTime[(*it)] &gt; tweetTime[ans[i]]) &#123;</span><br><span class="line">                    res.emplace_back(*it);</span><br><span class="line">                    ++it;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.emplace_back(ans[i]);</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 已经找到这两个链表合起来后最近的 recentMax 条推文</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">int</span>)res.<span class="built_in">size</span>() == recentMax) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; (<span class="keyword">int</span>)ans.<span class="built_in">size</span>() &amp;&amp; (<span class="keyword">int</span>)res.<span class="built_in">size</span>() &lt; recentMax; ++i) res.emplace_back(ans[i]);</span><br><span class="line">            <span class="keyword">for</span> (; it != user[followeeId].tweet.<span class="built_in">end</span>() &amp;&amp; (<span class="keyword">int</span>)res.<span class="built_in">size</span>() &lt; recentMax; ++it) res.emplace_back(*it);</span><br><span class="line">            ans.assign(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (user.<span class="built_in">find</span>(followerId) == user.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            init(followerId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (user.<span class="built_in">find</span>(followeeId) == user.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            init(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line">        user[followerId].followee.insert(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        user[followerId].followee.erase(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题56-II-数组中数字出现的次数-II"><a href="#面试题56-II-数组中数字出现的次数-II" class="headerlink" title="面试题56 - II. 数组中数字出现的次数 II"></a>面试题56 - II. 数组中数字出现的次数 II</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,3,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10000</code></li>
<li><code>1 &lt;= nums[i] &lt; 2^31</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="built_in">map</span>[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = <span class="built_in">map</span>.<span class="built_in">begin</span>();iter!= <span class="built_in">map</span>.<span class="built_in">end</span>();iter++)</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;second==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> iter-&gt;first;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p><strong>基本思路</strong>：如果某个数字出现3次，那么这个3个数字的和肯定能被3整除，则其对应二进制位的每一位的和也能被3整除<br>统计数组中每个数字的二进制中每一位的和，判断该和是否能被3整除。<br>若可以，则只出现一次的数字的二进制数中那一位为0，否则为1;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">                <span class="comment">// n &amp; 1 &lt;&lt; i 的值大于0即为真</span></span><br><span class="line">                <span class="keyword">if</span>(n &amp; <span class="number">1</span> &lt;&lt; i) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 构造只出现一次的那个数字，采用异或的方法生成二进制中的每一位</span></span><br><span class="line">            <span class="keyword">if</span>(cnt % <span class="number">3</span> == <span class="number">1</span>) ans ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题64-求1-2-…-n"><a href="#面试题64-求1-2-…-n" class="headerlink" title="面试题64. 求1+2+…+n"></a>面试题64. 求1+2+…+n</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10000</code></li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="amp-amp-的短路特性"><a href="#amp-amp-的短路特性" class="headerlink" title="&amp;&amp;的短路特性"></a>&amp;&amp;的短路特性</h4><ul>
<li>A &amp;&amp; B<ul>
<li>A 为 true，则<strong>计算并返回</strong>表达式 B 的 bool 值</li>
<li>A 为 false，则<strong>直接返回</strong> false</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> (n&gt;<span class="number">0</span>)&amp;&amp;(n+=sumNums(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法-1"><a href="#其它解法-1" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="递归快速加法"><a href="#递归快速加法" class="headerlink" title="递归快速加法"></a>递归快速加法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        (n &gt; <span class="number">0</span>) &amp;&amp; (ans = ans + sum(a &lt;&lt; <span class="number">1</span>, n &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        (n &amp; <span class="number">1</span>) &amp;&amp; (ans = ans + a);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">/*  --以下非递归写法，上面递归写法</span></span><br><span class="line"><span class="comment">            --非递归写法必然用到while或者for，不符合题意，所以要使用递归写法</span></span><br><span class="line"><span class="comment">        int ans = 0;</span></span><br><span class="line"><span class="comment">        while(n) &#123; </span></span><br><span class="line"><span class="comment">            if (n &amp; 1) &#123;</span></span><br><span class="line"><span class="comment">                ans = ans + a;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            a &lt;&lt;= 1; // 在快速幂中这里应该是a = a * a, 快速加应改成a = a + a</span></span><br><span class="line"><span class="comment">                     // 我用位运算优化了两数相加的操作</span></span><br><span class="line"><span class="comment">            n &gt;&gt;= 1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum(n + <span class="number">1</span>, n) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：suzukaze-aoba<span class="number">-2</span></span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/qiu-12n-lcof/solution/cshuang-bai-jie-fa-zui-you-jie-fa-kuai-su-jia-shi-/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h4 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h4><p>这个思路不但没用if这种条件判断语句，连逻辑运算中的短路运算也没有用到，也就是连判断的语义也没用到，确实挺牛的，还好这个题限制了n的大小，即限制了n二进制的位数，不然得累加32次……我在代码里为了可读性用临时变量保存了每一位的累加求解，当然一个return也是没问题的。</p>
<p>作者：shitsurei<br>链接：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/yan-jiu-liao-ban-tian-zhong-yu-kan-dong-da-lao-de-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof/solution/yan-jiu-liao-ban-tian-zhong-yu-kan-dong-da-lao-de-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负数在参与位运算时使用的是补码</span></span><br><span class="line"><span class="comment">     * -1的原码是   10000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="comment">     * -1的反码是   11111111 11111111 11111111 11111110</span></span><br><span class="line"><span class="comment">     * -1的补码是   11111111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">     * 因此任何数与-1做与运算的结果任然为原数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 由等差数列求和公式可知，结果等于n*(n+1)/2，其中除以2可以通过右移1位进行操作</span></span><br><span class="line"><span class="comment">         * 但n*(n+1)在不允许使用乘法的情况下，只能把n或n+1其中一个拆解为2的n次幂数之和，配合另一个来进行位运算和累加</span></span><br><span class="line"><span class="comment">         * 此代码利用了-1和任何整数进行与运算还等于原数的特点</span></span><br><span class="line"><span class="comment">         * -(n + 1 &gt;&gt; 0 &amp; 1)用于求从低到高第i+1位如果为0取，如果为1取-1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> n1 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">0</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n3 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> n4 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">3</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> n5 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">4</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> n6 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">5</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> n7 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">6</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> n8 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">7</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> n9 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">8</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> n10 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">9</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> n11 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">10</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n12 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">11</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">int</span> n13 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">12</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">int</span> n14 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">13</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">return</span> (n1 + n2 + n3 + n4 + n5 + n6 + n7 + n8 + n9 + n10 + n11 + n12 + n13 + n14) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a>445. 两数相加 II</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个 <strong>非空</strong> 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<h4 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a><strong>进阶：</strong></h4><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><p>翻转链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1||!l2)</span><br><span class="line">            <span class="keyword">return</span> l1==<span class="literal">nullptr</span>?l2:l1;</span><br><span class="line">        l1 = reverse(l1);</span><br><span class="line">        l2 = reverse(l2);</span><br><span class="line">        ListNode* p = l1;</span><br><span class="line">        ListNode* prev;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;val += l2-&gt;val + next;</span><br><span class="line">            next = l1-&gt;val / <span class="number">10</span>;</span><br><span class="line">            l1-&gt;val = l1-&gt;val % <span class="number">10</span>;</span><br><span class="line">            prev=l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = l2;</span><br><span class="line">            l1 = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;val += next;</span><br><span class="line">            next = l1-&gt;val / <span class="number">10</span>;</span><br><span class="line">            l1-&gt;val = l1-&gt;val % <span class="number">10</span>;</span><br><span class="line">            prev=l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* np = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            prev-&gt;next = np;</span><br><span class="line">            np-&gt;val = next;</span><br><span class="line">            np-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverse(p);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* l1)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode head;</span><br><span class="line">        head.next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *p = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            p-&gt;next = head.next;</span><br><span class="line">            head.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法-2"><a href="#其它解法-2" class="headerlink" title="其它解法"></a>其它解法</h3><p>使用栈</p>
<p>本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line">        <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">            s1.push(l1 -&gt; val);</span><br><span class="line">            l1 = l1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">            s2.push(l2 -&gt; val);</span><br><span class="line">            l2 = l2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* ans = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s1.empty() <span class="keyword">or</span> !s2.empty() <span class="keyword">or</span> carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = s1.empty() ? <span class="number">0</span> : s1.top();</span><br><span class="line">            <span class="keyword">int</span> b = s2.empty() ? <span class="number">0</span> : s2.top();</span><br><span class="line">            <span class="keyword">if</span> (!s1.empty()) s1.pop();</span><br><span class="line">            <span class="keyword">if</span> (!s2.empty()) s2.pop();</span><br><span class="line">            <span class="keyword">int</span> cur = a + b + carry;</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            cur %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">auto</span> curnode = <span class="keyword">new</span> ListNode(cur);</span><br><span class="line">            curnode -&gt; next = ans;</span><br><span class="line">            ans = curnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>特征点法的巅峰之作—ORBSLAM2</title>
    <url>/2020/04/13/2020-04-13-ORBSLAM2/</url>
    <content><![CDATA[<p>ORB-SLAM 是西班牙 Zaragoza 大学的 Raúl Mur-Arta 编写的视觉 SLAM 系统。 它是一个完整的 SLAM 系统，包括视觉里程计、跟踪、回环检测，是一种完全基于稀疏特征点的单目 SLAM 系统，同时还有单目、双目、RGBD 相机的接口。其核心是使用 ORB (Orinted FAST and BRIEF) 作为整个视觉 SLAM 中的核心特征。</p>
<a id="more"></a>

<h2 id="ORB-SLAM-基本介绍"><a href="#ORB-SLAM-基本介绍" class="headerlink" title="ORB-SLAM 基本介绍"></a><strong>ORB-SLAM 基本介绍</strong></h2><p>ORB-SLAM 基本延续了 PTAM 的算法框架,但对框架中的大部分组件都做了改进, 归纳起来主要有 4 点:</p>
<ol>
<li>ORB-SLAM 选用了 ORB 特征, 基于 ORB 描述量的特征匹配和重定位, 都比 PTAM 具有更好的视角不变性。此外, 新增三维点的特征匹配效率更高, 因此能更及时地扩展场景。扩展场景及时与否决定了后续帧是否能稳定跟踪。</li>
<li>ORBSLAM 加入了循环回路的检测和闭合机制, 以消除误差累积。系统采用与重定位相同的方法来检测回路(匹配回路两侧关键帧上的公共点), 通过方位图 (Pose Graph) 优化来闭合回路。</li>
<li>PTAM 需要用户指定 2 帧来初始化系统, 2 帧间既要有足够的公共点, 又要有足够的平移量. 平移运动为这些公共点提供视差 (Parallax) , 只有足够的视差才能三角化出精确的三维位置。ORB-SLAM 通过检测视差来自动选择初始化的 2 帧。</li>
<li>PTAM 扩展场景时也要求新加入的关键帧提供足够的视差, 导致场景往往难以扩展. ORB-SLAM 采用一种更鲁棒的关键帧和三维点的选择机制——先用宽松的判断条件尽可能及时地加入新的关键帧和三维点, 以保证后续帧的鲁棒跟踪; 再用严格的判断条件删除冗余的关键帧和不稳定的三维点，以保证 BA 的效率和精度。</li>
</ol>
<p><em>引自《基于单目视觉的同时定位与地图构建方法综述》</em></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>首个支持单目，双目和RGBD相机的完整的开源SLAM方案，能够实现地图重用，回环检测和重新定位的功能</li>
<li>能够在CPU上进行实时工作，比如手机、无人机、汽车。</li>
<li>特征点法的巅峰之作，定位精度极高。</li>
<li>能够实时计出相机的位姿，并生成场景的稀疏三维重建地图。</li>
<li>代码非常整洁，包含很多实际应用中的技巧，非常实用。</li>
<li>支持仅定位模式，该模式适用于轻量级以及在地图已知情况下长期运行，此时不使用局部建图和回环检测的线程。</li>
<li>双目和RGBD相对单目相机的主要优势在于，可以直接获得深度信息，不需要像单目情况中那样做一个特定的SFM初始化</li>
</ul>
<h3 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h3><p><img src="/2020/04/13/2020-04-13-ORBSLAM2/image-20200413105119355.png" alt="image-20200413105119355"></p>
<p>ORB-SLAM 它是由三大块、三个流程同时运行的。第一块是跟踪，第二块是建图，第三块是闭环检测。</p>
<h4 id="1-跟踪（Tracking）"><a href="#1-跟踪（Tracking）" class="headerlink" title="1. 跟踪（Tracking）"></a>1. 跟踪（Tracking）</h4><p>这一部分主要工作是从图像中提取 ORB 特征，根据上一帧进行姿态估计，或者进行通过全局重定位初始化位姿，然后跟踪已经重建的局部地图，优化位姿，再根据一些规则确定新关键帧。</p>
<h4 id="2-建图（LocalMapping）"><a href="#2-建图（LocalMapping）" class="headerlink" title="2. 建图（LocalMapping）"></a>2. 建图（LocalMapping）</h4><p>这一部分主要完成局部地图构建。包括对关键帧的插入，验证最近生成的地图点并进行筛选，然后生成新的地图点，使用局部捆集调整（Local BA），最后再对插入的关键帧进行筛选，去除多余的关键帧。</p>
<h4 id="3-闭环检测（LoopClosing）"><a href="#3-闭环检测（LoopClosing）" class="headerlink" title="3. 闭环检测（LoopClosing）"></a>3. 闭环检测（LoopClosing）</h4><p>这一部分主要分为两个过程，分别是闭环探测和闭环校正。闭环检测先使用 WOB 进行探测，然后通过 Sim3 算法计算相似变换。闭环校正，主要是闭环融合和 Essential Graph 的图优化。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点**"></a>优缺点**</h3><p><strong>优点：</strong></p>
<ul>
<li>一个代码构造优秀的视觉 SLAM 系统，非常适合移植到实际项目。</li>
<li>采用 g2o 作为后端优化工具，能有效地减少对特征点位置和自身位姿的估计误差。</li>
<li>采用 DBOW 减少了寻找特征的计算量，同时回环匹配和重定位效果较好。重定位：比如当机器人遇到一些意外情况之后，它的数据流突然被打断了，在 ORB-SLAM 算法下，可以在短时间内重新把机器人在地图中定位。</li>
<li>使用了类似「适者生存」的方案来进行关键帧的删选，提高系统追踪的鲁棒性和系统的可持续运行。</li>
<li>提供最著名的公共数据集（ KITTI 和 TUM 数据集）的详尽实验结果，以显示其性能。</li>
<li>可以使用开源代码，并且还支持使用 ROS。 (Github: <a href="https://link.zhihu.com/?target=https%3A//github.com/slightech/MYNT-EYE-ORB-SLAM2-Sample">slightech/MYNT-EYE-ORB-SLAM2-Sample</a>）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>构建出的地图是稀疏点云图。只保留了图像中特征点的一部分作为关键点，固定在空间中进行定位，很难描绘地图中的障碍物的存在。</li>
<li>初始化时最好保持低速运动，对准特征和几何纹理丰富的物体。</li>
<li>旋转时比较容易丢帧，特别是对于纯旋转，对噪声敏感，不具备尺度不变性。</li>
<li>如果使用纯视觉 slam 用于机器人导航，可能会精度不高，或者产生累积误差，漂移，尽管可以使用 DBoW 词袋可以用来回环检测。最好使用 VSLAM+IMU 进行融合，可以提高精度上去，适用于实际应用中机器人的导航。</li>
</ul>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>associate：深度图与彩色图之间不能超过0.02s。</p>
<h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ol>
<li>TUM</li>
<li>EuRoC</li>
<li>KITTI</li>
</ol>
<h3 id="地图表示"><a href="#地图表示" class="headerlink" title="地图表示"></a>地图表示</h3><p>红色点表示当前追踪的点，黑色点表示剩下的点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glcloor3f(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>); <span class="comment">//黑色</span></span><br><span class="line">glcloor3f(<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>); <span class="comment">//红色</span></span><br></pre></td></tr></table></figure>

<h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">loadImages(); <span class="comment">//读取图片的函数 用来loadframe</span></span><br></pre></td></tr></table></figure>

<h3 id="System-h"><a href="#System-h" class="headerlink" title="System.h"></a>System.h</h3><p>其中包含的系统类非常重要</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>ORBSLAM2</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 周赛184</title>
    <url>/2020/04/12/2020-04-12-LeetCode-Contest-184/</url>
    <content><![CDATA[<p>本周周赛战况不佳，只做出前两个来，剩下的其实也很简单。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th align="left">题目</th>
<th align="left">分值</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="left">数组中的字符串匹配</td>
<td align="left">3</td>
</tr>
<tr>
<td>2</td>
<td align="left">查询带键的排列</td>
<td align="left">4</td>
</tr>
<tr>
<td>3</td>
<td align="left">HTML 实体解析器</td>
<td align="left">5</td>
</tr>
<tr>
<td>4</td>
<td align="left">给 N x 3 网格图涂色的方案数</td>
<td align="left">7</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="5380-数组中的字符串匹配"><a href="#5380-数组中的字符串匹配" class="headerlink" title="5380. 数组中的字符串匹配"></a>5380. 数组中的字符串匹配</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串数组 <code>words</code> ，数组中的每个字符串都可以看作是一个单词。请你按 <strong>任意</strong> 顺序返回 <code>words</code> 中是其他单词的子字符串的所有单词。</p>
<p>如果你可以删除 <code>words[j]</code> 最左侧和/或最右侧的若干字符得到 <code>word[i]</code> ，那么字符串 <code>words[i]</code> 就是 <code>words[j]</code> 的一个子字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words &#x3D; [&quot;mass&quot;,&quot;as&quot;,&quot;hero&quot;,&quot;superhero&quot;]</span><br><span class="line">输出：[&quot;as&quot;,&quot;hero&quot;]</span><br><span class="line">解释：&quot;as&quot; 是 &quot;mass&quot; 的子字符串，&quot;hero&quot; 是 &quot;superhero&quot; 的子字符串。</span><br><span class="line">[&quot;hero&quot;,&quot;as&quot;] 也是有效的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words &#x3D; [&quot;leetcode&quot;,&quot;et&quot;,&quot;code&quot;]</span><br><span class="line">输出：[&quot;et&quot;,&quot;code&quot;]</span><br><span class="line">解释：&quot;et&quot; 和 &quot;code&quot; 都是 &quot;leetcode&quot; 的子字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words &#x3D; [&quot;blue&quot;,&quot;green&quot;,&quot;bu&quot;]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 100</code></li>
<li><code>1 &lt;= words[i].length &lt;= 30</code></li>
<li><code>words[i]</code> 仅包含小写英文字母。</li>
<li>题目数据 <strong>保证</strong> 每个 <code>words[i]</code> 都是独一无二的。</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>暴力匹配</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">stringMatching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        sort(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;words.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;words.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=j&amp;&amp;words[j].<span class="built_in">find</span>(words[i])!=<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(words[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5381-查询带键的排列"><a href="#5381-查询带键的排列" class="headerlink" title="5381. 查询带键的排列"></a>5381. 查询带键的排列</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个待查数组 <code>queries</code> ，数组中的元素为 <code>1</code> 到 <code>m</code> 之间的正整数。 请你根据以下规则处理所有待查项 <code>queries[i]</code>（从 <code>i=0</code> 到 <code>i=queries.length-1</code>）：</p>
<ul>
<li>一开始，排列 <code>P=[1,2,3,...,m]</code>。</li>
<li>对于当前的 <code>i</code> ，请你找出待查项 <code>queries[i]</code> 在排列 <code>P</code> 中的位置（<strong>下标从 0 开始</strong>），然后将其从原位置移动到排列 <code>P</code> 的起始位置（即下标为 0 处）。注意， <code>queries[i]</code> 在 <code>P</code> 中的位置就是 <code>queries[i]</code> 的查询结果。</li>
</ul>
<p>请你以数组形式返回待查数组 <code>queries</code> 的查询结果。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：queries &#x3D; [3,1,2,1], m &#x3D; 5</span><br><span class="line">输出：[2,1,2,1] </span><br><span class="line">解释：待查数组 queries 处理如下：</span><br><span class="line">对于 i&#x3D;0: queries[i]&#x3D;3, P&#x3D;[1,2,3,4,5], 3 在 P 中的位置是 2，接着我们把 3 移动到 P 的起始位置，得到 P&#x3D;[3,1,2,4,5] 。</span><br><span class="line">对于 i&#x3D;1: queries[i]&#x3D;1, P&#x3D;[3,1,2,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P&#x3D;[1,3,2,4,5] 。 </span><br><span class="line">对于 i&#x3D;2: queries[i]&#x3D;2, P&#x3D;[1,3,2,4,5], 2 在 P 中的位置是 2，接着我们把 2 移动到 P 的起始位置，得到 P&#x3D;[2,1,3,4,5] 。</span><br><span class="line">对于 i&#x3D;3: queries[i]&#x3D;1, P&#x3D;[2,1,3,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P&#x3D;[1,2,3,4,5] 。 </span><br><span class="line">因此，返回的结果数组为 [2,1,2,1] 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：queries &#x3D; [4,1,2,2], m &#x3D; 4</span><br><span class="line">输出：[3,1,2,0]</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：queries &#x3D; [7,5,5,8,3], m &#x3D; 8</span><br><span class="line">输出：[6,5,0,7,5]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m &lt;= 10^3</code></li>
<li><code>1 &lt;= queries.length &lt;= m</code></li>
<li><code>1 &lt;= queries[i] &lt;= m</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>我的这个解法很不好；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">processQueries</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            P[i+<span class="number">1</span>]=i;</span><br><span class="line">            l[i]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(P[queries[i]]);</span><br><span class="line">            <span class="keyword">int</span> val = queries[i]; <span class="comment">//值</span></span><br><span class="line">            <span class="keyword">int</span> loc = P[queries[i]]; <span class="comment">//位置</span></span><br><span class="line">            <span class="comment">//顺序移动到后边</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = loc<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = P[l[j]];</span><br><span class="line">                P[l[j]] += <span class="number">1</span>;</span><br><span class="line">                l[j+<span class="number">1</span>] = l[j];</span><br><span class="line">            &#125;</span><br><span class="line">            P[val] = <span class="number">0</span>;</span><br><span class="line">            l[<span class="number">0</span>] = val;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5382-HTML-实体解析器"><a href="#5382-HTML-实体解析器" class="headerlink" title="5382. HTML 实体解析器"></a>5382. HTML 实体解析器</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。</p>
<p>HTML 里这些特殊字符和它们对应的字符实体包括：</p>
<ul>
<li><strong>双引号：</strong>字符实体为 <code>&quot;</code> ，对应的字符是 <code>&quot;</code> 。</li>
<li><strong>单引号：</strong>字符实体为 <code>&#39;</code> ，对应的字符是 <code>&#39;</code> 。</li>
<li><strong>与符号：</strong>字符实体为 <code>&amp;</code> ，对应对的字符是 <code>&amp;</code> 。</li>
<li><strong>大于号：</strong>字符实体为 <code>&gt;</code> ，对应的字符是 <code>&gt;</code> 。</li>
<li><strong>小于号：</strong>字符实体为 <code>&lt;</code> ，对应的字符是 <code>&lt;</code> 。</li>
<li><strong>斜线号：</strong>字符实体为 <code>⁄</code> ，对应的字符是 <code>/</code> 。</li>
</ul>
<p>给你输入字符串 <code>text</code> ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text &#x3D; &quot;&amp; is an HTML entity but &amp;ambassador; is not.&quot;</span><br><span class="line">输出：&quot;&amp; is an HTML entity but &amp;ambassador; is not.&quot;</span><br><span class="line">解释：解析器把字符实体 &amp; 用 &amp; 替换</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text &#x3D; &quot;and I quote: &quot;...&quot;&quot;</span><br><span class="line">输出：&quot;and I quote: \&quot;...\&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text &#x3D; &quot;Stay home! Practice on Leetcode :)&quot;</span><br><span class="line">输出：&quot;Stay home! Practice on Leetcode :)&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text &#x3D; &quot;x &gt; y &amp;&amp; x &lt; y is always false&quot;</span><br><span class="line">输出：&quot;x &gt; y &amp;&amp; x &lt; y is always false&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a><strong>示例 5：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text &#x3D; &quot;leetcode.com&amp;frasl;problemset&amp;frasl;all&quot;</span><br><span class="line">输出：&quot;leetcode.com&#x2F;problemset&#x2F;all&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text.length &lt;= 10^5</code></li>
<li>字符串可能包含 256 个ASCII 字符中的任意字符。</li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">entityParser</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">"&amp;quot;"</span>]=<span class="string">"\""</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">"&amp;apos;"</span>]=<span class="string">"'"</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">"&amp;amp;"</span>]=<span class="string">"&amp;"</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">"&amp;gt;"</span>]=<span class="string">"&gt;"</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">"&amp;lt;"</span>]=<span class="string">"&lt;"</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">"&amp;frasl;"</span>]=<span class="string">"/"</span>;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> key=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:<span class="built_in">text</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">'&amp;'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=key;</span><br><span class="line">                key = <span class="string">"&amp;"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">';'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                key.append(<span class="number">1</span>,ch);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(key)!=<span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    res += <span class="built_in">map</span>[key];</span><br><span class="line">                    key = <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                key.append(<span class="number">1</span>,ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!key.empty())</span><br><span class="line">            res+=key;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5383-给-N-x-3-网格图涂色的方案数"><a href="#5383-给-N-x-3-网格图涂色的方案数" class="headerlink" title="5383. 给 N x 3 网格图涂色的方案数"></a>5383. 给 N x 3 网格图涂色的方案数</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>你有一个 <code>n x 3</code> 的网格图 <code>grid</code> ，你需要用 <strong>红，黄，绿</strong> 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。</p>
<p>给你网格图的行数 <code>n</code> 。</p>
<p>请你返回给 <code>grid</code> 涂色的方案数。由于答案可能会非常大，请你返回答案对 <code>10^9 + 7</code> 取余的结果。</p>
<h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：12</span><br><span class="line">解释：总共有 12 种可行的方法：</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：54</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：246</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：106494</span><br></pre></td></tr></table></figure>

<h4 id="示例-5：-1"><a href="#示例-5：-1" class="headerlink" title="示例 5："></a><strong>示例 5：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5000</span><br><span class="line">输出：30228214</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>n == grid.length</code></li>
<li><code>grid[i].length == 3</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
</ul>
<h3 id="他人解法"><a href="#他人解法" class="headerlink" title="他人解法"></a>他人解法</h3><h4 id="1-状态压缩-递推。"><a href="#1-状态压缩-递推。" class="headerlink" title="1. 状态压缩 + 递推。"></a>1. 状态压缩 + 递推。</h4><p><strong>状态压缩</strong><br>用一个数字表示集合的一种状态。<br>在本题中，三个并列的格子可以看作是一个集合。我们用数字表示这个集合的状态，也就是染色方案。</p>
<p><strong>具体的表示方法</strong>如下：<br>因为只有三种颜色，所以可以用三进制数字来表示染色方案。用 0，1，2 分别代表红黄绿。因为每个集合只有三个格子，所以只需要用三位数字。<br>比如21 = 0 + 31 + 92，代表第一个格子为红色，第二个格子为黄色，第三个格子为绿色。<br>我们可以把这个数字称为状态码。</p>
<p>关于状态码的取值范围<br>当三个格子都染成红色时，状态码取得最小值即 0 + 03 + 09 = 0。<br>当三个格子都染成绿色时，状态码取得最大值即 2 + 23 + 29 = 26。<br>所以状态码的取值范围为[0,26]。</p>
<p><strong>递归</strong><br>设 <code>dp[n][sc]</code> 为将前 n 层都染上颜色，且第n层的染色为 <code>sc</code>。<code>sc</code> 即上述的状态码。<br>当 n 等于 1时，<code>dp[n][sc]</code>很好计算，即判断<code>sc</code>代表的染色方案是否合法即可。<br>如果合法 <code>dp[1][sc] = 1</code>，否则 <code>dp[1][sc] = 0</code>。</p>
<p>当 <code>n &gt; 1</code> 时，<code>dp[n][sc]</code>由 <code>dp[n-1][psc]</code>推导得出。<code>sc</code> 为第<code>n</code>行的染色方案，<code>psc</code>为 <code>n-1</code>行的染色方案。</p>
<p>递推式子如下：</p>
<p><code>dp[n][sc] += dp[n-1][psc] (0 &lt;= psc &lt; 27)</code>。</p>
<p><strong>源代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">5001</span>][<span class="number">27</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//根据每个格子的颜色获取状态码</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + j*<span class="number">3</span> + k *<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据状态码获取每个格子的颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cs</span><span class="params">(<span class="keyword">int</span> statusCode, <span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b, <span class="keyword">int</span> &amp;c)</span> </span>&#123;</span><br><span class="line">        a = statusCode % <span class="number">3</span>;</span><br><span class="line">        b = (statusCode - a)%<span class="number">9</span>/<span class="number">3</span>;</span><br><span class="line">        c = statusCode/<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        初始化 n = <span class="number">1</span> 的方案数。</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != j &amp;&amp; j != k) &#123;</span><br><span class="line">                        dp[<span class="number">1</span>][sc(i,j,k)] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//枚举行数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> level = <span class="number">2</span>; level &lt;= n; level++) &#123;</span><br><span class="line">            <span class="comment">//枚举前一行的染色方案</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> pre = <span class="number">0</span>; pre &lt; <span class="number">27</span>; ++pre) &#123;</span><br><span class="line">                <span class="keyword">int</span> a, b, c;</span><br><span class="line">                cs(pre, a, b, c);</span><br><span class="line">                <span class="keyword">if</span>(a == b || b == c) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//枚举当前行的染色方案</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == a) &#123; <span class="keyword">continue</span>; &#125; <span class="comment">//检查是否冲突</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(i == j || j == b) &#123; <span class="keyword">continue</span>; &#125; <span class="comment">//检查是否冲突</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(j == k || k == c) &#123; <span class="keyword">continue</span>; &#125; <span class="comment">//检查是否冲突</span></span><br><span class="line">                            (dp[level][sc(i,j,k)] += dp[level<span class="number">-1</span>][pre]) %= mod; <span class="comment">//当前染色方案可行，累加方案数。</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">            (ans += dp[n][i]) %= mod; <span class="comment">//计算总的方案数。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">5010</span>][<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>];<span class="comment">//f[i][j][k][l]表示第i行涂的颜色为(j,k,l)时的涂色方案数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) <span class="keyword">if</span>(i!=j&amp;&amp;j!=k) f[<span class="number">1</span>][i][j][k] = <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">3</span>; i1++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j1 = <span class="number">0</span>; j1 &lt; <span class="number">3</span>; j1++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k1 = <span class="number">0</span>; k1 &lt; <span class="number">3</span>; k1++) </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt; <span class="number">3</span>; i2++)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt; <span class="number">3</span>; j2++)&#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; <span class="number">3</span>; k2++)&#123;<span class="comment">//枚举相邻两行的状态 再判断是否符合条件即可</span></span><br><span class="line">                                <span class="keyword">if</span>(i2!=j2&amp;&amp;j2!=k2 &amp;&amp; i1!=i2&amp;&amp;j1!=j2&amp;&amp;k1!=k2)<span class="comment">//水平不同 垂直不同 </span></span><br><span class="line">                                    f[i][i2][j2][k2] = (f[i][i2][j2][k2] + f[i<span class="number">-1</span>][i1][j1][k1])%p;</span><br><span class="line">                            &#125; </span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;<span class="comment">//得出结果 即为最后一行所有不同涂色状态时的累加和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) res = (res + f[n][i][j][k])%p; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>周赛</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4.11~12</title>
    <url>/2020/04/10/2020-04-11-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>[困难] 鸡蛋掉落 </li>
<li>[简单] 二叉树的最近公共祖先</li>
<li>[困难] 求两线段交点</li>
</ol>
<a id="more"></a>

<h2 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a>887. 鸡蛋掉落</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>你将获得 <code>K</code> 个鸡蛋，并可以使用一栋从 <code>1</code> 到 <code>N</code> 共有 <code>N</code> 层楼的建筑。</p>
<p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p>
<p>你知道存在楼层 <code>F</code> ，满足 <code>0 &lt;= F &lt;= N</code> 任何从高于 <code>F</code> 的楼层落下的鸡蛋都会碎，从 <code>F</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次<em>移动</em>，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 <code>X</code> 扔下（满足 <code>1 &lt;= X &lt;= N</code>）。</p>
<p>你的目标是<strong>确切地</strong>知道 <code>F</code> 的值是多少。</p>
<p>无论 <code>F</code> 的初始值如何，你确定 <code>F</code> 的值的最小移动次数是多少？</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：K &#x3D; 1, N &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F &#x3D; 0 。</span><br><span class="line">否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F &#x3D; 1 。</span><br><span class="line">如果它没碎，那么我们肯定知道 F &#x3D; 2 。</span><br><span class="line">因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：K &#x3D; 2, N &#x3D; 6</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：K &#x3D; 3, N &#x3D; 14</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= K &lt;= 100</code></li>
<li><code>1 &lt;= N &lt;= 10000</code></li>
</ol>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="背景资料"><a href="#背景资料" class="headerlink" title="背景资料"></a>背景资料</h4><p>本题是谷歌用于面试的一道经典面试题之一。由于本题过于经典，谷歌公司已经不再将这题作为面试的候选题目了。</p>
<p>本题难度较高，要想通过本题，需要一定的动态规划优化或数学功底。本题的标准解法为动态规划，由于篇幅有限，不会叙述 动态规划的边界条件、自底向上的动态规划和自顶向下的动态规划分别怎么实现 等较为基础的知识，而是把重点放在推导动态规划状态转移方程的过程，以及优化的思路、证明以及方法。</p>
<p>读者应当期望在阅读完本题解后，能够对方法一有一个大致的思路，并且可以在尝试中编写出代码。方法一已经是很优秀的解法，本题解也着重于此。而对于方法二和方法三，已经超过了面试难度，是竞赛中的考点，仅供读者挑战自我的极限。</p>
<h4 id="方法一：动态规划-二分搜索"><a href="#方法一：动态规划-二分搜索" class="headerlink" title="方法一：动态规划 + 二分搜索"></a>方法一：动态规划 + 二分搜索</h4><h5 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a>思路和算法</h5><p>我们可以考虑使用动态规划来做这道题，状态可以表示成 <code>(K, N)</code>，其中 <code>K</code>为鸡蛋数，<code>N</code>为楼层数。当我们从第 XX 楼扔鸡蛋的时候：</p>
<p>如果鸡蛋不碎，那么状态变成 <code>(K, N-X)</code>，即我们鸡蛋的数目不变，但答案只可能在上方的 <code>N-X</code>层楼了。也就是说，我们把原问题缩小成了一个规模为 <code>(K, N-X)</code>的子问题；</p>
<p>如果鸡蛋碎了，那么状态变成 <code>(K-1, X-1)</code>，即我们少了一个鸡蛋，但我们知道答案只可能在第<code>X</code>楼下方的 <code>X-1</code>层楼中了。也就是说，我们把原问题缩小成了一个规模为 <code>(K-1, X-1)</code>的子问题。</p>
<p>这样一来，我们定义 <code>dp(K, N)</code>为在状态 <code>(K, N)</code>下最少需要的步数。</p>
<p>根据以上分析我们可以列出状态转移方程：<br>$$<br>dp(K, N) = 1 + \min\limits_{1 \leq X \leq N} \Big( \max(dp(K-1, X-1), dp(K, N-X)) \Big)\<br>dp(K,N)=1+1≤X≤N \min<br> (max(dp(K−1,X−1),dp(K,N−X)))<br>$$<br>这个状态转移方程是如何得来的呢？对于 <code>dp(K, N)</code>而言，我们像上面分析的那样，枚举第一个鸡蛋扔在的楼层数 <code>X</code>。由于我们并不知道真正的 <code>F</code>值，因此我们必须保证 鸡蛋碎了之后接下来需要的步数 和 鸡蛋没碎之后接下来需要的步数 二者的 最大值 最小，这样就保证了在 最坏情况下（也就是无论 <code>F</code> 的值如何） <code>dp(K, N)</code>的值最小。如果能理解这一点，也就能理解上面的状态转移方程。即最小化 $\max(dp(K-1, X-1), dp(K, N-X))$。</p>
<p>如果我们直接暴力转移求解每个状态的<code>dp</code>值，时间复杂度是为 <code>O(KN^2)</code>，即一共有 <code>O(KN)</code>个状态，对于每个状态枚举扔鸡蛋的楼层 <code>X</code>,需要 <code>O(N)</code>的时间。这无疑在当前数据范围下是会超出时间限制的，因此我们需要想办法优化枚举的时间复杂度。</p>
<p>我们观察到 <code>dp(K, N)</code>是一个关于 <code>N</code> 的单调递增函数，也就是说在鸡蛋数 <code>K</code>固定的情况下，楼层数 <code>N</code>越多，需要的步数一定不会变少。在上述的状态转移方程中，第一项$\mathcal{T_1}(X) = dp(K-1, X-1)$是一个随 <code>X</code>的增加而单调递增的函数，第二项 $\mathcal{T_2}(X) = dp(K, N-X)$是一个随着 <code>X</code>的增加而单调递减的函数。这如何帮助我们来优化这个问题呢？当X增加时，$\mathcal{T_1}(X)$单调递增。而$\mathcal{T_2}(X)$单调递减，我们可以想象在一个直角坐标系中，横坐标为 XX，纵坐标为 $\mathcal{T_1}(X)$ 和 $\mathcal{T_2}(X)$。当一个函数单调递增而另一个函数单调递减时，我们如何找到一个位置使得它们的最大值最小呢？</p>
<p>如上图所示，如果这两个函数都是连续函数，那么我们只需要找出这两个函数的交点，在交点处就能保证这两个函数的最大值最小。但在本题中，$\mathcal{T_1}(X)$都是离散函数，也就是说，X的值只能取 <code>1,2,3</code> 等等。在这种情况下，我们需要找到最大的满足 $\mathcal{T_1}(X) &lt; \mathcal{T_2}(X)$ ，以及最小的满足 $\mathcal{T_1}(X) \geq \mathcal{T_2}(X)$，对应到上图中，就是离这两个函数（想象中的）交点左右两侧最近的整数。</p>
<p>我们只需要比较在$X_0$ 和 $X_1$处两个函数的最大值，取一个最小的作为 <code>X</code> 即可。在数学上，我们可以证明出 $X_0$和 $X_1$相差1，这也是比较显然的，因为它们正好夹住了那个想象中的交点，并且相距尽可能地近。因此我们就可以使用二分查找的方法找出 $X_0$ ，再得到$X_1$</p>
<p>我们在所有满足条件的 <code>X</code>X 上进行二分查找。对于状态 <code>(K, N)</code> 而言，<code>X</code>即为 <code>[1, N]</code>中的任一整数；</p>
<p>在二分查找的过程中，假设当前这一步我们查找到了 $X_\textit{mid}$，如果 $\mathcal{T_1}(X_\textit{mid}) &gt; \mathcal{T_2}(X_\textit{mid})$ ,那么真正的 $X_0$  一定在 $X_\textit{mid}$  的左侧，否则真正的 $X_0$  在 $X_\textit{mid}$  的右侧。</p>
<p>二分查找的写法因人而异，本质上我们就是需要找到最大的满足 $\mathcal{T_1}(X) &lt; \mathcal{T_2}(X)$ 的 $X_0$ ，根据 $X_\textit{mid}$  进行二分边界的调整。在得到了<code>X_0</code> 后，我们可以知道 $X_1$  即为 $X_0 + 1$，此时我们只需要比较 $\max(\mathcal{T_1}(X_0), \mathcal{T_2}(X_0))$和$\max(\mathcal{T_1}(X_1), \mathcal{T_2}(X_1))$，取较小的那个对应的位置作为 <code>X</code>即可。</p>
<p>这样一来，对于给定的状态 <code>(K, N)</code>，我们只需要 <code>O(logN)</code> 的时间，通过二分查找就能得到最优的那个<code>X</code>，因此时间复杂度从 <code>O(KN^2)</code>降低至 <code>O(KN \log N)</code>，可以通过本题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">find</span>(N * <span class="number">100</span> + K) == memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans;</span><br><span class="line">            <span class="keyword">if</span> (N == <span class="number">0</span>) ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>) ans = N;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> lo = <span class="number">1</span>, hi = N;</span><br><span class="line">                <span class="keyword">while</span> (lo + <span class="number">1</span> &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> t1 = dp(K<span class="number">-1</span>, x<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">int</span> t2 = dp(K, N-x);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (t1 &lt; t2) lo = x;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) hi = x;</span><br><span class="line">                    <span class="keyword">else</span> lo = hi = x;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ans = <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">max</span>(dp(K<span class="number">-1</span>, lo<span class="number">-1</span>), dp(K, N-lo)),</span><br><span class="line">                                   <span class="built_in">max</span>(dp(K<span class="number">-1</span>, hi<span class="number">-1</span>), dp(K, N-hi)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            memo[N * <span class="number">100</span> + K] = ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[N * <span class="number">100</span> + K];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(K, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题68-II-二叉树的最近公共祖先"><a href="#面试题68-II-二叉树的最近公共祖先" class="headerlink" title="面试题68 - II. 二叉树的最近公共祖先"></a>面试题68 - II. 二叉树的最近公共祖先</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt="img"></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;        </span><br><span class="line">        <span class="keyword">if</span>(root == p||root == q)<span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left ? left : right; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-16-03-交点"><a href="#面试题-16-03-交点" class="headerlink" title="面试题 16.03. 交点"></a>面试题 16.03. 交点</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>给定两条线段（表示为起点<code>start = {X1, Y1}</code>和终点<code>end = {X2, Y2}</code>），如果它们有交点，请计算其交点，没有交点则返回空值。</p>
<p>要求浮点型误差不超过<code>10^-6</code>。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">line1 &#x3D; &#123;0, 0&#125;, &#123;1, 0&#125;</span><br><span class="line">line2 &#x3D; &#123;1, 1&#125;, &#123;0, -1&#125;</span><br><span class="line">输出： &#123;0.5, 0&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">line1 &#x3D; &#123;0, 0&#125;, &#123;3, 3&#125;</span><br><span class="line">line2 &#x3D; &#123;1, 1&#125;, &#123;2, 2&#125;</span><br><span class="line">输出： &#123;1, 1&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">line1 &#x3D; &#123;0, 0&#125;, &#123;1, 1&#125;</span><br><span class="line">line2 &#x3D; &#123;1, 0&#125;, &#123;2, 1&#125;</span><br><span class="line">输出： &#123;&#125;，两条线段没有交点</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li>坐标绝对值不会超过 2^7</li>
<li>输入的坐标均是有效的二维坐标</li>
</ul>
<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="叉积法"><a href="#叉积法" class="headerlink" title="叉积法"></a>叉积法</h4><p>我们也可以不用表示出线段的方程，通过向量的基本运算来解决这个问题。这里引入一些向量运算的基本概念。</p>
<p>向量叉积的模：对于向量 $\boldsymbol{a} = (x_1, y_1)$和 $\boldsymbol{b} = (x_2, y_2)$，定义向量的叉积的模为<br>$$<br>|\boldsymbol{c}| = |\boldsymbol{a} \times \boldsymbol{b}| = |\boldsymbol{a}||\boldsymbol{b}| \sin \langle \boldsymbol{a}, \boldsymbol{b} \rangle = x_1 y_2 - x_2 y_1<br>$$</p>
<p>其中 $\langle \boldsymbol{a}, \boldsymbol{b} \rangle$表示 $\boldsymbol{a}$ 和 $\boldsymbol{b}$的夹角。这个模的正负性可以表示这两个向量的位置关系，如果 $\boldsymbol{a}$可以逆时针旋转与 $\boldsymbol{b}$共线，那么这个模大于 0；如果 $\boldsymbol{a}$可以顺时针旋转与 $\boldsymbol{b}$共线，那么这个模小于 0；如果已经共线，则等于 0。</p>
<p>三角形的面积：有了叉积的定义，我们可以这样计算三角形 ABCABC 的面积<br>$$<br>S = \frac{|\boldsymbol{AB}\times \boldsymbol{AC}|}{2}<br>$$</p>
<p>很好理解，画图可以看出 $\sin \langle \boldsymbol{a}, \boldsymbol{b}\rangle$ 相当于把一个向量投影成了另一个向量为底边的高。</p>
<p>定比分点：若 P(x, y)P(x,y) 在线段 ABAB 上，端点坐标$A(x_1, y_2)，B(x_2, y_2)$，且 <code>AP</code>和 <code>BP</code>的长度之比为 $\lambda$，那么<br>$$<br>\left { \begin{aligned} x &amp;=&amp; \frac{x_1 + \lambda x_2}{1 + \lambda} \ y &amp;=&amp; \frac{y_1 + \lambda y_2}{1 + \lambda} \end{aligned} \right .<br>$$</p>
<p><strong>说明</strong></p>
<p>题目要求「如果有交点则计算交点，没有则返回空值」，并说明有多个交点的时候返回以 <code>x</code>为第一关键字，以 <code>y</code> 为第二关键字排序的最小点。</p>
<p>首先我们要判断线段 <code>AB</code>和 <code>CD</code>是否存在交点，等价转换这个条件就是 <code>A</code>和 <code>B</code>位于<code>CD</code>的两侧并且 <code>C</code>和 <code>D</code> 位于 <code>AB</code>的两侧。那么如何判断「<code>P</code> 和<code>Q</code>位于<code>MN</code>的两侧」呢？我们可以连接<code>PM</code>和<code>QM</code>，如果能满足 $(\boldsymbol{MN} \times \boldsymbol{MP})(\boldsymbol{MN} \times \boldsymbol{MQ}) \leq 0$，即把 $\boldsymbol{MN}$ 向两个不同的方向旋转可以分别得到 $\boldsymbol{MP}$ 和 $\boldsymbol{MQ}$，则说明<code>P</code> 和<code>Q</code>位于 <code>MN</code>的两侧。考虑：什么时候等于 0？ 很明显当 <code>P</code> 或<code>Q</code>位于 <code>MN</code>上的时候，这个值等于 <code>0</code>。这里我们也可以先通过叉积的方法判断 $\boldsymbol{MN}$和$\boldsymbol{PQ}$是否共线，如果 $\boldsymbol{MN} \times \boldsymbol{MP}$和$ \boldsymbol{MN} \times \boldsymbol{MQ}$都为 <code>0</code>，则说明共线。对于共线的情况，我们可以根据方法一的做法做四个 <code>update</code>。</p>
<p>当已经确定两个线段 <code>AB</code>和 <code>CD</code>是相交的时候，如何求解线段的交点呢？我们可以把 <code>AB</code>和 <code>CD</code> 看成一个四边形的两条对角线，它们相交于点 O。我们可以通过三角形面积公式求出 <code>ABC</code> 和 <code>ABD</code>的面积，它们的比值就是 <code>OC</code>和 <code>OD</code> 的比值，然后再用<strong>定比分点公式</strong>求出 <code>O</code> 的坐标。</p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Coor = <span class="built_in">vector</span> &lt;<span class="keyword">double</span>&gt;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> EPS = <span class="number">1E-6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; start1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; end1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; start2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; end2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ax = start1[<span class="number">0</span>], ay = start1[<span class="number">1</span>], bx = end1[<span class="number">0</span>], by = end1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cx = start2[<span class="number">0</span>], cy = start2[<span class="number">1</span>], dx = end2[<span class="number">0</span>], dy = end2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> acx = cx - ax, acy = cy - ay, abx = bx - ax, aby = by - ay, adx = dx - ax, ady = dy - ay;</span><br><span class="line">        <span class="keyword">int</span> cax = ax - cx, cay = ay - cy, cbx = bx - cx, cby = by - cy, cdx = dx - cx, cdy = dy - cy;</span><br><span class="line">        <span class="comment">// 叉积运算</span></span><br><span class="line">        <span class="keyword">auto</span> cross = [] (<span class="keyword">int</span> ux, <span class="keyword">int</span> uy, <span class="keyword">int</span> vx, <span class="keyword">int</span> vy) &#123;</span><br><span class="line">            <span class="keyword">return</span> ux * vy - vx * uy;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 判断线段 (ux, uy) -- (vx, vy) 是否包含 (mx, my)  </span></span><br><span class="line">        <span class="keyword">auto</span> bothSide = [&amp;] (<span class="keyword">int</span> mx, <span class="keyword">int</span> my, <span class="keyword">int</span> ux, <span class="keyword">int</span> uy, <span class="keyword">int</span> vx, <span class="keyword">int</span> vy) &#123;</span><br><span class="line">            <span class="keyword">double</span> um = <span class="built_in">sqrt</span>((ux - mx) * (ux - mx) + (uy - my) * (uy - my));</span><br><span class="line">            <span class="keyword">double</span> vm = <span class="built_in">sqrt</span>((vx - mx) * (vx - mx) + (vy - my) * (vy - my));</span><br><span class="line">            <span class="keyword">double</span> uv = <span class="built_in">sqrt</span>((vx - ux) * (vx - ux) + (vy - uy) * (vy - uy));</span><br><span class="line">            <span class="keyword">return</span> (ux - mx) * (vx - mx) &lt;= <span class="number">0</span> &amp;&amp; (uy - my) * (vy - my) &lt;= <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 以 x 为第一关键字，y 为第二关键字比较两个点的大小</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [] (<span class="keyword">const</span> Coor&amp; u, <span class="keyword">const</span> Coor&amp; v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u.<span class="built_in">size</span>() == <span class="number">0</span> || v.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> v.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (u[<span class="number">0</span>] != v[<span class="number">0</span>]) ? (u[<span class="number">0</span>] &lt; v[<span class="number">0</span>]) : (u[<span class="number">1</span>] &lt; v[<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 共线处理和 T 形处理</span></span><br><span class="line">        <span class="keyword">if</span> (cross(cax, cay, cbx, cby) == <span class="number">0</span> || cross(adx, ady, abx, aby) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">bool</span> aInCd = bothSide(ax, ay, cx, cy, dx, dy), bInCd = bothSide(bx, by, cx, cy, dx, dy);</span><br><span class="line">            <span class="keyword">bool</span> cInAb = bothSide(cx, cy, ax, ay, bx, by), dInAb = bothSide(dx, dy, ax, ay, bx, by);</span><br><span class="line">            Coor ans;</span><br><span class="line">            <span class="keyword">if</span> (aInCd) ans = <span class="built_in">min</span>(ans, Coor(&#123;(<span class="keyword">double</span>)ax, (<span class="keyword">double</span>)ay&#125;), cmp) ;</span><br><span class="line">            <span class="keyword">if</span> (bInCd) ans = <span class="built_in">min</span>(ans, Coor(&#123;(<span class="keyword">double</span>)bx, (<span class="keyword">double</span>)by&#125;), cmp);</span><br><span class="line">            <span class="keyword">if</span> (cInAb) ans = <span class="built_in">min</span>(ans, Coor(&#123;(<span class="keyword">double</span>)cx, (<span class="keyword">double</span>)cy&#125;), cmp);</span><br><span class="line">            <span class="keyword">if</span> (dInAb) ans = <span class="built_in">min</span>(ans, Coor(&#123;(<span class="keyword">double</span>)dx, (<span class="keyword">double</span>)dy&#125;), cmp);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断两条线段是否有公共点</span></span><br><span class="line">        <span class="keyword">auto</span> intersect = [&amp;] () &#123;</span><br><span class="line">            <span class="keyword">return</span> cross(acx, acy, abx, aby) * cross(adx, ady, abx, aby) &lt;= <span class="number">0</span> &amp;&amp; cross(cax, cay, cdx, cdy) * cross(cbx, cby, cdx, cdy) &lt;= <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (!intersect()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Coor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算三角形 PQM 的面积</span></span><br><span class="line">        <span class="keyword">auto</span> getArea = [&amp;] (<span class="keyword">int</span> px, <span class="keyword">int</span> py, <span class="keyword">int</span> qx, <span class="keyword">int</span> qy, <span class="keyword">int</span> mx, <span class="keyword">int</span> my) -&gt; <span class="keyword">double</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mpx = px - mx, mpy = py - my, mqx = qx - mx, mqy = qy - my;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="keyword">double</span>(<span class="number">0.5</span>) * cross(mpx, mpy, mqx, mqy));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 定比分点</span></span><br><span class="line">        <span class="keyword">double</span> ck = getArea(ax, ay, bx, by, cx, cy), dk = getArea(ax, ay, bx, by, dx, dy);</span><br><span class="line">        <span class="keyword">double</span> k = ck / dk;</span><br><span class="line">        <span class="keyword">double</span> rx = (cx + k * dx) / (<span class="number">1</span> + k), ry = (cy + k * dy) / (<span class="number">1</span> + k);</span><br><span class="line">        <span class="keyword">return</span> Coor(&#123;rx, ry&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在代码中「共线处理和 T 形处理」部分，为什么只判断了 ABCABC 共线或者 ABDABD 共线呢？</p>
<p>如果 <code>ABC</code> 共线且 <code>ABD</code>共线，那么说明 <code>ABCD</code>共线<br>如果 <code>ABC</code>共线但 <code>ABD</code>不共线，那么说明<code>C</code>在「直线」<code>AB</code>上，如果 <code>C</code> 在「线段」<code>AB</code>上则形成一个 <code>T</code> 形结构<br>如果 <code>ABD</code>共线但是 ABCABC 不共线，那么说明 DD 在「直线」ABAB 上，如果 DD 在「线段」ABAB 上则形成一个 T 形结构<br>这里只能判断点是否在「直线」上，在 if 里面才可以判断点是否在线段上。这三种情况都能得到正确的结果，因为经过四个取 min 的操作（即方法一中的四个 update），所有「点 PP 在 MNMN 上」的情况可以被讨论出来，所以这里不仅处理的是共线的情况，还有四种 T 形的情况中的两种。思考：为什么不用处理剩下的两种呢？ 不判断 ACDACD 和 BCDBCD，因为后面定比分点用的是 ABCABC 和 ABDABD 的面积，前面 ABCABC 共线和 ABDABD 共线被处理掉之后，就不存在面积为 00 的状况，也就不会出现分母为 00。即使 ACDACD 和 BCDBCD 共线，ABCABC 和 ABDABD 的面积依然是大于 00 的，不影响定比分点。</p>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：<code>O(1)</code>。</p>
<p>空间复杂度：<code>O(1)</code>。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-9</title>
    <url>/2020/04/09/2020-04-09-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>括号生成</li>
<li>翻转字符串里的单词</li>
<li>不用加减乘除做加法</li>
</ol>
<a id="more"></a>

<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure>

<h3 id="我的解法：递归"><a href="#我的解法：递归" class="headerlink" title="我的解法：递归"></a>我的解法：递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">""</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">"()"</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp1 = generateParenthesis(i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp2 = generateParenthesis(n-i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> str1:tmp1)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> str2:tmp2)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">"("</span>+str1+<span class="string">")"</span>+str2);</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>+str1+<span class="string">")"</span>+str2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它方法一：暴力法"><a href="#其它方法一：暴力法" class="headerlink" title="其它方法一：暴力法"></a>其它方法一：暴力法</h3><p>思路</p>
<p>我们可以生成所有 2^{2n}2<br>2n<br>  个 ‘(‘ 和 ‘)’ 字符构成的序列，然后我们检查每一个是否有效即可。</p>
<p>算法</p>
<p>为了生成所有序列，我们可以使用递归。长度为 n 的序列就是在长度为 n-1 的序列前加一个 ‘(‘ 或 ‘)’。</p>
<p>为了检查序列是否有效，我们遍历这个序列，并使用一个变量 balance 表示左括号的数量减去右括号的数量。如果在遍历过程中 balance 的值小于零，或者结束时 balance 的值不为零，那么该序列就是无效的，否则它是有效的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str)</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>)</span><br><span class="line">                ++balance;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                --balance;</span><br><span class="line">                <span class="keyword">if</span> (balance &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> balance == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generate_all</span><span class="params">(<span class="built_in">string</span>&amp; current, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == current.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid(current))</span><br><span class="line">                result.push_back(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current += <span class="string">'('</span>;</span><br><span class="line">        generate_all(current, n, result);</span><br><span class="line">        current.pop_back();</span><br><span class="line">        current += <span class="string">')'</span>;</span><br><span class="line">        generate_all(current, n, result);</span><br><span class="line">        current.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="built_in">string</span> current;</span><br><span class="line">        generate_all(current, n * <span class="number">2</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其它方法二：DFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuffer sbq = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">        dfs(sbq,n,n);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(StringBuffer sb, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span>.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(sb.append(<span class="string">'('</span>), left - <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(sb.append(<span class="string">')'</span>), left, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a>151. 翻转字符串里的单词</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a><strong>说明：</strong></h4><ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">        <span class="built_in">string</span> temp = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp!=<span class="string">""</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    st.push(temp);</span><br><span class="line">                    temp=<span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp+=ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="string">""</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(temp);</span><br><span class="line">            temp=<span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            res+=temp;</span><br><span class="line">            <span class="keyword">if</span>(!st.empty())</span><br><span class="line">                res+=<span class="string">" "</span>;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题65-不用加减乘除做加法"><a href="#面试题65-不用加减乘除做加法" class="headerlink" title="面试题65. 不用加减乘除做加法"></a>面试题65. 不用加减乘除做加法</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: a &#x3D; 1, b &#x3D; 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">int</span> plus1 = (a ^ b); <span class="comment">// 求和（不计进位）. 相同位置0，相反位置1</span></span><br><span class="line">        <span class="keyword">int</span> plus2 = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>); <span class="comment">// 计算进位. 先保留同为1的位，都为1的位要向左进位，因此左移1位</span></span><br><span class="line">        <span class="keyword">return</span> add(plus1,plus2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果是十进制的话，我们是如何完成加法计算的？<code>15 + 12 = ？</code> 个位数和十位数的数字分别相加先不管进位的问题，<code>2 + 5 = 7</code>；<code>1 + 1 = 2</code>；所以得到结果 27。</p>
<p><strong>计算产生进位的数字</strong> </p>
<p>这里有进位吗？没有，那么就是0, 把上面两步的结果进行相加：<code>27 + 0 = 27</code>；<code>99 + 111 = ？</code> 个、十、百位 的数字分别相加先不管进位的问题：<br>个位：9 + 1 = 0<br>十位：9 + 1 = 0<br>百位：0 + 1 = 1<br>得到临时结果：100</p>
<p><strong>计算进位的数字</strong><br>1 + 9 = 10;<br>10 + 90 = 100;<br>得到进位结果：110</p>
<p><strong>相加得到结果</strong><br>100 + 110 = 210<br>如何用二进制完成以上的步骤？</p>
<p><strong>问题1： 二进制的加法利用以上的步骤可以得到正确的结果吗？</strong><br>12 二进制：1100<br>15 二进制：1111</p>
<p>各位置上的数字分别相加先不管进位的问题：<br>1100 + 1111 = 0011<br>得到临时二进制结果：0011</p>
<p>计算进位的数字：<br>0100 + 0100 = 1000<br>1000 + 1000= 10000<br>得到进位结果：11000</p>
<p>相加得到结果<br>0011 + 11000 = 11011（十进制：27）<br>就目前来看，是可以的。</p>
<p><strong>问题2：第一步骤不用加法如何得到相同结果？异或</strong><br>异或：相同为0，相异为1</p>
<p>1100 ^ 1111 = 0011</p>
<p><strong>问题3：第二步骤不用加法如何得到相同结果？相与，左移一位</strong><br>如果一个位置上的数字相遇能得到1 ，那么表示，位置上的数字都是1，然后在往左移动一位，就是步骤二 进位得到的结果</p>
<p>(1100 &amp; 1111) &lt;&lt; 1 = 11000</p>
<p><strong>问题4：第三步骤不用加法如何得到相同结果？其实这是个套娃</strong><br>第三步不用加法实现最难，因为第三步是前两步的和，还是个加法；如果不用加法，就只能不断调用前两步的步骤。<br>我想用下面的一张图来说明：</p>
<p><img src="/2020/04/09/2020-04-09-LeetCode-CheckDaily/0fdd8e927c61b5f70bdc3e7da0ac100dcd1e3b2f66de5bdf3ebcfb1f6a73c64f-image.png" alt="image.png"></p>
<p>从上图，你大概可以看出，这个就是在不断重复第一，第二的步骤，那么退出条件是什么？<br>其实我们可以设想一个最坏的情况，那就是，这个循环到了一个情况，会在一直循环的情况，结果依然不变？<br>无疑，那就是，进位的结果为0的情况，所以，其实在不考虑溢位的情况下，其实最多最多就是循环32次就行,<br>所以，一下代码已经可以得到正确的结果了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 32; i++) &#123;</span><br><span class="line">		int tempSum &#x3D; a ^ b;</span><br><span class="line">		int carrySum &#x3D; (a &amp; b) &lt;&lt; 1;</span><br><span class="line">		a &#x3D; tempSum;</span><br><span class="line">		b &#x3D; carrySum;</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是以上的代码依然利用了加法运算，依然不不符合题意。<br>那么只能根据 条件 进位的结果为0的情况 进行判断停止了，就有了一下正确的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> tempSum = a ^ b;</span><br><span class="line">		<span class="keyword">int</span> carrySum = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		a = tempSum;</span><br><span class="line">		b = carrySum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>作者：fakerleet<br>链接：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/jin-zhi-tao-wa-ru-he-yong-wei-yun-suan-wan-cheng-j/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/jin-zhi-tao-wa-ru-he-yong-wei-yun-suan-wan-cheng-j/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</em></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-8</title>
    <url>/2020/04/08/2020-04-08-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>机器人的运动范围</li>
<li>用两个栈实现队列</li>
<li>从上到下打印二叉树 II</li>
</ol>
<a id="more"></a>

<h2 id="面试题13-机器人的运动范围"><a href="#面试题13-机器人的运动范围" class="headerlink" title="面试题13. 机器人的运动范围"></a>面试题13. 机器人的运动范围</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ </p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= n,m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p><strong>BFS</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy=&#123;<span class="number">0</span> ,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( k &lt; <span class="number">0</span> || ( !m &amp;&amp; !n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flag</span><span class="params">(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">1</span>))</span></span>;</span><br><span class="line">        flag[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; val = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = val.first+dx[i];</span><br><span class="line">                <span class="keyword">int</span> y = val.second+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span>&lt;=x &amp;&amp; x&lt;m &amp;&amp; <span class="number">0</span> &lt;=y &amp;&amp; y&lt;n &amp;&amp; flag[x][y] &amp;&amp; (countbit(x)+countbit(y)&lt;=k) )</span><br><span class="line">                &#123;</span><br><span class="line">                    flag[x][y]=<span class="number">0</span>;</span><br><span class="line">                    q.push(&#123;x,y&#125;);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countbit</span><span class="params">(<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=m%<span class="number">10</span>;</span><br><span class="line">            m/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题09-用两个栈实现队列"><a href="#面试题09-用两个栈实现队列" class="headerlink" title="面试题09. 用两个栈实现队列"></a>面试题09. 用两个栈实现队列</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>

<h4 id="提示：-1"><a href="#提示：-1" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= values &lt;= 10000</code></li>
<li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="1-设计两个栈，每次取数据都倒腾一下"><a href="#1-设计两个栈，每次取数据都倒腾一下" class="headerlink" title="1. 设计两个栈，每次取数据都倒腾一下"></a>1. 设计两个栈，每次取数据都倒腾一下</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mst;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nst;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        mst.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mst.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(mst.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> val = mst.top();</span><br><span class="line">            nst.push(val);</span><br><span class="line">            mst.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = mst.top();</span><br><span class="line">        mst.pop();</span><br><span class="line">        <span class="keyword">while</span>(!nst.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nst.top();</span><br><span class="line">            nst.pop();</span><br><span class="line">            mst.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p>执行用时：<strong>1532 ms</strong></p>
<p>内存消耗：<strong>110.9 MB</strong></p>
<h4 id="2-设计两个栈，出栈为空时才倒腾"><a href="#2-设计两个栈，出栈为空时才倒腾" class="headerlink" title="2. 设计两个栈，出栈为空时才倒腾"></a>2. 设计两个栈，出栈为空时才倒腾</h4><p>两个栈，一个负责入，一个负责出，取数据时先去出栈找，如果栈为空则把入栈的数据都丢到出栈里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CQueue &#123;</span><br><span class="line">    stack&lt;int&gt; ist;</span><br><span class="line">    stack&lt;int&gt; ost;</span><br><span class="line">public:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void appendTail(int value) &#123;</span><br><span class="line">        ist.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int deleteHead() &#123;</span><br><span class="line">        if(ost.empty())</span><br><span class="line">        &#123; </span><br><span class="line">            while(!ist.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                int tmp &#x3D; ist.top();</span><br><span class="line">                ist.pop();</span><br><span class="line">                ost.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ost.empty()) return -1;</span><br><span class="line">        int val &#x3D; ost.top();</span><br><span class="line">        ost.pop();</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p>执行用时 : <strong>996 ms</strong></p>
<p>内存消耗 : <strong>103.5 MB</strong></p>
<h2 id="面试题32-II-从上到下打印二叉树-II"><a href="#面试题32-II-从上到下打印二叉树-II" class="headerlink" title="面试题32 - II. 从上到下打印二叉树 II"></a>面试题32 - II. 从上到下打印二叉树 II</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<h4 id="例如"><a href="#例如" class="headerlink" title="例如:"></a>例如:</h4><p>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><p>层次遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>,nk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level = &#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* pt = q.front();</span><br><span class="line">            level.push_back(pt-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(pt-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(pt-&gt;left);</span><br><span class="line">                nk++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pt-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(pt-&gt;right);</span><br><span class="line">                nk++;</span><br><span class="line">            &#125;</span><br><span class="line">            q.pop();</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(level);</span><br><span class="line">                level = &#123;&#125;;</span><br><span class="line">                k = nk;</span><br><span class="line">                nk = <span class="number">0</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-7</title>
    <url>/2020/04/07/2020-04-07-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>旋转矩阵</li>
<li>非递增顺序的最小子序列</li>
<li>将二进制表示减到1的步骤数</li>
</ol>
<a id="more"></a>

<h2 id="面试题-01-07-旋转矩阵"><a href="#面试题-01-07-旋转矩阵" class="headerlink" title="面试题 01.07. 旋转矩阵"></a>面试题 01.07. 旋转矩阵</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="1-拷贝一个矩阵"><a href="#1-拷贝一个矩阵" class="headerlink" title="1. 拷贝一个矩阵"></a>1. 拷贝一个矩阵</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//a[i][j] = A[j][N-1-i];</span></span><br><span class="line">        <span class="comment">//A[i][j] = a[N-1-j][i]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">A</span><span class="params">(N,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                A[i][j] = matrix[N<span class="number">-1</span>-j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix = A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-原地解法"><a href="#2-原地解法" class="headerlink" title="2. 原地解法"></a>2. 原地解法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;N<span class="number">-1</span>-i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[N<span class="number">-1</span>-j][i];</span><br><span class="line">                matrix[N<span class="number">-1</span>-j][i] = matrix[N<span class="number">-1</span>-i][N<span class="number">-1</span>-j];</span><br><span class="line">                matrix[N<span class="number">-1</span>-i][N<span class="number">-1</span>-j] = matrix[j][N<span class="number">-1</span>-i];</span><br><span class="line">                matrix[j][N<span class="number">-1</span>-i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1403-非递增顺序的最小子序列"><a href="#1403-非递增顺序的最小子序列" class="headerlink" title="1403. 非递增顺序的最小子序列"></a>1403. 非递增顺序的最小子序列</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个数组 <code>nums</code>，请你从中抽取一个子序列，满足该子序列的元素之和 <strong>严格</strong> 大于未包含在该子序列中的各元素之和。</p>
<p>如果存在多个解决方案，只需返回 <strong>长度最小</strong> 的子序列。如果仍然有多个解决方案，则返回 <strong>元素之和最大</strong> 的子序列。</p>
<p>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。</p>
<p><strong>注意</strong>，题目数据保证满足所有约束条件的解决方案是 <strong>唯一</strong> 的。同时，返回的答案应当按 <strong>非递增顺序</strong> 排列。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,3,10,9,8]</span><br><span class="line">输出：[10,9] </span><br><span class="line">解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,4,7,6,7]</span><br><span class="line">输出：[7,7,6] </span><br><span class="line">解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 &#x3D; 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [6]</span><br><span class="line">输出：[6]</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>排序+再依次计算就好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minSubsequence</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums) sum+=n;</span><br><span class="line">        <span class="keyword">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">            sum2+=nums[i];</span><br><span class="line">            sum-=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum2&gt;sum)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1404-将二进制表示减到-1-的步骤数"><a href="#1404-将二进制表示减到-1-的步骤数" class="headerlink" title="1404. 将二进制表示减到 1 的步骤数"></a>1404. 将二进制表示减到 1 的步骤数</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个以二进制形式表示的数字 <code>s</code> 。请你返回按下述规则将其减少到 1 所需要的步骤数：</p>
<ul>
<li>如果当前数字为偶数，则将其除以 2 。</li>
<li>如果当前数字为奇数，则将其加上 1 。</li>
</ul>
<p>题目保证你总是可以按上述规则将测试用例变为 1 。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1101&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：&quot;1101&quot; 表示十进制数 13 。</span><br><span class="line">Step 1) 13 是奇数，加 1 得到 14 </span><br><span class="line">Step 2) 14 是偶数，除 2 得到 7</span><br><span class="line">Step 3) 7  是奇数，加 1 得到 8</span><br><span class="line">Step 4) 8  是偶数，除 2 得到 4  </span><br><span class="line">Step 5) 4  是偶数，除 2 得到 2 </span><br><span class="line">Step 6) 2  是偶数，除 2 得到 1</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;10&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：&quot;10&quot; 表示十进制数 2 。</span><br><span class="line">Step 1) 2 是偶数，除 2 得到 1</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li>
<li><code>s[0] == &#39;1&#39;</code></li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSteps</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">"1"</span>||s==<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[len<span class="number">-1</span>]==<span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">return</span> numSteps(s.substr(<span class="number">0</span>,len<span class="number">-1</span>))+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[len<span class="number">-1</span>]==<span class="string">'1'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum*=<span class="number">2</span>;</span><br><span class="line">                sum+=s[i]-<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">            s = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span>(sum)</span><br><span class="line">            &#123;</span><br><span class="line">                s+=sum%<span class="number">2</span>+<span class="string">'0'</span>;</span><br><span class="line">                sum/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> numSteps(s)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第23场双周赛</title>
    <url>/2020/04/06/2020-04-06-LeetCode-Double-Contest23/</url>
    <content><![CDATA[<p>这次参加了LeeCode双周赛，差了一分钟拿到四个pass，最后排名是585/2044；</p>
<table>
<thead>
<tr>
<th>题目列表</th>
<th>得分</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/count-largest-group/" target="_blank" rel="noopener">统计最大组的数目</a></td>
<td><strong>3</strong></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/construct-k-palindrome-strings/" target="_blank" rel="noopener">构造 K 个回文字符串</a></td>
<td>5</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/circle-and-rectangle-overlapping/" target="_blank" rel="noopener">圆和矩形是否有重叠</a></td>
<td>5</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/reducing-dishes/" target="_blank" rel="noopener">做菜顺序</a></td>
<td>6</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="1-统计最大组的数目"><a href="#1-统计最大组的数目" class="headerlink" title="1. 统计最大组的数目"></a>1. 统计最大组的数目</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数 <code>n</code> 。请你先求出从 <code>1</code> 到 <code>n</code> 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。</p>
<p>请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：4</span><br><span class="line">解释：总共有 9 个组，将 1 到 13 按数位求和后这些组分别是：</span><br><span class="line">[1,10]，[2,11]，[3,12]，[4,13]，[5]，[6]，[7]，[8]，[9]。总共有 4 个组拥有的数字并列最多。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：总共有 2 个大小为 1 的组 [1]，[2]。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 15</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 24</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countLargestGroup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Maxnum = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = BitSum(i);</span><br><span class="line">            <span class="built_in">map</span>[sum]++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[sum]&gt;Maxnum)</span><br><span class="line">            &#123;</span><br><span class="line">                Maxnum = <span class="built_in">map</span>[sum];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[sum] == Maxnum)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">BitSum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=i%<span class="number">10</span>;</span><br><span class="line">            i/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-构造K个回文字符串"><a href="#2-构造K个回文字符串" class="headerlink" title="2. 构造K个回文字符串"></a>2. 构造K个回文字符串</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>难度中等2</p>
<p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。请你用 <code>s</code> 字符串中 <strong>所有字符</strong> 构造 <code>k</code> 个非空 <strong>回文串</strong> 。</p>
<p>如果你可以用 <code>s</code> 中所有字符构造 <code>k</code> 个回文字符串，那么请你返回 <strong>True</strong> ，否则返回 <strong>False</strong> 。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;annabelle&quot;, k &#x3D; 2</span><br><span class="line">输出：true</span><br><span class="line">解释：可以用 s 中所有字符构造 2 个回文字符串。</span><br><span class="line">一些可行的构造方案包括：&quot;anna&quot; + &quot;elble&quot;，&quot;anbna&quot; + &quot;elle&quot;，&quot;anellena&quot; + &quot;b&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;, k &#x3D; 3</span><br><span class="line">输出：false</span><br><span class="line">解释：无法用 s 中所有字符构造 3 个回文串。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;true&quot;, k &#x3D; 4</span><br><span class="line">输出：true</span><br><span class="line">解释：唯一可行的方案是让 s 中每个字符单独构成一个字符串。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;yzyzyzyzyzyzyzy&quot;, k &#x3D; 2</span><br><span class="line">输出：true</span><br><span class="line">解释：你只需要将所有的 z 放在一个字符串中，所有的 y 放在另一个字符串中。那么两个字符串都是回文串。</span><br></pre></td></tr></table></figure>

<h4 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a><strong>示例 5：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;cr&quot;, k &#x3D; 7</span><br><span class="line">输出：false</span><br><span class="line">解释：我们没有足够的字符去构造 7 个回文串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>s</code> 中所有字符都是小写英文字母。</li>
<li><code>1 &lt;= k &lt;= 10^5</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator  iter;</span><br><span class="line">        <span class="keyword">for</span>(iter = <span class="built_in">map</span>.<span class="built_in">begin</span>();iter!=<span class="built_in">map</span>.<span class="built_in">end</span>();iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            i+=iter-&gt;second%<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;k&lt;&lt;len&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> i&lt;=k&amp;&amp;(len-i)&gt;=k-i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="3-圆和矩形是否有重叠"><a href="#3-圆和矩形是否有重叠" class="headerlink" title="3. 圆和矩形是否有重叠"></a>3. 圆和矩形是否有重叠</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个以 (<code>radius</code>, <code>x_center</code>, <code>y_center</code>) 表示的圆和一个与坐标轴平行的矩形 (<code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>)，其中 (<code>x1</code>, <code>y1</code>) 是矩形左下角的坐标，(<code>x2</code>, <code>y2</code>) 是右上角的坐标。</p>
<p>如果圆和矩形有重叠的部分，请你返回 True ，否则返回 False 。</p>
<p>换句话说，请你检测是否 <strong>存在</strong> 点 (xi, yi) ，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。</p>
<h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/04/sample_4_1728.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：radius &#x3D; 1, x_center &#x3D; 0, y_center &#x3D; 0, x1 &#x3D; 1, y1 &#x3D; -1, x2 &#x3D; 3, y2 &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line">解释：圆和矩形有公共点 (1,0)</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/04/sample_2_1728.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：radius &#x3D; 1, x_center &#x3D; 0, y_center &#x3D; 0, x1 &#x3D; -1, y1 &#x3D; 0, x2 &#x3D; 0, y2 &#x3D; 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/04/sample_6_1728.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：radius &#x3D; 1, x_center &#x3D; 1, y_center &#x3D; 1, x1 &#x3D; -3, y1 &#x3D; -3, x2 &#x3D; 3, y2 &#x3D; 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-2"><a href="#示例-4：-2" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：radius &#x3D; 1, x_center &#x3D; 1, y_center &#x3D; 1, x1 &#x3D; 1, y1 &#x3D; -3, x2 &#x3D; 2, y2 &#x3D; -1</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= radius &lt;= 2000</code></li>
<li><code>-10^4 &lt;= x_center, y_center, x1, y1, x2, y2 &lt;= 10^4</code></li>
<li><code>x1 &lt; x2</code></li>
<li><code>y1 &lt; y2</code></li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>1.</strong> 先计算矩形中心，边长；</p>
<p><strong>2.</strong> 把矩形中心，圆心投影到坐标轴上；</p>
<p><strong>3.</strong> 计算矩形中心与圆心在坐标轴上的距离；</p>
<p><strong>4.</strong> 判断，圆心超出矩形的距离是否小于圆的半径;</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkOverlap</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x_center, <span class="keyword">int</span> y_center, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x= <span class="number">0.5</span>*(x1+x2),y=<span class="number">0.5</span>*(y1+y2);</span><br><span class="line">        <span class="keyword">double</span> lenx = x2-x1,leny = y2-y1;</span><br><span class="line">        <span class="keyword">double</span> disx = <span class="built_in">abs</span>(x_center-x);</span><br><span class="line">        <span class="keyword">double</span> disy = <span class="built_in">abs</span>(y_center-y);</span><br><span class="line">        <span class="keyword">double</span> dis = <span class="built_in">max</span>(disx-lenx/<span class="number">2</span>,<span class="number">0.0</span>)*<span class="built_in">max</span>(disx-lenx/<span class="number">2</span>,<span class="number">0.0</span>)+<span class="built_in">max</span>(disy-leny/<span class="number">2</span>,<span class="number">0.0</span>)*<span class="built_in">max</span>(disy-leny/<span class="number">2</span>,<span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">return</span> dis&lt;=radius*radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><p><a href="https://www.zhihu.com/question/24251545" target="_blank" rel="noopener">一个很经典的解法</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">checkOverlap</span><span class="params">(<span class="keyword">int</span> radius,<span class="keyword">int</span> x_center,<span class="keyword">int</span> y_center,<span class="keyword">int</span> XI, Int y1, <span class="keyword">int</span> X2, <span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a =<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">max</span>(X1-x_center, x_center -X2));</span><br><span class="line">	<span class="keyword">int</span> b= <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">max</span>(y1-y_center, y_center -y2));</span><br><span class="line">	<span class="keyword">return</span> a*a+b*b&lt;=radius*radius;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="4-做菜顺序"><a href="#4-做菜顺序" class="headerlink" title="4. 做菜顺序"></a>4. 做菜顺序</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个厨师收集了他 <code>n</code> 道菜的满意程度 <code>satisfaction</code> ，这个厨师做出每道菜的时间都是 1 单位时间。</p>
<p>一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是 <code>time[i]</code>*<code>satisfaction[i]</code> 。</p>
<p>请你返回做完所有菜 「喜爱时间」总和的最大值为多少。</p>
<p>你可以按 <strong>任意</strong> 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。</p>
<h4 id="示例-1：-3"><a href="#示例-1：-3" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：satisfaction &#x3D; [-1,-8,0,5,-9]</span><br><span class="line">输出：14</span><br><span class="line">解释：去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1*1 + 0*2 + 5*3 &#x3D; 14) 。每道菜都需要花费 1 单位时间完成。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-3"><a href="#示例-2：-3" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：satisfaction &#x3D; [4,3,2]</span><br><span class="line">输出：20</span><br><span class="line">解释：按照原来顺序相反的时间做菜 (2*1 + 3*2 + 4*3 &#x3D; 20)</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-3"><a href="#示例-3：-3" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：satisfaction &#x3D; [-1,-4,-5]</span><br><span class="line">输出：0</span><br><span class="line">解释：大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-3"><a href="#示例-4：-3" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：satisfaction &#x3D; [-2,5,-1,0,3,-3]</span><br><span class="line">输出：35</span><br></pre></td></tr></table></figure>

<h4 id="提示：-1"><a href="#提示：-1" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>n == satisfaction.length</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>-10^3 &lt;= satisfaction[i] &lt;= 10^3</code></li>
</ul>
<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>首先对满意度排序，满意度越大的菜方法放到后边越好</li>
<li>首先把满意度为正的菜的序号拿出来；</li>
<li>然后逐步放进满意度为负的菜；一直到总体满意度下降为止；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfaction</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; satisfaction)</span> </span>&#123;</span><br><span class="line">        sort(satisfaction.<span class="built_in">begin</span>(),satisfaction.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> maxT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;satisfaction.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(satisfaction[i]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = pos;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = Compute(satisfaction,j);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;temp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;maxT)</span><br><span class="line">                maxT = temp;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> maxT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Compute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; satisfaction,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos;i&lt;satisfaction.<span class="built_in">size</span>();i++)</span><br><span class="line">            sum += satisfaction[i]* (++c);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM 岗位求职与简历书写</title>
    <url>/2020/04/04/2020-04-04-SLAM-CV/</url>
    <content><![CDATA[<p>本文学习自B站计算机视觉Life的<a href="https://www.bilibili.com/video/BV1mE411t7rT?from=search&seid=15622956175563291600" target="_blank" rel="noopener">如何写简历</a>。</p>
<a id="more"></a>

<h2 id="当前求职背景怎么样"><a href="#当前求职背景怎么样" class="headerlink" title="当前求职背景怎么样"></a>当前求职背景怎么样</h2><p>2019计算机直觉算法岗的求职情况为：</p>
<ol>
<li>候选人数很多，优秀者极少</li>
<li>找工作不仅需要实力，也需要运气</li>
</ol>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>贸易战影响：华为、海康、大华、商汤、旷视、依图、讯飞。</li>
<li>宏观经济下行：裁员潮商业落地困难大量其他行业转行到AI人才成本高</li>
<li>视觉算法的未来依然前途光明（智能手机、无人汽车、机器人、无人机等)。</li>
</ul>
<h2 id="简历内容怎么写"><a href="#简历内容怎么写" class="headerlink" title="简历内容怎么写"></a>简历内容怎么写</h2><h4 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h4><p>姓名、电话、邮箱（尽量用edu结尾的邮箱）、Github、博客、个人网站等</p>
<p>Github主页最好展示自己最有含金量的工作。</p>
<p>个人网站：自己、项目、论文、荣誉、生活博客</p>
<h4 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h4><p>从本科开始，包括时间、专业、成绩排名；</p>
<p>本科学校211以上就没问题了</p>
<p>相关课程：图像处理；模式识别啥的；参加过的培训；</p>
<h4 id="相关科研项目经历"><a href="#相关科研项目经历" class="headerlink" title="相关科研项目经历"></a>相关科研项目经历</h4><p>从最后学历开始，最重要的写前面。条理要清晰（背景、原理、结果）、用词要准确。</p>
<p>项目实现细节，成果（指标、论文、专利）。</p>
<p>可以放一个直观的研究成果展示，项目主页。</p>
<p>好的实习、竞赛、科研交流经历：简洁、突出结果。、行业知名公司</p>
<p>行业知名竞赛：Kitti，Kaggle，天池</p>
<h4 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h4><p>提到的方向尽量对口</p>
<p>内容：编程、奖学金、竞赛获奖、论文</p>
<p>语言得体不要夸大：精通C++，算法掌握程度</p>
<p>量化一下技能结果，比如国家励志奖学金、Kaggle比赛（3/1000）、ACM竞赛、CVPR论文（状态、几座、创新点、细节）</p>
<h4 id="什么是不需要的"><a href="#什么是不需要的" class="headerlink" title="什么是不需要的"></a>什么是不需要的</h4><ul>
<li><p>个人评价：没有区分度</p>
</li>
<li><p>社会活动经历、兴趣爱好、照片</p>
</li>
</ul>
<h2 id="其它注意事项"><a href="#其它注意事项" class="headerlink" title="其它注意事项"></a>其它注意事项</h2><ul>
<li><p>简历有很多格式格式：pdf，Word，Wps等，最好用pdf格式。</p>
</li>
<li><p>可以针对性地准备几份简历；</p>
</li>
<li><p>尽可能了解你投递的公司、岗位。（新闻，内部员工等途径）</p>
</li>
<li><p>可以根据不同公司、不同岗位调整简历。</p>
</li>
</ul>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ol>
<li>重视数学、编程；</li>
<li>传统图像处理、计算机视觉算法不可忽视；</li>
<li>挖掘底层技术原理，知其所以然；</li>
<li>注重CV领域和其它方向结合；</li>
<li>关注产品落地</li>
<li>越是站在浪潮之巅，越要保持清醒头脑</li>
</ol>
<h2 id="求职经历与心路历程"><a href="#求职经历与心路历程" class="headerlink" title="求职经历与心路历程"></a>求职经历与心路历程</h2><p>可能有SLAM岗位的公司：</p>
<p>企业：地平线、商汤、网易(3D视觉算法工程师)、百度、阿里菜鸟、海康威视、旷视、百度、大疆、大华、360、OPPO、奥比中光、臻迪、华为、图森未来、驭势科技、地平线、联想、滴滴、美团、优必选、博世、小马智行、纵目科技、步飞科技、宽凳科技爱笔科技、高仙、托斯达、瓜子二手车、速腾聚创、博智林、亿嘉和、四维图新、极智嘉、九阳、虹软（3维重建）。</p>
<p>其它：九号机器人、 Auto、银星智能、中车、徐工</p>
<p>研究所比较稳定</p>
<p>薪资：25w+</p>
<p><img src="/2020/04/04/2020-04-04-SLAM-CV/image-20200404020123103.png" alt="image-20200404020123103"></p>
<h2 id="需要准备的东西"><a href="#需要准备的东西" class="headerlink" title="需要准备的东西"></a>需要准备的东西</h2><ol>
<li>刷题（剑指offer(面试)、LeeCode（笔试）、牛客(笔试)）</li>
<li>简历</li>
<li>往届面试题 </li>
<li>项目情况压缩包及简介（VINS初始化/ORB）一定要了解VINS</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>求职</category>
      </categories>
      <tags>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-3~6</title>
    <url>/2020/04/03/2020-04-03-LeetCodeCheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<p>日打卡题目如下：</p>
<p>最近几日打卡题目如下：</p>
<ol>
<li>字符串转整数（4.3）</li>
<li>接雨水（4.4）</li>
<li>LFU缓存（4.5）</li>
<li>编辑距离（4.6）</li>
</ol>
<a id="more"></a>

<h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<ul>
<li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li>
<li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li>
<li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</li>
</ul>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</li>
<li>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。 </li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4:"></a><strong>示例 4:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure>

<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5:"></a><strong>示例 5:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>本需要测试很多的边界条件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">bit</span> =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">' '</span>&amp;&amp;<span class="built_in">bit</span>==<span class="number">0</span>&amp;&amp;!count)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">' '</span>&amp;&amp;(<span class="built_in">bit</span>||count))</span><br><span class="line">                <span class="keyword">return</span> res*flag;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((str[i]==<span class="string">'+'</span>||str[i]==<span class="string">'-'</span>)&amp;&amp;!<span class="built_in">bit</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = str[i]==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'0'</span>&lt;=str[i]&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">bit</span>++;</span><br><span class="line">                res=res*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">                res = flag == <span class="number">1</span> ? <span class="built_in">min</span>(res, (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MAX) : <span class="built_in">min</span>(res, -(<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> res*flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 <strong>感谢 Marcos</strong> 贡献此图。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>从左扫一遍，从右扫一遍，取最小值，减去原图；</p>
<p><img src="https://pic.leetcode-cn.com/53ab7a66023039ed4dce42b709b4997d2ba0089077912d39a0b31d3572a55d0b-trapping_rain_water.png" alt="trapping_rain_water.png"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!s) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="built_in">height</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lr</span><span class="params">(s,M)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            lr[i] = <span class="built_in">max</span>(M , <span class="built_in">height</span>[i]);</span><br><span class="line">            M = lr[i];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        M = <span class="built_in">height</span>[s<span class="number">-1</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rl</span><span class="params">(s,M)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s<span class="number">-1</span>; i&gt;=<span class="number">0</span> ; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            rl[i] = <span class="built_in">max</span>(M,<span class="built_in">height</span>[i]);</span><br><span class="line">            M = rl[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s; i++)</span><br><span class="line">            res+=<span class="built_in">min</span>(lr[i],rl[i])-<span class="built_in">height</span>[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="460-LFU缓存"><a href="#460-LFU缓存" class="headerlink" title="460. LFU缓存"></a><a href="https://leetcode-cn.com/problems/lfu-cache/" target="_blank" rel="noopener">460. LFU缓存</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>请你为 <a href="https://baike.baidu.com/item/缓存算法" target="_blank" rel="noopener">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。它应该支持以下操作：<code>get</code> 和 <code>put</code>。</p>
<ul>
<li><code>get(key)</code> - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。</li>
<li><code>put(key, value)</code> - 如果键不存在，请设置或插入值。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近</strong> 最少使用的键。</li>
</ul>
<p>「项的使用次数」就是自插入该项以来对其调用 <code>get</code> 和 <code>put</code> 函数的次数之和。使用次数会在对应项被移除后置为 0 。 </p>
<p><strong>进阶：</strong><br>你是否可以在 <strong>O(1)</strong> 时间复杂度内执行两项操作？ </p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LFUCache cache &#x3D; new LFUCache( 2 &#x2F;* capacity (缓存容量) *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; 去除 key 2</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到key 2)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; 返回 3</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; 去除 key 1</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到 key 1)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; 返回 3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a>思路和算法</h4><p>我们定义两个哈希表，第一个 freq_table 以频率 freq 为索引，每个索引存放一个双向链表，这个链表里存放所有使用频率为 freq 的缓存，缓存里存放三个信息，分别为键 key，值 value，以及使用频率 freq。第二个 key_table 以键值 key 为索引，每个索引存放对应缓存在 freq_table 中链表里的内存地址，这样我们就能利用两个哈希表来使得两个操作的时间复杂度均为 O(1)O(1)。同时需要记录一个当前缓存最少使用的频率 minFreq，这是为了删除操作服务的。</p>
<p>对于 get(key) 操作，我们能通过索引 key 在 key_table 中找到缓存在 freq_table 中的链表的内存地址，如果不存在直接返回 -1，否则我们能获取到对应缓存的相关信息，这样我们就能知道缓存的键值还有使用频率，直接返回 key 对应的值即可。</p>
<p>但是我们注意到 get 操作后这个缓存的使用频率加一了，所以我们需要更新缓存在哈希表 freq_table 中的位置。已知这个缓存的键 key，值 value，以及使用频率 freq，那么该缓存应该存放到 freq_table 中 freq + 1 索引下的链表中。所以我们在当前链表中 <code>O(1)</code> 删除该缓存对应的节点，根据情况更新 minFreq 值，然后将其O(1)O(1) 插入到 freq + 1 索引下的链表头完成更新。这其中的操作复杂度均为 <code>O(1)</code>。你可能会疑惑更新的时候为什么是插入到链表头，这其实是为了保证缓存在当前链表中从链表头到链表尾的插入时间是有序的，为下面的删除操作服务。</p>
<p>对于 <code>put(key, value)</code> 操作，我们先通过索引 <code>key</code>在 <code>key_table</code> 中查看是否有对应的缓存，如果有的话，其实操作等价于 <code>get(key)</code>操作，唯一的区别就是我们需要将当前的缓存里的值更新为 <code>value</code>。如果没有的话，相当于是新加入的缓存，如果缓存已经到达容量，需要先删除最近最少使用的缓存，再进行插入。</p>
<p>先考虑插入，由于是新插入的，所以缓存的使用频率一定是 1，所以我们将缓存的信息插入到 <code>freq_table</code> 中 1 索引下的列表头即可，同时更新 <code>key_table[key]</code> 的信息，以及更新 <code>minFreq = 1</code>。</p>
<p>那么剩下的就是删除操作了，由于我们实时维护了 <code>minFreq</code>，所以我们能够知道 <code>freq_table</code> 里目前最少使用频率的索引，同时因为我们保证了链表中从链表头到链表尾的插入时间是有序的，所以 <code>freq_table[minFreq]</code> 的链表中链表尾的节点即为使用频率最小且插入时间最早的节点，我们删除它同时根据情况更新 <code>minFreq</code> ，整个时间复杂度均为 <code>O(1)</code>。</p>
<p>源代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存的节点信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, val, freq;</span><br><span class="line">    Node(<span class="keyword">int</span> _key,<span class="keyword">int</span> _val,<span class="keyword">int</span> _freq): key(_key), val(_val), freq(_freq)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> minfreq, capacity;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;Node&gt;::iterator&gt; key_table;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;Node&gt;&gt; freq_table;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> _capacity) &#123;</span><br><span class="line">        minfreq = <span class="number">0</span>;</span><br><span class="line">        capacity = _capacity;</span><br><span class="line">        key_table.<span class="built_in">clear</span>();</span><br><span class="line">        freq_table.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">list</span>&lt;Node&gt;::iterator node = it -&gt; second;</span><br><span class="line">        <span class="keyword">int</span> val = node -&gt; val, freq = node -&gt; freq;</span><br><span class="line">        freq_table[freq].erase(node);</span><br><span class="line">        <span class="comment">// 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq</span></span><br><span class="line">        <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            freq_table.erase(freq);</span><br><span class="line">            <span class="keyword">if</span> (minfreq == freq) minfreq += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入到 freq + 1 中</span></span><br><span class="line">        freq_table[freq + <span class="number">1</span>].push_front(Node(key, val, freq + <span class="number">1</span>));</span><br><span class="line">        key_table[key] = freq_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 缓存已满，需要进行删除操作</span></span><br><span class="line">            <span class="keyword">if</span> (key_table.<span class="built_in">size</span>() == capacity) &#123;</span><br><span class="line">                <span class="comment">// 通过 minFreq 拿到 freq_table[minFreq] 链表的末尾节点</span></span><br><span class="line">                <span class="keyword">auto</span> it2 = freq_table[minfreq].back();</span><br><span class="line">                key_table.erase(it2.key);</span><br><span class="line">                freq_table[minfreq].pop_back();</span><br><span class="line">                <span class="keyword">if</span> (freq_table[minfreq].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    freq_table.erase(minfreq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            freq_table[<span class="number">1</span>].push_front(Node(key, value, <span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">            minfreq = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 与 get 操作基本一致，除了需要更新缓存的值</span></span><br><span class="line">            <span class="built_in">list</span>&lt;Node&gt;::iterator node = it -&gt; second;</span><br><span class="line">            <span class="keyword">int</span> freq = node -&gt; freq;</span><br><span class="line">            freq_table[freq].erase(node);</span><br><span class="line">            <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                freq_table.erase(freq);</span><br><span class="line">                <span class="keyword">if</span> (minfreq == freq) minfreq += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            freq_table[freq + <span class="number">1</span>].push_front(Node(key, value, freq + <span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个单词 <em>word1</em> 和 <em>word2*，请你计算出将 *word1</em> 转换成 <em>word2</em> 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们可以对任意一个单词进行三种操作：</p>
<ul>
<li>插入一个字符；</li>
<li>删除一个字符；</li>
<li>替换一个字符。</li>
</ul>
<p>题目给定了两个单词，设为 A 和 B，这样我们就能够六种操作方法。</p>
<p>但我们可以发现，如果我们有单词 A 和单词 B：</p>
<ul>
<li>对单词 A 删除一个字符和对单词 B 插入一个字符是等价的。例如当单词 A 为 doge，单词 B 为 dog 时，我们既可以删除单词 A 的最后一个字符 e，得到相同的 dog，也可以在单词 B 末尾添加一个字符 e，得到相同的 doge；</li>
<li>同理，对单词 B 删除一个字符和对单词 A 插入一个字符也是等价的；</li>
<li>对单词 A 替换一个字符和对单词 B 替换一个字符是等价的。例如当单词 A 为 bat，单词 B 为 cat 时，我们修改单词 A 的第一个字母 b -&gt; c，和修改单词 B 的第一个字母 c -&gt; b 是等价的。</li>
</ul>
<p>这样以来，本质不同的操作实际上只有三种：</p>
<ul>
<li><p>在单词 A 中插入一个字符；</p>
</li>
<li><p>在单词 B 中插入一个字符；</p>
</li>
<li><p>修改单词 A 的一个字符。</p>
</li>
</ul>
<p>这样以来，我们就可以把原问题转化为规模较小的子问题。我们用 A = horse，B = ros 作为例子，来看一看是如何把这个问题转化为规模较小的若干子问题的。</p>
<ul>
<li>在单词 A 中插入一个字符：如果我们知道 horse 到 ro 的编辑距离为 a，那么显然 horse 到 ros 的编辑距离不会超过 a + 1。这是因为我们可以在 a 次操作后将 horse 和 ro 变为相同的字符串，只需要额外的 1 次操作，在单词 A 的末尾添加字符 s，就能在 a + 1 次操作后将 horse 和 ro 变为相同的字符串；</li>
<li>在单词 B 中插入一个字符：如果我们知道 hors 到 ros 的编辑距离为 b，那么显然 horse 到 ros 的编辑距离不会超过 b + 1，原因同上；</li>
<li>修改单词 A 的一个字符：如果我们知道 hors 到 ro 的编辑距离为 c，那么显然 horse 到 ros 的编辑距离不会超过 c + 1，原因同上。</li>
</ul>
<p>那么从 horse 变成 ros 的编辑距离应该为 min(a + 1, b + 1, c + 1)。</p>
<p>注意：为什么我们总是在单词 A 和 B 的末尾插入或者修改字符，能不能在其它的地方进行操作呢？答案是可以的，但是我们知道，操作的顺序是不影响最终的结果的。例如对于单词 cat，我们希望在 c 和 a 之间添加字符 d 并且将字符 t 修改为字符 b，那么这两个操作无论为什么顺序，都会得到最终的结果 cdab。</p>
<p>你可能觉得 horse 到 ro 这个问题也很难解决。但是没关系，我们可以继续用上面的方法拆分这个问题，对于这个问题拆分出来的所有子问题，我们也可以继续拆分，直到：</p>
<p>字符串 A 为空，如从 转换到 ro，显然编辑距离为字符串 B 的长度，这里是 2；</p>
<p>字符串 B 为空，如从 horse 转换到 ，显然编辑距离为字符串 A 的长度，这里是 5。</p>
<p>因此，我们就可以使用动态规划来解决这个问题了。我们用 D[i][j] 表示 A 的前 i 个字母和 B 的前 j 个字母之间的编辑距离。</p>
<p>如上所述，当我们获得 D[i][j-1]，D[i-1][j] 和 D[i-1][j-1] 的值之后就可以计算出 D[i][j]。</p>
<p>D[i][j-1] 为 A 的前 i 个字符和 B 的前 j - 1 个字符编辑距离的子问题。即对于 B 的第 j 个字符，我们在 A 的末尾添加了一个相同的字符，那么 D[i][j] 最小可以为 D[i][j-1] + 1；</p>
<p>D[i-1][j] 为 A 的前 i - 1 个字符和 B 的前 j 个字符编辑距离的子问题。即对于 A 的第 i 个字符，我们在 B 的末尾添加了一个相同的字符，那么 D[i][j] 最小可以为 D[i-1][j] + 1；</p>
<p>D[i-1][j-1] 为 A 前 i - 1 个字符和 B 的前 j - 1 个字符编辑距离的子问题。即对于 B 的第 j 个字符，我们修改 A 的第 i 个字符使它们相同，那么 D[i][j] 最小可以为 D[i-1][j-1] + 1。特别地，如果 A 的第 i 个字符和 B 的第 j 个字符原本就相同，那么我们实际上不需要进行修改操作。在这种情况下，D[i][j] 最小可以为 D[i-1][j-1]。</p>
<p>那么我们可以写出如下的状态转移方程：</p>
<p>若 A 和 B 的最后一个字母相同：<br>$$<br>\begin{aligned} D[i][j] &amp;= \min(D[i][j - 1] + 1, D[i - 1][j]+1, D[i - 1][j - 1])\ &amp;= 1 + \min(D[i][j - 1], D[i - 1][j], D[i - 1][j - 1] - 1) \end{aligned}<br>$$<br>若 A 和 B 的最后一个字母不同：<br>$$<br>D[i][j] = 1 + \min(D[i][j - 1], D[i - 1][j], D[i - 1][j - 1])<br>$$<br>所以每一步结果都将基于上一步的计算结果，示意如下：</p>
<p><img src="https://pic.leetcode-cn.com/3241789f2634b72b917d769a92d4f6e38c341833247391fb1b45eb0441fe5cd2-72_fig2.PNG" alt="72_fig2.PNG"></p>
<p>对于边界情况，一个空串和一个非空串的编辑距离为 <code>D[i][0] = i</code> 和 <code>D[0][j] = j</code>，<code>D[i][0]</code> 相当于对 word1 执行 i 次删除操作，<code>D[0][j]</code> 相当于对 word1执行 j 次插入操作。</p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.length();</span><br><span class="line">        <span class="keyword">int</span> m = word2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有一个字符串为空串</span></span><br><span class="line">        <span class="keyword">if</span> (n * m == <span class="number">0</span>) <span class="keyword">return</span> n + m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DP 数组</span></span><br><span class="line">        <span class="keyword">int</span> D[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界状态初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            D[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            D[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> left = D[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> down = D[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> left_down = D[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]) left_down += <span class="number">1</span>;</span><br><span class="line">                D[i][j] = <span class="built_in">min</span>(left, <span class="built_in">min</span>(down, left_down));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> D[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛182</title>
    <url>/2020/04/02/2020-03-28-LeetCode-Contest182/</url>
    <content><![CDATA[<p>LeeCode第182场周赛题目如下:</p>
<ol>
<li>找出数组中的幸运数</li>
<li>统计作战单位数</li>
<li>设计地铁系统t</li>
<li>找到所有好字符串</li>
</ol>
<a id="more"></a>

<h2 id="1394-找出数组中的幸运数"><a href="#1394-找出数组中的幸运数" class="headerlink" title="1394. 找出数组中的幸运数"></a>1394. 找出数组中的幸运数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。</p>
<p>给你一个整数数组 <code>arr</code>，请你从中找出并返回一个幸运数。</p>
<ul>
<li>如果数组中存在多个幸运数，只需返回 <strong>最大</strong> 的那个。</li>
<li>如果数组中不含幸运数，则返回 <strong>-1</strong> 。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,2,3,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,2,3,3,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a><strong>示例 3</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,2,2,3,3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：数组中不存在幸运数。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a><strong>示例 4</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [5]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a><strong>示例 5</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 500</code></li>
<li><code>1 &lt;= arr[i] &lt;= 500</code></li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLucky</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:arr)</span><br><span class="line">            <span class="built_in">set</span>[n]++;</span><br><span class="line">        <span class="keyword">int</span> maxnum = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">        <span class="keyword">for</span>(iter = <span class="built_in">set</span>.<span class="built_in">begin</span>();iter!=<span class="built_in">set</span>.<span class="built_in">end</span>();iter++)</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;first==iter-&gt;second)</span><br><span class="line">                maxnum = <span class="built_in">max</span>(maxnum,iter-&gt;first);</span><br><span class="line">        <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1395-统计作战单位数"><a href="#1395-统计作战单位数" class="headerlink" title="1395. 统计作战单位数"></a>1395. 统计作战单位数</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p> <code>n</code> 名士兵站成一排。每个士兵都有一个 <strong>独一无二</strong> 的评分 <code>rating</code> 。</p>
<p>每 <strong>3</strong> 个士兵可以组成一个作战单位，分组规则如下：</p>
<ul>
<li>从队伍中选出下标分别为 <code>i</code>、<code>j</code>、<code>k</code> 的 3 名士兵，他们的评分分别为 <code>rating[i]</code>、<code>rating[j]</code>、<code>rating[k]</code></li>
<li>作战单位需满足： <code>rating[i] &lt; rating[j] &lt; rating[k]</code> 或者 <code>rating[i] &gt; rating[j] &gt; rating[k]</code> ，其中 <code>0 &lt;= i &lt; j &lt; k &lt; n</code></li>
</ul>
<p>请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。</p>
<p><strong>示例 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rating &#x3D; [2,5,3,4,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rating &#x3D; [2,1,3]</span><br><span class="line">输出：0</span><br><span class="line">解释：根据题目条件，我们无法组建作战单位。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rating &#x3D; [1,2,3,4]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTeams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rating)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rating.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>;<span class="comment">// 顺序增大的个数</span></span><br><span class="line">        <span class="keyword">int</span> num2=<span class="number">0</span>;<span class="comment">// 顺序减小的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;n;k++)</span><br><span class="line">                    <span class="keyword">if</span>(rating[i]&lt;rating[j]&amp;&amp;rating[j]&lt;rating[k])</span><br><span class="line">                        num1++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(rating[i]&gt;rating[j]&amp;&amp;rating[j]&gt;rating[k])</span><br><span class="line">                        num2++;</span><br><span class="line">        <span class="keyword">return</span> num1+num2;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1396-设计地铁系统"><a href="#1396-设计地铁系统" class="headerlink" title="1396. 设计地铁系统"></a>1396. 设计地铁系统</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>请你实现一个类 <code>UndergroundSystem</code> ，它支持以下 3 种方法：</p>
<p>1.<code>checkIn(int id, string stationName, int t)</code></p>
<ul>
<li>编号为 <code>id</code> 的乘客在 <code>t</code> 时刻进入地铁站 <code>stationName</code> 。</li>
<li>一个乘客在同一时间只能在一个地铁站进入或者离开。</li>
</ul>
<p>2.<code>checkOut(int id, string stationName, int t)</code></p>
<ul>
<li>编号为 <code>id</code> 的乘客在 <code>t</code> 时刻离开地铁站 <code>stationName</code> 。</li>
</ul>
<p>3.<code>getAverageTime(string startStation, string endStation)</code> </p>
<ul>
<li>返回从地铁站 <code>startStation</code> 到地铁站 <code>endStation</code> 的平均花费时间。</li>
<li>平均时间计算的行程包括当前为止所有从 <code>startStation</code> <strong>直接到达</strong> <code>endStation</code> 的行程。</li>
<li>调用 <code>getAverageTime</code> 时，询问的路线至少包含一趟行程。</li>
</ul>
<p>你可以假设所有对 <code>checkIn</code> 和 <code>checkOut</code> 的调用都是符合逻辑的。也就是说，如果一个顾客在 <strong>t1</strong> 时刻到达某个地铁站，那么他离开的时间 <strong>t2</strong> 一定满足 <strong>t2 &gt; t1</strong> 。所有的事件都按时间顺序给出。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;UndergroundSystem&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;,&quot;getAverageTime&quot;,&quot;checkIn&quot;,&quot;getAverageTime&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;]</span><br><span class="line">[[],[45,&quot;Leyton&quot;,3],[32,&quot;Paradise&quot;,8],[27,&quot;Leyton&quot;,10],[45,&quot;Waterloo&quot;,15],[27,&quot;Waterloo&quot;,20],[32,&quot;Cambridge&quot;,22],[&quot;Paradise&quot;,&quot;Cambridge&quot;],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Leyton&quot;,24],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Waterloo&quot;,38],[&quot;Leyton&quot;,&quot;Waterloo&quot;]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,null,null,null,14.0,11.0,null,11.0,null,12.0]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">UndergroundSystem undergroundSystem &#x3D; new UndergroundSystem();</span><br><span class="line">undergroundSystem.checkIn(45, &quot;Leyton&quot;, 3);</span><br><span class="line">undergroundSystem.checkIn(32, &quot;Paradise&quot;, 8);</span><br><span class="line">undergroundSystem.checkIn(27, &quot;Leyton&quot;, 10);</span><br><span class="line">undergroundSystem.checkOut(45, &quot;Waterloo&quot;, 15);</span><br><span class="line">undergroundSystem.checkOut(27, &quot;Waterloo&quot;, 20);</span><br><span class="line">undergroundSystem.checkOut(32, &quot;Cambridge&quot;, 22);</span><br><span class="line">undergroundSystem.getAverageTime(&quot;Paradise&quot;, &quot;Cambridge&quot;);       &#x2F;&#x2F; 返回 14.0。从 &quot;Paradise&quot;（时刻 8）到 &quot;Cambridge&quot;(时刻 22)的行程只有一趟</span><br><span class="line">undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);          &#x2F;&#x2F; 返回 11.0。总共有 2 躺从 &quot;Leyton&quot; 到 &quot;Waterloo&quot; 的行程，编号为 id&#x3D;45 的乘客出发于 time&#x3D;3 到达于 time&#x3D;15，编号为 id&#x3D;27 的乘客于 time&#x3D;10 出发于 time&#x3D;20 到达。所以平均时间为 ( (15-3) + (20-10) ) &#x2F; 2 &#x3D; 11.0</span><br><span class="line">undergroundSystem.checkIn(10, &quot;Leyton&quot;, 24);</span><br><span class="line">undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);          &#x2F;&#x2F; 返回 11.0</span><br><span class="line">undergroundSystem.checkOut(10, &quot;Waterloo&quot;, 38);</span><br><span class="line">undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);          &#x2F;&#x2F; 返回 12.0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>总共最多有 <code>20000</code> 次操作。</li>
<li><code>1 &lt;= id, t &lt;= 10^6</code></li>
<li>所有的字符串包含大写字母，小写字母和数字。</li>
<li><code>1 &lt;= stationName.length &lt;= 10</code></li>
<li>与标准答案误差在 <code>10^-5</code> 以内的结果都视为正确结果。</li>
</ul>
<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用 checkRecord 根据 id 来保存上车 车站名字 和 时间<br>在下车车站，把乘车时间计算出来，按两个 车站名字 保存起来，同时还要保存 乘车次数<br>取得平均时间时，只需要查询两个车站，得到总时间，和总次数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergroundSystem</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; checkRecord;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;&gt; count;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UndergroundSystem() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkIn</span><span class="params">(<span class="keyword">int</span> id, <span class="built_in">string</span> stationName, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        checkRecord[id] = &#123; stationName, t &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkOut</span><span class="params">(<span class="keyword">int</span> id, <span class="built_in">string</span> stationName, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> name = getStationName(checkRecord[id].first, stationName);</span><br><span class="line">        t -= checkRecord[id].second;</span><br><span class="line">        count[name].first += (<span class="keyword">double</span>)t;</span><br><span class="line">        count[name].second += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAverageTime</span><span class="params">(<span class="built_in">string</span> startStation, <span class="built_in">string</span> endStation)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> name = getStationName(startStation, endStation);</span><br><span class="line">        <span class="keyword">double</span> ans = count[name].first / (<span class="keyword">double</span>)count[name].second;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getStationName</span><span class="params">(<span class="built_in">string</span> startStation, <span class="built_in">string</span> endStation)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startStation + endStation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="1397-找到所有好字符串"><a href="#1397-找到所有好字符串" class="headerlink" title="1397. 找到所有好字符串"></a>1397. 找到所有好字符串</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个长度为 <code>n</code> 的字符串 <code>s1</code> 和 <code>s2</code> ，以及一个字符串 <code>evil</code> 。请你返回 <strong>好字符串</strong> 的数目。</p>
<p><strong>好字符串</strong> 的定义为：它的长度为 <code>n</code> ，字典序大于等于 <code>s1</code> ，字典序小于等于 <code>s2</code> ，且不包含 <code>evil</code> 为子字符串。</p>
<p>由于答案可能很大，请你返回答案对 10^9 + 7 取余的结果。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, s1 &#x3D; &quot;aa&quot;, s2 &#x3D; &quot;da&quot;, evil &#x3D; &quot;b&quot;</span><br><span class="line">输出：51 </span><br><span class="line">解释：总共有 25 个以 &#39;a&#39; 开头的好字符串：&quot;aa&quot;，&quot;ac&quot;，&quot;ad&quot;，...，&quot;az&quot;。还有 25 个以 &#39;c&#39; 开头的好字符串：&quot;ca&quot;，&quot;cc&quot;，&quot;cd&quot;，...，&quot;cz&quot;。最后，还有一个以 &#39;d&#39; 开头的好字符串：&quot;da&quot;。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 8, s1 &#x3D; &quot;leetcode&quot;, s2 &#x3D; &quot;leetgoes&quot;, evil &#x3D; &quot;leet&quot;</span><br><span class="line">输出：0 </span><br><span class="line">解释：所有字典序大于等于 s1 且小于等于 s2 的字符串都以 evil 字符串 &quot;leet&quot; 开头。所以没有好字符串。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a><strong>示例 3</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, s1 &#x3D; &quot;gx&quot;, s2 &#x3D; &quot;gz&quot;, evil &#x3D; &quot;x&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>s1.length == n</code></li>
<li><code>s2.length == n</code></li>
<li><code>s1 &lt;= s2</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>1 &lt;= evil.length &lt;= 50</code></li>
<li>所有字符串都只包含小写英文字母。</li>
</ul>
<h3 id="其它解法-1"><a href="#其它解法-1" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="思路数位DP-前缀数组"><a href="#思路数位DP-前缀数组" class="headerlink" title="思路数位DP + 前缀数组"></a>思路数位DP + 前缀数组</h4><p>看到题目，很容易能够想到是动态规划问题来解决，接下来就是定义状态方程，该如何定义？</p>
<p>从题目中我们知道判断某一位的状态取决于前面的字符匹配情况，有三种：</p>
<p>s1为下限，s2为上限<br>s1为下限，s2无限制<br>s1无限制，s2为上限<br>s1和s2均无限制，即可以选任意小写字母<br>这种思想很容易联想到数位DP(数位DP不熟悉的可以查阅下相关资料)，那么在数位DP的基础上我们还要增加一个维度来解决不包含子串问题：</p>
<p>那么增加的维度表示前面已经匹配的evil的长度, 想计算加入当前字符后最长匹配的evil长度是需要使用KMP算法的前缀数组来解决的，如果不是很熟悉这个算法参考下上周周赛的最后一题最长快乐前缀。</p>
<p>因此一个维度表示遍历的索引，一个维度表示当前可选字符的限制，一个维度表示已经匹配的evil的长度，因此三维的状态就可以定义出来了，具体的可以看代码的注释。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findGoodStrings</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">string</span> a, <span class="built_in">string</span> b, <span class="built_in">string</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> en = e.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fa</span><span class="params">(en+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = fa[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i&lt;en; i++, j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; e[j]!=e[i])j=fa[j];</span><br><span class="line">            fa[i+<span class="number">1</span>]=j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> plen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.substr(<span class="number">0</span>, i) == b.substr(<span class="number">0</span>, i))plen = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>, flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;plen; i++, now++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; a[i]!=e[now])&#123;</span><br><span class="line">                now=fa[now];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now==en<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(plen == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sc</span><span class="params">(en, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a[plen]-<span class="string">'a'</span>+<span class="number">1</span>; i&lt;b[plen]-<span class="string">'a'</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> noww = now;</span><br><span class="line">            <span class="keyword">while</span>(noww!=<span class="number">-1</span> &amp;&amp; i+<span class="string">'a'</span>!=e[noww])&#123;</span><br><span class="line">                noww=fa[noww];</span><br><span class="line">            &#125;noww++;</span><br><span class="line">            <span class="keyword">if</span>(noww&lt;en)sc[noww]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nowa = now;</span><br><span class="line">        <span class="keyword">while</span>(nowa!=<span class="number">-1</span> &amp;&amp; a[plen]!=e[nowa])&#123;</span><br><span class="line">            nowa=fa[nowa];</span><br><span class="line">        &#125;nowa++;</span><br><span class="line">        <span class="keyword">int</span> nowb = now;</span><br><span class="line">        <span class="keyword">while</span>(nowb!=<span class="number">-1</span> &amp;&amp; b[plen]!=e[nowb])&#123;</span><br><span class="line">            nowb=fa[nowb];</span><br><span class="line">        &#125;nowb++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=plen+<span class="number">1</span>; p&lt;n; p++)&#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(en, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(nowa&lt;en)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=a[p]-<span class="string">'a'</span>+<span class="number">1</span>; i&lt;<span class="number">26</span>; i++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> noww = nowa;</span><br><span class="line">                    <span class="keyword">while</span>(noww!=<span class="number">-1</span> &amp;&amp; i+<span class="string">'a'</span>!=e[noww])&#123;</span><br><span class="line">                        noww=fa[noww];</span><br><span class="line">                    &#125;noww++;</span><br><span class="line">                    <span class="keyword">if</span>(noww&lt;en)d[noww]++;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(nowb&lt;en)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;b[p]-<span class="string">'a'</span>; i++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> noww = nowb;</span><br><span class="line">                    <span class="keyword">while</span>(noww!=<span class="number">-1</span> &amp;&amp; i+<span class="string">'a'</span>!=e[noww])&#123;</span><br><span class="line">                        noww=fa[noww];</span><br><span class="line">                    &#125;noww++;</span><br><span class="line">                    <span class="keyword">if</span>(noww&lt;en)d[noww]++;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;<span class="number">26</span>; c++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> nn=<span class="number">0</span>; nn&lt;en; nn++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> now = nn;</span><br><span class="line">                    <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; c+<span class="string">'a'</span>!=e[now])&#123;</span><br><span class="line">                        now=fa[now];</span><br><span class="line">                    &#125;now++;</span><br><span class="line">                    <span class="keyword">if</span>(now&lt;en)(d[now]+=sc[nn])%=mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sc=d;</span><br><span class="line">            <span class="keyword">if</span>(nowa&lt;en)&#123;</span><br><span class="line">                <span class="keyword">while</span>(nowa!=<span class="number">-1</span> &amp;&amp; a[p]!=e[nowa])&#123;</span><br><span class="line">                    nowa=fa[nowa];</span><br><span class="line">                &#125;nowa++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nowb&lt;en)&#123;</span><br><span class="line">                <span class="keyword">while</span>(nowb!=<span class="number">-1</span> &amp;&amp; b[p]!=e[nowb])&#123;</span><br><span class="line">                    nowb=fa[nowb];</span><br><span class="line">                &#125;nowb++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;en; j++)&#123;</span><br><span class="line">            ans=(ans+sc[j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=(nowa&lt;en)+(nowb&lt;en);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>周赛</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-2</title>
    <url>/2020/04/02/2020-04-02-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下:</p>
<ol>
<li>289.生命游戏</li>
<li>链表中倒数第k个节点</li>
<li>从尾到头打印链表</li>
</ol>
<a id="more"></a>

<h2 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289. 生命游戏"></a>289. 生命游戏</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>根据 <a href="https://baike.baidu.com/item/生命游戏/2926434?fr=aladdin" target="_blank" rel="noopener">百度百科</a> ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p>
<p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<ol>
<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li>
<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li>
<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li>
<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li>
</ol>
<p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,1,1],</span><br><span class="line">  [0,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong></p>
<ul>
<li>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</li>
<li>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>用哈希表保存点与状态，然后按照哈希表保存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cood</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x,y,num;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        row = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!row) <span class="keyword">return</span>;</span><br><span class="line">        col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">queue</span>&lt;cood&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> num = countalive(board,i,j);</span><br><span class="line">                q.push(&#123;i,j,num&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            cood c = q.front();</span><br><span class="line">            <span class="keyword">if</span>(board[c.x][c.y]&amp;&amp;c.num&lt;<span class="number">2</span>)</span><br><span class="line">                board[c.x][c.y]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[c.x][c.y]&amp;&amp;c.num&lt;=<span class="number">3</span>)</span><br><span class="line">                board[c.x][c.y]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[c.x][c.y]&amp;&amp;c.num&gt;<span class="number">3</span>)</span><br><span class="line">                board[c.x][c.y]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!board[c.x][c.y]&amp;&amp;c.num==<span class="number">3</span>)</span><br><span class="line">                board[c.x][c.y]=<span class="number">1</span>;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countalive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        res += i<span class="number">-1</span> &gt;=<span class="number">0</span>  ? board[i<span class="number">-1</span>][j]:<span class="number">0</span>;</span><br><span class="line">        res += i+<span class="number">1</span> &lt;row ? board[i+<span class="number">1</span>][j]:<span class="number">0</span>;</span><br><span class="line">        res += j<span class="number">-1</span> &gt;=<span class="number">0</span>  ? board[i][j<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">        res += j+<span class="number">1</span> &lt;col ? board[i][j+<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res += i<span class="number">-1</span> &gt;= <span class="number">0</span>  &amp;&amp;  j<span class="number">-1</span> &gt;= <span class="number">0</span>  ? board[i<span class="number">-1</span>][j<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">        res += i+<span class="number">1</span> &lt; row &amp;&amp;  j<span class="number">-1</span> &gt;= <span class="number">0</span>  ? board[i+<span class="number">1</span>][j<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">        res += i<span class="number">-1</span> &gt;= <span class="number">0</span>  &amp;&amp;  j+<span class="number">1</span> &lt; col ? board[i<span class="number">-1</span>][j+<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res += i+<span class="number">1</span> &lt; row &amp;&amp;  j+<span class="number">1</span> &lt; col ? board[i+<span class="number">1</span>][j+<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗 :7.1 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
<table>
<thead>
<tr>
<th align="left">提交时间</th>
<th align="left">提交结果</th>
<th align="left">执行用时</th>
<th align="left">内存消耗</th>
<th align="left">语言</th>
</tr>
</thead>
<tbody><tr>
<td align="left">几秒前</td>
<td align="left">通过</td>
<td align="left">0 ms</td>
<td align="left">7.1 MB</td>
<td align="left">Cpp</td>
</tr>
<tr>
<td align="left">几秒前</td>
<td align="left">通过</td>
<td align="left">0 ms</td>
<td align="left">7.3 MB</td>
<td align="left">Cp</td>
</tr>
</tbody></table>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：复制原数组进行模拟"><a href="#方法一：复制原数组进行模拟" class="headerlink" title="方法一：复制原数组进行模拟"></a>方法一：复制原数组进行模拟</h4><ul>
<li>复制一份原始数组；</li>
<li>根据复制数组中邻居细胞的状态来更新 <code>board</code> 中的细胞状态。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> neighbors[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建复制数组 copyBoard</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;copyBoard(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从原数组复制一份到 copyBoard 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                copyBoard[row][col] = board[row][col];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历面板每一个格子里的细胞</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于每一个细胞统计其八个相邻位置里的活细胞数量</span></span><br><span class="line">                <span class="keyword">int</span> liveNeighbors = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!(neighbors[i] == <span class="number">0</span> &amp;&amp; neighbors[j] == <span class="number">0</span>)) &#123;</span><br><span class="line">                            <span class="keyword">int</span> r = (row + neighbors[i]);</span><br><span class="line">                            <span class="keyword">int</span> c = (col + neighbors[j]);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 查看相邻的细胞是否是活细胞</span></span><br><span class="line">                            <span class="keyword">if</span> ((r &lt; rows &amp;&amp; r &gt;= <span class="number">0</span>) &amp;&amp; (c &lt; cols &amp;&amp; c &gt;= <span class="number">0</span>) &amp;&amp; (copyBoard[r][c] == <span class="number">1</span>)) &#123;</span><br><span class="line">                                liveNeighbors += <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 规则 1 或规则 3      </span></span><br><span class="line">                <span class="keyword">if</span> ((copyBoard[row][col] == <span class="number">1</span>) &amp;&amp; (liveNeighbors &lt; <span class="number">2</span> || liveNeighbors &gt; <span class="number">3</span>)) &#123;</span><br><span class="line">                    board[row][col] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 规则 4</span></span><br><span class="line">                <span class="keyword">if</span> (copyBoard[row][col] == <span class="number">0</span> &amp;&amp; liveNeighbors == <span class="number">3</span>) &#123;</span><br><span class="line">                    board[row][col] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="方法二：使用额外的状态"><a href="#方法二：使用额外的状态" class="headerlink" title="方法二：使用额外的状态"></a>方法二：使用额外的状态</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>方法一中 <code>O(mn)</code>的空间复杂度在数组很大的时候内存消耗是非常昂贵的。题目中每个细胞只有两种状态 <code>live(1)</code> 或 <code>dead(0)</code>，但我们可以拓展一些复合状态使其包含之前的状态。举个例子，如果细胞之前的状态是 0，但是在更新之后变成了 1，我们就可以给它定义一个复合状态 2。这样我们看到 2，既能知道目前这个细胞是活的，还能知道它之前是死的。</p>
<h5 id="遍历-board-中的细胞。"><a href="#遍历-board-中的细胞。" class="headerlink" title="遍历 board 中的细胞。"></a>遍历 board 中的细胞。</h5><p>根据数组的细胞状态计算新一轮的细胞状态，这里会用到能同时代表过去状态和现在状态的复合状态。</p>
<p>具体的计算规则如下所示：</p>
<ul>
<li><p>规则 1：如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡。这时候，将细胞值改为 -1，代表这个细胞过去是活的现在死了；</p>
</li>
<li><p>规则 2：如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活。这时候不改变细胞的值，仍为 1；</p>
</li>
<li><p>规则 3：如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡。这时候，将细胞的值改为 -1，代表这个细胞过去是活的现在死了。可以看到，因为规则 1 和规则 3 下细胞的起始终止状态是一致的，因此它们的复合状态也一致；</p>
</li>
<li><p>规则 4：如果死细胞周围正好有三个活细胞，则该位置死细胞复活。这时候，将细胞的值改为 2，代表这个细胞过去是死的现在活了。</p>
</li>
</ul>
<p>根据新的规则更新数组；</p>
<p>现在复合状态隐含了过去细胞的状态，所以我们可以在不复制数组的情况下完成原地更新；</p>
<p>对于最终的输出，需要将 board 转成 0，1 的形式。因此这时候需要再遍历一次数组，将复合状态为 2 的细胞的值改为 1，复合状态为 -1 的细胞的值改为 0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> neighbors[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历面板每一个格子里的细胞</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于每一个细胞统计其八个相邻位置里的活细胞数量</span></span><br><span class="line">                <span class="keyword">int</span> liveNeighbors = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!(neighbors[i] == <span class="number">0</span> &amp;&amp; neighbors[j] == <span class="number">0</span>)) &#123;</span><br><span class="line">                            <span class="comment">// 相邻位置的坐标</span></span><br><span class="line">                            <span class="keyword">int</span> r = (row + neighbors[i]);</span><br><span class="line">                            <span class="keyword">int</span> c = (col + neighbors[j]);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 查看相邻的细胞是否是活细胞</span></span><br><span class="line">                            <span class="keyword">if</span> ((r &lt; rows &amp;&amp; r &gt;= <span class="number">0</span>) &amp;&amp; (c &lt; cols &amp;&amp; c &gt;= <span class="number">0</span>) &amp;&amp; (<span class="built_in">abs</span>(board[r][c]) == <span class="number">1</span>)) &#123;</span><br><span class="line">                                liveNeighbors += <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 规则 1 或规则 3 </span></span><br><span class="line">                <span class="keyword">if</span> ((board[row][col] == <span class="number">1</span>) &amp;&amp; (liveNeighbors &lt; <span class="number">2</span> || liveNeighbors &gt; <span class="number">3</span>)) &#123;</span><br><span class="line">                    <span class="comment">// -1 代表这个细胞过去是活的现在死了</span></span><br><span class="line">                    board[row][col] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 规则 4</span></span><br><span class="line">                <span class="keyword">if</span> (board[row][col] == <span class="number">0</span> &amp;&amp; liveNeighbors == <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="comment">// 2 代表这个细胞过去是死的现在活了</span></span><br><span class="line">                    board[row][col] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 board 得到一次更新后的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[row][col] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    board[row][col] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    board[row][col] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：<code>O(mn)</code>，其中 <code>m</code>，<code>n</code>分别为 <code>board</code> 的行数和列数。</p>
<p>空间复杂度：<code>O(1)</code>，除原数组外只需要常数的空间存放若干变量。</p>
<h2 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22. 链表中倒数第k个节点"></a>面试题22. 链表中倒数第k个节点</h2><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>计算长度，然后数数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            len++;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(len&gt;k)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len==k? p:<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其它解法：快慢指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;k)&#123;</span><br><span class="line">                fast=fast-&gt;next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i&lt;k?<span class="literal">nullptr</span>:slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题06-从尾到头打印链表"><a href="#面试题06-从尾到头打印链表" class="headerlink" title="面试题06. 从尾到头打印链表"></a>面试题06. 从尾到头打印链表</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>


<p>限制：</p>
<p><code>0 &lt;= 链表长度 &lt;= 10000</code></p>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><p>栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Res;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> val = st.top();</span><br><span class="line">            Res.push_back(val);</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 简析容器Vector</title>
    <url>/2020/04/02/2020-04-02-Cpp-Vector/</url>
    <content><![CDATA[<p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p>
<a id="more"></a>

<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p>
<h2 id="二、容器特性"><a href="#二、容器特性" class="headerlink" title="二、容器特性"></a>二、容器特性</h2><h3 id="1-顺序序列"><a href="#1-顺序序列" class="headerlink" title="1. 顺序序列"></a>1. 顺序序列</h3><p>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p>
<h3 id="2-动态数组"><a href="#2-动态数组" class="headerlink" title="2. 动态数组"></a>2. 动态数组</h3><p>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</p>
<h3 id="3-能够感知内存分配器的（Allocator-aware）"><a href="#3-能够感知内存分配器的（Allocator-aware）" class="headerlink" title="3. 能够感知内存分配器的（Allocator-aware）"></a>3. 能够感知内存分配器的（Allocator-aware）</h3><p>容器使用一个内存分配器对象来动态地处理它的存储需求。</p>
<h2 id="三、基本函数"><a href="#三、基本函数" class="headerlink" title="三、基本函数"></a>三、基本函数</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><ul>
<li>vector():创建一个空vector</li>
<li>vector(int nSize):创建一个vector,元素个数为nSize</li>
<li>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</li>
<li>vector(const vector&amp;):复制构造函数</li>
<li>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</li>
</ul>
<h3 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2.增加函数"></a>2.增加函数</h3><ul>
<li>void push_back(const T&amp; x):向量尾部增加一个元素X</li>
<li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li>
<li>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</li>
<li>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</li>
</ul>
<h3 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h3><ul>
<li>iterator erase(iterator it):删除向量中迭代器指向元素</li>
<li>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</li>
<li>void pop_back():删除向量中最后一个元素</li>
<li>void clear():清空向量中所有元素</li>
</ul>
<h3 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h3><ul>
<li>reference at(int pos):返回pos位置元素的引用</li>
<li>reference front():返回首元素的引用</li>
<li>reference back():返回尾元素的引用</li>
<li>iterator begin():返回向量头指针，指向第一个元素</li>
<li>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置</li>
<li>reverse_iterator rbegin():反向迭代器，指向最后一个元素</li>
<li>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</li>
</ul>
<h3 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h3><ul>
<li>bool empty() const:判断向量是否为空，若为空，则向量中无元素</li>
</ul>
<h3 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h3><ul>
<li>int size() const:返回向量中元素的个数</li>
<li>int capacity() const:返回当前向量所能容纳的最大元素值</li>
<li>int max_size() const:返回最大可允许的vector元素数量值</li>
</ul>
<h3 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h3><ul>
<li>void swap(vector&amp;):交换两个同类型向量的数据</li>
<li>void assign(int n,const T&amp; x):设置向量中第n个元素的值为x</li>
<li>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</li>
</ul>
<h3 id="8-看着清楚"><a href="#8-看着清楚" class="headerlink" title="8.看着清楚"></a>8.看着清楚</h3><table>
<thead>
<tr>
<th></th>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">push_back( )</td>
<td align="center">在数组的最后添加一个数据</td>
</tr>
<tr>
<td>2</td>
<td align="center">pop_back()</td>
<td align="center">去掉数组的最后一个数据</td>
</tr>
<tr>
<td>3</td>
<td align="center">at</td>
<td align="center">得到编号位置的数据</td>
</tr>
<tr>
<td>4</td>
<td align="center">begin</td>
<td align="center">得到数组头的指针</td>
</tr>
<tr>
<td>5</td>
<td align="center">end</td>
<td align="center">得到数组的最后一个单元+1的指针</td>
</tr>
<tr>
<td>6</td>
<td align="center">front</td>
<td align="center">得到数组头的引用</td>
</tr>
<tr>
<td>7</td>
<td align="center">back</td>
<td align="center">得到数组的最后一个单元的引用</td>
</tr>
<tr>
<td>8</td>
<td align="center">max_size</td>
<td align="center">得到vector最大可以是多大</td>
</tr>
<tr>
<td>9</td>
<td align="center">capacity</td>
<td align="center">当前vector分配的大小</td>
</tr>
<tr>
<td>10</td>
<td align="center">size</td>
<td align="center">当前使用数据的大小</td>
</tr>
<tr>
<td>11</td>
<td align="center">resize</td>
<td align="center">改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</td>
</tr>
<tr>
<td>12</td>
<td align="center">reserve</td>
<td align="center">改变当前vecotr所分配空间的大小</td>
</tr>
<tr>
<td>13</td>
<td align="center">erase</td>
<td align="center">删除指针指向的数据项</td>
</tr>
<tr>
<td>14</td>
<td align="center">clear</td>
<td align="center">清空当前的vector</td>
</tr>
<tr>
<td>15</td>
<td align="center">rbegin</td>
<td align="center">将vector反转后的开始指针返回(其实就是原来的end-1)</td>
</tr>
<tr>
<td>16</td>
<td align="center">rend</td>
<td align="center">将vector反转构的结束指针返回(其实就是原来的begin-1)</td>
</tr>
<tr>
<td>17</td>
<td align="center">empty</td>
<td align="center">判断vector是否为空</td>
</tr>
<tr>
<td>18</td>
<td align="center">swap</td>
<td align="center">与另一个vector交换数据</td>
</tr>
</tbody></table>
<h2 id="四、二维Vector初始化"><a href="#四、二维Vector初始化" class="headerlink" title="四、二维Vector初始化"></a>四、二维Vector初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二维vector初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vt;<span class="comment">//初始化一个 二维vector</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">vect</span><span class="params">(vt)</span></span>;<span class="comment">//使用另一个 二维 vector 初始化当前二维vector</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">vec</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(column))</span></span>;<span class="comment">//初始化一个 二维的vector 行row,列column,且值为0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">visited</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(column,<span class="number">6</span>))</span></span>;<span class="comment">//初始化一个 二维vector 行row,列column ,且 值为data=6 自定义data;</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">vecto</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vt[<span class="number">0</span>].<span class="built_in">begin</span>()+<span class="number">1</span>,vt[<span class="number">0</span>].<span class="built_in">begin</span>()+<span class="number">3</span>))</span></span>;<span class="comment">////初始化一个 二维vector 行row,第二个参数为一维vector;</span></span><br></pre></td></tr></table></figure>

<h3 id="五、排序"><a href="#五、排序" class="headerlink" title="五、排序"></a>五、排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">sort(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序</span></span><br><span class="line"><span class="keyword">auto</span> compare = [](<span class="built_in">string</span> sa, <span class="built_in">string</span> sb)&#123;<span class="keyword">return</span> sa+sb &lt; sb+sa;&#125;;</span><br><span class="line">sort(numstr.<span class="built_in">begin</span>(),numstr.<span class="built_in">end</span>(),compare);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-1</title>
    <url>/2020/04/01/2020-04-01-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>1111.有效括号的嵌套深度</li>
<li>面试题29. 顺时针打印矩阵</li>
<li>面试题10- II. 青蛙跳台阶问题</li>
</ol>
<a id="more"></a>

<h2 id="1111-有效括号的嵌套深度"><a href="#1111-有效括号的嵌套深度" class="headerlink" title="1111. 有效括号的嵌套深度"></a>1111. 有效括号的嵌套深度</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><strong>有效括号字符串</strong> 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「<strong>有效括号字符串</strong>」部分。</p>
<p><strong>嵌套深度</strong> <code>depth</code> 定义：即有效括号字符串嵌套的层数，<code>depth(A)</code> 表示有效括号字符串 <code>A</code> 的嵌套深度。详情参见题末「<strong>嵌套深度</strong>」部分。</p>
<p>有效括号字符串类型与对应的嵌套深度计算方法如下图所示：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/01/1111.png" alt="img"></p>
<p>给你一个「有效括号字符串」 <code>seq</code>，请你将其分成两个不相交的有效括号字符串，<code>A</code> 和 <code>B</code>，并使这两个字符串的深度最小。</p>
<ul>
<li>不相交：每个 <code>seq[i]</code> 只能分给 <code>A</code> 和 <code>B</code> 二者中的一个，不能既属于 <code>A</code> 也属于 <code>B</code> 。</li>
<li><code>A</code> 或 <code>B</code> 中的元素在原字符串中可以不连续。</li>
<li><code>A.length + B.length = seq.length</code></li>
<li>深度最小：<code>max(depth(A), depth(B))</code> 的可能取值最小。 </li>
</ul>
<p>划分方案用一个长度为 <code>seq.length</code> 的答案数组 <code>answer</code> 表示，编码规则如下：</p>
<ul>
<li><code>answer[i] = 0</code>，<code>seq[i]</code> 分给 <code>A</code> 。</li>
<li><code>answer[i] = 1</code>，<code>seq[i]</code> 分给 <code>B</code> 。</li>
</ul>
<p>如果存在多个满足要求的答案，只需返回其中任意 <strong>一个</strong> 即可。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：seq &#x3D; &quot;(()())&quot;</span><br><span class="line">输出：[0,1,1,1,1,0]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：seq &#x3D; &quot;()(())()&quot;</span><br><span class="line">输出：[0,0,0,1,1,0,1,1]</span><br><span class="line">解释：本示例答案不唯一。</span><br><span class="line">按此输出 A &#x3D; &quot;()()&quot;, B &#x3D; &quot;()()&quot;, max(depth(A), depth(B)) &#x3D; 1，它们的深度最小。</span><br><span class="line">像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A &#x3D; &quot;()()()&quot;, B &#x3D; &quot;()&quot;, max(depth(A), depth(B)) &#x3D; 1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt; seq.size &lt;= 10000</code> </li>
</ul>
<p><strong>有效括号字符串：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">仅由 &quot;(&quot; 和 &quot;)&quot; 构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。</span><br><span class="line">下述几种情况同样属于有效括号字符串：</span><br><span class="line"></span><br><span class="line">  1. 空字符串</span><br><span class="line">  2. 连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串</span><br><span class="line">  3. 嵌套，可以记作 (A)，其中 A 是有效括号字符串</span><br></pre></td></tr></table></figure>

<p><strong>嵌套深度：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)：</span><br><span class="line"></span><br><span class="line">  1. s 为空时，depth(&quot;&quot;) &#x3D; 0</span><br><span class="line">  2. s 为 A 与 B 连接时，depth(A + B) &#x3D; max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串</span><br><span class="line">  3. s 为嵌套情况，depth(&quot;(&quot; + A + &quot;)&quot;) &#x3D; 1 + depth(A)，其中 A 是有效括号字符串</span><br><span class="line"></span><br><span class="line">例如：&quot;&quot;，&quot;()()&quot;，和 &quot;()(()())&quot; 都是有效括号字符串，嵌套深度分别为 0，1，2，而 &quot;)(&quot; 和 &quot;(()&quot; 都不是有效括号字符串。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>要求划分出使得最大嵌套深度最小的分组，我们首先得知道如何计算嵌套深度。我们可以通过栈实现括号匹配来计算：</p>
<p>维护一个栈 s，从左至右遍历括号字符串中的每一个字符：</p>
<p>如果当前字符是 (，就把 ( 压入栈中，此时这个 ( 的嵌套深度为栈的高度；</p>
<p>如果当前字符是 )，此时这个 ) 的嵌套深度为栈的高度，随后再从栈中弹出一个 (。</p>
<p>下面给出了括号序列 (()(())()) 在每一个字符处的嵌套深度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">括号序列   ( ( ) ( ( ) ) ( ) )</span><br><span class="line">下标编号   <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">嵌套深度   <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>知道如何计算嵌套深度，问题就很简单了：只要在遍历过程中，我们保证栈内一半的括号属于序列 A，一半的括号属于序列 B，那么就能保证拆分后最大的嵌套深度最小，是当前最大嵌套深度的一半。要实现这样的对半分配，我们只需要把奇数层的 ( 分配给 A，偶数层的 ( 分配给 B 即可。对于上面的例子，我们将嵌套深度为 1 和 3 的所有括号 (()) 分配给 A，嵌套深度为 2 的所有括号 ()()() 分配给 B。<br>此外，由于在这个问题中，栈中只会存放 (，因此我们不需要维护一个真正的栈，只需要用一个变量模拟记录栈<br>的大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxDepthAfterSplit</span><span class="params">(<span class="built_in">string</span> seq)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:seq)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                A.push_back(st.<span class="built_in">size</span>()%<span class="number">2</span>);</span><br><span class="line">                st.push(<span class="string">'('</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                A.push_back(st.<span class="built_in">size</span>()%<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题29-顺时针打印矩阵"><a href="#面试题29-顺时针打印矩阵" class="headerlink" title="面试题29. 顺时针打印矩阵"></a>面试题29. 顺时针打印矩阵</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<h3 id="我的解题"><a href="#我的解题" class="headerlink" title="我的解题"></a>我的解题</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对矩阵进行顺时针访问时，利用一个标志矩阵判断是否访问过该元素。如果发生越界或者碰到已访问节点则会退一格，并换个方向继续访问。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表示方向:→、↓、←、↑</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; di = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;; </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dj = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空值情况处理</span></span><br><span class="line">        <span class="keyword">if</span>(!matrix.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(!matrix[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">return</span> matrix[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Res;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>(),col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> num = row*col;      <span class="comment">//矩阵元素个数</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y=<span class="number">0</span> ;        <span class="comment">//待访问元素坐标</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flag</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">1</span>))</span></span>; <span class="comment">//是否访问过该数组</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;              <span class="comment">//遍历方向        </span></span><br><span class="line">    <span class="keyword">while</span>(Res.<span class="built_in">size</span>()&lt; num)&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="number">0</span>&lt;= x &amp;&amp; x&lt;row &amp;&amp; <span class="number">0</span>&lt;= y &amp;&amp; y&lt;col &amp;&amp; flag[x][y])&#123;</span><br><span class="line">            Res.push_back(matrix[x][y]);</span><br><span class="line">            flag[x][y]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;               <span class="comment">//越界则回溯一个值，然后换个方向继续走</span></span><br><span class="line">            x-=di[k]; y-=dj[k];</span><br><span class="line">            k=(++k)%<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x+=di[k]; y+=dj[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*判断是否为空*/</span></span><br><span class="line">      <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      <span class="comment">/*设置上下左右四个界限*/</span></span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; <span class="comment">/*存储遍历结果*/</span></span><br><span class="line">      <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> bottom = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">      <span class="comment">/*此算法模拟顺时针输出的过程，请联想打印过程*/</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/*1.top行从左到右遍历*/</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">              res.push_back(matrix[top][i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*top移动至下一行，并进行边界检测*/</span></span><br><span class="line">          top++;</span><br><span class="line">          <span class="keyword">if</span>(top &gt; bottom ) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*2.right列从上到下遍历*/</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&lt;=bottom;i++)&#123;</span><br><span class="line">              res.push_back(matrix[i][right]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*right左移，并进行边界检测*/</span></span><br><span class="line">          right--;</span><br><span class="line">          <span class="keyword">if</span>(right &lt; left) <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">/*3.bottom行从右往左遍历*/</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = right;i&gt;=left;i--)&#123;</span><br><span class="line">              res.push_back(matrix[bottom][i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*bottom行上移，并进行边界检测*/</span></span><br><span class="line">          bottom -- ;</span><br><span class="line">          <span class="keyword">if</span>(bottom &lt; top) <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">/*4.left列从下往上遍历*/</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom;i&gt;=top;i--)&#123;</span><br><span class="line">              res.push_back(matrix[i][left]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*left右移，并进行边界检测*/</span></span><br><span class="line">          left++;</span><br><span class="line">          <span class="keyword">if</span>(left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*返回遍历结果*/</span></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题10-II-青蛙跳台阶问题"><a href="#面试题10-II-青蛙跳台阶问题" class="headerlink" title="面试题10- II. 青蛙跳台阶问题"></a>面试题10- II. 青蛙跳台阶问题</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h4 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>递归方法容易超时，因此采用哈希表保存中间结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(n<span class="number">-1</span>) == <span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">map</span>[n<span class="number">-1</span>]= numWays(n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(n<span class="number">-2</span>) == <span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">map</span>[n<span class="number">-2</span>]= numWays(n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">map</span>[n<span class="number">-1</span>]+<span class="built_in">map</span>[n<span class="number">-2</span>])%<span class="number">1000000007</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-31</title>
    <url>/2020/03/31/2020-03-31-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>排序数组</li>
</ol>
<p>各种排序算法</p>
<ol>
<li>冒泡排序</li>
<li>插入排序t</li>
<li>快速排序</li>
<li>堆排序</li>
<li>桶排序</li>
</ol>
<a id="more"></a>

<h2 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a>912. 排序数组</h2><p>给定一个整数数组 <code>nums</code>，将该数组升序排列。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-50000 &lt;= A[i] &lt;= 50000</code></li>
</ol>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        quicksort(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> num = nums[low];</span><br><span class="line">        <span class="keyword">int</span> left = low+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = high;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right &amp;&amp; nums[left]&lt;=num) left++;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right &amp;&amp; nums[right]&gt;=num) right--;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[left],nums[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = nums[right];</span><br><span class="line">        nums[right] = num;</span><br><span class="line">        quicksort(nums,low,right<span class="number">-1</span>);</span><br><span class="line">        quicksort(nums,right+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="十种常见排序算法"><a href="#十种常见排序算法" class="headerlink" title="十种常见排序算法"></a>十种常见排序算法</h1><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><strong>比较类排序</strong></li>
</ul>
<p>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</p>
<ul>
<li><strong>非比较类排序</strong></li>
</ul>
<p>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </p>
<h3 id="各算法复杂度"><a href="#各算法复杂度" class="headerlink" title="各算法复杂度"></a>各算法复杂度</h3><p><img src="/2020/03/31/2020-03-31-LeetCode-CheckDaily/849589-20180402133438219-1946132192.png" alt="img"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><strong>相关概念</strong></h3><ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li><strong>空间复杂度：</strong>是指算法在计算机</li>
</ul>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h3><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h3><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a>4. 快速排序</h3><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h3><h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h3><ol start="7">
<li><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3></li>
</ol>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM中的后端优化</title>
    <url>/2020/03/30/2020-03-30-Bundle-adjustment/</url>
    <content><![CDATA[<p>本节介绍SLAM中的后端优化过程</p>
<a id="more"></a>

<h2 id="一、问题阐述"><a href="#一、问题阐述" class="headerlink" title="一、问题阐述"></a>一、问题阐述</h2><p>同时对三维点位置和相机参数进行非线性优化</p>
<p><img src="/2020/03/30/2020-03-30-Bundle-adjustment/BA%E4%BC%98%E5%8C%96.jpg" alt="BA原理"></p>
<h2 id="二、LM法的原理与优势"><a href="#二、LM法的原理与优势" class="headerlink" title="二、LM法的原理与优势"></a>二、LM法的原理与优势</h2><p> <strong>原理</strong>：是一种“信赖域”的方法，当收敛速度较快时，增大信赖域使算法趋向于高斯牛顿法；当收敛速度较慢时，减小信赖域使算法趋向于最速下降法。</p>
<p><strong>优势</strong>：速度快；可以在距离初始值较远处得到最优解。</p>
<h4 id="SLAM优化算法对比"><a href="#SLAM优化算法对比" class="headerlink" title="SLAM优化算法对比"></a>SLAM优化算法对比</h4><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">缺点</th>
<th align="center">优点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">KF/EKF</td>
<td align="center">假设噪声为高斯分布，在高维状态空间时计算效率较低，不适合大规模场景的地图构建</td>
<td align="center">原理简单，小场景下收敛性好。</td>
</tr>
<tr>
<td align="center">PF</td>
<td align="center">会不可避免出现粒子退化现象，每个粒子需包含整张地图信息导致不适合大场景地图构建</td>
<td align="center">将运动方程表示为一组粒子，通过蒙特卡罗方法求解，能够处理非线性非高斯噪声。</td>
</tr>
<tr>
<td align="center">EM</td>
<td align="center">计算量大，不能用于大规模场景</td>
<td align="center">有效解决了数据关联问题</td>
</tr>
<tr>
<td align="center">图优化</td>
<td align="center">对闭环检测算法的要求严格</td>
<td align="center">出现多种图优化框架，能够有效解决滤波器算法的缺陷，能用于大规模场景的地图创建</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>BA</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-30</title>
    <url>/2020/03/30/2020-03-30-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>面试题62. 圆圈中最后t剩下的数字</li>
</ol>
<a id="more"></a>

<h2 id="面试题62-圆圈中最后剩下的数字"><a href="#面试题62-圆圈中最后剩下的数字" class="headerlink" title="面试题62. 圆圈中最后剩下的数字"></a>面试题62. 圆圈中最后剩下的数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p> <strong>示例 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p> <strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= m &lt;= 10^6</code></li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>该问题为约瑟夫环问题。</p>
<p>存储一个数组，每次删除一个元素，使用递归进行求解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++) num[i]=i;</span><br><span class="line">        <span class="keyword">return</span> deletem(num,n,<span class="number">0</span>,m<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deletem</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num,<span class="keyword">int</span> n,<span class="keyword">int</span> start,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> num[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=num.<span class="built_in">begin</span>();</span><br><span class="line">        num.erase(it+(start+m)%n);</span><br><span class="line">        start = (start+m)%n;</span><br><span class="line">        <span class="keyword">return</span> deletem(num,n<span class="number">-1</span>,start,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果：超时</p>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：数学-递归"><a href="#方法一：数学-递归" class="headerlink" title="方法一：数学 + 递归"></a>方法一：数学 + 递归</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>题目中的要求可以表述为：给定一个长度为 n 的序列，每次向后数 m 个元素并删除，那么最终留下的是第几个元素？</p>
<p>这个问题很难快速给出答案。但是同时也要看到，这个问题似乎有拆分为较小子问题的潜质：如果我们知道对于一个长度 n - 1 的序列，留下的是第几个元素，那么我们就可以由此计算出长度为 n 的序列的答案。</p>
<p>算法</p>
<p>我们将上述问题建模为函数 <code>f(n, m)</code>，该函数的返回值为最终留下的元素的序号。</p>
<p>首先，长度为 n 的序列会先删除第<code>m % n</code> 个元素，然后剩下一个长度为 n - 1 的序列。那么，我们可以递归地求解 f(n - 1, m)，就可以知道对于剩下的 n - 1 个元素，最终会留下第几个元素，我们设答案为 <code>x = f(n - 1, m)</code>。</p>
<p>由于我们删除了第 <code>m % n</code> 个元素，将序列的长度变为 <code>n - 1</code>。当我们知道了 <code>f(n - 1, m)</code> 对应的答案 <code>x</code> 之后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。因此有 <code>f(n, m) = (m % n + x) % n = (m + x) % n</code>。</p>
<p>我们递归计算 <code>f(n, m), f(n - 1, m), f(n - 2, m), ...</code>直到递归的终点<code>f(1, m)</code>。当序列长度为 1 时，一定会留下唯一的那个元素，它的编号为 0。</p>
<p>下面的代码实现了上述的递归函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x=lastRemaining(n<span class="number">-1</span>,m);</span><br><span class="line">        <span class="keyword">return</span> (x+m)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：<code>O(n)</code>，需要求解的函数值有 <code>n</code> 个。</p>
<p>空间复杂度：<code>O(n)</code>，函数的递归深度为 <code>n</code>，需要使用 <code>O(n)</code>的栈空间。</p>
<h4 id="方法二：数学-迭代"><a href="#方法二：数学-迭代" class="headerlink" title="方法二：数学 + 迭代"></a>方法二：数学 + 迭代</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>上面的递归可以改写为迭代，避免递归使用栈空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i != n + <span class="number">1</span>; ++i)</span><br><span class="line">            f = (m + f) % i;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：<code>O(n)</code>，需要求解的函数值有 <code>n</code> 个。</p>
<p>空间复杂度：<code>O(1)</code>，只使用常数个变量。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-29</title>
    <url>/2020/03/29/2020-03-29-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>1162.地图分析t</li>
<li>面试题05. 替换空格</li>
<li>面试题58 - II. 左旋转字符串</li>
</ol>
<a id="more"></a>

<h2 id="1162-地图分析"><a href="#1162-地图分析" class="headerlink" title="1162. 地图分析"></a>1162. 地图分析</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>你现在手里有一份大小为 N x N 的『地图』（网格） <code>grid</code>，上面的每个『区域』（单元格）都用 <code>0</code> 和 <code>1</code> 标记好了。其中 <code>0</code> 代表海洋，<code>1</code> 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。</p>
<p>我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：<code>(x0, y0)</code> 和 <code>(x1, y1)</code> 这两个区域之间的距离是 <code>|x0 - x1| + |y0 - y1|</code> 。</p>
<p>如果我们的地图上只有陆地或者海洋，请返回 <code>-1</code>。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><p><strong><img src="/2020/03/29/2020-03-29-LeetCode-CheckDaily/1.jpeg" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,0,1],[0,0,0],[1,0,1]]</span><br><span class="line">输出：2</span><br><span class="line">解释： </span><br><span class="line">海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><p><strong><img src="/2020/03/29/2020-03-29-LeetCode-CheckDaily/2.jpeg" alt="img"></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释： </span><br><span class="line">海洋区域 (<span class="number">2</span>, <span class="number">2</span>) 和所有陆地区域之间的距离都达到最大，最大距离为 <span class="number">4</span>。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= grid.length == grid[0].length &lt;= 100</code></li>
<li><code>grid[i][j]</code> 不是 <code>0</code> 就是 <code>1</code></li>
</ol>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>思路：先用哈希表存储海洋和陆地节点。</p>
<p>然后遍历寻找每个海洋节点的最近陆地。时间复杂度达到$O(N^4)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; sea; <span class="comment">//海洋</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; con; <span class="comment">//陆地</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;grid.<span class="built_in">size</span>();x++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = &#123;x,y&#125;;</span><br><span class="line">                <span class="keyword">if</span>(grid[x][y])</span><br><span class="line">                    con.push_back(temp);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sea.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(sea.<span class="built_in">size</span>()==grid.<span class="built_in">size</span>()*grid.<span class="built_in">size</span>()||con.<span class="built_in">size</span>()==grid.<span class="built_in">size</span>()*grid.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxdis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nearcon;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sea.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mindis = grid.<span class="built_in">size</span>()&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;con.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                mindis = <span class="built_in">min</span>(mindis,mahtdis(sea[i],con[j]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxdis&lt;mindis)</span><br><span class="line">            &#123;</span><br><span class="line">                maxdis = mindis;</span><br><span class="line">                nearcon = mindis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nearcon;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mahtdis</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sea,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; con)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(sea[<span class="number">0</span>]-con[<span class="number">0</span>])+<span class="built_in">abs</span>(sea[<span class="number">1</span>]-con[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果：超时</p>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h5><p>考虑最朴素的方法，即求出每一个海洋区域（<code>grid[i][j] == 0</code> 的区域）的「最近陆地区域」，然后记录下它们的距离，然后在这些距离里面取一个最大值。</p>
<p>对于一个给定的区域<code>(x, y)</code> ，求它的「最近陆地区域」，可以使用宽度优先搜索思想。我们把每个区域的坐标作以及这个区域与 <code>(x, y)</code>的曼哈顿距离为搜索状态，即 Coordinate 结构体的 <code>x</code>、<code>y</code>和<code>step</code> 属性。findNearestLand 方法实现了宽度优先搜索的过程，我们用一个 <code>vis[u][v]</code> 数组记录<code>(u, v)</code> 区域是否被访问过，在拓展新状态的时候按照如下四个方向：</p>
<p><code>(x - 1, y)</code>,<code>(x, y + 1)</code>,<code>(x + 1, y)</code>,<code>(x, y - 1)</code><br>在这里我们可以把四个方向定义为常量增量数组 <code>dx</code> 和 <code>dy</code>。</p>
<p>思考：我们需不需要搜索到队列为空才停止 BFS ？ 答案是不需要。当我们搜索到一个新入队的区域它的 grid 值为 1，即这个区域是陆地区域的时候我们就可以停止搜索，因为 BFS 能保证当前的这个区域是最近的陆地区域（BFS 的性质决定了这里求出来的一定是最短路）。</p>
<p><code>findNearestLand</code>如果我们找不不到任何一个点是陆地区域则返回 -1。最终我们把 ans 的初始值置为 -1，然后与所有的 BFS 结果取最大。</p>
<h4 id="方法一：宽度优先搜索"><a href="#方法一：宽度优先搜索" class="headerlink" title="方法一：宽度优先搜索"></a>方法一：宽度优先搜索</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Coordinate</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y, <span class="built_in">step</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxdis = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!grid[i][j])</span><br><span class="line">                    maxdis = <span class="built_in">max</span>(maxdis, findNearestLand(i, j, grid, row, col));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxdis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNearestLand</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="built_in">queue</span> &lt;Coordinate&gt; q;</span><br><span class="line">        q.push(&#123;x, y, <span class="number">0</span>&#125;);</span><br><span class="line">        vis[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.front(); </span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (!(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt;= row - <span class="number">1</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt;= col - <span class="number">1</span>)) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!vis[nx][ny]) </span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(&#123;nx, ny, f.<span class="built_in">step</span> + <span class="number">1</span>&#125;);</span><br><span class="line">                    vis[nx][ny] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[nx][ny]) </span><br><span class="line">                        <span class="keyword">return</span> f.<span class="built_in">step</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p><strong>时间复杂度</strong>：该算法最多执行 <code>n^2</code>  次 BFS，即我们考虑最坏情况所有的区域都是海洋，那么每一个区域都会进行 BFS。对于每一次 BFS，最坏的情况是找不到陆地区域，我们只能遍历完剩下的 <code>n^2 - 1</code>个海洋区域，由于 vis 数组确保每个区域只被访问一次，所以单次 BFS 的渐进时间复杂度是 <code>O(n^2)</code>，程序的总的渐进时间复杂度是 <code>O(n^4)</code>。</p>
<p><strong>空间复杂度</strong>：该算法使用了 <code>vis</code> 数组，渐进空间复杂度为 <code>O(n^2)</code></p>
<h4 id="方法二：多源最短路"><a href="#方法二：多源最短路" class="headerlink" title="方法二：多源最短路"></a>方法二：多源最短路</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>其实在方法一中我们已经发现我们 BFS 的过程是求最短路的过程，但是这里不是求某一个海洋区域到陆地区域的最短路，而是求所有的海洋区域到陆地区域这个「点集」的最短路。显然这不是一个「单源」最短路问题（SSSP）。在我们学习过的最短路算法中，求解 SSSP 问题的方法有 Dijkstra 算法和 SPFA算法，而求解任意两点之间的最短路一般使用 Floyd 算法。那我们在这里就应该使用 Floyd 算法吗？要考虑这个问题，我们需要分析一下这里使用 Floyd 算法的时间复杂度。我们知道在网格图中求最短路，每个区域（格子）相当于图中的顶点，而每个格子和上下左右四个格子的相邻关系相当于边，我们记顶点的个数为 VV，Floyd 算法的时间复杂度为 $O(V^3)$,而这里 $V = n^2$ ，所以 $O(V^3) = O(n^6)$，显然是不现实的。</p>
<p>考虑 <code>SSSP</code> 是求一个源点到一个点集中所有点的最短路，而这个问题的本质是求某个点集到另一个点集中所有点的最短路，即「多源最短路」，我们只需要对 <code>Dijkstra</code> 算法或者<code>SPFA</code> 算法稍作修改。这里以 <code>Dijkstra</code> 算法为例，我们知道堆优化的 <code>Dijkstra</code> 算法实际上是 BFS 的一个变形，把 BFS 中的队列变成了优先队列，在拓展新状态的时候加入了松弛操作。<code>Dijkstra</code> 的堆优化版本第一步是源点入队，我们只需要把它改成源点集合中的所有的点入队就可以实现求「多源最短路」。</p>
<p>思考：为什么？ 因为我们这样做相当于建立了一个超级源点 SS，这个点与源点集中的 $s_0, s_1, s_2 \cdots s_{|V|}$<br>都有边，并且权都为 0。这样求源点集到目标点集的最短路就变成了求超级源点 SS 到它们的最短路，于是又转化成了 SSSP 问题。</p>
<p>思考：海洋区域和陆地区域，应该哪一个作为源点集？ 也许你分析出「我们需要找一个海洋区域，满足它到陆地的最小距离是最大」会把海洋区域作为源点集。我们可以考虑后续的实现，我们知道 Dijkstra 中一个 <code>d</code>数组用来维护当前源点集到其他点的最短路，而对于源点集中的任意一个点 <code>s</code>，<code>d[s_x][s_y] = 0</code>，这很好理解，源点到源点的最短路就是 <code>0</code>。如果我们把海洋区域作为源点集、陆地区域作为目标点集，假设 tt 是目标点集中的一个点，算法执行结束后 <code>d[t_x][t_y]</code> 就是海洋区域中的点到 <code>t</code> 的最短距离，但是我们却不知道哪些 <code>t</code> 是海洋区域的这些点的「最近陆地区域」，我们也不知道每个 <code>s</code> 距离它的「最近陆地区域」的曼哈顿距离。考虑我们把陆地区域作为源点集、海洋区域作为目标点集，目标点集中的点 <code>t</code>对应的 <code>d[t_x][t_y]</code> 就是海洋区域 <code>t</code>对应的距离它的「最近陆地区域」的曼哈顿距离，正是我们需要的，所以应该把陆地区域作为源点集。</p>
<p>最终我们只需要比出 <code>d[t_x][t_y]</code> 的最大值即可。Dijkstra 算法在初始化 <code>d</code> 数组的时候，把每个元素预置为 <code>INF</code>，所以如果发现最终比出的最大值为 <code>INF</code>，那么就返回 <code>-1</code>。</p>
<p>由于这里的边权为 <code>1</code>，也可以直接使用多源 <code>BFS</code>，在这里每个点都只会被松弛一次。</p>
<p><strong>代码实现</strong></p>
<ul>
<li>Dijkstra 版</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> INF = <span class="keyword">int</span>(<span class="number">1E6</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> d[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> v, x, y;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Status &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v &gt; rhs.v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue &lt;Status&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> &amp;a = grid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]) &#123;</span><br><span class="line">                    d[i][j] = <span class="number">0</span>;</span><br><span class="line">                    q.push(&#123;<span class="number">0</span>, i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.top(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (!(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt;= n - <span class="number">1</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt;= n - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (f.v + <span class="number">1</span> &lt; d[nx][ny]) &#123;</span><br><span class="line">                    d[nx][ny] = f.v + <span class="number">1</span>;</span><br><span class="line">                    q.push(&#123;d[nx][ny], nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a[i][j]) ans = <span class="built_in">max</span>(ans, d[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (ans == INF) ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>多源 BFS 版</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> INF = <span class="keyword">int</span>(<span class="number">1E6</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> d[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Coordinate</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> &lt;Coordinate&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> &amp;a = grid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]) &#123;</span><br><span class="line">                    d[i][j] = <span class="number">0</span>;</span><br><span class="line">                    q.push(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (!(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt;= n - <span class="number">1</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt;= n - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (d[nx][ny] &gt; d[f.x][f.y] + <span class="number">1</span>) &#123;</span><br><span class="line">                    d[nx][ny] = d[f.x][f.y] + <span class="number">1</span>;</span><br><span class="line">                    q.push(&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a[i][j]) ans = <span class="built_in">max</span>(ans, d[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (ans == INF) ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：考虑这里的「多源最短路」的本质还是「单源最短路」，因此就是 Dijkstra 算法堆优化版本的渐进时间复杂度 $O(E \log V)$，这里 <code>E</code> 为边的个数，约等于$ \frac{4n^2}{2} $ ，<code>V</code> 为顶点个数，约等于 $n^2$ ，所以这里的渐进时间复杂度为 $O(n^2 \log n^2) = O(n^2 \log n)$。</p>
<p>在多源 BFS 当中，由于每个点只能被访问一次，渐进时间复杂度为 $O(V+E) = O(n^2)$。</p>
<p>SPFA 算法的理论渐进上界是 $O(VE) = O(n^2)$，但是由于这里的边权都为 <code>1</code>，于是它退化成了 <code>BFS</code>，渐进时间复杂度 $O(n^2)$。<br>空间复杂度：该算法使用了 <code>d</code> 数组，渐进空间复杂度为 $O(n^2)$。</p>
<h4 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h4><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>考虑优化方法二中的「把陆地区域作为源点集、海洋区域作为目标点集，求最短路」的过程。我们知道对于每个海洋区域 <code>(x, y)</code>，离它最近的陆地区域到它的路径要么从上方或者左方来，要么从右方或者下方来。考虑做两次动态规划，第一次从左上到右下，第二次从右下到左上，记 f(x, y) 为(x,y) 距离最近的陆地区域的曼哈顿距离，则我们可以推出这样的转移方程：</p>
<p>第一阶段<br>$$<br>f(x, y) = \left { \begin{aligned} &amp; 0 &amp; , &amp; (x, y) {\rm , is, land} \ &amp; \min { f(x - 1, y), f(x, y - 1) } + 1 &amp; , &amp; (x, y) {\rm , is,ocean} \end{aligned} \right.<br>$$<br>第二阶段<br>$$<br>f(x, y) = \left { \begin{aligned} &amp; 0 &amp; , &amp; (x, y) {\rm , is, land} \ &amp; \min { f(x + 1, y), f(x, y + 1) } + 1 &amp; , &amp; (x, y) {\rm , is,ocean} \end{aligned} \right.<br>$$</p>
<p>我们初始化的时候把陆地的 f 值全部预置为 0，海洋的 f 全部预置为 <code>INF</code>，做完两个阶段的动态规划后，我们在所有的不为零的 <code>f[i][j]</code> 中比一个最大值即可，如果最终比较出的最大值为 <code>INF</code>，就返回 <code>-1</code>。</p>
<p>思考：如果用 <code>f(x, y)</code> 记录左上方的 DP 结果，<code>g(x, y)</code> 记录右下方的DP结果可行吗？ 答案是不可行。因为考虑距离点 <code>(x, y)</code>最近的点可能既不来自左上方，也不来自右下方，比如它来自右上方，这个时候，第二阶段我们就需要用到第一阶段的计算结果。</p>
<p>代码实现如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> INF = <span class="keyword">int</span>(<span class="number">1E6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> f[MAX_N][MAX_N];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a = grid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = (a[i][j] ? <span class="number">0</span> : INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a[i][j]) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, f[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ans == INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p><strong>时间复杂度</strong>：从代码不难看出，这个算法的过程就是四个双重 <code>for</code> 循环，渐进时间复杂度为 <code>O(n^2）</code></p>
<p><strong>空间复杂度</strong>：该算法使用了 <code>f</code> 数组，渐进空间复杂度为 <code>O(n^2)</code></p>
<h2 id="面试题05-替换空格"><a href="#面试题05-替换空格" class="headerlink" title="面试题05. 替换空格"></a>面试题05. 替换空格</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>字符转字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:s)</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">' '</span>) res+=<span class="string">"%20"</span>;</span><br><span class="line">            <span class="keyword">else</span> res.append(<span class="number">1</span>,ch);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span>::size_type <span class="title">pos</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((pos=s.<span class="built_in">find</span>(<span class="string">" "</span>))!=<span class="built_in">string</span>::npos)<span class="comment">//找到了空格</span></span><br><span class="line">        s.replace(pos,<span class="number">1</span>,<span class="string">"%20"</span>);<span class="comment">//替换</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题58-II-左旋转字符串"><a href="#面试题58-II-左旋转字符串" class="headerlink" title="面试题58 - II. 左旋转字符串"></a>面试题58 - II. 左旋转字符串</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="*示例 *"></a>*<em>示例 *</em></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="*示例 *"></a>*<em>示例 *</em></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> num = n%len;</span><br><span class="line">        res = s.substr(num,len-num)+s.substr(<span class="number">0</span>,num);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>相机标定</title>
    <url>/2020/03/28/2020-03-28-Camera-Calibration/</url>
    <content><![CDATA[<p>本节将探讨相机标定，主要探讨以下三个问题</p>
<ol>
<li>相机标定原理</li>
<li>实现过程</li>
<li>棋盘格的好处</li>
</ol>
<a id="more"></a>

<h2 id="相机标定"><a href="#相机标定" class="headerlink" title="相机标定"></a>相机标定</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>图像测量过程以及计算器视觉中，为确定空间物体某点的三维几何关系位置与其在图像中对应点之间的相互关系，必须建立相机成像的几何模型，模型的参数就是相机的参数。<strong>求解参数的过程</strong>称为相机标定。</p>
<p><strong>目的</strong>：求出相机的内、外参数，以及畸变参数。</p>
<p>标定相机后做的两件事：</p>
<ol>
<li>通过相机标定校正这种镜头畸变，生成矫正后的图像；</li>
<li>是根据获得的图像重构三维场景。</li>
</ol>
<h3 id="2-标定原理"><a href="#2-标定原理" class="headerlink" title="2. 标定原理"></a>2. 标定原理</h3><p>先定义以下<strong>涉及概念</strong>：</p>
<p><strong>世界坐标系</strong>：用户定义的三维世界的坐标系，为了描述目标物在真实世界里的位置而被引入。单位为m。</p>
<p><strong>相机坐标系</strong>：在相机上建立的坐标系，为了从相机的角度描述物体位置而定义，作为沟通世界坐标系和图像/像素坐标系的中间一环。单位为m。</p>
<p><strong>图像坐标系</strong>：为了描述成像过程中物体从相机坐标系到图像坐标系的投影透射关系而引入，方便进一步得到像素坐标系下的坐标。 单位为m。</p>
<p><strong>像素坐标系</strong>：为了描述物体成像后的像点在数字图像上（相片）的坐标而引入，即从相机内读取到的信息所在的坐标系。单位为像素。</p>
<p>下图可以清晰地表达四个坐标系之间的关系：</p>
<p><img src="/2020/03/28/2020-03-28-Camera-Calibration/%E5%9D%90%E6%A0%87%E7%B3%BB.jpg" alt="img"></p>
<p>世界坐标系：<code>Xw</code>、<code>Yw</code>、<code>Zw</code>。相机坐标系： <code>Xc</code>、<code>Yc</code>、<code>Zc</code>。图像坐标系：<code>x</code>、<code>y</code>。像素坐标系：<code>u</code>、<code>v</code>。</p>
<p>其中，相机坐标系的<code>Zc</code>轴与光轴重合，且垂直于图像坐标系平面并通过图像坐标系的原点，相机坐标系与图像坐标系之间的距离为焦距f（也即图像坐标系原点与焦点重合）。像素坐标系平面<code>u-v</code>和图像坐标系平面<code>x-y</code>重合，但像素坐标系原点位于图中左上角（之所以这么定义，目的是从存储信息的首地址开始读写）。</p>
<p>下面将依次对刚体进行一系列变换，使之从世界坐标系进行仿射变换、投影透射，最终得到像素坐标系下的离散图像点，过程中会逐步引入各参数矩阵。</p>
<h4 id="A-从世界坐标系到相机坐标系"><a href="#A-从世界坐标系到相机坐标系" class="headerlink" title="A. 从世界坐标系到相机坐标系"></a>A. 从世界坐标系到相机坐标系</h4><p>刚体从世界坐标系转换到相机坐标系的过程，可以通过旋转和平移来得到，我们将其变换矩阵由一个旋转矩阵和平移向量组合成的齐次坐标矩阵（为什么要引入齐次坐标可见后续文章）来表示：</p>
<p><img src="https://img-blog.csdn.net/20180204203239598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>其中，R为旋转矩阵，t为平移向量，因为假定在世界坐标系中物点所在平面过世界坐标系原点且与Zw轴垂直（也即棋盘平面与Xw-Yw平面重合，目的在于方便后续计算），所以<code>zw=0</code>，可直接转换成式1的形式。其中变换矩阵<br>$$<br>\left[<br>\begin{matrix}<br>R&amp;t\<br>0_3^T&amp;1<br>\end{matrix}<br>\right]<br>$$<br>即为前文提到的外参矩阵，之所称之为外参矩阵可以理解为只与相机外部参数有关，且外参矩阵随刚体位置的变化而变化。</p>
<p><img src="https://img-blog.csdn.net/20180204203322511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h4 id="B-从相机坐标系到理想图像坐标系（不考虑畸变）"><a href="#B-从相机坐标系到理想图像坐标系（不考虑畸变）" class="headerlink" title="B. 从相机坐标系到理想图像坐标系（不考虑畸变）"></a>B. 从相机坐标系到理想图像坐标系（不考虑畸变）</h4><p>该过程进行了从三维坐标到二维坐标的转换，也即投影透视过程（用中心投影法将物体投射到投影面上，从而获得的一种较为接近视觉效果的单面投影图，也就是使我们人眼看到景物近大远小的一种成像方式）。以针孔成像为例（除了成像亮度低外，成像效果和透镜成像是一样的，但是光路更简单）。成像过程如图二所示：</p>
<p>针孔面（相机坐标系）在图像平面（图像坐标系）和物点平面（棋盘平面）之间，所成图像为倒立实像。</p>
<p><img src="https://img-blog.csdn.net/20180204203348763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>为了在数学上更方便描述，我们将相机坐标系和图像坐标系位置对调，变成图三所示的布置方式（没有实际的物理意义，只是方便计算）：</p>
<p><img src="https://img-blog.csdn.net/20180204203408825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>此时，假设相机坐标系中有一点M，则在理想图像坐标系下（无畸变）的成像点P的坐标为（可由相似三角形原则得出）：<br>$$<br>x_p=f\frac{x_M}{z_M},y_p=f\frac{y_M}{z_M}<br>$$<br>将上式化为齐次坐标表示形式为：<br>$$<br>z_M<br>\left[\begin{matrix}f&amp;0&amp;0&amp;0\0&amp;f&amp;0&amp;0\0&amp;0&amp;1&amp;0\\end{matrix}\right]<br>\left[\begin{matrix}x_M\y_M\z_M\1\end{matrix}\right]=<br>\left[\begin{matrix}f&amp;0&amp;0\0&amp;f&amp;0\0&amp;0&amp;1\\end{matrix}\right]<br>\left[\begin{matrix}1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;0\\end{matrix}\right]<br>\left[\begin{matrix}x_M\y_M\z_M\1\end{matrix}\right]<br>$$</p>
<h4 id="C-从理想图像坐标系到实际图像坐标系（考虑畸变）"><a href="#C-从理想图像坐标系到实际图像坐标系（考虑畸变）" class="headerlink" title="C. 从理想图像坐标系到实际图像坐标系（考虑畸变）"></a>C. 从理想图像坐标系到实际图像坐标系（考虑畸变）</h4><p>透镜的畸变主要分为径向畸变和切向畸变，还有薄透镜畸变等等，但都没有径向和切向畸变影响显著，所以我们在这里只考虑径向和切向畸变。</p>
<h5 id="径向畸变"><a href="#径向畸变" class="headerlink" title="径向畸变"></a><strong>径向畸变</strong></h5><p>由于透镜形状的制造工艺导致。且越向透镜边缘移动径向畸变越严重。下图所示是径向畸变的两种类型：桶形畸变和枕形畸变。</p>
<p><img src="https://img-blog.csdn.net/20180204203515701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>实际情况中我们常用r=0处的泰勒级数展开的前几项来近似描述径向畸变。矫正径向畸变前后的坐标关系为：<br>$$<br>\left{<br>\begin<br>\end<br>\right<br>$$</p>
<p><img src="https://img-blog.csdn.net/20180204203540542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>由此可知对于径向畸变，我们有3个畸变参数需要求解。</p>
<h5 id="切向畸变"><a href="#切向畸变" class="headerlink" title="切向畸变"></a><strong>切向畸变</strong></h5><p>由于透镜和CMOS或者CCD的安装位置误差导致。因此，如果存在切向畸变，一个矩形被投影到成像平面上时，很可能会变成一个梯形。切向畸变需要两个额外的畸变参数来描述，矫正前后的坐标关系为：</p>
<p><img src="https://img-blog.csdn.net/20180204203600045?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>由此可知对于切向畸变，我们有2个畸变参数需要求解。</p>
<p>综上，我们一共需要5个畸变参数（<code>k1</code>、<code>k2</code>、<code>k3</code>、<code>p1</code>和<code>p2</code> ）来描述透镜畸变。</p>
<p>下图表示了用<code>R</code>，<code>t</code>将上述世界坐标系转换到相机坐标系的过程。</p>
<h4 id="D-从图像坐标系到像素坐标系"><a href="#D-从图像坐标系到像素坐标系" class="headerlink" title="D. 从图像坐标系到像素坐标系"></a>D. 从图像坐标系到像素坐标系</h4><p>像素坐标系原点与图像坐标系原点不重合。假设像素坐标系原点在图像坐标系下的坐标为<code>（u0，v0）</code>，每个像素点在图像坐标系x轴、y轴方向的尺寸为：<code>dx</code>、<code>dy</code>，且像点在实际图像坐标系下的坐标为<code>（xc，yc）</code>，可得到像点在像素坐标系下的坐标为：<br>$$<br>u=\frac{x_t}{d_x}+u_0,v=\frac{y_c}{dy}+v_0<br>$$<br>化为齐次坐标表示形式可得：<br>$$<br>\left[\begin{matrix}u\v\1\end{matrix}\right]=<br>\left[\begin{matrix}1/d_x&amp;0&amp;u_0\0&amp;1/d_y&amp;v_0\0&amp;0&amp;1\end{matrix}\right]<br>\left[\begin{matrix}x_c\y_c\1\end{matrix}\right]<br>$$</p>
<p>公式2中1<code>(xp, yp)</code>与公式5中<code>(xc, yc)</code>相同，都是图像坐标系下的坐标。</p>
<p>若暂不考虑透镜畸变，则将式2与式5的转换矩阵相乘即为内参矩阵M：</p>
<p><img src="https://img-blog.csdn.net/20180204203659583?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>之所以称之为内参矩阵可以理解为矩阵内各值只与相机内部参数有关，且不随物体位置变化而变化。</p>
<p>最后用一幅图来总结从世界坐标系到像素坐标系（不考虑畸变）的转换关系：</p>
<p><strong>总结：</strong>从世界坐标系到像素坐标系（不考虑畸变）的转换关系</p>
<p><img src="/2020/03/28/2020-03-28-Camera-Calibration/%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B.jpg" alt="img"></p>
<h3 id="3-标定方法"><a href="#3-标定方法" class="headerlink" title="3. 标定方法"></a>3. 标定方法</h3><h4 id="传统相机标定法"><a href="#传统相机标定法" class="headerlink" title="传统相机标定法"></a>传统相机标定法</h4><p>传统相机标定法需要使用尺寸已知的标定物，通过建立标定物上坐标已知的点与其图像点之间的对应，利用一定的算法获得相机模型的内外参数。根据标定物的不同可分为三维标定物和平面型标定物。三维标定物可由单幅图像进行标定，标定精度较高，但高精密三维标定物的加工和维护较困难。平面型标定物比三维标定物制作简单，精度易保证，但标定时必须采用两幅或两幅以上的图像。</p>
<p><strong>缺点：</strong>传统相机标定法在标定过程中始终需要标定物，且标定物的制作精度会影响标定结果。同时有些场合不适合放置标定物也限制了传统相机标定法的应用。</p>
<h4 id="相机自标定法"><a href="#相机自标定法" class="headerlink" title="相机自标定法"></a>相机自标定法</h4><p>​    目前出现的自标定算法中主要是利用相机运动的约束。相机的运动约束条件太强，因此使得其在实际中并不实用。利用场景约束主要是利用场景中的一些平行或者正交的信息。其中空间平行线在相机图像平面上的交点被称为消失点，它是射影几何中一个非常重要的特征，所以很多学者研究了基于消失点的相机自标定方法。</p>
<p><strong>优点：</strong>自标定方法灵活性强，可对相机进行在线定标。</p>
<p><strong>缺点：</strong>但由于它是基于绝对二次曲线或曲面的方法，其算法鲁棒性差。</p>
<h4 id="主动视觉相机标定方法"><a href="#主动视觉相机标定方法" class="headerlink" title="主动视觉相机标定方法"></a>主动视觉相机标定方法</h4><p>基于主动视觉的相机标定法是指已知相机的某些运动信息对相机进行标定。该方法不需要标定物，但需要控制相机做某些特殊运动，利用这种运动的特殊性可以计算出相机内部参数。</p>
<p><strong>优点：</strong>是算法简单，往往能够获得线性解，故鲁棒性较高；</p>
<p><strong>缺点：</strong>是系统的成本高、实验设备昂贵、实验条件要求高，而且不适合于运动参数未知或无法控制的场合。</p>
<h3 id="4-棋盘格"><a href="#4-棋盘格" class="headerlink" title="4. 棋盘格"></a>4. 棋盘格</h3><p><strong>棋盘</strong>是一块由黑白方块间隔组成的标定板，我们用它来作为相机标定的标定物（从真实世界映射到数字图像内的对象）。之所以我们用棋盘作为标定物是因为平面棋盘模式更容易处理（相对于复杂的三维物体），但与此同时，二维物体相对于三维物体会缺少一部分信息，于是我们会多次改变棋盘的方位来捕捉图像，以求获得更丰富的坐标信息。如下图所示，是相机在不同方向下拍摄的同一个棋盘图像。</p>
<p><img src="/2020/03/28/2020-03-28-Camera-Calibration/%E6%A3%8B%E7%9B%98.jpg" alt="img"></p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><h3 id="5-张正友标定法"><a href="#5-张正友标定法" class="headerlink" title="5. 张正友标定法"></a>5. 张正友标定法</h3>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>相机标定</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 字符串</title>
    <url>/2020/03/28/2020-03-28-Cpp-String/</url>
    <content><![CDATA[<p>string是C++标准库的一个重要的部分，主要用于字符串处理。可以使用输入输出流方式直接进行string操作，也可以通过文件等手段进行string操作。同时，C++的算法库对string类也有着很好的支持，并且string类还和c语言的字符串之间有着良好的接口。</p>
<p>本文将介绍字符串的基本概念和C++的常用操作。</p>
<a id="more"></a>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>字符串或串(String)是由数字、字母、下划线组成的一串字符。一般记为 <code>s=“a1a2···an”(n&gt;=0)</code>。它是编程语言中表示文本的数据类型。在程序设计中，字符串（string）为符号或数值的一个连续序列，如符号串（一串字符）或二进制数字串（一串二进制数字）。</p>
<p>通常以串的整体作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。两个字符串相等的充要条件是：长度相等，并且各个对应位置上的字符都相等。设p、q是两个串，求q在p中首次出现的位置的运算叫做模式匹配。</p>
<p>串的两种最基本的存储方式是顺序存储方式和链接存储方式。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="1-常规方式"><a href="#1-常规方式" class="headerlink" title="1. 常规方式"></a>1. 常规方式</h4><p>下标+operator[]</p>
<h4 id="2-使用迭代器遍历"><a href="#2-使用迭代器遍历" class="headerlink" title="2. 使用迭代器遍历"></a>2. 使用迭代器遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>::iterator it = str.<span class="built_in">begin</span>();<span class="comment">//返回第一个位置的迭代器（类似于指针）</span></span><br><span class="line"><span class="keyword">while</span> (it != str.<span class="built_in">end</span>()) <span class="comment">//str.end()是最后一个数据的下一个位置 </span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line">    it++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-新式for循环"><a href="#3-新式for循环" class="headerlink" title="3. 新式for循环"></a>3. 新式for循环</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> ch:s)  <span class="built_in">cout</span>&lt;&lt;ch;</span><br></pre></td></tr></table></figure>



<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a><strong>成员函数</strong></h3><h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len = str.length();</span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h4><p>find() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果指定范围内如果包含指定索引值，返回的是索引值在字符串中的起始位置。如果不包含索引值，返回-1。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>对string字符串进行插入和删除字符操作函数原型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>; <span class="comment">//在指定位置插入n个字符</span></span><br></pre></td></tr></table></figure>

<h4 id="添加字符"><a href="#添加字符" class="headerlink" title="添加字符"></a>添加字符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">str.append(<span class="number">1</span>,ch); <span class="comment">//在末尾添加一个字符ch</span></span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cstring&amp; erase(int pos, int n &#x3D; npos); &#x2F;&#x2F;删除从Pos开始的n个字符</span><br></pre></td></tr></table></figure>

<h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>实现在字符串末尾拼接字符串；重载很多</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span>* str); <span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span> c); <span class="comment">//重载+=操作符s</span></span><br><span class="line">tring&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str); <span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>; <span class="comment">//把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>; <span class="comment">//把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>; <span class="comment">//同operator+=(const string&amp; str)</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span></span>;<span class="comment">//字符串s中从pos开始的n个字符连接到字符串结尾</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：例如在 C++ 中，res += s 和 res = res + s 的含义是不一样的。前者是直接在 res 后面添加字符串；后者是用一个临时对象计算 res + s，会消耗很多时间和内存。</p>
<h4 id="提取子串"><a href="#提取子串" class="headerlink" title="提取子串"></a>提取子串</h4><p>函数substr可以提取string字符串中的子字符串，该函数有两个参数，第一个参数为需要提取的子字符串的起始下标，第二个参数是需要提取的子字符串的长度。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"first second third"</span>;  </span><br><span class="line"><span class="built_in">string</span> s2;  s2 = s1.substr(<span class="number">6</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(str.<span class="built_in">begin</span>(),src.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h4 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">replace()</span><br></pre></td></tr></table></figure>

<h4 id="整型转串"><a href="#整型转串" class="headerlink" title="整型转串"></a>整型转串</h4><p>使用to_string()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> s = to_string(num);</span><br></pre></td></tr></table></figure>

<h4 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h4><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody></table>
<h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-28</title>
    <url>/2020/03/28/2020-03-28-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>820.单词的压缩编码</li>
<li>232.用栈实现队列t</li>
<li>242.有效的字母异位词</li>
</ol>
<a id="more"></a>

<h2 id="820-单词的压缩编码"><a href="#820-单词的压缩编码" class="headerlink" title="820. 单词的压缩编码"></a>820. 单词的压缩编码</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 <code>S</code> 与一个索引列表 <code>A</code>。</p>
<p>例如，如果这个列表是 <code>[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</code>，我们就可以将其表示为 <code>S = &quot;time#bell#&quot;</code> 和 <code>indexes = [0, 2, 5]</code>。</p>
<p>对于每一个索引，我们可以通过从字符串 <code>S</code> 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p>
<p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: words &#x3D; [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</span><br><span class="line">输出: 10</span><br><span class="line">说明: S &#x3D; &quot;time#bell#&quot; ， indexes &#x3D; [0, 2, 5] 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= words.length &lt;= 2000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 7</code></li>
<li>每个单词都是小写字母 。</li>
</ol>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> leni = words[i].length();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="built_in">set</span>.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> lastword = <span class="built_in">set</span>[j];</span><br><span class="line">                <span class="keyword">int</span> lenl = <span class="built_in">set</span>[j].length();</span><br><span class="line">                <span class="keyword">if</span>((leni&lt;=lenl) &amp;&amp; (lastword.substr(lenl-leni,leni)==words[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((leni&gt;lenl) &amp;&amp; (lastword==words[i].substr(leni-lenl,lenl)))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">set</span>.erase(<span class="built_in">set</span>.<span class="built_in">begin</span>()+j);</span><br><span class="line">                    len = len - lenl<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">set</span>.push_back(words[i]);</span><br><span class="line">                len += leni+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果：<strong>超时</strong></p>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：存储后缀"><a href="#方法一：存储后缀" class="headerlink" title="方法一：存储后缀"></a>方法一：存储后缀</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>如果单词 X 是 Y 的后缀，那么单词 X 就不需要考虑了，因为编码 Y 的时候就同时将 X 编码了。例如，如果 words 中同时有 “me” 和 “time”，我们就可以在不改变答案的情况下不考虑 “me”。</p>
<p>如果单词 Y 不在任何别的单词 X 的后缀中出现，那么 Y 一定是编码字符串的一部分。</p>
<p>因此，目标就是保留所有不是其他单词后缀的单词，最后的结果就是这些单词长度加一的总和，因为每个单词编码后后面还需要跟一个 # 符号。</p>
<p><img src="/2020/03/28/2020-03-28-LeetCode-CheckDaily/820_1.gif" alt="fig1"></p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>由数据范围可知一个单词最多含有 7 个后缀，所以我们可以枚举单词所有的后缀。对于每个后缀，如果其存在 words 列表中，我们就将其从列表中删除。为了高效删除，我们将 words 用哈希集合（HashSet）来存储。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">set</span><span class="params">(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="keyword">word</span>: words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="keyword">word</span>.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                <span class="built_in">set</span>.erase(<span class="keyword">word</span>.substr(k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="keyword">word</span>: <span class="built_in">set</span>) &#123;</span><br><span class="line">            ans += <span class="keyword">word</span>.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(\sum w_i^2)$，其中 $w_i$是 words[i] 的长度。每个单词有 $w_i$ 个后缀，对于每个后缀，查询其是否在集合中时需要进行 $O(w_i)$的哈希值计算。</p>
<p>空间复杂度：$O(\sum w_i)$，存储单词的空间开销。</p>
<h4 id="方法二：字典树"><a href="#方法二：字典树" class="headerlink" title="方法二：字典树"></a>方法二：字典树</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>如方法一所说，目标就是保留所有不是其他单词后缀的单词。</p>
<h5 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h5><p>去找到是否不同的单词具有相同的后缀，我们可以将其反序之后插入字典树中。例如，我们有 “time” 和 “me”，可以将 “emit” 和 “em” 插入字典树中。</p>
<p><img src="/2020/03/28/2020-03-28-LeetCode-CheckDaily/820_2.jpg" alt="fig2"></p>
<p>然后，字典树的叶子节点（没有孩子的节点）就代表没有后缀的单词，统计叶子节点代表的单词长度加一的和即为我们要的答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">    TrieNode* children[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) children[i] = <span class="literal">NULL</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TrieNode* <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (children[c - <span class="string">'a'</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> children[c - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        TrieNode* trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;TrieNode*, <span class="keyword">int</span>&gt; nodes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> <span class="keyword">word</span> = words[i];</span><br><span class="line">            TrieNode* cur = trie;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="keyword">word</span>.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                cur = cur-&gt;<span class="built_in">get</span>(<span class="keyword">word</span>[j]);</span><br><span class="line">            nodes[cur] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [node, idx] : nodes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += words[idx].length() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(\sum w_i)$，其中 $w_i$是 <code>words[i]</code>的长度。对于每个单词中的每个字母，只需要进行常数次操作。</p>
<p>空间复杂度：$O(S*\sum w_i)$，字典树的空间开销，其中 <code>S</code> 为字符集大小。</p>
<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a>232. 用栈实现队列</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (63.49%)</td>
<td align="center">151</td>
<td align="center">-</td>
</tr>
</tbody></table>
<details style="color: rgb(212, 212, 212); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, Ubuntu, &quot;Droid Sans&quot;, sans-serif, &quot;Microsoft Yahei UI&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary></details>

<details style="color: rgb(212, 212, 212); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, Ubuntu, &quot;Droid Sans&quot;, sans-serif, &quot;Microsoft Yahei UI&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Companies</strong></summary></details>

<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) – 将一个元素放入队列的尾部。</li>
<li>pop() – 从队列首部移除元素。</li>
<li>peek() – 返回队列首部的元素。</li>
<li>empty() – 返回队列是否为空。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyQueue queue &#x3D; new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.pop();   &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.empty(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ul>
<li>你只能使用标准的栈操作 – 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sst;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            sst.push(st.top());</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = sst.top();</span><br><span class="line">        sst.pop();</span><br><span class="line">        <span class="keyword">while</span>(!sst.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(sst.top());</span><br><span class="line">            sst.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sst;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            sst.push(st.top());</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = sst.top();</span><br><span class="line">        <span class="keyword">while</span>(!sst.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(sst.top());</span><br><span class="line">            sst.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (58.98%)</td>
<td align="center">170</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>你可以假设字符串只包含小写字母。</p>
<p><strong>进阶:</strong><br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        sort(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s==t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;       <span class="comment">//构建哈希数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:s)</span><br><span class="line">            hash[n-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:t)</span><br><span class="line">            hash[n-<span class="string">'a'</span>]--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(hash[i]!=<span class="number">0</span>)   <span class="keyword">return</span> <span class="literal">false</span>;          <span class="comment">//如果两数组不完全相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-27</title>
    <url>/2020/03/27/2020-03-27-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>914.卡牌分组</li>
<li>226.翻转二叉树</li>
<li>231.2的幂</li>
<li>278.第一个错误的版本</li>
<li>258.各位相加</li>
</ol>
<a id="more"></a>

<h2 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a>914. 卡牌分组</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<ul>
<li>每组都有 <code>X</code> 张牌。</li>
<li>组内所有的牌上都写着相同的整数。</li>
</ul>
<p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,2,2,2,3,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]</span><br></pre></td></tr></table></figure>

<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,2,2,2,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[2,2]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>1 &lt;= deck.length &lt;= 10000</li>
<li>0 &lt;= deck[i] &lt; 10000</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>思路：统计各个数字的个数，然后求最大公约数；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!deck.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:deck)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[n]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="built_in">map</span>[deck[<span class="number">0</span>]];</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator  iter;</span><br><span class="line">       	<span class="keyword">for</span>(iter = <span class="built_in">map</span>.<span class="built_in">begin</span>(); iter != <span class="built_in">map</span>.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        &#123;</span><br><span class="line">           res = gcd(res,iter-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res&gt;=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: deck) cnt[x]++;</span><br><span class="line">        <span class="keyword">int</span> g = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)<span class="keyword">if</span>(cnt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (~g) g = gcd(g, cnt[i]);</span><br><span class="line">            <span class="keyword">else</span> g = cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g &gt;= <span class="number">2</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：<code>O(N log C)</code>，其中<code>N</code> 是卡牌的个数，<code>C</code> 是数组 <code>deck</code> 中数的范围，在本题中 C 的值为 10000。求两个数最大公约数的复杂度是 <code>O(log C)</code>，需要求最多 <code>N-1</code>次。</p>
<p>空间复杂度：<code>O(N + C)</code> 或 <code>O(N)</code>。</p>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (74.43%)</td>
<td align="center">393</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>翻转一棵二叉树。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>递归思路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        swap(root-&gt;left,root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            invertTree(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            invertTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a>231. 2的幂</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (47.79%)</td>
<td align="center">173</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个函数来判断它是否是 2 的幂次方。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: true</span><br><span class="line">解释: 20 &#x3D; 1</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 16</span><br><span class="line">输出: true</span><br><span class="line">解释: 24 &#x3D; 16</span><br></pre></td></tr></table></figure>

<h4 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a><strong>示例 3</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 218</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><p>位操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=n&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(res&gt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278.第一个错误的版本"></a>278.第一个错误的版本</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (37.51%)</td>
<td align="center">148</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 n &#x3D; 5，并且 version &#x3D; 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><p>使用二分查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">            &#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：求mid的时候要防止int溢出。</p>
<h2 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258. 各位相加"></a>258. 各位相加</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (65.90%)</td>
<td align="center">219</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 38</span><br><span class="line">输出: 2 </span><br><span class="line">解释: 各位相加的过程为：3 + 8 &#x3D; 11, 1 + 1 &#x3D; 2。 由于 2 是一位数，所以返回 2。</span><br></pre></td></tr></table></figure>

<h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a><strong>进阶</strong></h5><p>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p>
<h3 id="我的解法-4"><a href="#我的解法-4" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;=<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=num%<span class="number">10</span>;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=num;</span><br><span class="line">        <span class="keyword">return</span> sum&lt;<span class="number">10</span>?sum:addDigits(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h3><p>时间复杂度为O(1)的解法：</p>
<ul>
<li><p>除个位外，每一位上的值都是通过(9+1)进位的过程得到的，想一下拨算盘进位</p>
</li>
<li><p>把整数n看成n样物品，原本是以10个1份打包的，现在从这些10个1份打包好的里面，拿出1个，让它们以9个为1份打包。</p>
<p>这样就出现了两部分的东西：</p>
</li>
<li><p>原本10个现在9个1份的，打包好的物品，这些，我们不用管零散的物品，它们还可以分成：</p>
<ul>
<li>从原来打包的里面拿出来的物品，<strong>它们的总和 =》 原来打包好的份数 =》 10进制进位的次数 =》 10进制下，除个位外其他位上的值的总和</strong></li>
<li>以10个为1份打包时，打不进去的零散物品 =》 10进制个位上的值</li>
</ul>
</li>
<li><p>如上零散物品的总数，就是第一次处理num后得到的累加值<br>如果这个累加值&gt;9，那么如题就还需要将各个位上的值再相加，直到结果为个位数为止。也就意味着还需要来一遍如上的过程。</p>
<p>那么按照如上的思路，似乎可以通过n % 9得到最后的值。但是有1个关键的问题，如果num是9的倍数，那么就不适用上述逻辑。原本我是想得到n被打包成10个1份的份数+打不进10个1份的散落个数的和。通过与9取模，去获得那个不能整除的1，作为计算份数的方式，但是如果可以被9整除，我就无法得到那个1，也得不到个位上的数。<br>所以需要做一下特殊处理，<code>(num - 1) % 9 + 1</code><br>可以这么做的原因：原本可以被完美分成9个为一份的n样物品，我故意去掉一个，那么就又可以回到上述逻辑中去得到我要的n被打包成10个一份的份数+打不进10个一份的散落个数的和。而这个减去的1就相当于从，在10个1份打包的时候散落的个数中借走的，本来就不影响原来10个1份打包的份数，先拿走再放回来，都只影响散落的个数，所以没有关系。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>对极约束</title>
    <url>/2020/03/26/2020-03-26-Epipolar-constraint/</url>
    <content><![CDATA[<p>本文旨在了解一下几点：</p>
<ol>
<li>对极约束是什么</li>
<li>基础矩阵F</li>
<li>F的秩有什么意义</li>
<li>本质矩阵E</li>
<li>E与F的区别与联系</li>
</ol>
<a id="more"></a>

<h2 id="对极约束"><a href="#对极约束" class="headerlink" title="对极约束"></a>对极约束</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>在已知 2D像素坐标的前提下，根据两幅图像间多组2D像素点对来估计相机的运动。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><p><img src="/2020/03/26/2020-03-26-Epipolar-constraint/image-20200326152746588.png" alt="image-20200326152746588"></p>
<p>如上图所示，我们希望求取两帧图像 $I_1$,$ I_2$ 之间的运动，设第一帧到第二帧的运动为 $R$，$t$。两个相机中心分别为 $O_1$,$O_2$。现在，考虑 $I_1$ 中有一个特征点 $p_1$，它在 $I_2$ 中对应着特征点 $p_2$。我们知道两者是通过特征匹配得到的。首先，连线 $O_2P$与$O_1P$ 在三维空间中会相交于点 P。由$O_1$, $O_2$, $P$ 三点确定的平面为<strong>极平面</strong>（<code>Epipolar plane</code>）。$O_1O_2$ 连线与像平面 $I_1$, $I_2$ 的交点$e_1$, $e_2$ 称为<strong>极点</strong>（<code>Epipoles</code>），$O_1O_2$ 被称为<strong>基线</strong>（<code>Baseline</code>）。我们称极平面与两个像平面 $I_1$, $I_2$ 之间的相交线 $l_1$, $l_2$ 为<strong>极线</strong>（<code>Epipolar line</code>）。</p>
<p>设P的空间位置为 $P=[X,Y,Z]^T$。则根据针孔模型，两个像素点$p_1,p_2$的像素位置为:<br>$$<br>s_1p_1=KP,s_2p_2=K(RP+t)<br>$$<br>其中，K为相机内参矩阵，R，t为两个坐标系的相机运动。具体来说，计算的是$R_{21}$，$t_{21}$，因为他们把第一个坐标系下的坐标转换到了第二个坐标系下。其也可写作是李代数形式。</p>
<p>尺度意义下相等记作：$sp\simeq p$，可表示投影关系。</p>
<p>因此有:<br>$$<br>x_1=K^{-1}p_1, x_2=K^{-1}p_2<br>$$<br>其中，$x_1$,$x_2$表示像素点在归一化平面上的坐标。代入上式，得：<br>$$<br>x_2\simeq Rx_1+t<br>$$<br>两边同时左乘<code>t^</code>。因此得到:<br>$$<br>t^{.}x_2\simeq t^{.}Rx_1<br>$$<br>然后同时左乘<code>x2^</code>，得到</p>
<p><img src="/2020/03/26/2020-03-26-Epipolar-constraint/image-20200326155950749.png" alt="image-20200326155950749"></p>
<p>重新带入$p_1,p_2$有:</p>
<p><img src="/2020/03/26/2020-03-26-Epipolar-constraint/image-20200326160100489.png" alt="image-20200326160100489"></p>
<p>上述两式称为<strong>对极约束</strong>。</p>
<p><strong>几何意义</strong>:    $O_1,P,O_2$三者共面。</p>
<p>把中间部分记作两个矩阵，基础矩阵F和本质矩阵E，可进一步检核对极约束：<code>E=t^R</code>，$F=K^{-T}EK^{-1}$，$x^T_2Ex^1=p^T_2Fp_1=0$。</p>
<p>可看出，对极约束简洁地给出了两个匹配点之间的中间位置关系。</p>
<p>于是位子估计变为以下两部:</p>
<ol>
<li>根据配对点的像素为最初求出E或者F。</li>
<li>根据E或者F求出R,t。</li>
</ol>
<p>由于E和F只相差了相机内参，而内参在SLAM通常是已知的，因此实践中往往使用形式更简单的E。</p>
<h2 id="基础矩阵F"><a href="#基础矩阵F" class="headerlink" title="基础矩阵F"></a>基础矩阵F</h2><h2 id="本质矩阵E"><a href="#本质矩阵E" class="headerlink" title="本质矩阵E"></a>本质矩阵E</h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>对极约束</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表与C++</title>
    <url>/2020/03/26/2020-03-26-Hash-Table/</url>
    <content><![CDATA[<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<p>本节将介绍哈希表的基本概念，与C++实现方法。</p>
<a id="more"></a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>若关键字为<strong>k</strong>，则其值存放在<strong>f(k)</strong>的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系<strong>f</strong>为散列函数，按这个思想建立的表为散列表。</p>
</li>
<li><p>对不同的关键字可能得到同一散列地址，即<code>k1≠k2</code>，而<code>f(k1)=f(k2)</code>，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数<code>f(k)</code>和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。</p>
</li>
<li><p>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</p>
</li>
</ol>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。</p>
<p>实际工作中需视不同的情况采用不同的哈希函数，通常考虑的因素有：</p>
<ol>
<li><p>计算哈希函数所需时间</p>
</li>
<li><p>关键字的长度</p>
</li>
<li><p>哈希表的大小</p>
</li>
<li><p>关键字的分布情况</p>
</li>
<li><p>记录的查找频率</p>
</li>
</ol>
<h3 id="1-直接寻址法"><a href="#1-直接寻址法" class="headerlink" title="1. 直接寻址法"></a>1. 直接寻址法</h3><p>取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种<a href="https://baike.baidu.com/item/散列函数" target="_blank" rel="noopener">散列函数</a>叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。</p>
<h3 id="2-数字分析法"><a href="#2-数字分析法" class="headerlink" title="2. 数字分析法"></a>2. 数字分析法</h3><p>分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p>
<h3 id="3-平方取中法"><a href="#3-平方取中法" class="headerlink" title="3. 平方取中法"></a>3. 平方取中法</h3><p>当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。 [1] </p>
<p>例：我们把英文字母在字母表中的位置序号作为该英文字母的内部编码。例如K的内部编码为11，E的内部编码为05，Y的内部编码为25，A的内部编码为01, B的内部编码为02。由此组成关键字“KEYA”的内部代码为11052501，同理我们可以得到关键字“KYAB”、“AKEY”、“BKEY”的内部编码。之后对关键字进行平方运算后，取出第7到第9位作为该关键字哈希地址，如下图所示</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>内部编码</th>
<th>内部编码的平方值</th>
<th>H(k)关键字的哈希地址</th>
</tr>
</thead>
<tbody><tr>
<td>KEYA</td>
<td>11052501</td>
<td>122157778355001</td>
<td>778</td>
</tr>
<tr>
<td>KYAB</td>
<td>11250102</td>
<td>126564795010404</td>
<td>795</td>
</tr>
<tr>
<td>AKEY</td>
<td>01110525</td>
<td>001233265775625</td>
<td>265</td>
</tr>
<tr>
<td>BKEY</td>
<td>02110525</td>
<td>004454315775625</td>
<td>315</td>
</tr>
</tbody></table>
<h3 id="4-折叠法"><a href="#4-折叠法" class="headerlink" title="4. 折叠法"></a>4. 折叠法</h3><p>将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。</p>
<h3 id="5-随机数法"><a href="#5-随机数法" class="headerlink" title="5. 随机数法"></a>5. 随机数法</h3><p>选择一随机函数，取关键字的随机值作为散列地址，即$H(key)=random(key)$其中random为随机函数,通常用于关键字长度不等的场合。</p>
<h3 id="6-除留余数法"><a href="#6-除留余数法" class="headerlink" title="6. 除留余数法"></a>6. 除留余数法</h3><p>取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即$H(key) = key \mod p,p&lt;=m$。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。</p>
<h2 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h2><h3 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1. 开放寻址法"></a>1. 开放寻址法</h3><p>$H_i=(H(key) + d_i) MOD m,i=1,2，…，k(k&lt;=m-1）$，其中<code>H(key）</code>为散列函数，<code>m</code>为散列表长，$d_i$为增量序列，可有下列三种取法：<br>1.1. di=1,2,3，…，m-1，称线性探测再散列；<br>1.2. di=1^2,-1^2,2^2,-2^2，⑶^2，…，±（k)^2,(k&lt;=m/2）称二次探测再散列；<br>1.3. di=伪随机数序列，称伪随机探测再散列。</p>
<h3 id="2-再散列法"><a href="#2-再散列法" class="headerlink" title="2. 再散列法"></a>2. 再散列法</h3><p>$H_i=RH_i(key), i=1,2，…，k$ ,$RH_i$均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。</p>
<h3 id="3-链地址法（拉链法）"><a href="#3-链地址法（拉链法）" class="headerlink" title="3. 链地址法（拉链法）"></a>3. 链地址法（拉链法）</h3><h3 id="4-建立一个公共溢出区"><a href="#4-建立一个公共溢出区" class="headerlink" title="4. 建立一个公共溢出区"></a>4. 建立一个公共溢出区</h3><h2 id="查找性能"><a href="#查找性能" class="headerlink" title="查找性能"></a>查找性能</h2><p>​        散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平均查找长度来衡量。<br>​        查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素：</p>
<ol>
<li>散列函数是否均匀；</li>
<li>处理冲突的方法；</li>
<li>散列表的装填因子。<br>散列表的装填因子定义为：α= 填入表中的元素个数 / 散列表的长度<br>α是散列表装满程度的标志因子。由于表长是定值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。<br>实际上，散列表的平均查找长度是装填因子α的函数，只是不同处理冲突的方法有不同的函数。</li>
</ol>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>C++中的STL提供了hash_map来实现哈希表功能，但在C++11中，<code>unordered_map</code>作为一种关联容器，替代了<code>hash_map</code>，<code>unordered_map</code>的底层实现是<code>hash</code>表，所以被称为无序关联容器。<br>不管是map还是unordered_map都是一种 key-map(value) 映射的容器，提供非常高的查找效率，下面我们来了解<code>unordered_map</code>的用法。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>在讲解<code>unordered_map</code>之前，我们先得了解一些预备知识：</p>
<h4 id="元素类型"><a href="#元素类型" class="headerlink" title="元素类型"></a>元素类型</h4><p>除常用的语言内置类型以外，<code>unordered_map</code>的元素类型大致有以下几种：</p>
<ul>
<li>value_type : unordered_map元素类型，这种类型的形式为 key-map类型，key和map的类型都是模板类型。</li>
<li>key_type : key，模板类型</li>
<li>mapped_type ：map，即我们常说的value，模板类型</li>
<li>pair类型 ：pair类型也是STL中的常用类型，原型为template &lt;class T1, class T2&gt; struct pair;由于unordered_map使用的就是Key-Map匹配对，所以在这里使用比较多。</li>
</ul>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>插槽：英文为bucket，又可以翻译成桶。在hash表中，hash函数通常返回一个整型(或无符号整型)元素，对应hash表的数组下标，但是数组类型通常为指针指向一片内存或者是一个链表头，对应许多元素，就像一个桶可以装很多元素，这里称为插槽。</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">unordered_map</span> <span class="params">( size_type n = N,<span class="keyword">const</span> hasher&amp; hf = hasher(),<span class="keyword">const</span> key_equal&amp; eql = key_equal(),<span class="keyword">const</span> allocator_type&amp; alloc = allocator_type() )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个构造函数接受无参数构造</p>
<ul>
<li>n：为hash表的最小插槽数，如果未指定，将会被自动确定(取决于特定的库实现，并不固定)</li>
<li>hf: hash函数，因为底层实现是hash表，必然就有hash函数，STL提供了非常全面的不同类型的hash函数实现，也可以自己实现hash函数。</li>
<li>key_equal:判断两个key对象的hash值相等以确定查找的命中，STL提供了大部分的不同类型的key_equal实现，同样也可以实现hash函数</li>
<li>alloc：容易使用的内存构造器，可选择不同的内存构建方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explicit unordered_map ( const allocator_type&amp; alloc );</span><br></pre></td></tr></table></figure>

<p>指定unordered_map的构造器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class InputIterator&gt;</span><br><span class="line">unordered_map ( InputIterator first, InputIterator last,size_type n &#x3D; N,const hasher&amp; hf &#x3D; hasher(),const key_equal&amp; eql &#x3D; key_equal(),const allocator_type&amp; alloc &#x3D; allocator_type() );</span><br></pre></td></tr></table></figure>

<p>接收输入迭代器构造方式，将迭代器指向的元素区间进行复制构造</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unordered_map ( const unordered_map&amp; ump );</span><br><span class="line">unordered_map ( const unordered_map&amp; ump, const allocator_type&amp; alloc );</span><br></pre></td></tr></table></figure>

<p>复制构造，第二个可指定构造器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unordered_map ( unordered_map&amp;&amp; ump );</span><br><span class="line">unordered_map ( unordered_map&amp;&amp; ump, const allocator_type&amp; alloc );</span><br></pre></td></tr></table></figure>

<p>移动构造方式，这个C++11中新支持的特性，移动构造方式提供临时变量的引用，即右值引用的功能,&amp;表示左值引用，&amp;&amp;表示右值引用。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unordered_map ( initializer_list&lt;value_type&gt; il,size_type n &#x3D; N,const hasher&amp; hf &#x3D; hasher(),const key_equal&amp; eql &#x3D; key_equal(),const allocator_type&amp; alloc &#x3D; allocator_type() );</span><br></pre></td></tr></table></figure>

<p>以传入列表的形式构造</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>[<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>](<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>) strmap( &#123;&#123;<span class="string">"name"</span>,<span class="string">"downey"</span>&#125;,&#123;<span class="string">"age"</span>,<span class="string">"500"</span>&#125;&#125; );</span><br></pre></td></tr></table></figure>

<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h5 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">mapped_type&amp; <span class="title">at</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> mapped_type&amp; <span class="title">at</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>根据Key值查找容器内元素，并返回map元素的引用。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mymap=&#123;<span class="string">"key"</span>,<span class="number">111</span>&#125;;</span><br><span class="line"><span class="built_in">map</span>.at(<span class="string">"key"</span>)=<span class="number">123</span>;</span><br><span class="line"><span class="built_in">map</span>.at(<span class="string">"key"</span>)+=<span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<h5 id="begin"><a href="#begin" class="headerlink" title="begin()"></a>begin()</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">local_iterator <span class="title">begin</span> <span class="params">( size_type n )</span></span>;</span><br><span class="line"><span class="function">const_local_iterator <span class="title">begin</span> <span class="params">( size_type n )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>指向容器内第一个元素的迭代器。迭代器访问元素时，it-&gt;first对应key，it-&gt;second对应map(value).</p>
<h5 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">local_iterator <span class="title">end</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function">const_local_iterator <span class="title">end</span> <span class="params">(size_type n)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>指向容器内最后一个元素的后一个位置的迭代器。</p>
<h5 id="cbegin"><a href="#cbegin" class="headerlink" title="cbegin()"></a>cbegin()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const_iterator cbegin() const noexcept;</span><br><span class="line">const_local_iterator cbegin ( size_type n ) const;</span><br></pre></td></tr></table></figure>

<p>返回const类型的第一位置迭代器</p>
<h5 id="cend"><a href="#cend" class="headerlink" title="cend()"></a>cend()</h5><p>返回const类型的最后一个位置的下一位置的迭代器。</p>
<h4 id="清空：clear"><a href="#清空：clear" class="headerlink" title="清空：clear()"></a>清空：clear()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void clear() noexcept;</span><br></pre></td></tr></table></figure>

<p>删除容器内所有元素。</p>
<h4 id="计数：count"><a href="#计数：count" class="headerlink" title="计数：count()"></a>计数：count()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_type count ( const key_type&amp; k ) const;</span><br></pre></td></tr></table></figure>

<p>某个key值对应的map(value)值的数量，因为unordered_map不允许重复元素，所以返回值总是0或1</p>
<h4 id="emplace"><a href="#emplace" class="headerlink" title="emplace()"></a>emplace()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class... Args&gt;</span><br><span class="line">pair&lt;iterator, bool&gt; emplace ( Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure>

<p>如果key元素是唯一的，在unordered_map中插入新元素，使用Args作为元素构造函数的参数来构造这个新元素。参数为右值引用。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mymap.emplace (&quot;NCC-1701&quot;, &quot;J.T. Kirk&quot;);</span><br></pre></td></tr></table></figure>

<p>即可插入相应的map元素</p>
<h4 id="emplace-hint"><a href="#emplace-hint" class="headerlink" title="emplace_hint()"></a>emplace_hint()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class... Args&gt;</span><br><span class="line">iterator emplace_hint ( const_iterator position, Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure>

<p>与emplace()操作一致，position参数则是提供一个建议搜索位置的起点的提示，可以优化执行时间。</p>
<h4 id="判断是否为空：empty"><a href="#判断是否为空：empty" class="headerlink" title="判断是否为空：empty()"></a>判断是否为空：empty()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool empty() const noexcept;</span><br></pre></td></tr></table></figure>

<p>判断容器是否为空，返回bool值</p>
<h4 id="擦除：erase"><a href="#擦除：erase" class="headerlink" title="擦除：erase()"></a>擦除：erase()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iterator erase ( const_iterator position );</span><br><span class="line">size_type erase ( const key_type&amp; k );</span><br><span class="line">iterator erase ( const_iterator first, const_iterator last );</span><br></pre></td></tr></table></figure>

<p>根据不同的索引擦除插槽中的元素.</p>
<h4 id="查找：find"><a href="#查找：find" class="headerlink" title="查找：find()"></a>查找：find()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iterator find ( const key_type&amp; k );</span><br><span class="line">const_iterator find ( const key_type&amp; k ) const;</span><br></pre></td></tr></table></figure>

<p>查找函数，通过key查找一个元素，返回迭代器类型。</p>
<h4 id="查找：bucket"><a href="#查找：bucket" class="headerlink" title="查找：bucket()"></a>查找：bucket()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">bucket</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>以key值寻找元素在容器中的位置。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">str_map map1;</span><br><span class="line">map1.insert(&#123;<span class="string">"downey"</span>,<span class="string">"hello"</span>&#125;);   </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;map1.bucket (it-&gt;first)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">output:</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>从返回值可以看出，即使是插入的第一个元素，位置也不一定是1，这跟容器的hash实现相关。</p>
<h4 id="插入：insert"><a href="#插入：insert" class="headerlink" title="插入：insert()"></a>插入：insert()</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">pair&lt;iterator,bool&gt; insert ( const value_type&amp; val );</span><br></pre></td></tr></table></figure>

<p>直接插入元素类型，返回pair类型，返回值pair第一元素是插入元素迭代器，第二元素表示操作是否成功</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator,bool&gt; <span class="title">insert</span> ( <span class="title">P</span>&amp;&amp; <span class="title">val</span> );</span></span><br></pre></td></tr></table></figure>

<p>移动插入方式，可以传入右值插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">( const_iterator hint, <span class="keyword">const</span> value_type&amp; val )</span></span>;</span><br></pre></td></tr></table></figure>

<p>用户给出一个插入起点以优化查找时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">( const_iterator hint, P&amp;&amp; val )</span></span>;</span><br><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( InputIterator first, InputIterator last )</span></span>;</span><br></pre></td></tr></table></figure>

<p>复制型插入，将(first,last]所包含的内容全部复制插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( <span class="built_in">initializer_list</span>&lt;value_type&gt; il )</span></span>;</span><br></pre></td></tr></table></figure>

<p>插入一个列表形式的元素</p>
<h4 id="比较：key-eq"><a href="#比较：key-eq" class="headerlink" title="比较：key_eq()"></a>比较：key_eq()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回比较关键相等性的函数。获取key equal函数，key_equal函数为判断key值是否匹配，在一般情况下，hash函数并不能保证每一个输入对应一个独一无二的输出，可能多个输入会对应同一个输出，这就是hash冲突。可能一个槽内同时由多个元素，这时候就需要使用key_equal来进行进一步判断。</p>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><h5 id="‘-’-运算符重载"><a href="#‘-’-运算符重载" class="headerlink" title="‘=’ 运算符重载"></a>‘=’ 运算符重载</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&amp; <span class="keyword">operator</span>= ( <span class="keyword">const</span> <span class="built_in">unordered_map</span>&amp; ump );</span><br><span class="line"><span class="built_in">unordered_map</span>&amp; <span class="keyword">operator</span>= ( <span class="built_in">unordered_map</span>&amp;&amp; ump );</span><br><span class="line"><span class="built_in">unordered_map</span>&amp; <span class="keyword">operator</span>= ( intitializer_list&lt;value_type&gt; il );</span><br></pre></td></tr></table></figure>

<p>以不同方式对容器进行赋值。</p>
<h5 id="‘-’-操作符重载"><a href="#‘-’-操作符重载" class="headerlink" title="‘[]’ 操作符重载"></a>‘[]’ 操作符重载</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mapped_type&amp; operator[] ( const key_type&amp; k );</span><br><span class="line">mapped_type&amp; operator[] ( key_type&amp;&amp; k );</span><br></pre></td></tr></table></figure>

<p>[]操作符重载，使得容易可以通过map[Key]的方式进行索引。</p>
<h4 id="重建：rehash"><a href="#重建：rehash" class="headerlink" title="重建：rehash()"></a>重建：rehash()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void rehash( size_type n );</span><br></pre></td></tr></table></figure>

<p>重建hash表，将插槽的数量扩展的n，如果n小于目前插槽数量，这个函数并不起作用。</p>
<h4 id="翻转：reserve"><a href="#翻转：reserve" class="headerlink" title="翻转：reserve()"></a>翻转：reserve()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void reserve ( size_type n );</span><br></pre></td></tr></table></figure>

<p>将容器的插槽数设置成最适合n个元素的情况，这样可以避免多次rehash和直接rehash空间的浪费。</p>
<p>与rehash相比，这个函数由用户给一个插槽数量建议值，由系统去分配空间，而rehash则是指定容器的插槽值</p>
<h4 id="大小：size"><a href="#大小：size" class="headerlink" title="大小：size()"></a>大小：size()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_type size() const noexcept;</span><br></pre></td></tr></table></figure>

<p>返回当前容器中元素的个数</p>
<h4 id="交换：swap"><a href="#交换：swap" class="headerlink" title="交换：swap()"></a>交换：swap()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap ( unordered_map&amp; ump )</span><br></pre></td></tr></table></figure>

<p>交换两个容器的内容，两个容器的类型必须一致，但大小可以不同。</p>
<h4 id="内部信息获取"><a href="#内部信息获取" class="headerlink" title="内部信息获取"></a>内部信息获取</h4><h5 id="get-allocator"><a href="#get-allocator" class="headerlink" title="get_allocator()"></a>get_allocator()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allocator_type get_allocator() const noexcept;</span><br></pre></td></tr></table></figure>

<p>返回容器目前使用的内存构造器。</p>
<h5 id="hash-function"><a href="#hash-function" class="headerlink" title="hash_function()"></a>hash_function()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hasher hash_function() const;</span><br></pre></td></tr></table></figure>

<p>获取hash容器当前使用的hash函数</p>
<h5 id="bucket-count"><a href="#bucket-count" class="headerlink" title="bucket_count()"></a>bucket_count()</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回hash表的插槽值个数，这个函数的值对应构造函数中的n(最小插槽数)参数。</p>
<h5 id="max-bucket-count"><a href="#max-bucket-count" class="headerlink" title="max_bucket_count()"></a>max_bucket_count()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_type max_bucket_count() const noexcept;</span><br></pre></td></tr></table></figure>

<p>返回容器所能支持的最大插槽数，根据平台不同而不同，一般是一个非常大的数字。</p>
<h5 id="bucket-size"><a href="#bucket-size" class="headerlink" title="bucket_size()"></a>bucket_size()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_type bucket_size ( size_type n ) const;</span><br></pre></td></tr></table></figure>

<p>这个函数返回每个插槽中的元素数量。</p>
<h5 id="max-load-factor"><a href="#max-load-factor" class="headerlink" title="max_load_factor()"></a>max_load_factor()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float max_load_factor() const noexcept;</span><br><span class="line">void max_load_factor ( float z );</span><br></pre></td></tr></table></figure>

<p>第一个函数是查询目前容器最大的负载因子，默认为1。</p>
<p>第二个函数是进行最大的负载因子的设置。</p>
<h5 id="max-size"><a href="#max-size" class="headerlink" title="max_size()"></a>max_size()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_type max_size() const noexcept;</span><br></pre></td></tr></table></figure>

<p>容器可支持的元素最大数量，linux平台下，使用4.8.5的STL库中这个值是：268435455</p>
<h5 id="load-factor"><a href="#load-factor" class="headerlink" title="load_factor()"></a>load_factor()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float load_factor() const noexcept;</span><br></pre></td></tr></table></figure>

<p>load factor在中文中被翻译成负载因子，负载因子是容器中元素数量与插槽数量之间的比例。即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load_factor &#x3D; size &#x2F; bucket_count</span><br></pre></td></tr></table></figure>

<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><h5 id="使用迭代器遍历"><a href="#使用迭代器遍历" class="headerlink" title="使用迭代器遍历"></a>使用迭代器遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> n:deck)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">map</span>[n]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=<span class="built_in">map</span>[deck[<span class="number">0</span>]];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator  iter;</span><br><span class="line"><span class="keyword">for</span>(iter = <span class="built_in">map</span>.<span class="built_in">begin</span>(); iter != <span class="built_in">map</span>.<span class="built_in">end</span>(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">    res = gcd(res,iter-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res&gt;=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-26</title>
    <url>/2020/03/26/2020-03-26-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>999.车的可用捕获量</li>
<li>205.同构字符串</li>
<li>217.存在重复元素</li>
<li>219.存在重复元素||</li>
</ol>
<a id="more"></a>

<h2 id="999-车的可用捕获量"><a href="#999-车的可用捕获量" class="headerlink" title="999. 车的可用捕获量"></a>999. 车的可用捕获量</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p>
<p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。</p>
<p>返回车能够在一次移动中捕获到的卒的数量。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><p><img src="/2020/03/26/2020-03-26-LeetCode-CheckDaily/1253_example_1_improved.PNG" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">在本例中，车能够捕获所有的卒。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>上下左右依次遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> col=board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'R'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> right = j+<span class="number">1</span>;right&lt;col;right++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][right]==<span class="string">'B'</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][right]==<span class="string">'p'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            flag++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> left = j<span class="number">-1</span>;left&gt;=<span class="number">0</span>;left--)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][left]==<span class="string">'B'</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][left]==<span class="string">'p'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            flag++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> down = i+<span class="number">1</span>;down&lt;row;down++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[down][j]==<span class="string">'B'</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span>(board[down][j]==<span class="string">'p'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            flag++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> up = i<span class="number">-1</span>;up&gt;=<span class="number">0</span>;up--)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[up][j]==<span class="string">'B'</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span>(board[up][j]==<span class="string">'p'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            flag++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> flag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：<code>O(n^2)</code>中 <code>n</code> 是棋盘的边长。找白色车在棋盘中的位置需要 <code>O(n^2)</code>的时间复杂度，模拟车在四个方向上捕获颜色相反的卒需要 <code>O(n)</code> 的时间复杂度，所以一共需要 <code>O(n^2+n) = O(n^2)</code>的时间复杂度。</p>
<p>空间复杂度：O(1)，只需要常数空间存放若干变量。</p>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, st = <span class="number">0</span>, ed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    st = i;</span><br><span class="line">                    ed = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>;; ++<span class="built_in">step</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> tx = st + <span class="built_in">step</span> * dx[i];</span><br><span class="line">                <span class="keyword">int</span> ty = ed + <span class="built_in">step</span> * dy[i];</span><br><span class="line">                <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= <span class="number">8</span> || ty &lt; <span class="number">0</span> || ty &gt;= <span class="number">8</span> || board[tx][ty] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[tx][ty] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a>205. 同构字符串</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (47.32%)</td>
<td align="center">172</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <strong>t</strong> ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;paper&quot;, t &#x3D; &quot;title&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>你可以假设 <strong><em>s</em></strong> 和 <strong><em>t\</em></strong> 具有相同的长度。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>使用哈希表，对一个字符，去检测其第一次出现的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = t.length();</span><br><span class="line">        <span class="keyword">if</span>(len1!=len2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; sHash;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; tHash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sHash.count(s[i])&amp;&amp;tHash.count(t[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(sHash[s[i]]!=tHash[t[i]])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sHash.count(s[i])||tHash.count(t[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!sHash.count(s[i])&amp;&amp;!tHash.count(t[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                sHash[s[i]]=i;</span><br><span class="line">                tHash[t[i]]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h4 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p><strong>哈希表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.<span class="built_in">find</span>(n)==<span class="built_in">set</span>.<span class="built_in">end</span>())</span><br><span class="line">                <span class="built_in">set</span>.insert(n);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="219-存在重复元素"><a href="#219-存在重复元素" class="headerlink" title="219. 存在重复元素||"></a>219. 存在重复元素||</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (37.80%)</td>
<td align="center">149</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的 <strong>绝对值</strong> 至多为 <em>k</em>。</p>
<h4 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1], k &#x3D; 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,0,1,1], k &#x3D; 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h4 id="示例-3-2"><a href="#示例-3-2" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(nums[i])==<span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">                <span class="built_in">map</span>[nums[i]]=i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="built_in">map</span>[nums[i]]-i)&lt;=k)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">map</span>[nums[i]]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-25</title>
    <url>/2020/03/25/2020-03-25-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>三维形体的表面积t</li>
<li>202.快乐数</li>
<li>204.计算质数</li>
<li>263.丑数</li>
<li>268.缺失数字</li>
</ol>
<a id="more"></a>

<h2 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892. 三维形体的表面积"></a>892. 三维形体的表面积</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在 <code>N * N</code> 的网格上，我们放置一些 <code>1 * 1 * 1</code>  的立方体。</p>
<p>每个值 <code>v = grid[i][j]</code> 表示 v 个正方体叠放在对应单元格 <code>(i, j)</code> 上。</p>
<p>请你返回最终形体的表面积。</p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2]]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure>

<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2],[3,4]]</span><br><span class="line">输出：34</span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,0],[0,2]]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>

<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure>

<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">输出：46</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>计算每一个小方块的面积将其叠加起来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j])</span><br><span class="line">                    sum+=<span class="number">2</span>; <span class="comment">//上下</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;grid[i][j];k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>||grid[i<span class="number">-1</span>][j]<span class="number">-1</span>&lt;k) <span class="comment">//左</span></span><br><span class="line">                        temp++;</span><br><span class="line">                    <span class="keyword">if</span>(i==row<span class="number">-1</span>||grid[i+<span class="number">1</span>][j]<span class="number">-1</span>&lt;k) <span class="comment">//右</span></span><br><span class="line">                        temp++;</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>||grid[i][j<span class="number">-1</span>]<span class="number">-1</span>&lt;k)    <span class="comment">//前</span></span><br><span class="line">                        temp++;</span><br><span class="line">                    <span class="keyword">if</span>(j==col<span class="number">-1</span>||grid[i][j+<span class="number">1</span>]<span class="number">-1</span>&lt;k) <span class="comment">//后</span></span><br><span class="line">                        temp++;</span><br><span class="line">                    sum += temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><p>我们单独计算每一个 <code>v = grid[i][j]</code> 所贡献的表面积，再将所有的 v 值相加就能得到最终形体的表面积：</p>
<p>对于顶面和底面的表面积，如果 <code>v &gt; 0</code>，那么顶面和底面各贡献了 1 的表面积，总计 <code>2</code> 的表面积；</p>
<p>对于四个侧面的表面积，只有在相邻位置的高度小于 v 时，对应的那个侧面才会贡献表面积，且贡献的数量为 <code>v - nv</code>，其中 <code>nv</code> 是相邻位置的高度。我们可以将其写成 <code>max(v - nv, 0)</code>。</p>
<p>举一个例子，对于网格</p>
<p><code>1 5
6 7</code><br>而言，位置 <code>grid[0][1]</code> 的高度为 5：</p>
<p>因为 <code>5 &gt; 0</code>，所以贡献了 <code>2</code> 的顶面和底面表面积；</p>
<p>该位置的上方和右侧没有单元格，可以看成高度为 0，所以分别贡献了 <code>max(5 - 0, 0) = 5</code> 的表面积；</p>
<p>该位置的左侧高度为 1，所以贡献了 <code>max(5 - 1, 0) = 4</code> 的表面积；</p>
<p>该位置的下方高度为 7，所以贡献了 <code>max(5 - 7, 0) = 0</code> 的表面积。</p>
<p>因此 grid[0][1] 贡献的表面积总和为 <code>2 + 5 + 5 + 4 + 0 = 16</code>。</p>
<p><strong>算法</strong></p>
<p>对于每个 <code>v = grid[r][c] &gt; 0</code>，计算 <code>ans += 2</code>，对于 <code>grid[r][c]</code> 四个方向的每个相邻值<code>nv</code> 还要加上 <code>max(v - nv, 0)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dr[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dc[]&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; N; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; ++c)</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] &gt; <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    ans += <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> nr = r + dr[k];</span><br><span class="line">                        <span class="keyword">int</span> nc = c + dc[k];</span><br><span class="line">                        <span class="keyword">int</span> nv = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; N &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; N)</span><br><span class="line">                            nv = grid[nr][nc];</span><br><span class="line"></span><br><span class="line">                        ans += <span class="built_in">max</span>(grid[r][c] - nv, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个算法来判断一个数是不是“快乐数”。</p>
<p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 19</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>本问题的关键在于找到出口，否则会无限循环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">7</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;         </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = n%<span class="number">10</span>;</span><br><span class="line">            sum+=i*i;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isHappy(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>使用“快慢指针”思想找出循环：“快指针”每次走两步，“慢指针”每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。</p>
<p>注意：此题不建议用集合记录每次的计算结果来判断是否进入循环，因为这个集合可能大到无法存储；另外，也不建议使用递归，同理，如果递归层次较深，会直接导致调用栈崩溃。不要因为这个题目给出的整数是int型而投机取巧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">bit</span> = n % <span class="number">10</span>;</span><br><span class="line">            sum += <span class="built_in">bit</span> * <span class="built_in">bit</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = n, fast = n;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = bitSquareSum(slow);</span><br><span class="line">            fast = bitSquareSum(fast);</span><br><span class="line">            fast = bitSquareSum(fast);</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (32.86%)</td>
<td align="center">309</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>

<h3 id="筛法解法"><a href="#筛法解法" class="headerlink" title="筛法解法"></a>筛法解法</h3><p>素数筛法</p>
<p>有一张很好理解的图</p>
<p><img src="/2020/03/25/2020-03-25-LeetCode-CheckDaily/%E7%AD%9B%E6%B3%95.gif" alt="1.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">7</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;         </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = n%<span class="number">10</span>;</span><br><span class="line">            sum+=i*i;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isHappy(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>算法复杂度</strong>： <code>O(N * loglogN)</code></p>
<h2 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263. 丑数"></a>263. 丑数</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (48.98%)</td>
<td align="center">108</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个程序判断给定的数是否为丑数。</p>
<p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 6</span><br><span class="line">输出: true</span><br><span class="line">解释: 6 &#x3D; 2 × 3</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: true</span><br><span class="line">解释: 8 &#x3D; 2 × 2 × 2</span><br></pre></td></tr></table></figure>

<h4 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 14</span><br><span class="line">输出: false </span><br><span class="line">解释: 14 不是丑数，因为它包含了另外一个质因数 7。</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><code>1</code> 是丑数。</li>
<li>输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。</li>
</ol>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>||num==<span class="number">2</span>||num==<span class="number">3</span>||num==<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(num ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> isUgly(num/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> isUgly(num/<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> isUgly(num/<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a>268. 缺失数字</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (54.70%)</td>
<td align="center">227</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。</p>
<h3 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h3 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p>
<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(s+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)</span><br><span class="line">            A[n]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s+<span class="number">1</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(!A[i])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><strong>时间复杂度</strong>：O(n)。集合的插入操作的时间复杂度都是 O(1)，一共插入了 n 个数，时间复杂度为 O(n)。</p>
<p>集合的查询操作的时间复杂度同样是 O(1)，最多查询 n+1 次，时间复杂度为 O(n)。因此总的时间复杂度为 O(n)。<br><strong>空间复杂度</strong>：O(n)。集合中会存储 nn 个数，因此空间复杂度为 O(n)O(n)。</p>
<h3 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h3><p><strong>思路</strong></p>
<p>如果数组是有序的，那么就很容易知道缺失的数字是哪个了。</p>
<p><strong>算法</strong></p>
<p>首先我们对数组进行排序，随后我们可以在常数时间内判断两种特殊情况：0 没有出现在数组的首位，以及 n没有出现在数组的末位。如果这两种特殊情况都不满足，那么缺失的数字一定在 0 和 n 之间（不包括两者）。此时我们可以在线性时间内扫描这个数组，如果某一个数比它前面的那个数大了超过 1，那么这两个数之间的那个数即为缺失的数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Ensure that n is at the last index</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">-1</span>] != len(nums):</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="comment"># Ensure that 0 is at the first index</span></span><br><span class="line">        <span class="keyword">elif</span> nums[<span class="number">0</span>] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If we get here, then the missing number is on the range (0, n)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            expected_num = nums[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] != expected_num:</span><br><span class="line">                <span class="keyword">return</span> expected_num</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n\log n)。由于排序的时间复杂度为 O(n\log n)，扫描数组的时间复杂度为O(n)，因此总的时间复杂度为 O(n\log n)。<br>空间复杂度：O(1)或 O(n)。空间复杂度取决于使用的排序算法，根据排序算法是否进行原地排序（即不使用额外的数组进行临时存储），空间复杂度为 O(1)或 O(n)。</p>
<h3 id="方法三：位运算"><a href="#方法三：位运算" class="headerlink" title="方法三：位运算"></a>方法三：位运算</h3><p><strong>思路</strong></p>
<p>由于异或运算（XOR）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数，因此我们可以通过异或运算找到缺失的数字。</p>
<p><strong>算法</strong></p>
<p>我们知道数组中有 <code>n</code> 个数，并且缺失的数在<code>[0..n]</code>中。因此我们可以先得到 <code>[0..n]</code>的异或值，再将结果对数组中的每一个数进行一次异或运算。未缺失的数在 <code>[0..n]</code> 和数组中各出现一次，因此异或后得到 0。而缺失的数字只在<code>[0..n]</code> 中出现了一次，在数组中没有出现，因此最终的异或结果即为这个缺失的数字。</p>
<p>在编写代码时，由于 <code>[0..n]</code> 恰好是这个数组的下标加上 <code>n</code>，因此可以用一次循环完成所有的异或运算，例如下面这个例子：</p>
<p>下标    0    1    2    3<br>数字    0    1    3    4<br>可以将结果的初始值设为 nn，再对数组中的每一个数以及它的下标进行一个异或运算，即：<br>$$<br>\begin{aligned} \mathrm{missing} &amp;= 4 \wedge (0 \wedge 0) \wedge (1 \wedge 1) \wedge (2 \wedge 3) \wedge (3 \wedge 4) \ &amp;= (4 \wedge 4) \wedge (0 \wedge 0) \wedge (1 \wedge 1) \wedge (3 \wedge 3) \wedge 2 \ &amp;= 0 \wedge 0 \wedge 0 \wedge 0 \wedge 2 \ &amp;= 2 \end{aligned}<br>$$</p>
<p>就得到了缺失的数字为 2。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> missing = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            missing ^= i^nums[i];</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (44.66%)</td>
<td align="center">358</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>删除链表中等于给定值 <strong><em>val\</em></strong> 的所有节点。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val &#x3D; 6</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-4"><a href="#我的解法-4" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;val == val)</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        ListNode *res = head;</span><br><span class="line">        <span class="keyword">while</span>( res )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( res -&gt; next &amp;&amp; res-&gt;next-&gt;val == val )</span><br><span class="line">            &#123;</span><br><span class="line">                res-&gt;next = res-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            res=res-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM中的三角测量</title>
    <url>/2020/03/24/2020-03-24-Triangulation/</url>
    <content><![CDATA[<p>三角测量是SLAM中，利用相机运动估计特征点空间位置的过程。</p>
<p>本节旨在解决以下问题：</p>
<ol>
<li>三角测量的概念</li>
<li>三角测量的过程及代码实现；</li>
<li>三角测量有哪些不确定性</li>
<li>如何提高三角测量的精度</li>
</ol>
<a id="more"></a>

<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>在SLAM中，利用对极几何约束估计相机运动之后，我们还需要通过三角测量来估计地图点的深度。三角测量（三角化）指的是，通过在两处观测同一个点的夹角，从而确定该点的距离。</p>
<p>SLAM中主要用三角化来估计像素点的距离。</p>
<p><img src="/2020/03/24/2020-03-24-Triangulation/%E4%B8%89%E8%A7%92%E6%B5%8B%E9%87%8F.png" alt="image-20200324165223362"></p>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h2><p>按照对极几何的定义，设$x_1,x_2$为两个特征点的归一化坐标，那么他们满足：<br>$$<br>s_1x_1=s_2Rx_2+t.<br>$$<br>经过对极几何之后，已得到了运动$R,t$，需要求解两个特征点的深度$s_1$,$s_2$。</p>
<p>两个深度可以分开算。若先算$s_2$,那么对上市两个做成一个$x_1$^,得：</p>
<p><img src="/2020/03/24/2020-03-24-Triangulation/%E6%96%B9%E7%A8%8B.png" alt="image-20200324170444757"></p>
<p>该式子左侧为0，右侧可看成是$s_2$的一个方程，可以根据它直接求$s_2$。有了$s_2$,$s_1$也非常容易求出。预测就可以得到两帧下的深度，即确定了空间坐标。</p>
<h2 id="3-代码实现；"><a href="#3-代码实现；" class="headerlink" title="3. 代码实现；"></a>3. 代码实现；</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangulation</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="built_in">vector</span>&lt;KeyPoint&gt;&amp; keypoint_1,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="built_in">vector</span>&lt;KeyPoint&gt;&amp; keypoint_2,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt;&amp; matches,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> Mat&amp; R, <span class="keyword">const</span> Mat&amp; t,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="built_in">vector</span>&lt;Point3d&gt;&amp; points</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangulation</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="built_in">vector</span>&lt; KeyPoint &gt;&amp; keypoint_1,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="built_in">vector</span>&lt; KeyPoint &gt;&amp; keypoint_2,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt;&amp; matches,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> Mat&amp; R, <span class="keyword">const</span> Mat&amp; t,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="built_in">vector</span>&lt; Point3d &gt;&amp; points )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mat T1 = (Mat_&lt;<span class="keyword">double</span>&gt; (<span class="number">3</span>,<span class="number">4</span>) &lt;&lt;</span><br><span class="line">	<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	Mat T2 = (Mat_&lt;<span class="keyword">double</span>&gt; (<span class="number">3</span>,<span class="number">4</span>) &lt;&lt;</span><br><span class="line">	R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">	R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">	R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Mat K = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point2d&gt; pts_1, pts_2;</span><br><span class="line">    <span class="keyword">for</span> ( DMatch m:matches )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将像素坐标转换至相机坐标</span></span><br><span class="line">        pts_1.push_back ( pixel2cam( keypoint_1[m.queryIdx].pt, K) );</span><br><span class="line">        pts_2.push_back ( pixel2cam( keypoint_2[m.trainIdx].pt, K) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat pts_4d;</span><br><span class="line">    cv::triangulatePoints( T1, T2, pts_1, pts_2, pts_4d );</span><br><span class="line">    <span class="comment">// 转换成非齐次坐标</span></span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pts_4d.cols; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">        Mat x = pts_4d.col(i);</span><br><span class="line">        x /= x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>,<span class="number">0</span>); <span class="comment">// 归一化</span></span><br><span class="line">        <span class="function">Point3d <span class="title">p</span> <span class="params">(x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>),x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>),x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">	points.push_back( p );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，在main函数中增加三角测量部分，并验证重投影关系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>∗∗ argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// .....</span></span><br><span class="line">	<span class="comment">//􀀀􀀀 三角化</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Point3d&gt; points;</span><br><span class="line">	triangulation( keypoints_1, keypoints_2, matches, R, t, points );</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//􀀀􀀀 验证三角化点与特征点的重投影关系</span></span><br><span class="line">	Mat K = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matches.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Point2d pt1_cam = pixel2cam( keypoints_1[ matches[i].queryIdx ].pt, K );</span><br><span class="line">        <span class="function">Point2d <span class="title">pt1_cam_3d</span> <span class="params">(points[i].x/points[i].z, points[i].y/points[i].z )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"point in the first camera frame: "</span>&lt;&lt;pt1_cam&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"point projected from 3D "</span>&lt;&lt;pt1_cam_3d&lt;&lt;<span class="string">", d="</span>&lt;&lt;points[i].z&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2幅图</span></span><br><span class="line">        Point2f pt2_cam = pixel2cam( keypoints_2[ matches[i].trainIdx ].pt, K );</span><br><span class="line">        Mat pt2_trans = R∗( Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>,<span class="number">1</span>) &lt;&lt; points[i].x, points[i].y, points[i].z ) + t;</span><br><span class="line">        pt2_trans /= pt2_trans.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"point in the second camera frame: "</span>&lt;&lt;pt2_cam&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"point reprojected from second frame: "</span>&lt;&lt;pt2_trans.t()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们打印了每个空间点在两个相机坐标系下的投影坐标与像素坐标——相当于P 的投影位置与看到的特征点位置。由于误差的存在，它们会有一些微小的差异。以下是某一特征点的信息：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">point</span> in the first camera frame: [<span class="number">0.0844072</span>, <span class="number">0.0734976</span>]</span><br><span class="line"><span class="built_in">point</span> projected from <span class="number">3</span>D [<span class="number">0.0843702</span>, <span class="number">0.0743606</span>], d=<span class="number">14.9895</span></span><br><span class="line"><span class="built_in">point</span> in the second camera frame: [<span class="number">0.0431343</span>, <span class="number">0.0459876</span>]</span><br><span class="line"><span class="built_in">point</span> reprojected from second frame: [<span class="number">0.04312769812378599</span>, <span class="number">0.04515455276163744</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>可以看到，误差的量级大约在小数点后第3 位。可以看到，三角化特征点的距离大约为15。</p>
<p>但由于尺度不确定性，我们并不知道这里的15 究竟是多少米。</p>
<h2 id="4-不确定性因素"><a href="#4-不确定性因素" class="headerlink" title="4. 不确定性因素"></a>4. 不确定性因素</h2><ol>
<li>由于<strong>噪声</strong>的存在，我们估得的运动R; t 不一定精确使(1)式为零，所以更常见的做法是求最小二乘解而不是零解。</li>
<li>三角测量是由平移得到的，有平移才会有对极几何中的三角形，才谈得上三角测量。因此，<strong>纯旋转</strong>是无法使用三角测量的，因为对极约束将永远满足。在平移存在的情况下，我们还要关心三角测量的不确定性，这会引出一个三角测量的矛盾</li>
<li>当平移很小时，<strong>像素上的不确定性</strong>将导致较大的深度不确定性。即若特征点运动一个像素x，使得视线角变化了一个角度，那么将测量到深度值有d 的变化。从几何关系可以看出，当t 较大时，d 将明显变小，这说明平移较大时，在同样的相机分辨率下，三角化测量将更精确。对该过程的定量分析可以使用正弦定理得到，不过这里先考虑定性分析。</li>
</ol>
<h2 id="5-如何提高精度"><a href="#5-如何提高精度" class="headerlink" title="5. 如何提高精度"></a>5. 如何提高精度</h2><p>要提高三角化的精度，主要有两种方法：</p>
<ol>
<li>提高特征点的提取精度，也就是提高图像分辨率——但这会导致图像变大，增加计算成本。</li>
<li>使平移量增大。但是，这会导致图像的外观发生明显的变化，比如箱子原先被挡住的侧面显示出来，又比如反射光发生变化，等等。外观变化会使得特征提取与匹配变得困难。</li>
</ol>
<p>总而言之，增大平移，会导致匹配失效；而平移太小，则三角化精度不够——这就是三角化的矛盾。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>面试</tag>
        <tag>三角化</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-24</title>
    <url>/2020/03/24/2020-03-24-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li><p>面试题17.16、按摩师 【每日打卡24】</p>
</li>
<li><p>198、打家劫舍</p>
</li>
<li><p>213、打家劫舍II</p>
</li>
</ol>
<a id="more"></a>

<h2 id="面试题17-16-按摩师"><a href="#面试题17-16-按摩师" class="headerlink" title="面试题17.16 按摩师"></a>面试题17.16 按摩师</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入： [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出： <span class="number">4</span></span><br><span class="line">解释： 选择 <span class="number">1</span> 号预约和 <span class="number">3</span> 号预约，总时长 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span>。</span><br></pre></td></tr></table></figure>

<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入： [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出： <span class="number">12</span></span><br><span class="line">解释： 选择 <span class="number">1</span> 号预约、 <span class="number">3</span> 号预约和 <span class="number">5</span> 号预约，总时长 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span>。</span><br></pre></td></tr></table></figure>

<h4 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入： [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出： <span class="number">12</span></span><br><span class="line">解释： 选择 <span class="number">1</span> 号预约、 <span class="number">3</span> 号预约、 <span class="number">5</span> 号预约和 <span class="number">8</span> 号预约，总时长 = <span class="number">2</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">3</span> = <span class="number">12</span>。</span><br></pre></td></tr></table></figure>

<h4 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h4><p><strong>动态规划</strong></p>
<p>状态转移方程：<br>$$<br>dp[i]=max[dp[i-1],dp[i-2]+nums[i]]<br>$$</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">time</span><span class="params">(s,<span class="number">0</span>)</span></span>;</span><br><span class="line">        time[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        time[<span class="number">1</span>] = max(time[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt; s;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            time[i] = max(time[i<span class="number">-1</span>],time[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time[s<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相似题目：<code>198.打家劫舍</code></p>
<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍|"></a>198. 打家劫舍|</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><p><strong>动态规划</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>( s==<span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( s==<span class="number">1</span> ) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">money</span><span class="params">(s,<span class="number">0</span>)</span></span>;</span><br><span class="line">        money[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        money[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;s;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            money[i]=<span class="built_in">max</span>(money[i<span class="number">-1</span>],money[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money[s<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="213-打家劫舍"><a href="#213-打家劫舍" class="headerlink" title="213. 打家劫舍||"></a>213. 打家劫舍||</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<h4 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,3,6,7,10,7,1,8,5,9,1,4,4,3]</span><br><span class="line">输出：41</span><br></pre></td></tr></table></figure>



<h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>在原来的基础标记是否使用过0号元素。但是考虑情况还不够，需要另外设置一个数组来防止中间标记都消失的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = nums.size();</span><br><span class="line">        <span class="keyword">if</span>( s==<span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( s==<span class="number">1</span> ) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">flag</span><span class="params">(s,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">money</span><span class="params">(s,<span class="number">0</span>)</span></span>;</span><br><span class="line">        money[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        money[<span class="number">1</span>]=max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> money[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">money0</span><span class="params">(s,<span class="number">0</span>)</span></span>;</span><br><span class="line">        money0[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        flag[<span class="number">1</span>] = nums[<span class="number">1</span>]&lt;nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;s<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            money0[i] = max(money0[i<span class="number">-1</span>],money0[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">            flag[i]=money[i<span class="number">-1</span>]&gt;money[i<span class="number">-2</span>]+nums[i]?flag[i<span class="number">-1</span>]:flag[i<span class="number">-2</span>];</span><br><span class="line">            money[i] = max(money[i<span class="number">-1</span>],money[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        money0[s<span class="number">-1</span>] = max(money0[s<span class="number">-2</span>],money0[s<span class="number">-3</span>]+nums[s<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(flag[s<span class="number">-3</span>])</span><br><span class="line">            money[s<span class="number">-1</span>]=money[s<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            money[s<span class="number">-1</span>]=max(money[s<span class="number">-2</span>],money[s<span class="number">-3</span>]+nums[s<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> max(money[s<span class="number">-1</span>],money0[s<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它思路："><a href="#其它思路：" class="headerlink" title="其它思路："></a>其它思路：</h3><ol>
<li>要求第0家和第n-1家永远也不能同时被偷，所以考虑第0家的时候不要包含第n-1家，考虑第n-1家的时候不要包含第0家；用这两个线性表分别去做198题的动态规划，取大的即可</li>
</ol>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>每日打卡</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM初始化</title>
    <url>/2020/03/23/2020-03-24-SLAM%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>本节的学习要点：</p>
<ol>
<li>初始化的目的(单目/双目)</li>
<li>初始化的两种方法</li>
<li>初始化过程</li>
</ol>
<a id="more"></a>

<h2 id="初始化的目的"><a href="#初始化的目的" class="headerlink" title="初始化的目的"></a>初始化的目的</h2><p>​        单目SLAM初始化的目的是 ==<strong>构建初始的三维点云地图（空间点）并为之后的计算提供初始值</strong>==。</p>
<p>​        由于仅从单帧的图像不能得到深度信息，因此需要从图像序列中选取两帧以上的图像以估计相机机姿态并重建出初始的三维点云。</p>
<h2 id="常见的方法"><a href="#常见的方法" class="headerlink" title="常见的方法"></a>常见的方法</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​        追踪一个已知物体。单帧图像的每一个点都对应于空间的一条射线。通过不同角度不同位置扫描同一个物体，期望能够将三维点的不确定性缩小到可接受的范围。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​        基于假设空间存在一个平面物体，选取两帧不同位置的图像，通过计算<strong>单应矩阵</strong>来估计位姿。这类方法在视差较小或者平面上的点靠近某个主点时效果不好。</p>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>​        根据两帧之间的特征点匹配计算<strong>基础矩阵</strong>，进一步估计位姿。这种方法要求存在不共面的特征点。</p>
<h2 id="单目初始化"><a href="#单目初始化" class="headerlink" title="单目初始化"></a>单目初始化</h2><h3 id="方法流程"><a href="#方法流程" class="headerlink" title="方法流程"></a>方法流程</h3><ol>
<li>匹配初始帧；</li>
<li>位姿计算；</li>
<li>三角测量和地图创建；</li>
<li>BA优化。</li>
</ol>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><h4 id="1-匹配初始帧"><a href="#1-匹配初始帧" class="headerlink" title="1. 匹配初始帧"></a>1. 匹配初始帧</h4><p>​        该阶段工作是，根据连续两帧图片中能够匹配的特征点数量来判断其是否可以作为初始帧，即只有连续两帧中能够匹配的特征点的数量大于某个值时才认为该帧（前一帧）为初始帧；<br>​        在ORM-SLAM2中认为连续帧匹配点的数量大于100时可以将前一帧作为初始帧并记录两帧的匹配关系；<br>​        以下是在ORB-SLAM2中相关部分的代码，功能为对两帧图片进行ORB特征点提取并进行匹配，当匹配的点的数量大于100时认为前一帧可以作为初始帧；可以通过修改代码中的参数来调整判断是否能够作为初始帧的条件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nmatches = matcher.SearchForInitialization(mInitialFrame,mCurrentFrame,mvbPrevMatched,mvIniMatches,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>



<h4 id="2-位姿计算"><a href="#2-位姿计算" class="headerlink" title="2. 位姿计算"></a>2. 位姿计算</h4><p>​        得到超过100对匹配点后，ORB-SLAM2同时计算适用于平面场景的单应矩阵H和适用于普通场景的基础矩阵F;<br>方法是：首先由抽样点计算出单次抽样的H（四对点）和F矩阵（八点法）,通过若干次RANSAC抽样计算出最优的H和F矩阵；然后选择最合适的结果作为相机的初始位姿。</p>
<h5 id="2-1-八点法"><a href="#2-1-八点法" class="headerlink" title="2.1. 八点法"></a>2.1. 八点法</h5><p>相机位姿估计问题是为了求解本质矩阵E或者基础矩阵F，然后求解旋转R和平移t。<br> 对于E矩阵认为是一个3*3的矩阵，因为任意常数乘以E不变，所以E矩阵的自由度是8。实际上E矩阵的自由度是5（反对称），但是对于SLAM运算中八点法和五点法区别不大且会增加麻烦所以我们只考虑E矩阵的尺度等价性用八点法来计算），从上式可以看出一对点可以确定一个关于E矩阵的方程，8个自由度就需要8对点来求解E矩阵，这就是八点法。</p>
<h5 id="2-2-计算位姿"><a href="#2-2-计算位姿" class="headerlink" title="2.2 计算位姿"></a>2.2 计算位姿</h5><p>在同时计算单应矩阵和基础矩阵后对两个模型进行打分选择得分高的那个模型用来位姿计算，打分是用求得的E矩阵和F矩阵将前一帧上的特征点投影到下一帧并将下一帧的特征点投影到前一帧来计算重投影误差的和，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat Hn = ComputeH21(vPn1i,vPn2i); <span class="comment">//计算单应矩阵        </span></span><br><span class="line">currentScore = CheckHomography(H21i, H12i, vbCurrentInliers, mSigma); <span class="comment">//进行评分</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat Fn = ComputeF21(vPn1i,vPn2i);<span class="comment">//计算基础矩阵         </span></span><br><span class="line">currentScore = CheckFundamental(F21i, vbCurrentInliers, mSigma);<span class="comment">//   进行评分</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> RH = SH/(SH+SF);<span class="comment">//计算评分比,如果RH&gt;0.4，选择单应矩阵来恢复相机位姿，否则选择基础矩阵来恢复相机位姿。</span></span><br></pre></td></tr></table></figure>

<p>在计算完E矩阵和F矩阵并确定模型后，如果是本质矩阵E，进行SVD分解会得到4组可能的R，t，对这些解进行检查求出唯一真正的解；如果是单应矩阵进行分解（数值法、解析法）得到4组解，利用先验信息进行排除得到唯一解。</p>
<h4 id="3-三角测量和地图创建"><a href="#3-三角测量和地图创建" class="headerlink" title="3. 三角测量和地图创建"></a>3. 三角测量和地图创建</h4><p>已知位姿后通过三角测量可以计算出特征点对应的深度从而生成点云；并以第一帧为世界坐标系创建地图并进行数据关联。</p>
<p>三角测量是指通过在两处观察同一个点的夹角从而确定该点的距离。数学上可以从上式进行求解，设$x_1$,$x_2$是两个特征点的归一化坐标，那么存在<br>$$<br>s_1x_1=s_2Rx_2+t<br>$$<br>现在已知$R$,$t$要求解$s_1$,$s_2$,先求解$s_2$,对上式左乘$x_1$^:</p>
<p><img src="/2020/03/23/2020-03-24-SLAM%E5%88%9D%E5%A7%8B%E5%8C%96/image-20200323214017168.png" alt="image-20200323214017168"></p>
<h5 id="数据关联"><a href="#数据关联" class="headerlink" title="数据关联"></a>数据关联</h5><ol>
<li><strong>地图点与关键帧关联</strong></li>
</ol>
<p>一个地图点可被多个关键帧观测到，将观测到这个地图点的关键帧与这个地图点进行关联，同时记录关键帧上哪一个特征点与这个地图点有关联。对于单目初始化来说，地图点需要关联第一步创建的两个关键帧；地图点与关键帧上的特征点关联后，计算最合适的描述子来描述该地图点，用于之后跟踪的匹配。</p>
<ol start="2">
<li><strong>关键帧与地图点关联</strong></li>
</ol>
<p>一个关键帧上的特征点由多个地图点投影而成，将关键帧与地图点关联。</p>
<ol start="3">
<li><strong>关键帧与关键帧关联</strong></li>
</ol>
<p>关键帧之间会共视一个地图点，如果共视的地图点个数越多，说明这两个关键帧之间的联系越紧密。对于某个关键帧，统计其与其他关键帧共视的特征点个数，如果大于某个阈值，那么将这两个关键帧进行关联。</p>
<ol start="4">
<li><strong>将关键帧和地图点加入到地图中</strong></li>
</ol>
<h4 id="4-BA优化。"><a href="#4-BA优化。" class="headerlink" title="4. BA优化。"></a>4. BA优化。</h4><p>初始化的最后一步将对只有两个关键帧的地图进行BA优化来优化位姿和路标点，以优化后的结果来重新生成点云地图。<br>同局部BA优化来最小化重投影误差不同，全局BA优化是在求解观测误差的最小二乘。由于观测误差的最小二乘是非线性的，利用了雅克比矩阵和H矩阵的稀疏性进行边缘化来简化运算，其中也使用了图优化理论。<br>实际上求解观测误差的最小二乘的过程是较复杂的，在这里就不多赘述了。<br>值得一提的是，由于单目没有尺度，因此在地图尺寸初始化时<strong>选择生成点深度的中位数作为单位尺寸1当作基准</strong>来进行地图的尺寸初始化。</p>
<h2 id="双目初始化"><a href="#双目初始化" class="headerlink" title="双目初始化"></a>双目初始化</h2><p>由于双目和RGB-D相机不需要通过两个相邻帧来恢复地图点深度，所以初始化过程极其相似。</p>
<p>只要得到两个满足条件的关键帧即可开始初始化。</p>
<p>双目/RGB-D相机已知若干个特征点的深度（通过双目匹配、结构光或者飞行时间等深度计算方法），可以求解二维点对应的世界坐标系下的空间点，即已知若干个3D空间点及其投影的位置；此时使用PnP来估计相机运动;PnP问题的求解方法有很多种，包括<code>P3P</code>, <code>DLT</code>,<code>EPnP</code>,<code>UPnP</code>, BA等，其中<code>ORM-SLAM2</code>使用的<code>PnP</code>方法是<code>EPnP</code>,具体计算方不作赘述。</p>
<h2 id="RGB-D初始化"><a href="#RGB-D初始化" class="headerlink" title="RGB-D初始化"></a>RGB-D初始化</h2><ol>
<li>初始化的目的是建立三维的空间点和地图并为之后的计算提供初始值；</li>
<li>同双目/RGB-D SLAM不同，单目SLAM无法从一帧图片中计算出深度，因此初始化需要两帧连续满足条件的图片来进行初始化；</li>
<li>单目SLAM初始化计算位姿是一个对极约束问题，而双目/RGB-D SLAM的初始化计算位姿是一个PnP问题；</li>
<li>在初始化成功后单目SLAM和双目SLAM一样是通过PnP来求解相机位姿的；</li>
<li>单目SLAM尺度不确定性的原因是因为在通过SVD分解E矩阵求解R，t时计算的t是没有单位的；</li>
<li>单目SLAM初始化的过程中对t进行了归一化来固定尺度，即以求解的初始帧的t为单位1，而后的轨迹和平移都将以这个t为单位；</li>
<li>单目SLAM的初始化一定要有一定程度的平移，纯旋转是无法完成初始化的。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>初始化</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-23</title>
    <url>/2020/03/23/2020-03-23-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li><p>876、链表的中间结点 【每日打卡23】</p>
</li>
<li><p>190、颠倒二进制位</p>
</li>
<li><p>191、位1的个数</p>
</li>
</ol>
<a id="more"></a>

<h2 id="876、链表的中间结点"><a href="#876、链表的中间结点" class="headerlink" title="876、链表的中间结点"></a>876、链表的中间结点</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：此列表中的结点 <span class="number">4</span> (序列化形式：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">由于该列表有两个中间结点，值分别为 <span class="number">3</span> 和 <span class="number">4</span>，我们返回第二个结点。</span><br></pre></td></tr></table></figure>

<h3 id="方法一：数组"><a href="#方法一：数组" class="headerlink" title="方法一：数组"></a>方法一：数组</h3><p>思路和算法</p>
<p>链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; A = &#123;head&#125;;</span><br><span class="line">        <span class="keyword">while</span> (A.back()-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            A.push_back(A.back()-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> A[A.size() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度</strong>：<code>O(N)</code>，其中 <code>N</code> 是给定链表中的结点数目。</p>
<p><strong>空间复杂度</strong>：<code>O(N)</code>，即数组 <code>A</code> 用去的空间。</p>
<h4 id="方法二：单指针法"><a href="#方法二：单指针法" class="headerlink" title="方法二：单指针法"></a>方法二：单指针法</h4><p>我们可以对方法一进行空间优化，省去数组 A。</p>
<p>我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ++n;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><p>时间复杂度：O(N)，其中 N 是给定链表的结点数目。</p>
<p>空间复杂度：<code>O(1)</code>，只需要常数空间存放变量和指针。</p>
<h3 id="快慢指针解法"><a href="#快慢指针解法" class="headerlink" title="快慢指针解法"></a>快慢指针解法</h3><p>快慢指针，使用一个快的一个慢的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* back = head;</span><br><span class="line">        ListNode* front = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(back&amp;&amp;front)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( front &amp;&amp;front-&gt;next)</span><br><span class="line">                front=front-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!front)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> back;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!front-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> back-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            back=back-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> back;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：<code>O(n)</code></p>
<p><strong>空间复杂度</strong>：<code>O(1)</code></p>
<h2 id="190、颠倒二进制位"><a href="#190、颠倒二进制位" class="headerlink" title="190、颠倒二进制位"></a>190、颠倒二进制位</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<h4 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>

<h4 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>

<h4 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>

<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>本题考查位操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bit ++;</span><br><span class="line">            <span class="keyword">int</span> i=n&amp;<span class="number">1</span>;</span><br><span class="line">            n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            res=(res&lt;&lt;<span class="number">1</span>)|i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res=bit==<span class="number">0</span>?<span class="number">0</span>:res&lt;&lt;(<span class="number">32</span>-bit);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="191、位1的个数"><a href="#191、位1的个数" class="headerlink" title="191、位1的个数"></a>191、位1的个数</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量" target="_blank" rel="noopener">汉明重量</a>）。</p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000000001011</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000000001011</span> 中，共有三位为 <span class="string">'1'</span>。</span><br></pre></td></tr></table></figure>

<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000010000000</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000010000000</span> 中，共有一位为 <span class="string">'1'</span>。</span><br></pre></td></tr></table></figure>

<h4 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">31</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 中，共有 <span class="number">31</span> 位为 <span class="string">'1'</span>。</span><br></pre></td></tr></table></figure>

<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i+=n&amp;<span class="number">1</span>;</span><br><span class="line">            n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>每日打卡</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP-Algorithm</title>
    <url>/2020/03/22/2020-03-22-KMP-Algorithm/</url>
    <content><![CDATA[<p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？</p>
<h2 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h2><p>如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</p>
<ul>
<li>如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；</li>
<li>如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li>
</ul>
<p>回溯的方法使得算法复杂度上升。</p>
<p>因此需要优化回溯的步骤以简化算法。</p>
<p>源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 字符串下标始于 0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NaiveStringSearch</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">// S 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;    <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> s_len = S.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> p_len = P.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == P[j])  <span class="comment">// 若相等，都前进一步</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>               <span class="comment">// 不相等</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == p_len)        <span class="comment">// 匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(nm)$</p>
<p>当n和m很大的时候不好用。</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p><strong>引入概念</strong></p>
<ul>
<li>前缀：指的是字符串的子串中从原串最前面开始的子串</li>
<li>后缀：指的是字符串的子串中在原串结尾处结尾的子串</li>
</ul>
<p><strong>算法思想</strong></p>
<p>利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。</p>
<p>KMP算法引入了一个next数组，next[i]表示的是前i的字符组成的这个子串。</p>
<p><strong>next数组的意义</strong></p>
<p>next 数组里面的变量，存的是最有可能匹配的长度，也就是在模式串中，前缀和后缀相等的最大长度。</p>
<p>以”ABCDABD”为例</p>
<p>－”A”的前缀和后缀都为空集，共有元素的长度为0；</p>
<p>－”AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</p>
<p>－”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</p>
<p>－”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</p>
<p>－”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</p>
<p>－”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</p>
<p>－”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</p>
<p>next 数组中，第一个值，也就是next [0] = -1，而且，next [n]里面存的是 str[0] ~ str[n - 1]的前缀和后缀相等的最大长度。</p>
<p><strong>源代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p_len = P.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; p_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 S 中找到 P 第一次出现的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GetNext(P, next);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// S 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> s_len = S.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> p_len = P.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len) <span class="comment">// 因为末尾 '\0' 的存在，所以不会越界</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == P[j])  <span class="comment">// P 的第一个字符不匹配或 S[i] == P[j]</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];  <span class="comment">// 当前字符匹配失败，进行跳转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == p_len)  <span class="comment">// 匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; KMP(<span class="string">"bbc abcdab abcdabcdabde"</span>, <span class="string">"abcdabd"</span>, next) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：$O(m+n)$</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第181场周赛</title>
    <url>/2020/03/22/2020-03-20-LeetCode-Contest-181/</url>
    <content><![CDATA[<p>第 181 场周赛</p>
<p>题目列表如下：</p>
<ol>
<li>按既定顺序创建目标数组</li>
<li>四因数</li>
<li>检查网络中是否存在有效路径</li>
<li>最长快乐前缀</li>
</ol>
<a id="more"></a>

<h2 id="1-按既定顺序创建目标数组"><a href="#1-按既定顺序创建目标数组" class="headerlink" title="1. 按既定顺序创建目标数组"></a>1. 按既定顺序创建目标数组</h2><p><strong>题目</strong></p>
<p>给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组：</p>
<ul>
<li>目标数组 target 最初为空</li>
<li>按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] </li>
<li>重复上一步，直到在 nums 和 index 中都没有要读取的元素。<br>请你返回目标数组</li>
</ul>
<p>题目保证数字插入位置总是存在。</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,2,3,4], index &#x3D; [0,1,2,2,1]</span><br><span class="line">输出：[0,4,1,3,2]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">0            0        [0]</span><br><span class="line">1            1        [0,1]</span><br><span class="line">2            2        [0,1,2]</span><br><span class="line">3            2        [0,1,3,2]</span><br><span class="line">4            1        [0,4,1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,0], index &#x3D; [0,1,2,3,0]</span><br><span class="line">输出：[0,1,2,3,4]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">1            0        [1]</span><br><span class="line">2            1        [1,2]</span><br><span class="line">3            2        [1,2,3]</span><br><span class="line">4            3        [1,2,3,4]</span><br><span class="line">0            0        [0,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1], index &#x3D; [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; nums.length, index.length &lt;&#x3D; 100</span><br><span class="line">nums.length &#x3D;&#x3D; index.length</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</span><br><span class="line">0 &lt;&#x3D; index[i] &lt;&#x3D; i</span><br></pre></td></tr></table></figure>

<h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>用Vector容器存放结果,进行一次遍历,将取到的结果插入.</p>
<p><strong>源代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">createTargetArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; index)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.insert(res.<span class="built_in">begin</span>()+index[i],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>: $O(n^2)$</p>
<p><strong>空间复杂度</strong>:$O(1)$</p>
<h2 id="2-四因数"><a href="#2-四因数" class="headerlink" title="2. 四因数"></a>2. 四因数</h2><p>题目:给你一个整数数组 <code>nums</code>，请你返回该数组中恰有四个因数的这些整数的各因数之和。</p>
<p>如果数组中不存在满足题意的整数，则返回 <code>0</code> 。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [21,4,7]</span><br><span class="line">输出：32</span><br><span class="line">解释：</span><br><span class="line">21 有 4 个因数：1, 3, 7, 21</span><br><span class="line">4 有 3 个因数：1, 2, 4</span><br><span class="line">7 有 2 个因数：1, 7</span><br><span class="line">答案仅为 21 的所有因数的和。</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure>

<h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>这道题本身不难,但需要为了降低时间复杂度做出一些调整。比如，计算过的数就不要再计算一次可以使用hash表来存储键对。对每一个数进行计算因子的时候，出现了多于四个的因子就停止计算。我的方法通过了但是相信会有更快速的解法。</p>
<p><strong>源代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumFourDivisors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(num)==<span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">                <span class="built_in">map</span>.insert(make_pair(num,factors(num)));</span><br><span class="line">            sum+=<span class="built_in">map</span>[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">factors</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;=<span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count==<span class="number">3</span>?sum+n:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><p><strong>筛法</strong></p>
<ul>
<li>要注意完全四因数的情况</li>
</ul>
<h2 id="3-检查网格中是否存在有效路径"><a href="#3-检查网格中是否存在有效路径" class="headerlink" title="3. 检查网格中是否存在有效路径"></a>3. 检查网格中是否存在有效路径</h2><p><strong>题目</strong></p>
<p>给你一个 m x n 的网格 grid。网格里的每个单元都代表一条街道。grid[i][j] 的街道可以是：</p>
<p>1 表示连接左单元格和右单元格的街道。<br>2 表示连接上单元格和下单元格的街道。<br>3 表示连接左单元格和下单元格的街道。<br>4 表示连接右单元格和下单元格的街道。<br>5 表示连接左单元格和上单元格的街道。<br>6 表示连接右单元格和上单元格的街道。    </p>
<p><img src="/2020/03/22/2020-03-20-LeetCode-Contest-181/3.png" alt="lee"></p>
<h3 id="DFS解法"><a href="#DFS解法" class="headerlink" title="DFS解法"></a>DFS解法</h3><p>通过构建pipe数组，将每个拼图转化为四个方向上的移动限制图。<br>$pipe[3][2]=3$ ，代表三号拼图可以由向上的方向进入其中，并转向左方向继续前进。<br>$pipe[5][3]=-1$ ，代表五号拼图不可以由向左的方向进入其中。</p>
<p>其中0代表向下、1代表向右、2代表向上、3代表向左、-1代表不可走</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> row,col;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">//0下、1右、2上、3左</span></span><br><span class="line">    <span class="keyword">int</span> pipe[<span class="number">7</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//记录各个拼图块路径的方向，0、1、2、3代表方向，-1代表不可走。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> dir,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( x == row<span class="number">-1</span> &amp;&amp; y == col<span class="number">-1</span> ) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//到达终点</span></span><br><span class="line">        <span class="keyword">int</span> nextx = x + dx[dir] ,nexty = y + dy[dir];</span><br><span class="line">        <span class="keyword">if</span>(nextx&lt;<span class="number">0</span> || nexty&lt;<span class="number">0</span> || nextx &gt;= row || nexty&gt;=col)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//越界</span></span><br><span class="line">        <span class="keyword">int</span> nxt=grid[nextx][nexty]; <span class="comment">//得到下一块拼图的编号</span></span><br><span class="line">        <span class="keyword">if</span>( pipe[nxt][dir]!= <span class="number">-1</span> )</span><br><span class="line">            <span class="keyword">return</span> dfs(nextx,nexty,pipe[nxt][dir],grid); <span class="comment">//如果当前方向可走，则方向改变，继续走。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasValidPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;    </span><br><span class="line">        row=grid.<span class="built_in">size</span>();</span><br><span class="line">        col=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sta=grid[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//起点的拼图编号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)<span class="comment">//朝着四个方向都试一下</span></span><br><span class="line">            <span class="keyword">if</span>(pipe[sta][i]!=<span class="number">-1</span>)<span class="comment">//当前方向可以走</span></span><br><span class="line">                <span class="keyword">if</span>(dfs(<span class="number">0</span>,<span class="number">0</span>,pipe[sta][i],grid))<span class="comment">//沿着当前方向搜索</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//拼图都有两个方向可以走，只要沿着一个初始方向走通就可以。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="4-最长快乐前缀"><a href="#4-最长快乐前缀" class="headerlink" title="4. 最长快乐前缀"></a>4. 最长快乐前缀</h2><p>题目：「快乐前缀」是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串。</p>
<p>给你一个字符串 s，请你返回它的 最长快乐前缀。</p>
<p>如果不存在满足题意的前缀，则返回一个空字符串。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcodeleet&quot;</span><br><span class="line">输出：&quot;leet&quot;</span><br></pre></td></tr></table></figure>

<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPrefix</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j= i;j&lt;len;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[j-i]!=s[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    res = s.substr(i,len-i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果：超时</p>
<h3 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a><strong>Hash算法</strong></h3><p>可以使用 hash 算法，O(n)搞定该问题。</p>
<p>首先假设有一个足够大的数据类型可以装下我们所需要的数字。 后面会优化掉对该假设的依赖。</p>
<p>对于长度为 i 的前缀，我们可以计算其hash值，计算公式如下：<br>$$<br>prefix(i)=∑<em>{j=0}^{i−1}∗(s[i]−′a′)∗salt^j<br>$$<br>对于长度为 i 的后缀，我们可以计算其hash值，设字符串长度为 n，计算公式如下：<br>$$<br>suffix(i) =∑</em>{j=0}^{i−1}(s[n−i+j]−′a′)∗salt_j<br>$$<br>salt 是一个随机数，但最好是一个大的质数。<br>分析上述两个公式会发现，如果长度为 i 的前缀和后缀相等，那么必然有 prefix(i) == suffix(i)。而且在满足前述假设的前提下，不相等的前缀和后缀必然有 prefix(i) ≠ suffix(i)。</p>
<p>但是可惜的是，并没有在大多数编程语言中，并不存在这样的数据类型。从而导致了hash值冲突的问题，即不相等的前缀和后缀其hash值也有可能相同。那么如何解决该问题呢？</p>
<p>借鉴于通用的解决hash冲突的办法，我们可以增加 salt 的个数，以降低冲突的概率。当长度为 i 的前缀和后缀对于所有salt都相等时，我们才认为其真正的相等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; MAXN = <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">uint64_t</span> salt[MAXN] = &#123;<span class="number">1000007</span>, <span class="number">100000007</span>, <span class="number">1000000007</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; feature[<span class="number">2</span>][MAXN];</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPrefix</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">            feature[<span class="number">0</span>][i].resize(s.<span class="built_in">size</span>());</span><br><span class="line">            feature[<span class="number">1</span>][i].resize(s.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">uint64_t</span> mul = <span class="number">1</span>, k = <span class="number">0</span>, n = s.<span class="built_in">size</span>(); k &lt; n; k++, mul *= salt[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">                    feature[<span class="number">0</span>][i][k] = s[<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    feature[<span class="number">0</span>][i][k] = feature[<span class="number">0</span>][i][k<span class="number">-1</span>] + mul*(s[k]-<span class="string">'a'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = s.<span class="built_in">size</span>()<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k == s.<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">                    feature[<span class="number">1</span>][i][k] = s[k]-<span class="string">'a'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    feature[<span class="number">1</span>][i][k] = (s[k]-<span class="string">'a'</span>) + feature[<span class="number">1</span>][i][k+<span class="number">1</span>]*salt[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(feature[<span class="number">0</span>][<span class="number">0</span>][i] == feature[<span class="number">1</span>][<span class="number">0</span>][s.<span class="built_in">size</span>()-i<span class="number">-1</span>]</span><br><span class="line">              &amp;&amp; feature[<span class="number">0</span>][<span class="number">1</span>][i] == feature[<span class="number">1</span>][<span class="number">1</span>][s.<span class="built_in">size</span>()-i<span class="number">-1</span>]</span><br><span class="line">              &amp;&amp; feature[<span class="number">0</span>][<span class="number">2</span>][i] == feature[<span class="number">1</span>][<span class="number">2</span>][s.<span class="built_in">size</span>()-i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> s.substr(<span class="number">0</span>, i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">作者：Time-Limit</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/longest-happy-prefix/solution/c-on-de-hashsuan-fa-sui-ji-wen-ti-kan-lian-guo-by-/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>周赛</tag>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>粒子滤波器</title>
    <url>/2020/03/14/2020-03-15-Particle_Filter/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>粒子滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>高斯混合模型</title>
    <url>/2020/03/14/2020-03-14-GMM/</url>
    <content><![CDATA[<p>高斯混合模型</p>
<a id="more"></a>

<h2 id="高斯混合模型"><a href="#高斯混合模型" class="headerlink" title="高斯混合模型"></a>高斯混合模型</h2><p>概率图模型（ probabilistic graphical model）是一类用图来表达变量相关关系的概率模型。它以图为表示工具，最常见的是用一个结点表示一个或一组随机变量，结点之间的边表示变量间的概率相关关系，即“变量关系图”.根据边的性质不同，概率图模型可大致分为两类：</p>
<p>第一类是使用有向无环图表示变量间的依赖关系，称为有向图模型或贝叶斯网（ Bayesian network）；</p>
<p>第二类是使用无向图表示变量间的相关关系，称为无向图模型或马尔可夫网（ Markovnetwork）</p>
<p><strong>定义</strong></p>
<p>高斯混合模型是指具有如下形式的概率分布模型。<br>$$<br>P(y|\theta)=\sum^K_{k=1}\alpha_k\phi(y|\theta_k)<br>$$<br>其中，$\alpha_k$是系数，$\alpha_k\geq0$,$\sum^K_{k=1}\alpha_k=1$;$\phi(y|\theta_k)$是高斯分布密度，$\theta_k=(\mu_k,\delta^2_k)$;<br>$$<br>\phi(y|\theta_k)=\cfrac{1}{\sqrt{2\pi}\delta^2}exp(-\cfrac{(y-\mu_k)^2}{2\delta^2_k})<br>$$<br>称为第k个分模型。</p>
<p>一般混合模型可以由任意概率分布密度代替上式的高斯分布密度。</p>
<h3 id="高斯混合模型参数估计的EM算法"><a href="#高斯混合模型参数估计的EM算法" class="headerlink" title="高斯混合模型参数估计的EM算法"></a>高斯混合模型参数估计的EM算法</h3><p>概率模型有时既含有观测变量（ observable variable），又含有隐变量或潜在变量（ latent variable）.如果概率模型的变量都是观测变量，那么给定数据，可以直接用极大似然估计法，或贝叶斯估计法估计模型参数。但是，当模型含有隐变量时，就不能简单地使用这些估计方法。EM算法就是含有隐变量的概率模型参数的极大似然估计法，或极大后验概率估计法。我们仅讨论极大似然估计，极大后验概率估计与其类似。</p>
<p>假设观测数据$y_1,y_2,…,y_N$由高斯混合模型生成，<br>$$<br>P(y|\theta)=\sum^K_{k=1}\alpha_k\phi(y|\theta_k)<br>$$<br>其中，$\theta=(\alpha_1,\alpha_2,…,\alpha_k;\theta_1,\theta_2,\theta_k)$。我们用EM算法估计高斯混合模型的参数$\theta$。</p>
<p><strong>EM（期望最大化）算法</strong></p>
<p>输入：观测数据$y_1,y_2,…,y_N$，高斯混合模型；</p>
<p>输出：高斯混合模型参数。</p>
<ol>
<li><p>取参数的初始值开始迭代</p>
</li>
<li><p>求E步，根据当前模型参数，计算分模型k对观测数据$y_j$的相应度<br>$$<br>\hat{\gamma}<em>{jk}=\cfrac{\alpha_k\phi(y_j|\theta_k)}{\sum^K</em>{k=1}\alpha_k\phi(y_j|\theta_k)}，j=1,2,…N;k=1,2,..K<br>$$</p>
</li>
<li><p>求M步:计算新一轮的迭代的模型参数：<br>$$<br>\hat{\mu}<em>k=\cfrac{\sum^N</em>{j=1}\hat{\gamma}<em>{jk}y_j}{\sum^N</em>{j=1}\hat{\gamma}_{jk}},k=1,2,..,K<br>$$</p>
</li>
</ol>
<p>$$<br>\hat{\delta_k}^2=\cfrac{\sum^N_{j=1}\hat{gamma}<em>{jk}(y_j-\mu_k)^2}{\sum^N</em>{j=1}\hat{\gamma}_{jk}},k=1,2,…K<br>$$</p>
<p>$$<br>\hat{\alpha}<em>k=\cfrac{\sum^N_j=1\hat{\gamma</em>{jk}}}{N},k=1,2,…,K<br>$$</p>
<ol start="4">
<li>重复第二步和第三步，直至收敛。</li>
</ol>
<h2 id="GMM-HMM"><a href="#GMM-HMM" class="headerlink" title="GMM-HMM"></a>GMM-HMM</h2><p><img src="/2020/03/14/2020-03-14-GMM/20140528175313171.png" alt="20140528175313171"></p>
<p>语音识别系统主要由信号处理和特征提取、声学模型（AM）、语言模型（LM）和解码搜索部分。</p>
<ul>
<li>信号处理和特征提取部分以音频信号为输入，通过消除噪声和信道失真对语音进行增强，将信号从时域转化到频域，并为声学模型提取合适的特征向量。</li>
<li>声学模型将声学和发音学（phonetics）进行整合，以特征向量作为输入，并为可变长特征序列生成声学模型分数。</li>
<li>语言模型学习词与词间的相互关系，来评估序列的可能性。</li>
<li>解码搜索对给定特征向量序列和若干假设次序列计算声学模型和语言模型分数，并输出得分最高的结果</li>
</ul>
<p>语音识别系统中经常使用基于GMM-HMM的声学模型。</p>
<p><strong>GMM被整合进HMM中，用来拟合基于状态的输出分布。</strong></p>
<p>用GMM建模声学特征（Acoustic Feature）$O_1,O_2,…,O_n$，可以理解成：</p>
<ul>
<li>每一个特征是由一个音素确定的，即不同特征可以按音素来聚类。由于在HMM中音素被表示为隐变量（状态），故等价于：</li>
<li>每一个特征是由某几个状态确定的，即不同特征可以按状态来聚类。</li>
<li>则设$P(O|S_i)$符合正态分布，则根据GMM的知识，$O_1,O_2,…,O_n$实际上就是一个混合高斯模型下的采样值。</li>
</ul>
<p>若包含了语音顺序信息，GMM不再是一个好模型，因为它不包含任何顺序信息。当给定HMM的一个状态后，若要对属于该状态的语音特征向量的概率分布进行建模，GMM仍不失为一个好的模型。因此，GMM被整合进HMM中，用来拟合基于状态的输出分布。</p>
<p><strong>利用声学特征训练HMM</strong></p>
<p>确定状态转移矩阵，是执行解码问题的基础。</p>
<p>而状态转移矩阵的确定即等价于HMM的训练问题（即状态转移矩阵u=max(P(u|O))，从语音特征序列中利用EM算法学习得到状态转移矩阵。</p>
<h2 id="应用GMM-HMM模型识别语音"><a href="#应用GMM-HMM模型识别语音" class="headerlink" title="应用GMM-HMM模型识别语音"></a>应用GMM-HMM模型识别语音</h2><p><img src="/2020/03/14/2020-03-14-GMM/..%5Cimages%5CGMM%5C20160901093401467.png" alt></p>
<ul>
<li><strong>对待识别语音做信号预处理</strong></li>
<li><strong>对待识别语音提取声学特征</strong></li>
<li><strong>对声学特征利用Viterbi算法解码</strong></li>
</ul>
<p>对声学特征解码后得到的是状态序列，即音素序列。</p>
<p>如果把声学模型的结果表示为句子，往往效果不尽如意，所以还需要用语言模型把识别出的各个音素纠正为正确的句子</p>
<p><strong>其它应用</strong></p>
<p><img src="/2020/03/14/2020-03-14-GMM/D:%5CProject%5Cgrobenis.github.io%5Cimages%5CHMM%5CHMM_nlp.jpg" alt></p>
<p>将上图中的拼音换成语音，就成了语音识别问题，转移概率仍然是二元语言模型，其输出概率则是语音模型，即语音和汉字的对应模型。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>GMM</tag>
      </tags>
  </entry>
  <entry>
    <title>概率图模型</title>
    <url>/2020/03/14/2020-03-14-Probability_graph_model/</url>
    <content><![CDATA[<p>概率图模型（ probabilistic graphical model）是一类用图来表达变量相关关系的概率模型。它以图为表示工具，最常见的是用一个结点表示一个或一组随机变量，结点之间的边表示变量间的概率相关关系，即“变量关系图”.根据边的性质不同，概率图模型可大致分为两类：第一类是使用有向无环图表示变量间的依赖关系，称为有向图模型或贝叶斯网（ Bayesian network）；第二类是使用无向图表示变量间的相关关系，称为无向图模型或马尔可夫网（ Markovnetwork）</p>
<p>本节将用来介绍概率图模型。</p>
<a id="more"></a>

<h2 id="概率图模型"><a href="#概率图模型" class="headerlink" title="概率图模型"></a>概率图模型</h2><p>概率图模型（ probabilistic graphical model）是一类用图来表达变量相关关系的概率模型。它以图为表示工具，最常见的是用一个结点表示一个或一组随机变量，结点之间的边表示变量间的概率相关关系，即“变量关系图”.</p>
<p><strong>分类</strong></p>
<p>根据边的性质不同，概率图模型可大致分为两类：</p>
<p>第一类是使用有向无环图表示变量间的依赖关系，称为有向图模型或贝叶斯网（ Bayesian network）；</p>
<p>第二类是使用无向图表示变量间的相关关系，称为无向图模型或马尔可夫网（ Markovnetwork）；</p>
<p><strong>前提背景</strong></p>
<p>利用条件独立性可以降低概率模型的计算复杂度；</p>
<p>条件独立性要在图的结构上有所映射；</p>
<p><strong>图的构建方法</strong></p>
<p>拓扑排序;</p>
<p>根据拓扑排序构建的概率图能够得到联合概率的因子分解式；</p>
<p>性质：</p>
<p>如果父节点被观测，则其子节点独立；</p>
<h2 id="因子图"><a href="#因子图" class="headerlink" title="因子图"></a>因子图</h2><p>有向图：$P(x)=\Pi(x_i|x_{pa_i})$</p>
<p>无向图：$P(x)=\cfrac{1}{Z}\Pi^k_{i=1}\phi_{c_i}(x_{c_i})$</p>
<p>道德图：有向图 → 无向图</p>
<p>出发点：</p>
<ol>
<li>引入环</li>
<li>简便</li>
</ol>
<p>因子图把因子引入图里边。</p>
<p><img src="/2020/03/14/2020-03-14-Probability_graph_model/%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="factor_graph"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>概率图</tag>
      </tags>
  </entry>
  <entry>
    <title>Kalman滤波器学习</title>
    <url>/2020/03/14/2020-03-13-Kalman_Filter/</url>
    <content><![CDATA[<p>概率图+时间=动态系统</p>
<p>​    对概率图模型考虑其时间序列，可以得到动态系统。根据动态系统的隐状态的连续性和分布可以把系统大致分为三类：</p>
<ol>
<li>若隐状态离散，不要求分布，则为隐马尔可夫模型</li>
<li>如果隐状态连续、线性且服从高斯分布，则为Kalman滤波器（线性高斯模型）</li>
<li>如果隐状态连续且非线性，作为得到粒子滤波器</li>
</ol>
<p>本节主要来介绍kalman滤波器。</p>
<a id="more"></a>

<h2 id="Kalman滤波器"><a href="#Kalman滤波器" class="headerlink" title="Kalman滤波器"></a>Kalman滤波器</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>卡尔曼滤波器是由Swerling（1958）和Kalman（1960）作为线性高斯系统中的预测和滤波技术而发明的，使用矩来定义的。KF实现了对连续状态的置信度计算。KF用矩参数来表示置信度：在时刻k，置信度用均值$ \mu_k $（一阶矩）和方差$ \sum _{k-1} $（二阶矩）表达。</p>
<p>卡尔曼滤波建立在线性代数和隐马尔可夫模型上。其基本动态系统可以用一个马尔可夫链来表示，该马尔可夫链建立在一个线性高斯系统上。系统的状态可以用一个元素为实数的向量表示。随着离散时间的每一个增加，这个线性算子就会作用在当前状态上，产生一个新的状态，并也会带入一些噪声，同时系统的一些已知的控制器的控制信息也会被加入。同时，另一个受噪声干扰的线性算子产生出这些隐含状态的可见输出。</p>
<p>使后验为高斯分布的前提，同时也是KF的特性：<br>       （1）状态转移必须是带有随机高斯噪声的参数的线性函数。<br>       （2）测量也与带有高斯噪声的自变量呈线性关系。<br>       （3）初始置信度必须是正态分布的。</p>
<p>这三个假设足以确保后验在任何时刻<code>t</code>总符合高斯分布。</p>
<p>根据线性高斯系统可以得到<strong>卡尔曼滤波器</strong>。 </p>
<p>卡尔曼滤波器的状态由以下两个变量表示：</p>
<ol>
<li>$\hat{x}_k$，在时刻k的状态的估计；</li>
<li>$\Sigma_{k}$，后验估计误差协方差矩阵，度量估计值的精确程度。</li>
</ol>
<h3 id="线性高斯系统"><a href="#线性高斯系统" class="headerlink" title="线性高斯系统"></a>线性高斯系统</h3><p>线性高斯系统是说，运动方程和观测方程可以由线性方程来描述：<br>$$<br>\begin{cases}x_k=A_kx_{k-1}+u_k+w_k \quad k=1,…,N\<br>z_k=C_kx_k+v_k<br>\end{cases}<br>$$<br><img src="/2020/03/14/2020-03-13-Kalman_Filter/C:%5CUsers%5C%E9%83%AD%E7%8A%87%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200330234714941.png" alt="image-20200330234714941"></p>
<h4 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h4><p>$$<br>x_k=A_kx_{k-1}+u_k+w_k \quad k=1,…,N<br>$$</p>
<p>其中,$A_k$是作用在$x_{k-1}$的状态变换模型（矩阵/矢量）。</p>
<p>$w_k$是过程噪声,满足$w_k\sim N(0,Q)$</p>
<h4 id="观测模型"><a href="#观测模型" class="headerlink" title="观测模型"></a>观测模型</h4><p>$$<br>z_k = C_kx_k+v_k<br>$$</p>
<p>其中$C_k$是观测模型，能把真实状态空间映射成观测空间。并假设了所有的状态和噪声均满足高斯分布。</p>
<p>$v_k$观测噪声服从零均值高斯分布：即$.v_k\sim N(0,R)$。</p>
<p><strong>线性</strong></p>
<p>线性系统中的线性体现在以下两个方面:</p>
<ol>
<li>$X_k=A*X_{k-1}+B+\epsilon,\epsilon\sim N(0,Q)$</li>
<li>$Z_k=C*X_k+D+\delta,\epsilon \sim N(0,R)$</li>
</ol>
<p>两个条件服从高斯分布：<br>$$<br>P(X_k|X_{k-1})\sim N(A*X_{k-1}+B,Q)<br>$$</p>
<p>$$<br>P(Z_k|X_k)\sim N(C*X_k+D,R)<br>$$</p>
<p>可以系统的初始状态：<br>$$<br>X_1\sim N(\mu_1,\Sigma_1)<br>$$</p>
<p>$$<br>\begin{equation}<br>\left{<br>    \begin{array}{lr}<br>        P(X_k|X_{k-1})\sim N(A<em>X_{k-1}+B,Q)\<br>        P(Z_k|X_k)\sim N(C</em>X_k+D,R)\<br>        P(Z_1)=N(\mu_1,\Sigma_1)<br>    \end{array}<br>\right.<br>\end{equation}<br>$$<br>总共的参数表如下：</p>
<p>$$<br>\theta = (A,B,C,D,Q,R,\mu_1,\Sigma_1)<br>$$</p>
<p>卡尔曼滤波是一种递归的估计，即只要获知上一时刻状态的估计值以及当前状态的观测值就可以计算出当前状态的估计值，因此不需要记录观测或者估计的历史信息。卡尔曼滤波器与大多数滤波器不同之处，在于它是一种纯粹的时域滤波器，它不需要像低通滤波器等频域滤波器那样，需要在频域设计再转换到时域实现。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>卡尔曼滤波器的操作包括两个阶段：<strong>预测</strong>与<strong>更新</strong>。</p>
<ol>
<li>预测阶段，滤波器使用上一状态的估计，做出对当前状态的预测。</li>
<li>更新阶段，滤波器利用对当前状态的观测值优化在预测阶段获得的预测值，以获得一个更精确的新估计值。</li>
</ol>
<p><strong>输入：</strong>系统在<code>t-1</code>时刻状态的置信度（正态分布，均值和方差用$\mu_{t-1}$和$\Sigma_{t-1}$）; 输入的控制向量$u_t$和测量向量$z_t$。</p>
<p><strong>输出：</strong>系统t时刻的状态的置信度$bel(x_t)$，均值向量$\mu_t$，方差$\Sigma_t$。</p>
<p><strong>伪代码</strong></p>
<p><strong>Algorithm Kalman_filter</strong> ($\mu_{t-1}$,$\Sigma_{t-1}$,$\mu_t$,$z_t$)</p>
<ol>
<li>$\hat\mu_t = A_t\mu_{t-1}+B_tu_t$</li>
<li>$\hat\sum_t =A_t\sum_{t-1}A^T_t+R_t$</li>
<li>$K_t=\hat\sum_tC^T_t(C_t\hat\sum_tC^T_t+Q_t)^{-1}$</li>
<li>$\mu_t=\hat\mu_t+K_t(z_t-C_t\hat\mu_t)$</li>
<li>$\sum_t=(I-K_tC_t)\hat\sum_t$</li>
</ol>
<p><strong>return</strong> $\mu_t$, $ \sum_t$</p>
<h3 id="代码样例"><a href="#代码样例" class="headerlink" title="代码样例"></a>代码样例</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ predictx, predicty, state, param ]</span> = <span class="title">kalmanFilter</span><span class="params">( t, x, y, state, param, previous_t )</span></span></span><br><span class="line"><span class="comment">% 卡尔曼滤波器</span></span><br><span class="line"><span class="comment">% 输入：当前时间t，位置，状态，参数，前一帧的时间t-1</span></span><br><span class="line"><span class="comment">% UNTITLED Summary of this function goes here</span></span><br><span class="line"><span class="comment">%   假设状态为四维:[p_x,p_y,v_x,v_y]</span></span><br><span class="line"><span class="comment">%   Four dimensional state: position_x, position_y, velocity_x, velocity_y</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">%% Place parameters like covarainces, etc. here:</span></span><br><span class="line">    <span class="comment">% P = eye(4)</span></span><br><span class="line">    <span class="comment">% R = eye(2)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">% Check if the first time running this function</span></span><br><span class="line">    <span class="comment">% 初始化</span></span><br><span class="line">    <span class="keyword">if</span> previous_t&lt;<span class="number">0</span></span><br><span class="line">        state = [x, y, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">        param.P = <span class="number">0.1</span> * <span class="built_in">eye</span>(<span class="number">4</span>);</span><br><span class="line">        predictx = x;</span><br><span class="line">        predicty = y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%% Naive estimate 朴素估计</span></span><br><span class="line"><span class="comment">%     % As an example, here is a Naive estimate without a Kalman filter</span></span><br><span class="line"><span class="comment">%     % You should replace this code</span></span><br><span class="line"><span class="comment">%     vx = (x - state(1)) / (t - previous_t);</span></span><br><span class="line"><span class="comment">%     vy = (y - state(2)) / (t - previous_t);</span></span><br><span class="line"><span class="comment">%     % Predict 330ms into the future</span></span><br><span class="line"><span class="comment">%     predictx = x + vx * 0.330;</span></span><br><span class="line"><span class="comment">%     predicty = y + vy * 0.330;</span></span><br><span class="line"><span class="comment">%     % State is a four dimensional element</span></span><br><span class="line"><span class="comment">%     state = [x, y, vx, vy];</span></span><br><span class="line">    <span class="comment">%% <span class="doctag">TODO:</span> Add Kalman filter updates</span></span><br><span class="line">    <span class="comment">%% 当前目的：更新kalman滤波器</span></span><br><span class="line">    <span class="comment">% 1. 计算时间间隔</span></span><br><span class="line">    dt = t - previous_t; <span class="comment">% Time interval</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% PREDICT</span></span><br><span class="line">    <span class="comment">% 2. 预测</span></span><br><span class="line">    A = [<span class="number">1</span> <span class="number">0</span> dt <span class="number">0</span>; <span class="comment">% Transform matrix A</span></span><br><span class="line">         <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> dt;</span><br><span class="line">         <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>  <span class="number">0</span>;</span><br><span class="line">         <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>  <span class="number">1</span>];</span><br><span class="line">     </span><br><span class="line">    C = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; <span class="comment">% Observation matrix C</span></span><br><span class="line">         <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">     </span><br><span class="line">    z_t = [x, y]'; <span class="comment">% Measurement data</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Q = 0.005 * eye(4);</span></span><br><span class="line">    Q = [dt^<span class="number">2</span>  <span class="number">0</span>        <span class="number">0</span>       <span class="number">0</span>; <span class="comment">% System (Motion) noise covariance</span></span><br><span class="line">         <span class="number">0</span>        dt^<span class="number">2</span>  <span class="number">0</span>       <span class="number">0</span>;</span><br><span class="line">         <span class="number">0</span>        <span class="number">0</span>        <span class="number">1</span>       <span class="number">0</span>;</span><br><span class="line">         <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>       <span class="number">1</span>];</span><br><span class="line">           </span><br><span class="line">    R = <span class="number">0.005</span> * <span class="built_in">eye</span>(<span class="number">2</span>); <span class="comment">% Measurement noise covariance</span></span><br><span class="line">    </span><br><span class="line">    P = A * param.P * transpose(A) + Q; <span class="comment">% Prior estimation covariance</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% UPDATE</span></span><br><span class="line">    <span class="comment">% 3. 更新</span></span><br><span class="line">    K = P * transpose(C) * inv(R + C * P * transpose(C)); <span class="comment">% Kalman gain</span></span><br><span class="line">    state = (A * (state') + K * (z_t - C * A * (state')))'; <span class="comment">% Posterior state estimation</span></span><br><span class="line">    param.P = P - K * C * P; <span class="comment">% Posterior estimation covariance</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Predict 330ms into the future</span></span><br><span class="line">    predictx = state(<span class="number">1</span>) + state(<span class="number">3</span>) * <span class="number">0.330</span>;</span><br><span class="line">    predicty = state(<span class="number">2</span>) + state(<span class="number">4</span>) * <span class="number">0.330</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="基于后验概率推导Kalman滤波器·"><a href="#基于后验概率推导Kalman滤波器·" class="headerlink" title="基于后验概率推导Kalman滤波器·"></a>基于后验概率推导Kalman滤波器·</h3><p>可以看作是一个Filter问题的求解过程<br>$$<br>P(X_t|z_1,z_2,…z_t)\propto P(z_1,z_2,…z_t,X_t)\=P(z_t|z_1,z_2,…z_{t-1},X_t)*P(z_1,z_2,…z_{t-1},X_t)\<br>=P(z_t|X_t)P(z_1,…,z_{t-1},X_t)\<br>=P(z_t|X_t)P(X_t|z_1,…,z_{t-1})P(z_1,…,z_{t-1})\<br>\propto P(z_t|X_t)P(X_t|z_1,…,z_{t-1})\<br>$$</p>
<p>其中：<br>$$<br>P(X_t|z_1,…,z_{t-1})<br>=\int_{X_{t-1}}P(X_t,X_{t-1}|z_1,…,z_{t-1})dz_{t-1}\<br>=\int_{X_{t-1}}P(X_t|X_{t-1},z_1,…,z_{t-1})P(X_{t-1}|z_1,…,z_{t-1})dz_{t-1}<br>\=\int_{X_{t-1}}P(X_t|X_{t-1})P(X_{t-1}|z_1,…,z_{t-1})dz_{t-1}<br>$$</p>
<p> 基于概率的推导步骤：</p>
<ul>
<li><p>t=1,<br>$$<br>\begin{equation}<br>\left {</p>
<pre><code>\begin{array}{lr}
P(X_1|z_1)\rarr update\\
P(X_2|z_1)\rarr prediction
\end{array}</code></pre><p>\right.<br>\end{equation}<br>$$</p>
</li>
<li><p>t=2,<br>$$<br>\begin{equation}<br>\left {</p>
<pre><code>\begin{array}{lr}
P(X_2|z_1,z_2)\rarr update\\
P(X_3|z_1,z_2)\rarr prediction
\end{array}</code></pre><p>\right.<br>\end{equation}<br>$$</p>
</li>
<li><p>t=T,<br>$$<br>\begin{equation}<br>\left {</p>
<pre><code>\begin{array}{lr}
P(X_T|z_1,z_2...z_T)\rarr update\\
P(X_{T+1}|z_1,z_2,...,z_T)\rarr prediction
\end{array}</code></pre><p>\right.<br>\end{equation}<br>$$</p>
</li>
</ul>
<h3 id="Kalman滤波器与HMM之间的关系"><a href="#Kalman滤波器与HMM之间的关系" class="headerlink" title="Kalman滤波器与HMM之间的关系"></a>Kalman滤波器与HMM之间的关系</h3><p>本节<a href="https://www.cnblogs.com/pinking/p/9201405.html" target="_blank" rel="noopener">出处</a>。</p>
<p>Kalman与HMM的关系，事实上，他们解决的问题模型都是如上图所示，只不过一个是利用最小均方误差准则进行估计，一个是利用最大后验进行估计。事实上，HMM的预测问题中，就是一个最大的后验概率作为其似然函数，然后通过viterbi算法解的这个似然函数。</p>
<h2 id="拓展Kalman滤波器"><a href="#拓展Kalman滤波器" class="headerlink" title="拓展Kalman滤波器"></a>拓展Kalman滤波器</h2><p>核心思想：把卡尔曼滤波器的结果拓展到非线性系统中</p>
<p>做法：在某个点附近考虑运动方程以及观测方程的一阶泰勒展开，只保留一阶项，即闲下来部分，然后按照线性系统进行推导。</p>
<p>卡尔曼滤波器给出了在线性化之后，状态变量分布的变化过程。在线性系统和高斯噪声下，卡尔曼滤波器给出了无偏最优估计。而在SLAM 这种非线性的情况下，它给出了单次线性近似下最大后验估计（MAP）。</p>
<h3 id="EKF的应用"><a href="#EKF的应用" class="headerlink" title="EKF的应用"></a>EKF的应用</h3><p>EKF在SLAM中有着广泛的应用</p>
<h3 id="EKF的局限性"><a href="#EKF的局限性" class="headerlink" title="EKF的局限性"></a>EKF的局限性</h3><ol>
<li>EKF假设了马尔可夫性，即k时刻的状态只与k-1时刻相关，而与k-1之前的状态和观测都无关。但在视觉里程计中，只考虑相邻两帧的关系会累积误差。如果有回环检测的，滤波器就很难处理这种情况。</li>
<li>与非线性优化方法相比，EKF滤波器仅在$\hat{x}_{k-1}$处做了一次线性化，然后直接根据这次线性化结果计算后验概率。。这相当于在说，我们认为该点处的线性化近似，在后验概率处仍然是有效的。而实际上，当我们离开工作点较远的时候，一阶泰勒展开并不一定能够近似整个函数，这取决于运动模型和观测模型的非线性情况。如果它们有强烈的非线性，那线性近似就只在很小范围内成立，不能认为在<br>很远的地方仍能用线性来近似。这就是EKF 的非线性误差，是它的主要问题所在。在优化问题中，尽管我们也做一阶（最速下降）或二阶（G-N 或L-M）的近似，但每迭代一次，状态估计发生改变之后，我们会重新对新的估计点做泰勒展开，而不像EKF 那样只在固定点上做一次泰勒展开。这就导致优化方法适用范围更广，则在状态变化较大时亦能适用。</li>
<li>从程序实现上来说，EKF 需要存储状态量的均值和方差，并对它们进行维护和更新。如果把路标也放进状态的话，由于视觉SLAM 中路标数量很大，这个存储量是相当可观的，且与状态量呈平方增长（因为要存储协方差矩阵）。因此，EKF-SLAM 普遍被认为不可适用于大型场景。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Kalman滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>运动一致性判断</title>
    <url>/2020/03/14/2020-03-15-Motion_consistency/</url>
    <content><![CDATA[<p>直至以来，SLAM的研究共朝着三个方向努力：精度、速度、鲁棒性。尤以鲁棒性居多。通常动态场景中，根据IMU测量值与视觉测量值分别进行计算得到的结果会有所不同。因此需要进行一致性的检测，以得到真值。本文将主要讲运动一致性检测。</p>
<a id="more"></a>

<h1 id="运动一致性判断"><a href="#运动一致性判断" class="headerlink" title="运动一致性判断"></a>运动一致性判断</h1><p>基于聚类将图片分割之后获得的区域需要判断其运动一致性以分离动态物体和静态背景。</p>
<p>目的：对图片中各部分进行运动一致性判断以分离出目标和背景。</p>
<p>下面介绍各个论文中的判断方法</p>
<h2 id="Nonparametric-Statistical-and-Clustering-Based-RGB-D-Dense-Visual-Odometry-in-a-Dynamic-Environment"><a href="#Nonparametric-Statistical-and-Clustering-Based-RGB-D-Dense-Visual-Odometry-in-a-Dynamic-Environment" class="headerlink" title="Nonparametric Statistical and Clustering Based RGB-D Dense Visual Odometry in a Dynamic Environment"></a>Nonparametric Statistical and Clustering Based RGB-D Dense Visual Odometry in a Dynamic Environment</h2><p>该论文将RGB图片与深度图结合后进行k均值聚类以实现图片分割</p>
<p>过程：</p>
<ol>
<li>进行k-means聚类</li>
<li>计算每一个簇的残差</li>
<li>根据计算出的残差建立非参数统计模型</li>
</ol>
<p>聚类的好处有两点：</p>
<ol>
<li>能够将非刚体场景表示基于聚类的刚体场景</li>
<li>可有效增强密集运动的分割效果，从而支持场景流估计和避障。</li>
</ol>
<p>本文使用了一个残差模型。该模型基于一个假设：</p>
<p>若图片对齐，则基于静态背景的聚类将会有一个很小的残差。</p>
<p>光照强度残差：<br>$$<br>r^p_I(\xi）= I_k(W(x^p_{k-n},\xi^k_{k-n}))-I_{k-n}(x^p_{k-n})<br>$$<br>图像扭曲，Warp函数：<br>$$<br>W(x^p_{k-n},\xi^k_{k-n})=\pi(T^k_{k-n}\pi^{-1}(x^p_{k-n},Z_{k-n}(x^p_{k-n})))<br>$$</p>
<p>第i个聚类的残差计算方法如下所示：<br>$$<br>\delta^{k,i}<em>{k-n}=\cfrac{\sum^{S_i-O_i}</em>{p=1}\alpha_Ir^p_I+r^P_Z/\hat Z_i}{S_i-O_i}<br>$$<br>其中，$S_i$是第i类的像素大小。$O_i$是第i类遮挡的区域大小。</p>
<p>$\hat Z_i$是第i类的平均深度，$\alpha_I$是平衡深度和广度的权重。<br>$$<br>r_Z^P(\Chi)=Z_k(W(x^p_{k-n},\Chi^k_{k-n}))-|T^k_{k-n}|_Z<br>$$</p>
<p><strong>非参数统计模型</strong></p>
<p>该模型的用途是为了你和实际实验残差的直方图，为每个聚类提供权重以估计相机运动</p>
<p>静态背景部分的运动始终与相机运动具有双重关系。因此，静态簇的残差通常会很小或接近零，因为它们会完美对齐，而这些动态簇的残差通常是较大的值，由于动态对象的独立运动，它们的值会很明显的偏移于零。</p>
<p>对于不同的场景，残差分布并不总是相同的。应该探索聚类残差的分布特征。图2是高动态场景的统计残差直方图示例。</p>
<p><img src="/2020/03/14/2020-03-15-Motion_consistency/Motion_consistency.png" alt="image-20200316123237971"></p>
<p>在概率论和统计学中，t-分布（t-distribution）用于根据小样本来估计呈正态分布且方差未知的总体的均值。</p>
<p>受[14，23]的启发，基于t分布的非参数统计模型构造如下：<br>$$<br>w_i = \cfrac{v_0+1}{v_0+((\delta’_i-\mu))^2}<br>$$</p>
<p>$$<br>\delta = 1.4826 Median {|\delta’_i-\mu|}<br>$$</p>
<p>其中，$v_0$是t分布的自由度，决定了分布曲线的陡峭程度。</p>
<p>实验中，$v_0$被设置为10，$\mu$是样本均值，设为0；</p>
<p>$\delta$是样本方差，即基于中位数绝对偏差的非参数统计。</p>
<p>由于统计模型的概率表示簇的运动可能性，因此它可以指导场景运动分割，并为每个聚类提供权重以估计自我运动。</p>
<p>聚类标签根据如下给出：<br>$$<br>\Beta_i=\left{<br>\begin{array}{l}<br>1,&amp;\delta’_i\leq1/(\min(10,\max(3.\alpha_Bv_c\delta)))<br>\0,&amp;\delta’_i\geq1/(\min(10,\max(3,\alpha_Bv_c\delta)))<br>\end{array}<br>\right.<br>$$<br>Bi表示第i个簇的聚类标签。1表示该类属于静态背景。</p>
<p>0表示该类属于动态部分。$\alpha_B$是一个用来调节独立变量和残差的维度协方差，计算方法为：<br>$$<br>\alpha_B=10^3\times\min(10^3,10^{N_d})<br>$$<br>$N_d$是标记为移动部分的聚类数。</p>
<p>聚类权重参考聚类的残差来给出，如下所示：<br>$$<br>w_i^p=\left{<br>\begin{array}{}<br> w_i, &amp;Meadian(\delta’_i)&gt;0.02\or N_d&gt;5\<br>1-\delta’_i,&amp;Others<br>\end{array}<br>\right.<br>$$<br>其中，$w_i$是第i类的权重。Median($\delta’_i$)是聚类残差的中位数。</p>
<p>最后将运动标记和权重模型添加到稠密视觉里程计的能量优化函数中。优化函数是根据Kerl的工作[9]基于深度和强度构建的，具有很高的稳定性，而Jaimez的工作[15]的方法表明优化过程可以在Cauchy M估计器中获得良好的结果。自运动通过以下等式估算：<br>$$<br>\Chi = \arg \min_{\Chi}{\sum^M_{m=1}\Beta_i[F(w^P_i)r^P_Z(\Chi)+F(\alpha_I)w^p_ir^p_I(\Chi)]<br>$$</p>
<p>$$<br>F(r)=\cfrac{c^2}{2}\log(1+(\cfrac{r}{c})^2)<br>$$</p>
<p>此外，基于能量函数的视觉里程计方法只有在运动较小时才能收敛到真实值，而较大的运动通常会将收敛收敛到局部最小值。因此，我们使用金字塔模型来解决此优化问题，以获得更准确的自我运动估计。</p>
<h2 id="Dection-and-Resolution-of-Motion-Conflict-Inertial-Odometry"><a href="#Dection-and-Resolution-of-Motion-Conflict-Inertial-Odometry" class="headerlink" title="Dection and Resolution of Motion Conflict Inertial Odometry"></a>Dection and Resolution of Motion Conflict Inertial Odometry</h2><p>判断路标点间一致性的策略：</p>
<ol>
<li><p>基于IMU判断的运动对每一个特征点计算重投影残差<br>$$<br>\delta_{l_j}=\sum_{i\in S}(z_ij-h(\hat X^I_j,l_j))<br>$$</p>
</li>
<li><p>计算当前帧中特征点的残差不一致点的个数，如果不一致点的个数超过了一定比例，则判断发生了运动冲突。<br>$$<br>Mr:=\cfrac{landmarks<del>wihtout</del>confilt}{landmarks}<br>$$</p>
</li>
<li><p>另一方面，分别根据基于IMU和视觉的运动计算重投影误差，再计算二者的分歧度，再根据分歧度计算当前帧是否发生了冲突。<br>$$<br>\delta_{MC}=||{\hat p_k^V-\hat p_k^I}||_{\sum}<br>$$</p>
</li>
</ol>
<h2 id="On-Exploting-Per-Pixel-Conflict-to-Extract-Secondary-Motions"><a href="#On-Exploting-Per-Pixel-Conflict-to-Extract-Secondary-Motions" class="headerlink" title="On Exploting Per-Pixel Conflict to Extract Secondary Motions"></a>On Exploting Per-Pixel Conflict to Extract Secondary Motions</h2><p>基于DNN训练一个概率图，提取出概率图（Mask）</p>
<p>然后基于该概率图分别计算主要运动和次要运动。</p>
<h2 id="A-Compatible-Framework-for-RGB-D-in-Dynamic-Scenes"><a href="#A-Compatible-Framework-for-RGB-D-in-Dynamic-Scenes" class="headerlink" title="A Compatible Framework for RGB-D in Dynamic Scenes"></a>A Compatible Framework for RGB-D in Dynamic Scenes</h2><ol>
<li><p>首先利用CNN提取出图像中潜在的动态区域</p>
</li>
<li><p><strong>运动检测方法</strong></p>
<p>​    本文采用基于光学流的方法来检查潜在动态区域和背景区域的一致性。光学流算法[30]在该领域已被广泛研究，该算法在运动检测中表现出色。该算法的总体思想是在两个图像的时空一致性假设下，从两个连续的图像中确定点的对应关系。提出了两种针对光流问题的解决方法，分别称为稀疏法和稠密法。稠密解决方案逐像素计算图像中的光学流值。但稀疏解决方案仅在这些兴趣点上计算流量矢量。可以通过以下公式获得一个像素的光学流值：<br>$$<br>\tau(\Chi,u)=\sum_{\Chi_i\in S}[I_{l-1}(X_i)-I_l(X_i+u(X_i))]^2<br>$$<br>​    对于每一个2D再集合$S\subset R^2$的点$X_i$，$I_{l-1}(X_i)$是第l-1帧的$X_i$的雄塑强度。$I_l(X_i+u(X_I))$表示相应的第l帧中的光照强度。</p>
<p>$u(X_i)$是第l-1和第l帧的相应点的变化，该项根据局部窗口中基于重心$X_i$的变化而来，是使函数达到最小的变量。</p>
<p>为了减少上面所说的损失函数，$X_i$点的光流向量$(\frac{u_x(X_i)}{dt},\frac{u_y(X_i)}{dt})$。$\frac{u_x(X_i)}{dt}$是其沿x轴的时间随时间变化的导数，$\frac{u_y(X_i)}{dt}$是其沿y轴方向变化的倒数。沿y轴的时间。利用广泛使用的Lucas-Kanade光流法用于跟踪潜在动态对象内部和外部的稀疏点。</p>
<p>对于光学流向量$p =（u，v）$，其方向$\Phi$和大小$ρ$表示如下：<br>$$<br>\phi=\left{<br>\begin{array}{}<br>atan2(\frac{v}{u})<em>180/\pi,&amp;if~atan2(\frac{v}{u})&gt;0\<br>(360+atan2(\frac{v}{u}))</em>180/\pi,&amp;otherwise<br>\end{array}<br>\right.<br>$$</p>
<p>$$<br>\rho = \sqrt2{u^2+v^2}<br>$$</p>
<p>然后，类似于[15]，将为潜在的动态区域和背景区域构建标准化的直方图，其中每个单元格的范围将由如下所示的公式确定：<br>$$<br>2\pi<em>\frac{r-1}{R}&lt;\psi&lt;2\pi</em>{\frac{r}{R}}<br>$$<br>其中，$\R$是bins的数目，r是从左到右的系列字母。所有的流向量将根据它们与水平轴的夹角划分为每个容器。此外，所有流向量将分配给不同的簇。每个bin的高度将如下计算：<br>$$<br>H=\frac{\sum_{\xi\in bin}\rho_\xi}{\sum_{\mu\in area}\rho_\mu}<br>$$</p>
</li>
</ol>
<p>   其中$ρ_ξ$表示一个箱中流量矢量的大小，而$ρ_\mu$是势能动态区域或背景区域中流量矢量的大小。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS-Fusion代码阅读</title>
    <url>/2020/03/10/2020-03-10-Read-VINS-Fusion/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Loop-Fusion"><a href="#Loop-Fusion" class="headerlink" title="Loop Fusion"></a>Loop Fusion</h2><p>Loop Fusion结点包括：</p>
<h2 id="VINS-estimator"><a href="#VINS-estimator" class="headerlink" title="VINS_estimator"></a>VINS_estimator</h2><p>VINS_estimator是VINS_Fusion的节点，其不包含回环检测部分，该节点可以单独对相机进行位姿估计。</p>
<h3 id="rosNodeTest-cpp"><a href="#rosNodeTest-cpp" class="headerlink" title="rosNodeTest.cpp"></a>rosNodeTest.cpp</h3><p>rosNodeTest.cpp是vins_estimator节点的程序入口。主要实现以下函数。</p>
<p>主程序包含以下流程：</p>
<ol>
<li><p>读取配置文件参数 readParameter()</p>
</li>
<li><p>订阅了四个话题，分别是imu、双目相机图像以及feature_tracker所提供的跟踪光流点，收到各个话题的消息后执行回调函数，对各个数据进行相应的处理</p>
</li>
<li><p>开启一个新线程sync_process。</p>
<p>该线程的作用：若图像buffer里面有数据,读入数据并且添加到estimator中。利用图片携带的时间戳信息能够检测两图片是否同步，若两图片的时间戳差距在一定范围内，则添加到estimator中中，否则丢弃两帧图片。</p>
</li>
</ol>
<h3 id="estimator"><a href="#estimator" class="headerlink" title="estimator"></a>estimator</h3><p>VIO系统的整个程序从Estimator estimator开启。</p>
<p>estimator类的定义由estimator.h和estimator.cpp两个文件完成。</p>
<p>包含以下重要的自定义成员：</p>
<table>
<thead>
<tr>
<th align="center">成员</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Feature_Tracker featureTracker</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">FeatureManager f_manager</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>estimator类中包含两类成员函数：</p>
<ol>
<li><p>接口函数</p>
<p>包括以下8个函数：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">initFirstPose()</td>
<td align="left">初始化初始位姿</td>
</tr>
<tr>
<td align="center">inputIMU()</td>
<td align="left">输入IMU数据</td>
</tr>
<tr>
<td align="center">inputImage()</td>
<td align="left">输入图片数据</td>
</tr>
<tr>
<td align="center">inputFeature()</td>
<td align="left">输入特征</td>
</tr>
<tr>
<td align="center">ProcessIMU()</td>
<td align="left">处理IMU数据，对IMU进行预积分；</td>
</tr>
<tr>
<td align="center">ProcessImage()</td>
<td align="left">处理相机数据；<br>1. 基于特征点的视差来判断当前帧是否属于关键帧；<br>2. 判断相机到IMU的外参是否有校正，若无则用手眼标定法进行标定,具体在CalibrationExRotation里，此处只标定旋转矩阵，未标定平移矩阵，原因是系统对旋转矩阵较敏感，系统易因为小幅度的角度偏差而崩溃；<br>3. 判断是否有进行初始化;若已完成初始化，则调用optimization( )，用ceres_solver对滑窗进行非线性优化的求解，优化项主要有四项：边缘化残差、 imu残差、相机重投影残差以及相机与Imu间同步时间差的残差项。否则进行相应的初始化过程。<br>4. 本函数中包含一个failureDetection()函数,用于判断系统在一定条件下是否崩溃，比如非线性求解器中的解有大跳动，求解出相机IMU的外参矩阵或IMU偏移等等，系统挂掉就清空状态，重新初始化。</td>
</tr>
<tr>
<td align="center">ProcessMeasurements()</td>
<td align="left">处理测量值；处理各buffer里的数据，当featureBuf不等于空时，开始进行以下处理（为什么是featureBuf，因为当有图像buffer数据的时候，才会有featuretracker.push(make_pair(t,featureFrame))，即有图像数据后，程序才发给跟踪器叫他产生feature，因此当featureBuf不等于空，所有的buffer，包括imu,图像，都不为空）：</td>
</tr>
<tr>
<td align="center">changeSensrType</td>
<td align="left">改变传感器类型，用于确定是否使用IMU，使用单目相机还是双目相机</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="2">
<li>内部函数</li>
</ol>
<p>类的初始化函数Estimator()，由于Estimator类成员内部有两个比较重要的自定义类成员：<br>（1）Feature_Tracker featuretracker;（以前vins-mono这部分是作为一个独立的Node存在）:<br>用来对原始图像进行畸变校正，特征点采集，光流跟踪<br>（2）FeatureManager f_manager;<br>用来对滑动窗口内所有特征点的管理。<br>简单设置了一些参数后，系统进入main()。</p>
<p>接着main()与Estimator estimator两者开始发生联系：<br>main()中estimator.setParameter()开启了滑动窗口估计的一个新线程<br>由于我们在配置文件中 多线程MULTIPLE_THREAD设置为1，因此当setParameter()时候，就开启了一个Estimator类内的新线程：processMeasurements();</p>
<p>pub VIO的各种话题，包括里程计信息，tf变换，相机姿态，点云信息，并且发布关键帧。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>VINS</tag>
        <tag>代码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>经典聚类算法调研</title>
    <url>/2020/03/10/2020-03-12-Clustering_Survey/</url>
    <content><![CDATA[<p>本文将盘点六个经典的聚类算法，以便于后续研究。经典的聚类算法主要包括以下六种：</p>
<ol>
<li>Means-shift聚类</li>
<li>k-means聚类</li>
<li>Fuzzy C means聚类</li>
<li>Medoid shift算法</li>
<li>Turbopixel算法</li>
<li>SLIC算法</li>
</ol>
<a id="more"></a>

<h2 id="Means-shift聚类（均值漂移）"><a href="#Means-shift聚类（均值漂移）" class="headerlink" title="Means-shift聚类（均值漂移）"></a>Means-shift聚类（均值漂移）</h2><p><strong>核心思想</strong></p>
<p>均值漂移聚类是基于滑动窗口的算法，用来寻找到数据最密集的区域。这是一个基于质心的算法，通过将中心点的候选点更新为滑动窗口内点的均值来完成，来定位每个组/类的中心点。</p>
<p>然后对这些候选窗口进行相似窗口进行去除，最终形成中心点集及相应的分组。</p>
<p><strong>算法步骤</strong></p>
<ol>
<li><p>确定滑动窗口半径r，以随机选取的中心点C半径为r的圆形滑动窗口开始滑动。均值漂移类似一种爬山算法，在每一次迭代中向密度更高的区域移动，直到收敛。</p>
</li>
<li><p>每一次滑动到新的区域，计算滑动窗口内的均值来作为中心点，滑动窗口内的点的数量为窗口内的密度。在每一次移动中，窗口会想密度更高的区域移动。</p>
</li>
<li><p>移动窗口，计算窗口内的中心点以及窗口内的密度，知道没有方向在窗口内可以容纳更多的点，即一直移动到圆内密度不再增加为止。</p>
</li>
<li><p>步骤一到三会产生很多个滑动窗口，当多个滑动窗口重叠时，保留包含最多点的窗口，然后根据数据点所在的滑动窗口进行聚类。</p>
<p>下图演示了均值漂移聚类的计算步骤：</p>
<p><img src="/2020/03/10/2020-03-12-Clustering_Survey/..%5Cimages%5C%E8%81%9A%E7%B1%BB%5CMeanshift%E7%AE%97%E6%B3%95.gif" alt="Meanshift算法"></p>
</li>
</ol>
<p><strong>算法评价</strong></p>
<p>优点：1.稳定性和鲁棒性较好，基于密度的算法相比于K-Means受均值影响较小。 2.不需要选择簇的数量</p>
<p>缺点：1.给定的图像语义信息较少；2.进行分割时效果较差；3.时间复杂度较高，导致分割速度慢；4.图像分割块数量不可控；5.固定了窗口大小/半径</p>
<h2 id="K-means聚类"><a href="#K-means聚类" class="headerlink" title="K-means聚类"></a>K-means聚类</h2><p><strong>核心思想</strong></p>
<p>输入参数 K，将给定的 N 个数据样本点平均分成 K 个组，把输入的 K 个点作为聚类起始点。计算簇中其他采样点到 K 个起始点的欧氏距离，并对比全部采样点和收敛中心点之间的距离。通过对比最小的欧氏距离进行归类，然后经重复迭代，逐次得计算K 个簇的均值。直到聚类的性能准则函数最优</p>
<p><strong>算法步骤</strong></p>
<ol>
<li>选择一些类/组，随机初始化各自的中心点。中心点是与每个数据点向量长度相同的位置。这需要我们提前预知类的数量(即中心点的数量)。</li>
<li>计算每个数据点到中心点的距离，数据点距离哪个中心点最近就划分到哪一类中。</li>
<li>计算每一类中中心点作为新的中心点。</li>
<li>重复以上步骤，直至聚类中心变化在一定范围内为止</li>
</ol>
<p><strong>算法评价</strong></p>
<p>优点：简单快速高效；对异常值不太敏感</p>
<p>缺点：聚类数目 K 值是必须事先给出；不适合处理不规则形状；距离函数对结果有影响。</p>
<p>下图演示了k均值聚类的过程：</p>
<p><img src="/2020/03/10/2020-03-12-Clustering_Survey/..%5Cimages%5C%E8%81%9A%E7%B1%BB%5Ck%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB.gif" alt></p>
<h2 id="Fuzzy-C-means算法"><a href="#Fuzzy-C-means算法" class="headerlink" title="Fuzzy C-means算法"></a>Fuzzy C-means算法</h2><p><strong>核心思想</strong></p>
<p>Fuzzy C-means又名模糊C均值聚类，模糊C均值聚类融合了模糊理论的精髓，相较于k-means的硬聚类，模糊C提供了更加灵活的聚类结果。因为在大部分情况下，数据集中的对象不能划分成为明显分离的簇，指派一个对象到一个特定的簇有些生硬，也可能会出错。故，对每个对象和每个簇赋予一个权值，指明对象属于该簇的程度。当然，基于概率的方法也可以给出这样的权值，但是有时候我们很难确定一个合适的统计模型，因此使用具有自然地、非概率特性的模糊c均值就是一个比较好的选择。</p>
<p>简单地说，就是要最小化目标函数（即误差的平方和）：<br>$$<br>J_m = \sum^N_{i=1}\sum^C_{j=1}U^m_{ij}||x_i-c_j||^2 ,1&lt;=m&lt;∞<br>$$<br>其中，m是聚类的簇数；i,j是类标号；$u_{ij}$ 表示样本$x_i$ 属于j类的隶属度。i表示第i个样本，x是具有d维特征的一个样本。$c_j$是j簇的中心，也具有d维度。$||*||$是表示距离的度量。</p>
<p>模糊C聚类是一个不断得带隶属度$u_{ij}$ 和簇中心$c_j$ 的过程，直到达到最优。</p>
<p><strong>算法思路</strong></p>
<p>将提供的 n 个样本分为 C 组，通过迭代寻找各个组的聚类中心与隶属度值 Uij ，使非相似性指标的目标函数 J( U，V) 取最小值。该算法将隶属度 0 至 1 分别分派给每个数据对象，数据对象所属于哪类的问题是由隶属度值来决定。且规定每一个样本的隶属度值的总和是 1。</p>
<p><strong>算法步骤</strong></p>
<ol>
<li><p>初始化。通常采用随机初始化。即权值随机地选取。簇数需要人为选定。</p>
</li>
<li><p>计算质心。FCM中的质心有别于传统质心的地方在于，它是以隶属度为权重做一个加权平均。</p>
</li>
<li><p>更新模糊伪划分。即更新权重（隶属度）。简单地说，如果x越靠近质心c，则隶属度越高，反之越低。</p>
</li>
</ol>
<p><strong>算法评价</strong></p>
<p>优点：当聚类数量较多且类间差异明显时，简单高效效果较好</p>
<p>缺点：1.需要接收参数 C，若给定的参数不恰当，会对聚类结果产生负面影响。2. 当待检测数据样本总数过大并特征点过多，聚类效果不好。算法没有分析图像中各个像素间的领域关系，导致分割后的样本点易受噪声点的影响。</p>
<h2 id="Medoid-shift-算法"><a href="#Medoid-shift-算法" class="headerlink" title="Medoid shift 算法"></a>Medoid shift 算法</h2><p><strong>核心思想</strong></p>
<p>基于Means shift算法进行的改进，不同之处，MeanShift 算法经过多次迭代计算出的均值，即偏移值。相比较 Medoidshift 算法不要求求出平均值，而是从数据中将偏移值取出，但仍然需要确定两点之间距离。Medoidshift 算法每次迭代会计算出新的中心点，并非新位置，中心点可以被定义如下:</p>
<p><strong>算法步骤</strong></p>
<p><strong>算法评价</strong></p>
<p>优点：比Mean shift更高效</p>
<p>缺点：不能控制图像块数量和大小</p>
<h2 id="Turbo-Pixel算法"><a href="#Turbo-Pixel算法" class="headerlink" title="Turbo Pixel算法"></a>Turbo Pixel算法</h2><p><strong>核心思想</strong></p>
<p>该算法是一种基于几何流的超像素快速分割算法。首先，像素块应先满足以下几个条件：</p>
<p>①每个图像块尺寸大小尽可能均匀：</p>
<p>②各个图像块之间紧凑连接且保持连通</p>
<p>③各图像块彼此不覆盖且每块边界光滑无特殊棱角。</p>
<p><strong>算法步骤</strong></p>
<ol>
<li><p>首先为避免在给种子点定义时被噪声污染，特添加扰动。</p>
</li>
<li><p>对图像中的像素点进行标记</p>
</li>
<li><p>初始化水平集函数。</p>
</li>
<li><p>执行以下步骤，通过反复迭代并检验种子点膨胀边缘的演化速度是否为0，若达到则停止，反之继续，一是首先水平集曲线函数演化二是开始对未分配区域进行比较冫三是边界上的所有像素点的演化速度是由根据比较的结果进行更新</p>
</li>
</ol>
<p>⑤返回边界。</p>
<p><strong>算法评价</strong></p>
<p>超像素分割算法利用图像相似度将图像分割成几个同质超像素子区域。对于基于像素的处理方法，用来处理超像素的图像，可以更有助于获取的特定部分特征，从而保留更有效的信息的图像</p>
<h2 id="SLIC算法"><a href="#SLIC算法" class="headerlink" title="SLIC算法"></a>SLIC算法</h2><p><strong>核心思想</strong></p>
<p> 利用CIE-Lab 颜色空间来表示图像颜色信息，需要颜色空间转换，对应着图像中的每个像素，将其用一个由CIE-Lab 颜色空间和像素坐标 组成的 5 维向量{ L,a,b,x,y} 表示。通过向量距离来度量两个像素的相似性.</p>
<p>像素相似性与向量距离成反比。</p>
<p><strong>算法步骤</strong></p>
<p>1.初始化图像分割块。根据超参数生成K个种子点，计算种子点到所有像素的梯度值，搜索每个种子点周围空间里距离该点的最近的像素点。将各个像素分类。</p>
<p>步距设置为：$S=\sqrt{\frac{N}{K}}$ 。N是像素边，K是种子点个数</p>
<p>2.初始化聚类中心。将所有像素归类，计算领域内像素与种子间的距离，取最小距离作为聚类中心。</p>
<p>距离计算公式如下：<br>$$<br>d_c=\sqrt{(l_j-l_i)^2+(a_j-a_i)^2+(b_j-b_i)^2}<br>$$</p>
<p>$$<br>d_s=\sqrt{(x_j-x_i)^2+(y_j-y_i)^2}<br>$$</p>
<p>$$<br>D’=\sqrt{(\frac{d_c}{N_c})^2+(\frac{d_s}{N_s})^2}<br>$$</p>
<p>其中，$N_S=S=\sqrt{\frac{N}{K}}$</p>
<p>3.计算聚类中心到领域内所有像素点的距离。刷新原有的K个聚类重心点，再以刷新后的收敛中心点去搜索其周围与其相似度最高的点。</p>
<p>4.重新聚类，更新每个像素点所属的图像块，将同一个图像块的像素点取平均，得到新的聚类中心。</p>
<p>5.重复前面的步骤，直到两次聚类中心的距离小于某个阈值。</p>
<p><strong>算法评价</strong></p>
<p>优点：</p>
<p>1.聚类结果紧凑整齐且邻域特征明显。</p>
<p>2.可处理彩色图和灰度图</p>
<p>3.只需一个超参数。</p>
<p>4.运行速度较快。</p>
<p>缺点：因为对边缘的保持使用位置限制，导致超像素和图像边缘的契合度变差。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>聚类</tag>
        <tag>图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title>回环检测与DBoW2库</title>
    <url>/2020/03/10/2020-03-10-Use_DBoW2_to_Loop_Detection/</url>
    <content><![CDATA[<p>本文目的是为了更加详细的学习通用的回环检测算法 中的DBoW2库，了解其代码构成。</p>
<ol>
<li>回环检测</li>
<li>DBOW2介绍</li>
<li>DBOW3介绍</li>
</ol>
<a id="more"></a>

<h2 id="回环的评价指标"><a href="#回环的评价指标" class="headerlink" title="回环的评价指标"></a>回环的评价指标</h2><p>一个回环的结果，可能有以下四种情况出现：</p>
<table>
<thead>
<tr>
<th align="center">算法结果事实</th>
<th align="center">是回环</th>
<th align="center">不是回环</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是回环</td>
<td align="center">真阳性</td>
<td align="center">假阳性</td>
</tr>
<tr>
<td align="center">不是回环</td>
<td align="center">假阴性</td>
<td align="center">真阴性</td>
</tr>
</tbody></table>
<p>回环检测算法可以输出以下结果：四种结果的数量分别为<br>$$<br>准确率=N_{TP}/{N_{TP}+N_{FP}}<br>$$</p>
<p>$$<br>Recall = N_{TP}/{N_{TP}+N_{FN}}<br>$$</p>
<p>准确率描述了检测到的回环中真回环的个数。</p>
<p>Recall描述了真回环中有多少个被检测出来了。</p>
<p>根据准确率和召回率可以得到ROC曲线.</p>
<p>ROC曲线越靠右上方越好，但是通常这两者是矛盾的。</p>
<h2 id="回环检测"><a href="#回环检测" class="headerlink" title="回环检测"></a>回环检测</h2><p>闭环检测算法指的是通过检测算法检测出之前访问过的场景。</p>
<p><img src="/2020/03/10/2020-03-10-Use_DBoW2_to_Loop_Detection/%E5%9B%9E%E7%8E%AF%E6%A3%80%E6%B5%8B.jpg" alt="img"></p>
<p>如图1所示，当机器人在移动过程中，特别是在探索大面积的场景时，由于模型的不确定性以及设备的噪声，不确定性会逐渐增长。通过引入闭环检测技术，识别出历史访问过的场景以增加位姿之间的约束，可以很好的减少这种不确定性。</p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><h4 id="一、关键帧匹配"><a href="#一、关键帧匹配" class="headerlink" title="一、关键帧匹配"></a>一、关键帧匹配</h4><p>最简单的闭环检测算法是将新检测出来的关键帧和过去所有的关键帧一一进行比较，虽然这种方法能比较好的检测出当前场景是否在之前出现过，但是在大规模场景下，机器人往往有成千上万个关键帧，这种方法检测效率及其底下，不能再实际场景中使用。</p>
<h4 id="二、将特征与路标对应"><a href="#二、将特征与路标对应" class="headerlink" title="二、将特征与路标对应"></a>二、将特征与路标对应</h4><p>通过将图像中的特征和整个地图中的路标对应起来，然后建立一个所有路标的数据库，通过使用路标分类器来加快场景识别速度。比如讲所有路标构建成一棵KD-Tree，当新添加一帧关键帧时，将关键帧在KD-Tree中进行检索，从中检索之前出现过的场景。</p>
<h4 id="三、视觉词袋方法"><a href="#三、视觉词袋方法" class="headerlink" title="三、视觉词袋方法"></a>三、视觉词袋方法</h4><p>基于视觉词袋的闭环检测方法，这种方法通过将特征描述子抽象成词汇，通过TF-IDF方法识别出现过的场景。如图2所示，是闭环检测中基于词袋模型流程图。使用视觉词袋的方法效率很高，可用在大规模地图的创建上。</p>
<h2 id="DBoW2视觉词袋库"><a href="#DBoW2视觉词袋库" class="headerlink" title="DBoW2视觉词袋库"></a>DBoW2视觉词袋库</h2><p><a href="https://github.com/rmsalinas/DBow3" target="_blank" rel="noopener">Github地址</a></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​        DBoW2是DBow库的改进版本，DBow库是一个开放源代码的C ++库，用于根据图像建立索引，并将其转换成词袋表示。它实现了一个层次树，用于近似图像特征空间中的最近邻居并创建视觉词汇。 DBoW2还使用反向和直接文件来实现图像数据库，以索引图像并支持快速查询和功能比较。与以前的DBow库的主要区别在于：</p>
<ul>
<li>DBoW2类是模板化的，因此它可以与任何类型的描述符一起使用。</li>
<li>DBoW2附带了可直接与ORB或Brief描述符一起使用的类。</li>
<li>DBoW2将直接文件添加到图像数据库以进行快速功能比较。 DLoopDetector使用它。</li>
<li>DBoW2不再使用二进制格式。另一方面，它使用OpenCV存储系统来保存词汇表和数据库。这意味着这些文件可以YAML格式存储为纯文本，从而使兼容性更容易，也可以将其压缩为gunzip格式（.gz）以减少磁盘使用。</li>
<li>一些代码已被重写以优化速度。 DBoW2的界面已简化。</li>
<li>出于性能原因，DBoW2不支持停用词。</li>
</ul>
<p>DBoW2需要OpenCV和Boost :: dynamic_bitset类才能使用Brief版本。<br>DBoW2与DLoopDetector一起在多个真实数据集上进行了测试，执行时间为3毫秒，将图像的Brief特征转换为词袋矢量，执行时间为5毫秒，以在数据库中查找图像匹配项。超过19000张图像。</p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><h4 id="加权和计分"><a href="#加权和计分" class="headerlink" title="加权和计分"></a>加权和计分</h4><p>DBoW2实现与DBow相同的加权和计分机制。在这里检查。唯一的区别是DBoW2将所有分数缩放到[0..1]，因此不再使用缩放标志。</p>
<h4 id="保存并加载"><a href="#保存并加载" class="headerlink" title="保存并加载"></a>保存并加载</h4><p>可以使用保存和加载成员功能将所有词汇表和数据库保存到磁盘或从磁盘加载。保存数据库时，与之关联的词汇表也嵌入到文件中，因此词汇表和数据库文件是完全独立的。<br>您还可以将词汇表或数据库数据添加到使用cv :: FileStorage结构打开的任何文件中。<br>您可以使用任何文件扩展名保存词汇表或数据库。如果使用.gz，则文件将自动压缩（OpenCV行为）。</p>
<h3 id="应用说明"><a href="#应用说明" class="headerlink" title="应用说明"></a>应用说明</h3><h4 id="类参数"><a href="#类参数" class="headerlink" title="类参数"></a>类参数</h4><p>DBoW2有两个主要的类：<code>TemplatedVocabulary</code>和<code>TemplatedDatabase</code>。这些工具实现了视觉词汇，可将图像转换成词袋矢量，并将数据库转换成索引图像。这些类是模板化的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">TDescriptor</span>, <span class="title">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">TemplatedVocabulary</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">TDescriptor</span>, <span class="title">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">TemplatedDatabase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>两个类必须被提供：<code>TDescriptor</code>是单个描述符向量的数据类型，而<code>F</code>是具有从<code>FClass</code>派生的具有操作描述符功能的类。<br>例如，要使用<code>ORB</code>描述符，<code>TDescriptor</code>定义为<code>cv :: Mat</code>（类型为<code>CV_8UC1</code>），它是包含32个8位值的单行。从图像中提取特征时，必须获取<code>std :: vector &lt;TDescriptor&gt;</code>。对于<code>BRIEF</code>描述子，<code>TDescriptor</code>被定义为<code>boost :: dynamic_bitset &lt;&gt;</code>。<br><code>F</code>参数是实现<code>FClass</code>中定义的函数的类的名称。这些函数获取<code>TDescriptor</code>数据并计算一些结果。 <code>DBoW2</code>中已经包含了处理<code>ORB</code>和<code>Brief</code>描述符的类。 （<code>FORB</code>，<code>FBrief</code>）。</p>
<h4 id="预定义的词汇表和数据库"><a href="#预定义的词汇表和数据库" class="headerlink" title="预定义的词汇表和数据库"></a>预定义的词汇表和数据库</h4><p>为了便于使用，<code>DBoW2</code>定义了两种词汇表和数据库：<code>OrbVocabulary</code>，<code>OrbDatabase</code>，<code>BriefVocabulary</code>，<code>BriefDatabase</code>。请检查演示应用程序，以了解如何创建和使用它们。</p>
<h2 id="DBoW3视觉词袋库"><a href="#DBoW3视觉词袋库" class="headerlink" title="DBoW3视觉词袋库"></a>DBoW3视觉词袋库</h2><p><a href="https://github.com/rmsalinas/DBow3" target="_blank" rel="noopener"><strong>Github地址</strong></a></p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>​        DBoW3是DBow2库的改进版本，DBow2库是一个开放源C ++库，用于将图像索引并将其转换为词袋表示。它实现了一个层次树，用于近似图像特征空间中的最近邻居并创建视觉词汇。 DBoW3还使用反向和直接文件来实现图像数据库，以索引图像并支持快速查询和功能比较。与以前的DBow2库的主要区别是：</p>
<ul>
<li>DBoW3仅需要OpenCV。 DLIB的DBoW2依赖性已删除。</li>
<li>DBoW3可以立即使用二进制和浮点描述符。无需为任何描述符重新实现任何类。</li>
<li>DBoW3可以在linux和Windows中进行编译。</li>
<li>一些代码已被重写以优化速度。 DBoW3的界面已简化。</li>
<li>使用二进制文件的可能性。二进制文件的加载/保存速度比yml快4-5倍。同样，它们可以被压缩。</li>
<li>兼容DBoW2 yml文件</li>
</ul>
<h3 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h3><p><code>DBoW3</code>仅需要<code>OpenCV</code>。<br>要编译<code>utils / demo_general.cpp</code>，必须针对<code>OpenCV 3</code>进行编译。如果已安装<code>contrib_modules</code>，请使用<code>cmake</code>选项<code>-DUSE_CONTRIB = ON</code>启用<code>SURF</code>。</p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>检查<code>utils/demo_general.cpp</code></p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>DBoW3主要有两个类： <code>Vocabulary</code> 和<code>Database</code>。这些工具实现了视觉词汇，可将图像转换成词袋矢量，并将数据库转换成索引图像。有关示例，请参见<code>utils / demo_general.cpp</code>。</p>
<h4 id="读取-存储-词汇"><a href="#读取-存储-词汇" class="headerlink" title="读取/存储 词汇"></a>读取/存储 词汇</h4><p>文件<code>orbvoc.dbow3</code>是<code>ORBSLAM2</code>中的<code>ORB</code>词汇，但采用<code>DBoW3</code>的二进制格式：</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>DBoW2</tag>
        <tag>回环检测</tag>
      </tags>
  </entry>
  <entry>
    <title>隐马尔可夫模型</title>
    <url>/2020/03/10/2020-03-13-HMM_model/</url>
    <content><![CDATA[<p>隐马尔可夫模型是关于时序的概率模型，描述由一个隐藏的马尔可夫链随机生成不可观测的状态的序列，再由各个状态随机生成一个观测而产生观测的序列的过程。</p>
<p>隐马尔可夫模型是可用于标注问题的统计学习模型，描述有隐藏的马尔科夫链随机生成观测序列的过程，属于生成模型。本文将学习隐马尔可夫模型，着重介绍掌握HMM的模型、应用、及理论推导过程。</p>
<p>来源：李航的《统计学习方法》</p>
<a id="more"></a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>隐马尔可夫模型是关于时序的概率模型，描述了由一个隐藏的马尔可夫链随机生成不可观测的状态随机序列，再有各个状态生成一个观测而产生随机序列的过程。隐藏的马尔可夫链随机生成的状态的序列成为状态序列；每个状态生成一个观测得到的观测随机序列成为观测序列。序列得每一个位置都可以看作是一个时刻。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>机器学习中的步骤优化：</p>
<ol>
<li>确定模型</li>
<li>确定策略 即准则（损失函数）</li>
<li>算法：GN</li>
</ol>
<h3 id="概率图模型"><a href="#概率图模型" class="headerlink" title="概率图模型"></a>概率图模型</h3><p>概率图模型（ probabilistic graphical model）是一类用图来表达变量相关关系的概率模型。它以图为表示工具，最常见的是用一个结点表示一个或一组随机变量，结点之间的边表示变量间的概率相关关系，即“变量关系图”.根据边的性质不同，概率图模型可大致分为两类：</p>
<p>第一类是使用有向无环图表示变量间的依赖关系，称为有向图模型或贝叶斯网（ Bayesian network）；</p>
<p>第二类是使用无向图表示变量间的相关关系，称为无向图模型或马尔可夫网（ Markov network）;</p>
<p>概率图模型可以分为有向图(贝叶斯网络)、无向图（马尔可夫随机场）；</p>
<p>概率图模型+时间序列=动态模型；</p>
<p>动态模型主要有：HMM、卡尔曼滤波器、粒子滤波器；</p>
<ol>
<li>HMM：系统状态离散</li>
<li>Kalman滤波器：系统状态连续且线性分布</li>
<li>Particle滤波器：系统状态连续且非线性分布</li>
</ol>
<h3 id="HMM定义"><a href="#HMM定义" class="headerlink" title="HMM定义"></a>HMM定义</h3><p>​        隐马尔可夫模型由初始概率分布、状态转移概率分布以及观测概率分布确定。形式定义如下：</p>
<p>设Q是所有可能的状态集合，V是所有可能的观测的集合。<br>$$<br>Q = {q_1,q_2,…,q_N},V={v_1,v_2,…v_M}<br>$$<br>其中，N是可能的状态数，M是可能的观测数。</p>
<p>I是长度为T的状态序列，O是对应的观测序列<br>$$<br>I={i_1,i_2,…,i_N},O={v_1,v_2,…,v_M}<br>$$<br>A是状态转移概率矩阵：<br>$$<br>A=[a_ij]<em>{N\times N}<br>$$<br>其中，<br>$$<br>a</em>{ij}=P(i_{t+1}=i_t|q_j),i=1,2,..N;j=1,2,…,N<br>$$<br>表示在时刻t处于状态$q_i$的条件下在时刻t+1转移到状态$q_j$的概率。</p>
<p>B是观测概率矩阵：<br>$$<br>B=[b_j(k)]_{N\times M}<br>$$<br>其中，<br>$$<br>b_j(k)=P(o_t=v_k|i_t=q_j)，i=1,2,…N;j=1,2,…,N<br>$$<br>是在时刻t处于状态$q_j$的条件下生成观测$v_k$的概率。</p>
<p>$\pi$是初始状态概率向量：<br>$$<br>\pi=(\pi_i)<br>$$<br>其中，<br>$$<br>\pi=P(i_1=q_i),i=1,2,…N<br>$$<br>是时刻t=1处于状态$t=1$处于状态$q_i$的概率。</p>
<p>​    因此，隐马尔勒夫模型由初始状态向量$\pi$、状态转移概率矩阵Ahead观测概率矩阵B决定。$\pi$和A决定状态序列，B决定观测序列。因此，隐马尔可夫模型$\lambda$可以用三元符号表示，即<br>$$<br>\lambda=(A,B,\pi)<br>$$<br>$A,B,\pi$称为隐马尔可夫模型的三要素。</p>
<p>​    状态转移概率矩阵A与初始状态概率向量π确定了隐藏的马尔可夫链，生成不可观测的状态序列。观测概率矩阵B确定了如何从状态生成观测，与状态序列综合确定了如何产生观测序列</p>
<h3 id="两个基本假设"><a href="#两个基本假设" class="headerlink" title="两个基本假设"></a>两个基本假设</h3><ol>
<li><p><strong>齐次马尔可夫性假设</strong>，即假设隐藏的马尔可夫链在任意时刻t的状态只依赖于其前一其前一时刻的状态，于其它时刻的状态及观测无关，也与时刻t无关。<br>$$<br>P(i_t|i_t-1,o_{t-1},…,i_1,o_1)=P(i_t|i_t-1),t=1,2,…,T<br>$$</p>
</li>
<li><p><strong>观测独立性假设</strong>，即假设任意时刻的观测只依赖于该时刻的马尔可夫链的状态，与其他观测及状态无关。<br>$$<br>P(o_T|i_T,o_T,i_{T-1},o_{T-1}，…i_{t+1},o_{t+1},i_t,i_{t-1},o_{t-1},…,i_1,o_1)=P(o_t|i_t)<br>$$</p>
</li>
</ol>
<h3 id="观测序列的生成过程"><a href="#观测序列的生成过程" class="headerlink" title="观测序列的生成过程"></a>观测序列的生成过程</h3><p>根据HMM模型定义，可以将一个长度为T的观测序列$O=(o_1,o_2,…o_T)$的生成过程描述如下：</p>
<p>算法：观测序列的生成</p>
<p>输入：隐马尔可夫模型$\lambda=(A,B,\pi)$,观测序列长度；</p>
<p>输出：观测序列$O=(o_1,o_2,…,o_T)$</p>
<ol>
<li>按照初始状态分布$\pi$产生状态$i_1$</li>
<li>令t=1</li>
<li>按照状态$i_t$的观测概率分布$b_{i_t(k)}$生成$o_t$</li>
<li>按照状态$i_t$的状态转移概率分布${a_{i_ti_{t+1}}}$产生状态$i_{t+1},i_{t+2}=1,2,…N$ </li>
<li>令t=t+1,如果t&lt;T，转步（3），否则，终止</li>
</ol>
<h2 id="算法推导"><a href="#算法推导" class="headerlink" title="算法推导"></a>算法推导</h2><p>隐马尔可夫模型有三个<strong>基本问题</strong>：</p>
<ol>
<li><strong>概率计算问题</strong>。给的模型$\lambda=(A,B,\pi)$和观测序列$O=(o_1,o_2,…,o_T)$，计算在模型$\lambda$下观测序列O出现的概率$P(O|\lambda)$。</li>
<li><strong>学习问题</strong>。阈值观测序列$O=(o_1,o_2,…,o_T)$，估计模型参数$\lambda=(A,B,\pi)$参数，使得在该模型下观测序列序列概率$P(O|\lambda)$最大，即用极大似然估计的方法估计参数</li>
<li><strong>预测问题</strong>，（解码（decoding）问题）。一致模型$\lambda=(A,B,\pi)$和观测序列$O=(o_1,o_2,…,o_T)$,求对给定观测序列条件概率$P(I|O)$最大的状态序列$I=(i_1,i_2,…,i_T)$，即<strong>给定观测序列，求最有可能的对应的状态序列。</strong></li>
</ol>
<p>本节将介绍HMM模型的概率计算算法、学习算法以及预测算法</p>
<h3 id="概率计算算法"><a href="#概率计算算法" class="headerlink" title="概率计算算法"></a>概率计算算法</h3><p><strong>目的</strong>：给定模型$\lambda=(A,B,\pi)$和观测序列$O=(o_1,o_2,…,o_T)$，计算在模型$\lambda$下观测序列O出现的概率$P(O|\lambda)$。</p>
<h4 id="直接计算法"><a href="#直接计算法" class="headerlink" title="直接计算法"></a>直接计算法</h4><p>最直接的方法是按照概率公式直接计算。通过列举所有可能的长度为T的状态序列$I=(i_1,i_2,…i_T)$，求各个状态序列I与观测序列$O=(o_1,o_2,…,o_T)$的联合概率$P(O,I|\lambda)$，然后对所有可能的状态序列求和，得到$P(O|\lambda)$。</p>
<p>状态序列$I=(i_1,i_2,…i_T)$的概率是<br>$$<br>P(I|\lambda)=\pi_{i_1}a_{i_1i_2}a_{i_2i_3}…a_{i_{T-1}i_T}<br>$$<br>对固定的状态序列$I=(i_1,i_2,…i_T)$,观测序列$O=(o_1,o_2,…,o_T)$的概率是$P(O|I,\lambda)$，<br>$$<br>P(O|I,\lambda)=b_{i_1}(o_1)b_{i_2}(o_2)…b_{i_T}(o_T)<br>$$<br>O和I同时出现的概率为：<br>$$<br>P(O,I|\lambda)=P(O|I,\lambda)P(I,\lambda)=\pi_{i_i}b_{i_1}(o_1)a_{i_1i_2}b_{i_2}(o_2)…a_{i_{T-1}i_T}b(o_T)<br>$$<br>对所有可能的状态序列I球壳，得到观测序列O的概率$P(P|\lambda)$，即<br>$$<br>P(O|\lambda)=\sum_IP(O|I,\lambda)P(I|\lambda)=\sum_{i_1,i_2,…,i_T}\pi_{i_1}b_{i_1}(o_1)a_{i_1I_2}b_{i_2}(o_2)…a_{i_{T-1}i_T}b_{i_T}(o_T)<br>$$<br>这种方法很容易理解，但是计算量很大，是$O(TN^T)$阶的。不可行</p>
<h4 id="前向算法（forward-backward-algorithm）"><a href="#前向算法（forward-backward-algorithm）" class="headerlink" title="前向算法（forward-backward algorithm）"></a>前向算法（forward-backward algorithm）</h4><p><strong>前向概率</strong> 给定隐马尔可夫模型$\lambda$，定义时刻t部分观测序列为$O=(o_1,o_2,…,o_T)$且状态为$q_i$的概率为前向概率，记作<br>$$<br>\alpha_t(i)=P(o_1,o_2,…,o_t,i_t=q_i|\lambda)<br>$$<br><strong>观测序列概率的前向算法</strong></p>
<p>输入：隐马尔可夫模型$\lambda$，观测序列O;</p>
<p>输出：观测序列概率$P(O|\lambda)$</p>
<ol>
<li><p>初值<br>$$<br>\alpha_1(i)=\pi_ib_i(o_1),i=1,2,…N<br>$$</p>
</li>
<li><p>递推 对 $t=1,2,..,T-1$<br>$$<br>\alpha_{t+1}(i)=[\sum^N_{j=1}\alpha_t(j)a_{ji}]b_t(o_{t+1}),i=1,2,…N<br>$$</p>
</li>
<li><p>终止<br>$$<br>P(O|\lambda)=\sum^N_{j=1}\alpha_T(i)<br>$$</p>
</li>
</ol>
<p>算法解读，步骤（1）初始化前向概率是初始时刻状态和观测的联合概率，步骤（2）是前向概率的递推公式，计算到时刻t+1部分观测序列在时刻t+1且初始状态$q_i$的的前向概率。</p>
<p>所以：<br>$$<br>P(O|\lambda)=\sum^N_{j=1}\alpha_T(i)<br>$$<br>下图表示了前向概率的递推公式：</p>
<p><img src="/2020/03/10/2020-03-13-HMM_model/..%5Cimages%5CHMM%5C%E5%89%8D%E5%90%91%E6%A6%82%E7%8E%87%E7%9A%84%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F.png" alt="递推公式"></p>
<h4 id="后向算法"><a href="#后向算法" class="headerlink" title="后向算法"></a>后向算法</h4><p><strong>后向概率</strong>：给定隐马尔可夫模型$\lambda$ ，定义在时刻t状态为$q_i$的条件下，从t+1到T的部分观测序列为$o_{t+1},o_{t+2},…o_T$的概率为后向概率，记作：<br>$$<br>\beta_t(i)=P(o_{t+1},o_{t+2},…,o_T|i_t=q_i,\lambda)<br>$$<br>可以也递推的方法求得后向概率$\beta_t(i)$及观测序列概率$P(O|\lambda)$.</p>
<p><strong>算法步骤</strong></p>
<p><strong>输入</strong>：隐马尔可夫模型$\lambda$,观测序列O;</p>
<p><strong>输出</strong>：观测序列$P(O|\lambda)$;</p>
<ol>
<li><p>$\beta_T(i)=1,i=1,2,…N$</p>
</li>
<li><p>对$t=T-1,T-2,…1$<br>$$<br>\beta_t(i)=\sum^N_{j=1}a_{ij}b_j(a_{t+1})\beta_{t+1}(j),i=1,2,…,N<br>$$</p>
</li>
</ol>
<p>算法（1）初始化后向概率，对最终时刻的所有状态$q_i$规定$\beta_T(i)=1$ ；步骤（2）是后向概率的递推公式。</p>
<p><img src="/2020/03/10/2020-03-13-HMM_model/..%5Cimages%5CHMM%5C%E5%90%8E%E5%90%91%E6%A6%82%E7%8E%87%E7%9A%84%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F.png" alt="后向概率的递推公式"></p>
<h3 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h3><h4 id="监督学习方法"><a href="#监督学习方法" class="headerlink" title="监督学习方法"></a>监督学习方法</h4><h4 id="Baum-welch算法"><a href="#Baum-welch算法" class="headerlink" title="Baum-welch算法"></a>Baum-welch算法</h4><h3 id="预测算法（Decoding算法"><a href="#预测算法（Decoding算法" class="headerlink" title="预测算法（Decoding算法)"></a>预测算法（Decoding算法)</h3><h4 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h4><h4 id="维特比算法"><a href="#维特比算法" class="headerlink" title="维特比算法"></a>维特比算法</h4><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>隐马尔可夫模型在语音识别、自然语言处理、生物信息、模式识别等领域有着广泛的应用。</p>
<p>HMM的主要应用是解码</p>
<p>两种解码方法：</p>
<ol>
<li>Viterbi算法解码</li>
<li>前向后向算法+贝叶斯后验概率</li>
</ol>
<h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><h3 id="词性标注"><a href="#词性标注" class="headerlink" title="词性标注"></a>词性标注</h3><p>词性是隐藏状态，词出现时观察序列。</p>
<p>首先我们要知道模型的参数，如果又标注数据，直接用比例代替概率，如果没有用前向后向算法求除</p>
<p>知道模型参数吧，使用Viterbi算法来计算某个标注序列（隐含状态）的概率</p>
<h3 id="实际建模过程"><a href="#实际建模过程" class="headerlink" title="实际建模过程"></a>实际建模过程</h3><ul>
<li>根据实际问题确定状态个数及观察序列</li>
<li>用若干已知序列，采用B-W算法估计参数（转移概率和输出概率的值）</li>
<li>输入位置序列用Viterbi算法或者贝叶斯概率解码</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>HMM</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Kalibr标定双目相机与IMU</title>
    <url>/2020/02/15/2020-02-15-Calibrate_IMU_Camera_by_Kalibr/</url>
    <content><![CDATA[<p>本文介绍如何利用Kalibr标定工具进行双目相机与IMU的联合标定。主要过程包括以下四步：</p>
<ol>
<li>生成标定板</li>
<li>标定双目相机</li>
<li>标定IMU</li>
<li>联合标定</li>
</ol>
<a id="more"></a>

<h2 id="1-生成标定板"><a href="#1-生成标定板" class="headerlink" title="1. 生成标定板"></a>1. 生成标定板</h2><p>使用AprilTag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosrun kalibr kalibr_create_target_pdf --type apriltag --nx 6 --ny 6 --tsize 0.002 --tspace 0.3</span><br></pre></td></tr></table></figure>



<h2 id="2-标定双目相机"><a href="#2-标定双目相机" class="headerlink" title="2. 标定双目相机"></a>2. 标定双目相机</h2><p>降低帧率</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosrun topic_tools throttle messages &#x2F;l_cam&#x2F;image_raw 4 &#x2F;left</span><br><span class="line">rosrun topic_tools throttle messages &#x2F;r_cam&#x2F;image_raw 4 &#x2F;right</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">advertised as &#x2F;left &#x2F;&#x2F;出现时说明将帧成功</span><br></pre></td></tr></table></figure>

<p>录制bag包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosbag record &#x2F;left &#x2F;right &gt;mycamera.bag</span><br></pre></td></tr></table></figure>

<h3 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h3><h4 id="ImportError-cannot-import-name-NavigationToolbar2Wx"><a href="#ImportError-cannot-import-name-NavigationToolbar2Wx" class="headerlink" title="ImportError: cannot import name NavigationToolbar2Wx"></a>ImportError: cannot import name NavigationToolbar2Wx</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;cjn&#x2F;kalibr&#x2F;src&#x2F;kalibr&#x2F;Schweizer-Messer&#x2F;sm_python&#x2F;python&#x2F;sm&#x2F;PlotCollection.py</span><br><span class="line">解决：将 PlotCollection.py 中的NavigationToolbar2Wx 改为 NavigationToolbar2WxAgg</span><br></pre></td></tr></table></figure>

<h4 id="ImportError-No-module-named-igraph"><a href="#ImportError-No-module-named-igraph" class="headerlink" title="ImportError: No module named igraph"></a>ImportError: No module named igraph</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python2.7-igraph</span><br></pre></td></tr></table></figure>



<h4 id="kalibr标定时出现：ImportError-No-module-named-Image"><a href="#kalibr标定时出现：ImportError-No-module-named-Image" class="headerlink" title="kalibr标定时出现：ImportError: No module named Image."></a>kalibr标定时出现：ImportError: No module named Image.</h4><p>解决方法： 在kalibr_workspace/aslam_offline_calibration/kalibr/python/kalibr_camera_calibration/MulticamGraph.py中<br>将import Image改为from PIL import Image</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosrun kalibr kalibr_calibrate_cameras --bag &#39;&#x2F;home&#x2F;guoben&#x2F;stereocam.bag&#39; --topics &#x2F;left &#x2F;right --models pinhole-radtan pinhole-radtan --target &#39;&#x2F;home&#x2F;guoben&#x2F;Project&#x2F;Kalibr_ws&#x2F;april_6x6_80x80cm.yaml&#39; --show-extraction --approx-sync 0.1</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>标定的时候图中不能存在两个标定板</li>
<li>起始画面和终止画面要稳定</li>
</ul>
<h2 id="3-标定IMU"><a href="#3-标定IMU" class="headerlink" title="3. 标定IMU"></a>3. 标定IMU</h2><p>参考：<a href="https://blog.csdn.net/learning_tortosie/article/details/89878769" target="_blank" rel="noopener">IMU噪声标定——加速度计和陀螺仪的白噪声和零偏不稳定性</a></p>
<p>//录制bag文件</p>
<ol>
<li>collect the data while the IMU is Stationary, with a two hours duration;</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosbag	record &#x2F;imu0</span><br></pre></td></tr></table></figure>

<p>有Code_utils和imu_utils两个包 先编译code_utils再编译imu_tils</p>
<p>得到的imu.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">IMU</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">ICM20602</span></span><br><span class="line"><span class="attr">Gyr:</span></span><br><span class="line">   <span class="attr">unit:</span> <span class="string">" rad/s"</span></span><br><span class="line">   <span class="attr">avg-axis:</span></span><br><span class="line">      <span class="attr">gyr_n:</span> <span class="number">1.4127871720120859e+02</span></span><br><span class="line">      <span class="attr">gyr_w:</span> <span class="number">4.8477797168896648e-03</span></span><br><span class="line">   <span class="attr">x-axis:</span></span><br><span class="line">      <span class="attr">gyr_n:</span> <span class="number">3.9615886574940606e+02</span></span><br><span class="line">      <span class="attr">gyr_w:</span> <span class="number">4.8477797168896648e-03</span></span><br><span class="line">   <span class="attr">y-axis:</span></span><br><span class="line">      <span class="attr">gyr_n:</span> <span class="number">1.5284722859858114e+01</span></span><br><span class="line">      <span class="attr">gyr_w:</span> <span class="number">4.8477797168896648e-03</span></span><br><span class="line">   <span class="attr">z-axis:</span></span><br><span class="line">      <span class="attr">gyr_n:</span> <span class="number">1.2392562994361640e+01</span></span><br><span class="line">      <span class="attr">gyr_w:</span> <span class="number">4.8477797168896648e-03</span></span><br><span class="line"><span class="attr">Acc:</span></span><br><span class="line">   <span class="attr">unit:</span> <span class="string">" m/s^2"</span></span><br><span class="line">   <span class="attr">avg-axis:</span></span><br><span class="line">      <span class="attr">acc_n:</span> <span class="number">3.8264508828802807e-01</span></span><br><span class="line">      <span class="attr">acc_w:</span> <span class="number">1.0613073078261251e-02</span></span><br><span class="line">   <span class="attr">x-axis:</span></span><br><span class="line">      <span class="attr">acc_n:</span> <span class="number">3.6962189636668691e-01</span></span><br><span class="line">      <span class="attr">acc_w:</span> <span class="number">1.0916554449621266e-02</span></span><br><span class="line">   <span class="attr">y-axis:</span></span><br><span class="line">      <span class="attr">acc_n:</span> <span class="number">4.6707198750779616e-01</span></span><br><span class="line">      <span class="attr">acc_w:</span> <span class="number">1.0721472803944067e-02</span></span><br><span class="line">   <span class="attr">z-axis:</span></span><br><span class="line">      <span class="attr">acc_n:</span> <span class="number">3.1124138098960102e-01</span></span><br><span class="line">      <span class="attr">acc_w:</span> <span class="number">1.0201191981218414e-02</span></span><br></pre></td></tr></table></figure>

<p>修改为如下样式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rostopic:</span> <span class="string">/imu0</span></span><br><span class="line"><span class="attr">update_rate:</span> <span class="number">100.0</span> <span class="comment">#Hz</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">accelerometer_noise_density:</span> <span class="number">3.8264508828802807e-01</span> <span class="comment">#continous</span></span><br><span class="line"><span class="attr">accelerometer_random_walk:</span> <span class="number">1.0613073078261251e-02</span> </span><br><span class="line"><span class="attr">gyroscope_noise_density:</span> <span class="number">1.4127871720120859e+02</span> <span class="comment">#continous</span></span><br><span class="line"><span class="attr">gyroscope_random_walk:</span> <span class="number">4.8477797168896648e-03</span></span><br></pre></td></tr></table></figure>



<h2 id="4-录制数据包"><a href="#4-录制数据包" class="headerlink" title="4. 录制数据包"></a>4. 录制数据包</h2><p>沿着3个轴旋转平移三次</p>
<h2 id="5-联合标定"><a href="#5-联合标定" class="headerlink" title="5. 联合标定"></a>5. 联合标定</h2><p>准备好四个文件</p>
<ol>
<li>标定半文件</li>
<li>相机参数文件</li>
<li>imu参数文件</li>
<li>数据bag文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosrun kalibr kalibr_calibrate_imu_camera --target april_6x6_80x80cm.yaml --cam stereocam.yaml --imu ICM20602.yaml --bag camera_imu.bag --timeoffset-padding 0.1</span><br></pre></td></tr></table></figure>

<h2 id="6-标定结果"><a href="#6-标定结果" class="headerlink" title="6. 标定结果"></a>6. 标定结果</h2><p>得到结果为camchain.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cam0:</span></span><br><span class="line">  <span class="attr">T_cam_imu:</span> <span class="comment"># 从IMU到相机坐标的转换</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.08233179976406399,</span> <span class="number">-0.9949127683235393</span><span class="string">,</span> <span class="number">-0.05805220214946505</span><span class="string">,</span> <span class="number">-0.008744023342066004</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[-0.9959106050536686,</span> <span class="number">-0.08430878258416843</span><span class="string">,</span> <span class="number">0.032466843406961834</span><span class="string">,</span> <span class="number">0.07000917129335886</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[-0.03719598754229868,</span> <span class="number">0.055141750117018384</span><span class="string">,</span> <span class="number">-0.9977854708827878</span><span class="string">,</span> <span class="number">-0.11902680705823296</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.0,</span> <span class="number">0.0</span><span class="string">,</span> <span class="number">0.0</span><span class="string">,</span> <span class="number">1.0</span><span class="string">]</span></span><br><span class="line">  <span class="attr">cam_overlaps:</span> <span class="string">[1]</span></span><br><span class="line">  <span class="attr">camera_model:</span> <span class="string">pinhole</span></span><br><span class="line">  <span class="attr">distortion_coeffs:</span> <span class="string">[-0.4274960254764774,</span> <span class="number">0.1522753401860188</span><span class="string">,</span> <span class="number">0.022086313718892994</span><span class="string">,</span></span><br><span class="line">    <span class="number">-0.0007250205609533983</span><span class="string">]</span> <span class="comment">#失真模型的参数向量</span></span><br><span class="line">  <span class="attr">distortion_model:</span> <span class="string">radtan</span> </span><br><span class="line">  <span class="attr">intrinsics:</span> <span class="string">[576.2948258096362,</span> <span class="number">570.5120047531799</span><span class="string">,</span> <span class="number">290.9276492936449</span><span class="string">,</span> <span class="number">165.99488000803987</span><span class="string">]</span> <span class="comment">#相机内参 之前标好的</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">[640,</span> <span class="number">480</span><span class="string">]</span> <span class="comment">#分辨率</span></span><br><span class="line">  <span class="attr">rostopic:</span> <span class="string">/l_cam/image_raw</span> <span class="comment">#话题</span></span><br><span class="line">  <span class="attr">timeshift_cam_imu:</span> <span class="number">-0.04319840825131607</span> <span class="comment">#漂移</span></span><br><span class="line"><span class="attr">cam1:</span> </span><br><span class="line">  <span class="attr">T_cam_imu:</span> <span class="comment"># 从IMU到相机坐标的转换</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.0894795247331801,</span> <span class="number">-0.9911722483784674</span><span class="string">,</span> <span class="number">0.0978314300104943</span><span class="string">,</span> <span class="number">-0.06676213145949367</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[-0.995095690056223,</span> <span class="number">-0.08480851440432002</span><span class="string">,</span> <span class="number">0.05091250844401363</span><span class="string">,</span> <span class="number">0.06960856622513922</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[-0.04216612722380045,</span> <span class="number">-0.10190726141402426</span><span class="string">,</span> <span class="number">-0.9938998580269747</span><span class="string">,</span> <span class="number">-0.12389393733183268</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.0,</span> <span class="number">0.0</span><span class="string">,</span> <span class="number">0.0</span><span class="string">,</span> <span class="number">1.0</span><span class="string">]</span></span><br><span class="line">  <span class="attr">T_cn_cnm1:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.9878176058814627,</span> <span class="number">-0.002372804306504643</span><span class="string">,</span> <span class="number">-0.1555980311904324</span><span class="string">,</span> <span class="number">-0.07647885002996721</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[-0.000506528488511444,</span> <span class="number">0.9998294218114983</span><span class="string">,</span> <span class="number">-0.01846268422998622</span><span class="string">,</span> <span class="number">-0.0025906464811484946</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.155615297896788,</span> <span class="number">0.018316579369764666</span><span class="string">,</span> <span class="number">0.9876479038507021</span><span class="string">,</span> <span class="number">-0.0062589855841411746</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.0,</span> <span class="number">0.0</span><span class="string">,</span> <span class="number">0.0</span><span class="string">,</span> <span class="number">1.0</span><span class="string">]</span></span><br><span class="line">  <span class="attr">cam_overlaps:</span> <span class="string">[0]</span></span><br><span class="line">  <span class="attr">camera_model:</span> <span class="string">pinhole</span></span><br><span class="line">  <span class="attr">distortion_coeffs:</span> <span class="string">[-0.4358292770104687,</span> <span class="number">0.13856343257725542</span><span class="string">,</span> <span class="number">0.01867787729653694</span><span class="string">,</span></span><br><span class="line">    <span class="number">-0.011189753016360725</span><span class="string">]</span></span><br><span class="line">  <span class="attr">distortion_model:</span> <span class="string">radtan</span></span><br><span class="line">  <span class="attr">intrinsics:</span> <span class="string">[572.0873971077864,</span> <span class="number">571.5888157262697</span><span class="string">,</span> <span class="number">349.04660762135626</span><span class="string">,</span> <span class="number">174.35778659111406</span><span class="string">]</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">[640,</span> <span class="number">480</span><span class="string">]</span></span><br><span class="line">  <span class="attr">rostopic:</span> <span class="string">/r_cam/image_raw</span></span><br><span class="line">  <span class="attr">timeshift_cam_imu:</span> <span class="number">-0.002440062477866302</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>IMU</tag>
        <tag>Kalibr</tag>
      </tags>
  </entry>
  <entry>
    <title>利用ROS标定相机步骤与方法</title>
    <url>/2020/02/15/2020-02-15-Calibrate_Camera_by_ROS/</url>
    <content><![CDATA[<p>本文讲解利用ROS框架下的工具标定USB相机的过程。</p>
<a id="more"></a>

<h2 id="利用IMU标定相机流程"><a href="#利用IMU标定相机流程" class="headerlink" title="利用IMU标定相机流程"></a>利用IMU标定相机流程</h2><ol>
<li>驱动USB摄像头</li>
<li>利用camera_calibration标定相机</li>
</ol>
<p>执行命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosrun camera_calibration cameracalibrator.py --approximate 0.1 --size 9x6 --square 0.03 right:&#x3D;&#x2F;r_cam&#x2F;image_raw left:&#x3D;&#x2F;l_cam&#x2F;image_raw right_camera:&#x3D;&#x2F;r_cam left_camera:&#x3D;&#x2F;l_cam</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image_width: 320</span><br><span class="line">image_height: 240</span><br><span class="line">camera_matrix:</span><br><span class="line">  rows: 3</span><br><span class="line">  cols: 3</span><br><span class="line">  data: [247.284755, 0.000000, 160.857882, 0.000000, 246.200449, 111.816057, 0.000000, 0.000000, 1.000000]</span><br><span class="line"></span><br><span class="line">distortion_coefficients:</span><br><span class="line">  rows: 1</span><br><span class="line">  cols: 5</span><br><span class="line">  data: [-0.405110, 0.167545, -0.000400, -0.002129, 0.000000]</span><br><span class="line"></span><br><span class="line">rectification_matrix:</span><br><span class="line">  rows: 3</span><br><span class="line">  cols: 3</span><br><span class="line">  data: [0.999530, -0.021547, 0.021827, 0.021830, 0.999680, -0.012768, -0.021545, 0.013239, 0.999680]</span><br><span class="line">  </span><br><span class="line">projection_matrix:</span><br><span class="line">  rows: 3</span><br><span class="line">  cols: 4</span><br><span class="line">  data: [227.343911, 0.000000, 160.318575, 0.000000, 0.000000, 227.343911, 109.066130, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>内参矩阵A：(cx,cy)为主光轴点,一般为图像的中心；fx和fy为焦距</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9565709-72d7a6aeb3e0826d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/127/format/webp" alt="img"></p>
</li>
<li><p>畸变参数向量：[k1,k2,p1,p2]</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">camera matrix &#x3D;</span><br><span class="line"></span><br><span class="line">[fx 0.0 cx</span><br><span class="line"></span><br><span class="line">0.0 fy cy</span><br><span class="line"></span><br><span class="line">0.0 0.0 1.0]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>相机标定</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu1604连接蓝牙鼠标</title>
    <url>/2020/02/15/2020-02-15-UbuntuBluetooth/</url>
    <content><![CDATA[<p>打开命令行<br>$ sudo -i</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[bluetooth]# power off</span><br><span class="line">[bluetooth]# power on</span><br><span class="line">[bluetooth]# scan on</span><br><span class="line">[bluetooth]# connect XX:XX:XX:XX:XX:XX</span><br><span class="line">[Arc Touch Mouse SE]# trust</span><br><span class="line">[Arc Touch Mouse SE]# pair</span><br><span class="line">[Arc Touch Mouse SE]# unblock</span><br><span class="line">[Arc Touch Mouse SE]# power off</span><br><span class="line">[bluetooth]# power on</span><br></pre></td></tr></table></figure>

<p>注意先从系统设置的蓝牙里，把之前配对的设备删掉，我还把 /var/lib/bluetooth/…./XX:XX:XX:XX:XX 的老的配对文件也给删了。<br>重新配对后，info 文件里的内容比1楼里的内容多了 ConnectionParameters、IdentityResolvingKey、LocalSignatureKey、LongTermKey 等好几段数据</p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS系统解析</title>
    <url>/2020/02/15/2020-02-15-VINS_Mono_System/</url>
    <content><![CDATA[<h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>基本框架如下图所示<br><img src="/images/VINS%E8%A7%A3%E6%9E%90/VINS%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="image-20191202164309191"></p>
<a id="more"></a>

<p><img src="/images/VINS%E8%A7%A3%E6%9E%90/VINS%E5%B8%A7%E9%97%B4%E7%BA%A6%E6%9D%9F.png" alt="image-20191202163857217"></p>
<blockquote>
<ol>
<li>黄色的是IMU的帧间约束（PVQBaBg 15*1）</li>
<li>蓝色为视觉重投影误差约束（2*1）</li>
<li>绿色为闭环帧，用来计算相对位资，用于闭环优化时使用</li>
<li>红色的是IMU预计分步骤</li>
</ol>
</blockquote>
<p>本文重点看IMU约束与视觉约束</p>
<h4 id="前端使用光流跟踪"><a href="#前端使用光流跟踪" class="headerlink" title="前端使用光流跟踪"></a>前端使用光流跟踪</h4><ol>
<li>cv::goodfeaturesToTrack检测Harris角点</li>
<li>cv::CalcOpticalFlowPyrLK跟踪相邻帧的角点</li>
<li>cv::findFundamentalMat 去除异常点</li>
<li>统一的球面模型</li>
</ol>
<h4 id="关键帧选择机制"><a href="#关键帧选择机制" class="headerlink" title="关键帧选择机制"></a>关键帧选择机制</h4><ol>
<li>平均视差大于某个阈值</li>
<li>跟踪的特征点数量小于某个阈值</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>VINS</tag>
      </tags>
  </entry>
  <entry>
    <title>发布IMU信息到ROS系统中</title>
    <url>/2020/02/15/2020-02-15-Pub_IMU_Message_To_ROS/</url>
    <content><![CDATA[<p>以下记录是在调试树莓派3b中得到的经验</p>
<p>​    本文记录调试树莓派3b中得到的经验，如何把IMU信息发布到ROS系统中。</p>
<a id="more"></a>

<h2 id="发布IMU信息到ROS"><a href="#发布IMU信息到ROS" class="headerlink" title="发布IMU信息到ROS"></a>发布IMU信息到ROS</h2><h2 id="sensor-msgs-Imu-msg"><a href="#sensor-msgs-Imu-msg" class="headerlink" title="sensor_msgs/Imu.msg"></a>sensor_msgs/Imu.msg</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Header header</span><br><span class="line"> </span><br><span class="line">geometry_msgs&#x2F;Quaternion orientation</span><br><span class="line">float64[9] orientation_covariance # Row major about x, y, z axes</span><br><span class="line"> </span><br><span class="line">geometry_msgs&#x2F;Vector3 angular_velocity</span><br><span class="line">float64[9] angular_velocity_covariance # Row major about x, y, z axes</span><br><span class="line"> </span><br><span class="line">geometry_msgs&#x2F;Vector3 linear_acceleration</span><br><span class="line">float64[9] linear_acceleration_covariance # Row major x, y z</span><br></pre></td></tr></table></figure>

<p>其中，文档描述了Imu的消息结构，其中姿态（orientation）类型为四元数（geometry_msgs/Quaternion）；角速度（angular_velocity）和线加速度（linear_acceleration）的类型为三维向量（geometry_msgs/Vector3）。</p>
<h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><ol>
<li><p>WiringPi未安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone WiringPi</span><br><span class="line">cd WiringPi</span><br><span class="line">sudo chmod 771 .&#x2F;build</span><br><span class="line">sudo .&#x2F;build</span><br></pre></td></tr></table></figure>
</li>
<li><p>I2C device</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建ros包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">catkin_create_pkg beginner_tutorials std_msgs rospy roscpp</span><br></pre></td></tr></table></figure>

<p>然后修改XML和CMakeLists.txt</p>
</li>
</ol>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>IMU</tag>
      </tags>
  </entry>
  <entry>
    <title>VIO主流框架</title>
    <url>/2020/02/15/2020-02-15-VIO_Framework/</url>
    <content><![CDATA[<p>本节主要说明当前主流的VIO算法流程。课程来源于<a href="https://www.bilibili.com/video/av44472237?t=297" target="_blank" rel="noopener">B站</a>。</p>
<a id="more"></a>

<h2 id="高斯牛顿法"><a href="#高斯牛顿法" class="headerlink" title="高斯牛顿法"></a>高斯牛顿法</h2><p>误差项:<br>$$<br>e(x+\Delta x)=e(x)+J(x)\Delta x<br>$$</p>
<ol>
<li>一次观测</li>
<li>多次观测</li>
<li>逆深度 + VIO</li>
</ol>
<h2 id="EKF滤波和优化"><a href="#EKF滤波和优化" class="headerlink" title="EKF滤波和优化"></a>EKF滤波和优化</h2><ol>
<li>EKF铝箔相当于之迭代一次的优化，区别是滤波仅考虑上一帧的影响，而优化则考虑所有帧的影响</li>
<li>多次优化精度比滤波高，但效率低于滤波，因优化可以迭代多次，不断优化线性化点，是误差最小</li>
</ol>
<h2 id="IMU预积分"><a href="#IMU预积分" class="headerlink" title="IMU预积分"></a>IMU预积分</h2><ol>
<li>积分下一个时刻的PVQ作为视觉初始值</li>
<li>预计分相邻帧的PVQ变化量，作为IMU的约束</li>
<li>计算IMU误差的协方差和jacobian</li>
</ol>
<p><img src="/images/photo/image-20191202112248399.png" alt="image-20191202112248399"></p>
<h2 id="VIO分类"><a href="#VIO分类" class="headerlink" title="VIO分类"></a>VIO分类</h2><ol>
<li><p>将视觉约束就加到联合优化是紧耦合</p>
</li>
<li><p>将视觉约束后的位姿加入到联合优化是松耦合</p>
</li>
</ol>
<p><img src="/image/image-20191202135710367.png" alt="image-20191202135710367"></p>
<h3 id="MSCKF"><a href="#MSCKF" class="headerlink" title="MSCKF"></a>MSCKF</h3><p>具体流程如下所示:</p>
<ol>
<li>初始化</li>
<li>IMU预测</li>
<li>视觉跟踪</li>
<li>视觉增广</li>
<li>视觉更新—选老点或者看不见的点</li>
<li>视觉更新—边缘化</li>
<li>剔除老帧</li>
</ol>
<p><img src="/images/SLAM/image-20191202142230678.png" alt="image-20191202142230678"></p>
<p>误差状态向量<br>$$<br>\hat{X_k}^{(15+6N)\times1} = [\hat{X_{IMU_k}} \delta \theta_{C_1} \ce{G}\hat{p}<em>{C_1} …\ce{^{G}\hat{p}</em>{c_N} \ce{G}\hat{p}_{C_N}}]<br>$$</p>
<p>$$<br>\hat{X}_{IMU}_k^{15\times1}=[\delta\theta_I  \hat{b_g}\space\ce{G}\hat{v}_I\hat{b}_a\space \ce{G}\hat{p}_I ]^T<br>$$</p>
<blockquote>
<p>每得到一个新图像以后需要对协方差矩阵做一个增广</p>
</blockquote>
<p><img src="/images/SLAM/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E6%8E%A8%E5%AF%BC/MSCKF%E5%AF%B9%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%E7%9A%84%E5%A2%9E%E5%B9%BF.png" alt="MSCKF对协方差矩阵的增广"></p>
<p><img src="/images/SLAM/MSCKF%E6%BB%A4%E6%B3%A2.png" alt="image-20191202144228268"></p>
<blockquote>
<p>成熟的路标点 表示窗口内各帧都看得到的点</p>
</blockquote>
<p><strong>因子图</strong></p>
<p><img src="/images/SLAM/MSCKF%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="image-20191202145520572"></p>
<blockquote>
<p>Tbc表示IMU与相机间的转换矩阵</p>
</blockquote>
<p><img src="/images/SLAM/%E8%BE%B9%E7%BC%98%E5%8C%961.png" alt="image-20191202145642717"></p>
<p><img src="/images/SLAM/%E8%BE%B9%E7%BC%98%E5%8C%962.png" alt="image-20191202145714060"></p>
<p>路标点边缘化完后就可以了</p>
<p><strong>第j个路标点的所有视觉误差为</strong><br>$$<br>r^{2M\times1}\cong H_x^{2M\times(15+6N)\tilde{X}^{(15+N)\times1}}+H_f^{2M\times3}\ce{G}\hat{p}_{f_j}^{3\times1}+n^{2M\times1}<br>$$<br><img src="/images/SLAM/MSCKF%E5%9B%A0%E5%AD%90%E5%9B%BE3.png" alt="image-20191202150951897"></p>
<p>将r投影到Hf的左零空间，想党羽对路标点进行边缘化，将边缘化约束来优化共视帧。<br>$$<br>r_0^(2M-3M_L)\times1=A^Tr^2M\times1\cong A^TH_{x}^{2M\times(15+6N)}\tilde{X}^{(15+6N)\times1}+A^Tn^(2M\times1)<br>$$</p>
<h3 id="ROVIO"><a href="#ROVIO" class="headerlink" title="ROVIO"></a>ROVIO</h3><blockquote>
<p>复杂 不常用</p>
</blockquote>
<p>流程</p>
<ol>
<li>IMU预测</li>
<li>视觉更新</li>
<li>IEKF</li>
<li>相机模型</li>
<li>像素坐标校正</li>
<li>光度误差</li>
<li>QR分解</li>
<li>Paych提取及Warp计算</li>
<li>路标点质量评价及维护</li>
</ol>
<p><img src="/images/SLAM/ROVIO%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image-20191202152338738"></p>
<blockquote>
<p>ROVIO使用光度误差</p>
<p><img src="/images/SLAM/ROVIO%E7%8A%B6%E6%80%81%E5%90%91%E9%87%8F.png" alt="image-20191202152951499"></p>
</blockquote>
<blockquote>
<blockquote>
<p>ROVIO将路标点包含到状态向量中。有因将路标点表征在当前帧的坐标系下，有范围限制，因此对其进行归一化得到无约束的状态量—方向向量Bearing Vector</p>
</blockquote>
</blockquote>
<p>ROVIO的创新点如下所示：</p>
<p>ROVIO中，路标点使用当前帧下的归一化相机系坐标Pc和你深度表示，并作为状态向量进行预测和更新。参数化不同导致预测和更新的细节不同，但总体还是EKF五大公式。又因Pc有边界约束，因此引入了Bearing  Vector老了使得Pc平滑可导</p>
<p><img src="/images/SLAM/ROVIO%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png" alt="image-20191202153359978"></p>
<p>状态向量：当前帧的PVQB和路标点( mu,p)</p>
<p><img src="/images/SLAM/ROVIO%E7%8A%B6%E6%80%81%E5%90%91%E9%87%8F.png" alt="image-20191202154121085"></p>
<p>因子图如下</p>
<p><img src="/images/SLAM/ROVIO%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="image-20191202154600998"></p>
<h3 id="VINS"><a href="#VINS" class="headerlink" title="VINS"></a>VINS</h3><h4 id="优化向量"><a href="#优化向量" class="headerlink" title="优化向量"></a>优化向量</h4><blockquote>
<p>包括滑动窗口内的n个相机状态PVQB、Camera到IMU的外参、m个3D点的逆深度：</p>
</blockquote>
<p>$$<br>X=[x_0,x_1,…x_n,x_c^b,\lambda_0,\lambda_1,…\lambda_m]<br>$$</p>
<p><img src="/images/SLAM/VINS%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="image-20191202155816170"></p>
<blockquote>
<p>框表示滑动窗口，T中的R、t表示P、Q ；M中的是v和b；lambda表示路标的逆深度；（外参没有考虑）</p>
</blockquote>
<h3 id="VI-ORB"><a href="#VI-ORB" class="headerlink" title="VI-ORB"></a>VI-ORB</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="/images/SLAM/VIORB%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image-20191202160942722"></p>
<p>Tracklocal map：仅优化当前帧</p>
<p><img src="/images/SLAM/VIORB%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="image-20191202160729305"></p>
<p>Local Map：优化华创内的所有帧的PVQB和路标点</p>
<p><img src="/images/SLAM/VIORB_LocalBA%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="image-20191202161217237"></p>
<h3 id="ICE-BA"><a href="#ICE-BA" class="headerlink" title="ICE-BA"></a>ICE-BA</h3><p><strong>增量式BA</strong>，误差为IMU和视觉，LBA为滑窗优化，GBA为所有KF优化，速度很快。</p>
<p><img src="/home/guoben/ICE-BA%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="image-20191202161618980"></p>
<p>ICE-BA认为在建立增量方程时，对之前已经算过的且不变的那些状态向量没必要重新线性化（线性化及计算Jacobian），因为即使重新计算Jacobian也没什么变化。另外，也没必要对整体[H|b]矩阵进行消元，而是只对变化的进行更新。最后只计算变化的路标点即可。对于没有变化的状态向量的临时值则一直保存下来，避免重新计算。</p>
<p>总结而言，在ICE-BA中更新Factor有三种情况：</p>
<ol>
<li>该Factor在本次迭代中没有变化，则不更新；</li>
<li>该Factor是新Factor，则在原来基础上+=新Factor。如新观察到一个新的路标点，则对此新路标点的观测约束就是一个新的Factor；</li>
<li>该Factor已存在但需要更新，则先减去旧Factor，再架上新Factor。</li>
</ol>
<p><img src="/images/SLAM/ICEBA_LocalBA%E4%B8%8EGlobalBA.png" alt="image-20191202162754352"></p>
]]></content>
      <tags>
        <tag>VINS</tag>
        <tag>VIO</tag>
      </tags>
  </entry>
  <entry>
    <title>使用evo工具评测SLAM</title>
    <url>/2020/02/15/2020-02-19-How_to_use_evo/</url>
    <content><![CDATA[<p>evo是一款用于视觉里程计和slam问题的轨迹评估工具。核心功能是能够绘制相机的轨迹，或评估估计轨迹与真值的误差。支持多种数据集的轨迹格式（TUM、KITTI、EuRoC MAV、ROS的bag），同时支持这些数据格式之间进行相互转换。在此仅对其基本功能做简要介绍。并且介绍如何修改经典的SLAM算法以输出可使用evo评测的轨迹。</p>
<p><a href="https://github.com/MichaelGrupp/evo" target="_blank" rel="noopener">github地址</a></p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>使用pypi直接安装：</li>
</ol>
<figure class="highlight plain"><figcaption><span>install evo --upgrade --no-binary evo ```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 本地编译安装</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; pip install --editable . --upgrade --no-binary evo</span><br></pre></td></tr></table></figure>
<p>安装完毕后，在命令行输入evo，若显示了相关信息，则表明安装成功。若提示”command not found”也不用惊慌，很多人遇到这种问题，重启电脑即可找到evo相应指令。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>指标</strong></p>
<ul>
<li><code>evo_ape</code> - absolute pose error - 绝对误差计算绝对位姿误差(absolute pose error)，用于整体评估整条轨迹的全局一致性；<br>evo_rpe：计算相对位姿误差(relative pose error)，用于评价轨迹局部的准确性。</li>
<li><code>evo_rpe</code>  - relative pose error - 相对误差 （相对误差=绝对误差/真值）</li>
</ul>
<p><strong>工具命令</strong></p>
<ul>
<li><p><code>evo_traj</code> - tool for analyzing, plotting or exporting one or more trajectories 对轨迹进行分析、画图</p>
</li>
<li><p><code>evo_res</code> - tool for comparing one or multiple result files from <code>evo_ape</code> or <code>evo_rpe</code> 对比多个结果</p>
</li>
<li><p><code>evo_fig</code> - (experimental) tool for re-opening serialized plots (saved with <code>--serialize_plot</code>) </p>
</li>
<li><p><code>evo_config</code> - tool for global settings and config file manipulation -设置参数</p>
</li>
<li><p><code>-va</code> a 对齐轨迹</p>
</li>
</ul>
<p>evo绘制轨迹的指令为：evo_traj，后跟必要参数有：数据的格式（tum/kitti/bag/euroc等），轨迹文件。轨迹文件可以有多个，例如：<br>evo_traj tum traj1.txt traj2.txt<br>这个指令只是显示轨迹的基本信息，若要绘制轨迹，则增加可选参数 -p 或 –plot<br>evo_traj tum traj1.txt –p</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>对比/绘制VINS-mono/fusion的轨迹时需要对其代码进行修改，具体参考<a href="https://blog.rneko.com/posts/3937502838.html" target="_blank" rel="noopener">该博客</a>.</li>
</ul>
<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><h3 id="EuRoC"><a href="#EuRoC" class="headerlink" title="EuRoC"></a>EuRoC</h3><p>画groundtruth的轨迹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evo_traj euroc .&#x2F;groundtruth&#x2F;MH_01_data.csv -p --plot_mode&#x3D;xyz</span><br></pre></td></tr></table></figure>

<p>画某一次结果的轨迹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evo_traj tum .&#x2F;result&#x2F;MH_01&#x2F;loop_result.csv -p --plot_mode&#x3D;xyz</span><br></pre></td></tr></table></figure>

<h3 id="TUM"><a href="#TUM" class="headerlink" title="TUM"></a>TUM</h3><p>groundtruth.txt 为外部运动捕捉系统采集到的相机位姿,格式为(time, t x , t y , t z , q x , q y , q z , q w ),</p>
<h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><h3 id="VINS-Mono"><a href="#VINS-Mono" class="headerlink" title="VINS-Mono"></a>VINS-Mono</h3><p>VINS-mono的估计结果需要按照TUM格式输出 因此要对代码做一些调整。在一下两个文件中修改即可。</p>
<ul>
<li><p>“vins_result_loop” : defined in [path to Vins folder]/pose_graph/src/pose_graph.cpp ; line 156 or 630. The format is timestamp + position(x,y, z) + quaternion(qw, qx, qy, qz).</p>
</li>
<li><p>“vins_result_no_loop”: defined in [path to Vins folder]/vins_estimator/src/utility/visualization.cpp in function pubOdometry(). </p>
<p>The format is timestamp + position(x,y, z) + quaternion(qw, qx, qy, qz) + velocity(x,y,z).</p>
</li>
</ul>
<p>代码修改过程：</p>
<p><strong>visualization.cpp -&gt; Pubodometry ()</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// write result to file 为了按照TUM格式输出 调换了位置</span></span><br><span class="line"><span class="keyword">double</span> turetime = header.stamp.toSec();</span><br><span class="line"><span class="function">ofstream <span class="title">foutC</span><span class="params">(VINS_RESULT_PATH, ios::app)</span></span>;</span><br><span class="line">foutC.setf(ios::fixed, ios::floatfield);</span><br><span class="line">foutC &lt;&lt; turetime &lt;&lt;<span class="string">" "</span></span><br><span class="line">      &lt;&lt; estimator.Ps[WINDOW_SIZE].x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; estimator.Ps[WINDOW_SIZE].y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; estimator.Ps[WINDOW_SIZE].z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; tmp_Q.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; tmp_Q.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; tmp_Q.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; tmp_Q.w() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>*<em>pose_graph.cpp *</em></p>
<p>updatePath()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (SAVE_LOOP_PATH)</span><br><span class="line">   &#123;        </span><br><span class="line">       <span class="function">ofstream <span class="title">loop_path_file</span><span class="params">(<span class="string">"/home/guoben/Documents/output/loop_result.csv"</span>, ios::app)</span></span>;</span><br><span class="line">       <span class="keyword">double</span> turetime = cur_kf-&gt;time_stamp;</span><br><span class="line">       loop_path_file.setf(ios::fixed, ios::floatfield);</span><br><span class="line">       loop_path_file  &lt;&lt; turetime &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; P.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; P.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; P.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; Q.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; Q.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; Q.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; Q.w() &lt;&lt; <span class="built_in">endl</span>;           </span><br><span class="line">      loop_path_file.<span class="built_in">close</span>();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//一共有两处</span></span><br><span class="line">       <span class="keyword">if</span> (SAVE_LOOP_PATH)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="function">ofstream <span class="title">loop_path_file</span><span class="params">(VINS_RESULT_PATH, ios::app)</span></span>;</span><br><span class="line">           loop_path_file.setf(ios::fixed, ios::floatfield);</span><br><span class="line">           loop_path_file &lt;&lt; (*it)-&gt;time_stamp &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">           loop_path_file  &lt;&lt; P.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; P.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; P.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; Q.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; Q.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; Q.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; Q.w() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">           loop_path_file.<span class="built_in">close</span>();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<p>画某一个结果的轨迹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evo_traj tum .&#x2F;loop_result.csv -p --plot_mode&#x3D;xyz</span><br></pre></td></tr></table></figure>

<p>对比结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evo_rpe euroc .&#x2F;groundtruth&#x2F;MH_01_data.csv .&#x2F;result&#x2F;MH_01&#x2F;vins_result_loop.csv -va -r full --plot</span><br></pre></td></tr></table></figure>

<p>MSCKF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ofstream foutC(&quot;&#x2F;home&#x2F;guoben&#x2F;Documents&#x2F;output&#x2F;result_vio.csv&quot;, ios::app);</span><br><span class="line">&#x2F;&#x2F; foutC.setf(ios::fixed, ios::floatfield);</span><br><span class="line">&#x2F;&#x2F; foutC &lt;&lt; odom_msg.header.stamp.toSec() &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.position.x &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.position.y &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.position.z &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.orientation.x &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.orientation.y &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.orientation.z &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.orientation.w &lt;&lt; endl;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>VIO</tag>
        <tag>evo</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法简介</title>
    <url>/2020/01/15/2020-01-15-chinese-markdown-cheatsheet/</url>
    <content><![CDATA[<h2 id="分段与分行"><a href="#分段与分行" class="headerlink" title="分段与分行"></a>分段与分行</h2><p>以一个或多个空行来隔开段落；以两个或多个空格来段内换行。</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is an H1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">This is an H2</span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line"># This is an H1</span><br><span class="line"></span><br><span class="line">##  This is an H2</span><br><span class="line"></span><br><span class="line">######  This is an H6</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在每一行前面写一个<code>&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class="line">&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line">&gt;</span><br><span class="line">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class="line">&gt; id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
<p>或者在每一段前面写一个<code>&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class="line">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line"></span><br><span class="line">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class="line">id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>

<h2 id="多重引用"><a href="#多重引用" class="headerlink" title="多重引用"></a>多重引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; This is the first level of quoting.</span><br><span class="line">&gt;</span><br><span class="line">&gt; &gt; This is nested blockquote.</span><br><span class="line">&gt;</span><br><span class="line">&gt; Back to the first level.</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表项占一行，以*、+、-开头即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>有序列表只需要将上述标记符换成数字加句点。而且顺序由书写顺序决定，与数字无关，但数字需要从1开始。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1\.  Bird</span><br><span class="line">3.  McHale</span><br><span class="line">2.  Parish</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<p>每一个列表项可以多行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line">Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class="line">viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class="line">Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</li>
<li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</li>
</ul>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>每一行前面缩进四个或以上个空格，就认为是开始了一段代码块。代码块内原样输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is a normal paragraph:</span><br><span class="line"></span><br><span class="line">    This is a code block.</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p>This is a normal paragraph:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is a code block.</span><br></pre></td></tr></table></figure>

<h2 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h2><p>三个或更多个<code>*</code>、<code>-</code>（它们之间可以有空格）会产生横线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * *</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<hr>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>内嵌链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I get 10 times more traffic from [Google](http:&#x2F;&#x2F;google.com&#x2F; &quot;Google&quot;)</span><br><span class="line">than from [Yahoo](http:&#x2F;&#x2F;search.yahoo.com&#x2F; &quot;Yahoo Search&quot;) or</span><br><span class="line">[MSN](http:&#x2F;&#x2F;search.msn.com&#x2F; &quot;MSN Search&quot;).</span><br></pre></td></tr></table></figure>

<p>或参考文献式链接（缺省的链接标记认为与文本一致）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I get 10 times more traffic from [Google] [1] than from</span><br><span class="line">[Yahoo] [2] or [MSN] [3].</span><br><span class="line"></span><br><span class="line">  [1]: http:&#x2F;&#x2F;google.com&#x2F;        &quot;Google&quot;</span><br><span class="line">  [2]: http:&#x2F;&#x2F;search.yahoo.com&#x2F;  &quot;Yahoo Search&quot;</span><br><span class="line">  [3]: http:&#x2F;&#x2F;search.msn.com&#x2F;    &quot;MSN Search&quot;</span><br><span class="line"></span><br><span class="line">I get 10 times more traffic from [Google][] than from</span><br><span class="line">[Yahoo][] or [MSN][].</span><br><span class="line"></span><br><span class="line">  [google]: http:&#x2F;&#x2F;google.com&#x2F;        &quot;Google&quot;</span><br><span class="line">  [yahoo]:  http:&#x2F;&#x2F;search.yahoo.com&#x2F;  &quot;Yahoo Search&quot;</span><br><span class="line">  [msn]:    http:&#x2F;&#x2F;search.msn.com&#x2F;    &quot;MSN Search&quot;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p>I get 10 times more traffic from <a href="http://google.com/" target="_blank" rel="noopener" title="Google">Google</a> than from <a href="http://search.yahoo.com/" target="_blank" rel="noopener" title="Yahoo Search">Yahoo</a> or <a href="http://search.msn.com/" target="_blank" rel="noopener" title="MSN Search">MSN</a>.</p>
<p>如果直接以链接地址作为链接文本，可以用如下快捷写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;http:&#x2F;&#x2F;www.shengbin.me&gt; 效果：</span><br></pre></td></tr></table></figure>

<p><a href="http://www.shengbin.me/" target="_blank" rel="noopener">http://www.shengbin.me</a></p>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>单个<code>*</code>或<code>_</code>产生斜体，两个（<code>**</code>、<code>__</code>）则产生粗体。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*like* _this_</span><br><span class="line"></span><br><span class="line">**like** **this**</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><em>like</em> <em>this</em></p>
<p><strong>like</strong> <strong>this</strong></p>
<h2 id="内嵌代码"><a href="#内嵌代码" class="headerlink" title="内嵌代码"></a>内嵌代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code: &#96;echo hello&#96;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p>code: <code>echo hello</code></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片与链接类似，只需在文本前面加上感叹号<code>!</code>即可。图片位置和大小无法通过Markdown来指定。</p>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>以下特殊字符需要用<code>\</code>转义得到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\   backslash</span><br><span class="line">&#96;   backtick</span><br><span class="line">*   asterisk</span><br><span class="line">_   underscore</span><br><span class="line">&#123;&#125;  curly braces</span><br><span class="line">[]  square brackets</span><br><span class="line">()  parentheses</span><br><span class="line">#   hash mark</span><br><span class="line">+   plus sign</span><br><span class="line">-   minus sign (hyphen)</span><br><span class="line">.   dot</span><br><span class="line">!   exclamation mark</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM各算法运行方法与过程</title>
    <url>/2020/01/15/2020-01-15-SLAM_Alg_Indirect/</url>
    <content><![CDATA[<p>本文介绍本人在实践过程中遇到的各个间接法的运行和配置过程。</p>
<p>主要包括以下五种算法:</p>
<ol>
<li>VINS_mono/fusion</li>
<li>OKVIS</li>
<li>ROVIO</li>
<li>VI_ORB-SLAM</li>
<li>MSCKF</li>
</ol>
<a id="more"></a>

<h2 id="VINS-mono"><a href="#VINS-mono" class="headerlink" title="VINS_mono"></a>VINS_mono</h2><hr>
<h2 id="OKVIS"><a href="#OKVIS" class="headerlink" title="OKVIS"></a>OKVIS</h2><h3 id="Run-OKVIS"><a href="#Run-OKVIS" class="headerlink" title="Run OKVIS"></a>Run OKVIS</h3><p>可能需要加入std::ftream<br>Opencv需要3.4.2或以下版本，需要opencvv模块<br>Opencv3.4.7没有这个模块</p>
<hr>
<h2 id="ROVIO"><a href="#ROVIO" class="headerlink" title="ROVIO"></a>ROVIO</h2><p>可参考：[该博客]<a href="https://www.cnblogs.com/Jessica-jie/p/6607719.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jessica-jie/p/6607719.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">catkin build rovio --cmake-args -DCMAKE_BUILD_TYPE&#x3D;Release -DMAKE_SCENE&#x3D;ON</span><br></pre></td></tr></table></figure>

<h3 id="运行ROVIO"><a href="#运行ROVIO" class="headerlink" title="运行ROVIO"></a>运行ROVIO</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ source devel&#x2F;setup.bash </span><br><span class="line">$ roslaunch rovio rovio_node.launch</span><br></pre></td></tr></table></figure>

<h3 id="修改代码以输出路径"><a href="#修改代码以输出路径" class="headerlink" title="修改代码以输出路径"></a>修改代码以输出路径</h3><p>在发送IMU数据下边添加输出到文件的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;把数据写到文档里</span><br><span class="line"> std::ofstream vio_result_file(&quot;&#x2F;home&#x2F;guoben&#x2F;Documents&#x2F;output&#x2F;vio_result.csv&quot;, ios::app);</span><br><span class="line"> vio_result_file &lt;&lt; ros::Time(mpFilter_-&gt;safe_.t_) &lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; imuOutput_.WrWB()(0) &lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; imuOutput_.WrWB()(1) &lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; imuOutput_.WrWB()(2)  &lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; imuOutput_.qBW().x()  &lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; imuOutput_.qBW().y()&lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; imuOutput_.qBW().z() &lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; -imuOutput_.qBW().w() &lt;&lt; std::endl;</span><br><span class="line"> vio_result_file.close();</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="VI-ORB-SLAM"><a href="#VI-ORB-SLAM" class="headerlink" title="VI-ORB_SLAM"></a>VI-ORB_SLAM</h2><p><a href="https://github.com/jingpang/LearnVIORB" target="_blank" rel="noopener"> LearnVIORB 的代码地址</a><br>代码运行方法<br>轨迹生成<br>输出位置位于 System.cc    </p>
<hr>
<h2 id="MSCKF"><a href="#MSCKF" class="headerlink" title="MSCKF"></a>MSCKF</h2><h3 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">roslaunch msckf_vio msckf_vio_euroc.launch </span><br><span class="line">rosrun rviz rviz -d ~&#x2F;Project&#x2F;msckf_vio_workspace&#x2F;src&#x2F;msckf_vio&#x2F;rviz&#x2F;rviz_euroc_config.rviz   &#x2F;&#x2F;rviz显示模型</span><br><span class="line">  rosbag play &#x2F;home&#x2F;wj&#x2F;Downloads&#x2F;dataset&#x2F;EuRoC&#x2F;ROS_bag&#x2F;MH_05_difficult.bag</span><br></pre></td></tr></table></figure>

<p><strong>NOTE</strong><br>The software does not run on EuRoC <code>MH_01_easy.bag</code> and <code>MH_02_easy.bag</code>. As explained in the README, the algorithm requires the sensor to start from staic in order to initialize the orientation and IMU bias. unfortunately, <code>MH_01_easy.bag</code> and <code>MH_02_easy.bag</code> do not have the initial static period.</p>
]]></content>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World!</title>
    <url>/2020/01/14/2020-01-14_hello_world/</url>
    <content><![CDATA[<p>今天是我生平的第一个博客空间！</p>
<p>以后把好玩的东西、学习过程都写在这里！</p>
<p>愿世界和平！</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>Hello</tag>
        <tag>me</tag>
      </tags>
  </entry>
</search>
