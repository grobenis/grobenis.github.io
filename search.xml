<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于GroundTruth轨迹生成IMU数据</title>
    <url>/2020/09/19/Generate-Imu-Data-Based-on-GroundTruth/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="1、定义相机变换矩阵"><a href="#1、定义相机变换矩阵" class="headerlink" title="1、定义相机变换矩阵"></a>1、定义相机变换矩阵</h3><p>首先使用4*4的变换矩阵来来表示相机之间的变换T：</p>
<img src="/2020/09/19/Generate-Imu-Data-Based-on-GroundTruth/image-20200723220416181.png" alt="image-20200723220416181" style="zoom: 50%;">

<p>​    使用$T_{b,a}$表示时间Δt内，帧$T_{w,a}$与帧$T_{w,b}$(其中w为世界坐标系)之间运动的速度（该速度恒定且包括角速度和线速度）可表示为矩阵形式：</p>
<img src="/2020/09/19/Generate-Imu-Data-Based-on-GroundTruth/image-20200723220712114.png" alt="image-20200723220712114" style="zoom: 50%;">

<p>​        其中log是矩阵对数。对于矩阵组SE3，对数映射和它的逆(指数映射)就可以在闭域内计算。</p>
<h3 id="2、根据离散的点拟合连续的曲线"><a href="#2、根据离散的点拟合连续的曲线" class="headerlink" title="2、根据离散的点拟合连续的曲线"></a>2、根据离散的点拟合连续的曲线</h3><p>为了得到IMU数据，我们需要知晓轨迹的数学形式，为此，我们需要先根据离散的点轨迹拟合曲线，这个过程通过B样条插值来完成。</p>
<p>曲线p(t)可以使用点$P_i$和基本方程$B_{i,k}(t)$来表示:<br>$$<br>p(t) = \sum^n_{i=0}p_iB_{i,k}(t)<br>$$<br>其中$p_i$表示控制点，$B_{i,k}(t)$是基础函数，可以使用De Boor-Cox递归公式进行计算得到。上式可以组织为如下形式：<br>$$<br>p(t)=p_0\tilde{B}<em>{0,k}(t)+\sum^{n}</em>{i=1}(p_i-p_{i-1})\tilde{B}<em>{i,k}(t)<br>$$<br>其中$\tilde{B}</em>{i,k}(t) = \sum^{n}<em>{j=i}B</em>{j,k}(t)$是累加的基础函数。利用对数和指数映射，把$p_0$映射到李代数上：$p_0 = \log(T_{w,0})$.</p>
<p>将$p_i,p_{i-1}$两两个点之间的转移方程映射到李代数上，可表示为$\Omega_i = \log(T^{-1}<em>{w,i-1}T</em>{w,i})$.</p>
<p>可以把由等式2描述的李群中的轨迹重写为如下形式。<br>$$<br>T_{w,s}(t) = \exp(\tilde{B_{0,k}(t)})\log(T_{w,0}))\prod^n_{i=1}\exp(\tilde{B}<em>{i,k}(t)\Omega_i)<br>$$<br>其中，$R</em>{w,s}(t)\in SE^3$是t可是沿着样条线的位姿。 $T_{w,s}(t)$ 可以看作是轨迹</p>
<h3 id="3-根据曲线生成IMU的加速度和陀螺仪角速度数据"><a href="#3-根据曲线生成IMU的加速度和陀螺仪角速度数据" class="headerlink" title="3. 根据曲线生成IMU的加速度和陀螺仪角速度数据"></a>3. 根据曲线生成IMU的加速度和陀螺仪角速度数据</h3><p>​        累积的B样条参数化满足可求导性，因此可轻松地得到加速度计和陀螺仪的带误差的测量值。计算公式如下：</p>
<p><img src="/2020/09/19/Generate-Imu-Data-Based-on-GroundTruth/image-20200723171456502.png" alt="image-20200723171456502"></p>
<p>其中,$\dot{R}<em>{w,s}$和$\ddot{s}_w$分别是$\dot{T}</em>{w,s}$和$\ddot{T_{w,s}}$相应的子矩阵. $g_w$是世界坐标系下的重力加速度.</p>
<p>其中，$T_{w,s}$表示s系中的点在w系中的变换，$R^T_{w,s}$是的子矩阵，表示纯旋转。$R_{w,s}$是的子矩阵，$s_w(u)$是$T_{w,s}$的子矩阵，代表平移，$g_w$是重力在w系中的加速度。</p>
<h2 id="实践环节"><a href="#实践环节" class="headerlink" title="实践环节"></a>实践环节</h2><h3 id="TUM-GT2IMU"><a href="#TUM-GT2IMU" class="headerlink" title="TUM-GT2IMU"></a>TUM-GT2IMU</h3><p>程序语言 （Matlab）</p>
<h4 id="文档目录结构"><a href="#文档目录结构" class="headerlink" title="文档目录结构"></a>文档目录结构</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">(base) guoben@guoben-Ubuntu-<span class="number">1804</span>:~/Project/TUM-RGBD-GT2IMU$ <span class="built_in">tree</span>.</span><br><span class="line">├── GT2IMU.m</span><br><span class="line">├── IMUgenerate2.m</span><br><span class="line">├── IMUgenerate.m</span><br><span class="line">├── test1.m</span><br><span class="line">├── trajEst.m</span><br><span class="line">├── trajGenerate.m</span><br><span class="line">├── trajRead.m</span><br><span class="line">├── trajShow.m</span><br><span class="line">└── trajWrite.m</span><br><span class="line">├── tools</span><br><span class="line">│   ├── asm2v.m</span><br><span class="line">│   ├── c2q.m</span><br><span class="line">│   ├── pose2T.m</span><br><span class="line">│   ├── q2c.m</span><br><span class="line">│   ├── q4inv.m</span><br><span class="line">│   ├── q4mult.m</span><br><span class="line">│   ├── RK4.m</span><br><span class="line">│   ├── state_pro.m</span><br><span class="line">│   ├── T2J.m</span><br><span class="line">│   ├── v2asm.m</span><br><span class="line">│   └── zeta2J.m</span><br></pre></td></tr></table></figure>

<h3 id="各文件函数与作用"><a href="#各文件函数与作用" class="headerlink" title="各文件函数与作用"></a>各文件函数与作用</h3><h4 id="1-GT2IMU-m：源文件，在这里设置轨迹文件作为输入，然后生成IMU轨迹"><a href="#1-GT2IMU-m：源文件，在这里设置轨迹文件作为输入，然后生成IMU轨迹" class="headerlink" title="1. GT2IMU.m：源文件，在这里设置轨迹文件作为输入，然后生成IMU轨迹"></a>1. GT2IMU.m：源文件，在这里设置轨迹文件作为输入，然后生成IMU轨迹</h4><h4 id="2-trajRead：读取轨迹文件"><a href="#2-trajRead：读取轨迹文件" class="headerlink" title="2. trajRead：读取轨迹文件"></a>2. trajRead：读取轨迹文件</h4><p>输入：<code>groundtruth.txt</code>文件</p>
<p>输出：<code>GT</code>文件，<code>timestamp</code>文件，<code>pose</code>文件</p>
<p>其中，时间戳文件是一维矩阵，pose文件是7维矩阵，格式：四元数+平移</p>
<h4 id="3-trajEst：仿真轨迹估计"><a href="#3-trajEst：仿真轨迹估计" class="headerlink" title="3. trajEst：仿真轨迹估计"></a>3. trajEst：仿真轨迹估计</h4><p>读取<code>GT</code>文件，生成B样条插值函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">save(<span class="string">'Bs'</span>,<span class="string">'kT'</span>,<span class="string">'Tk'</span>,<span class="string">'dT'</span>,<span class="string">'tIMU'</span>,<span class="string">'Te'</span>,<span class="string">'dt'</span>,<span class="string">'B0'</span>,<span class="string">'B1'</span>,<span class="string">'B2'</span>,<span class="string">'B3'</span>,<span class="string">'tl'</span>)</span><br></pre></td></tr></table></figure>

<p>生成仿真函数的过程</p>
<ul>
<li>统计节点Node个数 计算对应的时间</li>
<li>最小化由实际观测值与预测观测值之差形成的目标函数，来批量或在窗口上求解样条曲线和摄像机参数。</li>
</ul>
]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>IMU</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>本文学习自《图解HTTP》，目的是为了系统的学习这个协议</p>
<a id="more"></a>

<p>HTTP的</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最初设想的基本理念是:借助多文档之间相互关联形成的超文本(HyperText),连成可相互参阅的 WWW(World Wide Web,万维网)。</p>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h4><p>HTTP 正式作为标准被公布是在 1996 年的 5 月,版本被命名为HTTP/1.0,并记载于 RFC1945。虽说是初期标准,但该协议标准至今仍被广泛使用在服务器端。</p>
<h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>1997 年 1 月公布的 HTTP/1.1 是目前主流的 HTTP 协议版本。当初的标准是 RFC2068,之后发布的修订版 RFC2616 就是当前的最新版本。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层:应用层、传输层、网络层和数据链路层。</p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914102826121.png" alt="image-20200914102826121"></p>
<table>
<thead>
<tr>
<th></th>
<th>各层的作用</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>决定了向用户提供应用服务时通信的活动</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层对上层应用层,提供处于网络连接中的两台计算机之间的数据传输。</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。<br>该层规定了通过怎样的路径(所谓的传输路线)到达对方计算机,并把数据包传送给对方。</td>
</tr>
<tr>
<td>网络接口层</td>
<td>用来处理连接网络的硬件部分。</td>
</tr>
</tbody></table>
<p>与 HTTP 关系密切的协议 : IP、TCP 和DNS，其中IP协议负责传输，TCP协议确保可靠，DNS服务负责域名解析。</p>
<p>各个协议与HTTP协议之间的关系</p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914103657745.png" alt="image-20200914103657745"></p>
<h3 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h3><p>URI 用字符串标识某一互联网资源,而 URL 表示资源的地点(互联网上所处的位置)。可见 URL 是 URI 的子集。</p>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p> HTTP 协议用于客户端和服务器端之间的通信</p>
<h3 id="1-通过请求和响应的交换达成通信"><a href="#1-通过请求和响应的交换达成通信" class="headerlink" title="1 通过请求和响应的交换达成通信"></a>1 通过请求和响应的交换达成通信</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。</p>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>响应报文基本上由协议版本、状态码(表示请求成功或失败的数字代码)、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。稍后我们会对这些内容进行详细说明。</p>
<h3 id="2-HTTP-是不保存状态的协议"><a href="#2-HTTP-是不保存状态的协议" class="headerlink" title="2 HTTP 是不保存状态的协议"></a>2 HTTP 是不保存状态的协议</h3><p>HTTP 是一种不保存状态,即无状态(stateless)协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别,协议对于发送过的请求或响应都不做持久化处理。</p>
<p>HTTP/1.1 虽然是无状态协议,但为了实现期望的保持状态功能,于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信,就可以管理状态了。有关 Cookie 的详细内容稍后讲解。</p>
<h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><h4 id="1-GET-获取资源"><a href="#1-GET-获取资源" class="headerlink" title="1 GET: 获取资源"></a>1 GET: 获取资源</h4><p>GET 方法用来请求访问已被 URI 识别的资源。</p>
<p>指定的资源经服务器端解析后返回响应内容。也就是说,如果请求的资源是文本,那就保持原样返回;如果是像 CGI(Common Gateway Interface,通用网关接口)那样的程序,则返回经过执行后的输出结果。</p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914104731577.png" alt="image-20200914104731577"></p>
<h4 id="2-POST-传输实体主体"><a href="#2-POST-传输实体主体" class="headerlink" title="2 POST: 传输实体主体"></a>2 POST: 传输实体主体</h4><p>POST 方法用来传输实体的主体。</p>
<p>虽然用 GET 方法也可以传输实体的主体,但一般不用 GET 方法进行传输,而是用 POST 方法。虽说 POST 的功能与 GET 很相似,但POST 的主要目的并不是获取响应的主体内容。</p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914104844902.png" alt="image-20200914104844902"></p>
<h4 id="3-PUT-传输文件"><a href="#3-PUT-传输文件" class="headerlink" title="3 PUT:传输文件"></a>3 PUT:传输文件</h4><p>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样,要求在请求报文的主体中包含文件内容,然后保存到请求 URI 指定的位置。</p>
<p>但是,鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制,任何人都可以上传文件 , 存在安全性问题,因此一般的 Web 网站不使用该方法。</p>
<p>若配合 Web 应用程序的验证机制,或架构设计采用REST(REpresentational State Transfer,表征状态转移)标准的同类Web 网站,就可能会开放使用 PUT 方法。</p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914105045445.png" alt="image-20200914105045445"></p>
<h4 id="4-HEAD-获得报文首部"><a href="#4-HEAD-获得报文首部" class="headerlink" title="4 HEAD:获得报文首部"></a>4 HEAD:获得报文首部</h4><p>HEAD 方法和 GET 方法一样,只是不返回报文主体部分。用于确认<br>URI 的有效性及资源更新的日期时间等。</p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914105138317.png" alt="image-20200914105138317"></p>
<h4 id="5-DELETE-删除文件"><a href="#5-DELETE-删除文件" class="headerlink" title="5 DELETE:删除文件"></a>5 DELETE:删除文件</h4><p>DELETE 方法用来删除文件,是与 PUT 相反的方法。</p>
<p>DELETE 方法按请求 URI 删除指定的资源。但是,HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制,所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用程序的验证机制,或遵守 REST 标准时还是有可能会开放使用的。</p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914105210975.png" alt="image-20200914105210975"></p>
<h4 id="6-OPTIONS-询问支持的方法"><a href="#6-OPTIONS-询问支持的方法" class="headerlink" title="6 OPTIONS:询问支持的方法"></a>6 OPTIONS:询问支持的方法</h4><p>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914105231225.png" alt="image-20200914105231225"></p>
<h4 id="7-TRACE-追踪路径"><a href="#7-TRACE-追踪路径" class="headerlink" title="7 TRACE:追踪路径"></a>7 TRACE:追踪路径</h4><p>TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。</p>
<p>发送请求时,在 Max-Forwards 首部字段中填入数值,每经过一个服务器端就将该数字减 1,当数值刚好减到 0 时,就停止继续传输,最后接收到请求的服务端则返回状态码 200 OK 的响应。客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/ 篡改的。这是因为,请求想要连接到源目标服务器可能会通过代理中转,TRACE 方法就是用来确认连接过程中发生的一系列操作。但是,TRACE 方法本来就不怎么常用,再加上它容易引发XST(Cross-Site Tracing,跨站追踪)攻击,通常就更不会用到了。</p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914105432225.png" alt="image-20200914105432225"></p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914105506925.png" alt="image-20200914105506925"></p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914105512891.png" alt="image-20200914105512891"></p>
<h4 id="8-CONNECT-要求用隧道协议连接代理"><a href="#8-CONNECT-要求用隧道协议连接代理" class="headerlink" title="8 CONNECT: 要求用隧道协议连接代理"></a>8 CONNECT: 要求用隧道协议连接代理</h4><p>CONNECT 方法要求在与代理服务器通信时建立隧道,实现用隧道协议进行 TCP 通信。</p>
<p>主要使用 SSL(Secure Sockets Layer,安全套接层) 和 TLS(Transport Layer Security,传输层安全)协议把通信内容加密后经网络隧道传输。</p>
<p>CONNECT 方法的格式如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONNECT 代理服务器名:端口号 HTTP版本</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914105636433.png" alt="image-20200914105636433"></p>
<h3 id="4-使用方法下达命令"><a href="#4-使用方法下达命令" class="headerlink" title="4 使用方法下达命令"></a>4 使用方法下达命令</h3><p>向请求 URI 指定的资源发送请求报文时,采用称为方法的命令。<br>方法的作用在于,可以指定请求的资源按期望产生某种行为。方法中有 GET、POST 和 HEAD 等。</p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914105745371.png" alt="image-20200914105745371"></p>
<h3 id="5-持久连接节省通信量"><a href="#5-持久连接节省通信量" class="headerlink" title="5 持久连接节省通信量"></a>5 持久连接节省通信量</h3><p>使用浏览器浏览一个包含多张图片的 HTML 页面时,在发送请求访问 HTML 页面资源的同时,也会请求该 HTML 页面里包含的其他资源。因此,每次的请求都会造成无谓的 TCP 连接建立和断开,增加通信量的开销</p>
<h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p>为解决上述 TCP 连接的问题,HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接(HTTP Persistent Connections,也称为 HTTP keep-alive 或HTTP connection reuse)的方法。</p>
<p>持久连接的特点是,<strong>只要任意一端没有明确提出断开连接,则保持 TCP 连接状态。</strong></p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914110115581.png" alt="image-20200914110115581"></p>
<p>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销,减轻了服务器端的负载。另外,减少开销的那部分时间,使HTTP 请求和响应能够更早地结束,这样 Web 页面的显示速度也就相应提高了。</p>
<p>在 HTTP/1.1 中,所有的连接默认都是持久连接,但在 HTTP/1.0 内并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接,但服务器端不一定能够支持持久连接。毫无疑问,除了服务器端,客户端也需要支持持久连接。</p>
<h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p>持久连接使得多数请求以管线化(pipelining)方式发送成为可能。从前发送请求后需等待并收到响应,才能发送下一个请求。</p>
<p>管线化技术出现后,不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求,而不需要一个接一个地等待响应了。</p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914110212175.png" alt="image-20200914110212175"></p>
<h3 id="6-使用-Cookie-的状态管理"><a href="#6-使用-Cookie-的状态管理" class="headerlink" title="6 使用 Cookie 的状态管理"></a>6 使用 Cookie 的状态管理</h3><p>HTTP 是无状态协议,它不对之前发生过的请求和响应的状态进行管理。也就是说,无法根据之前的状态进行本次的请求处理。</p>
<p>假设要求登录认证的 Web 页面本身无法进行状态的管理(不记录已登录的状态),那么每次跳转新页面不是要再次登录,就是要在每次请求报文中附加参数来管理登录状态。</p>
<p>不可否认,无状态协议当然也有它的优点。由于不必保存状态,自然可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说,也正是因为 HTTP 协议本身是非常简单的,所以才会被应用在各种场景里。</p>
<p>保留无状态协议这个特征的同时又要解决类似的矛盾问题,于是引入了 Cookie 技术。</p>
<p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>
<p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息,通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后,会去检查究竟是从哪一个客户端发来的连接请求,然后对比服务器上的记录,最后得到之前的状态信息。</p>
<p>上图展示了发生 Cookie 交互的情景,HTTP 请求报文和响应报文的内容如下。</p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914110504696.png" alt="image-20200914110504696"></p>
<h2 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h2><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。</p>
<ul>
<li>请求端(客户端)的HTTP 报文叫做请求报文。</li>
<li>响应端(服务器端)的叫做响应报文。</li>
</ul>
<p>HTTP 报文本身是由多行(用 CR+LF 作换行符)数据构成的字符串文本。<br>HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行(CR+LF)来划分。通常,并不一定要有报文主体。</p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914111139781.png" alt="image-20200914111139781"></p>
<h3 id="请求报文及响应报文的结构"><a href="#请求报文及响应报文的结构" class="headerlink" title="请求报文及响应报文的结构"></a>请求报文及响应报文的结构</h3><p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914111057252.png" alt="image-20200914111057252"></p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914111104870.png" alt="image-20200914111104870"></p>
<table>
<thead>
<tr>
<th>请求行</th>
<th>包含用于请求的方法,请求 URI 和 HTTP 版本。</th>
</tr>
</thead>
<tbody><tr>
<td>状态行</td>
<td>包含表明响应结果的状态码,原因短语和 HTTP 版本。</td>
</tr>
<tr>
<td>首部字段</td>
<td>包含表示请求和响应的各种条件和属性的各类首部。</td>
</tr>
</tbody></table>
<p>一般有 4 种首部,分别是:通用首部、请求首部、响应首部和实体首部。其他可能包含 HTTP 的 RFC 里未定义的首部(Cookie 等)。</p>
<h3 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h3><p>HTTP 在传输数据时可以按照数据原貌直接传输,但也可以在传输过程中通过编码提升传输速率。通过在传输时编码,能有效地处理大量的访问请求。但是,编码的操作需要计算机来完成,因此会消耗更多的 CPU 等资源。</p>
<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914111710636.png" alt="image-20200914111710636"></p>
<p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914111718030.png" alt="image-20200914111718030"></p>
<h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><p><img src="/2020/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%8D%8F%E8%AE%AE/image-20200914112312857.png" alt="image-20200914112312857"></p>
<h3 id="HTTP-首部字段结构"><a href="#HTTP-首部字段结构" class="headerlink" title="HTTP 首部字段结构"></a>HTTP 首部字段结构</h3><p>HTTP 首部字段是由首部字段名和字段值构成的,中间用冒号“:” 分隔。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首部字段名: 字段值</span><br></pre></td></tr></table></figure>

<p>例如,在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对象类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type: text&#x2F;html</span><br></pre></td></tr></table></figure>

<p>就以上述示例来看,首部字段名为 Content-Type,字符串 text/html 是字段值。</p>
<p>另外,字段值对应单个 HTTP 首部字段可以有多个值,如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Keep-Alive: timeout&#x3D;15, max&#x3D;100</span><br></pre></td></tr></table></figure>


<p>若 HTTP 首部字段重复了会如何当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样?这种情况在规范内尚未明确,根据浏览器内部处理逻辑的不同,结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段,而有些则会优先处理最后出现的首部字段。</p>
<h3 id="首部字段类型"><a href="#首部字段类型" class="headerlink" title="首部字段类型"></a>首部字段类型</h3><ol>
<li>通用首部字段(General Header Fields)，请求报文和响应报文两方都会使用的首部。</li>
<li>请求首部字段(Request Header Fields)，从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li>
<li>响应首部字段(Response Header Fields)，从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容,也会要求客户端附加额外的内容信息。</li>
<li>实体首部字段(Entity Header Fields)，针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</li>
</ol>
<h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><h3 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h3><ul>
<li>通信使用明文(不加密),内容可能会被窃听</li>
<li>不验证通信方的身份,因此有可能遭遇伪装</li>
<li>无法证明报文的完整性,所以有可能已遭篡改</li>
</ul>
<h4 id="通信使用明文可能会被窃听"><a href="#通信使用明文可能会被窃听" class="headerlink" title="通信使用明文可能会被窃听"></a>通信使用明文可能会被窃听</h4><h4 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+ 加密 + 认证 + 完整性保护=HTTPS"></a>HTTP+ 加密 + 认证 + 完整性保护=HTTPS</h4>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>面试经典代码题</title>
    <url>/2020/09/11/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E4%BB%A3%E7%A0%81%E9%A2%98/</url>
    <content><![CDATA[<p>本文旨在整理面试过程中经典的考题</p>
<a id="more"></a>

<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><h3 id="1-字符串转数字-atoi-stoi"><a href="#1-字符串转数字-atoi-stoi" class="headerlink" title="1 字符串转数字(atoi/stoi)"></a>1 字符串转数字(atoi/stoi)</h3><blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> len = str.length();</span><br><span class="line">     <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (i &lt; len &amp;&amp; str[i] == <span class="string">' '</span>)  ++i;  <span class="comment">// 排除开头的空格</span></span><br><span class="line">     <span class="keyword">if</span> (i == len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(str[i]) &amp;&amp; str[i] != <span class="string">'+'</span> &amp;&amp; str[i] != <span class="string">'-'</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//判断第一个符号</span></span><br><span class="line">     <span class="keyword">bool</span> neg = str[i]==<span class="string">'-'</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">     i = <span class="built_in">isdigit</span>(str[i]) ? i : i+<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (i &lt; len &amp;&amp; <span class="built_in">isdigit</span>(str[i])) &#123;</span><br><span class="line">         ans = ans * <span class="number">10</span> + (str[i++]-<span class="string">'0'</span>);</span><br><span class="line">         <span class="keyword">if</span> (!neg &amp;&amp; ans &gt; INT_MAX) &#123;</span><br><span class="line">             ans = INT_MAX;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (neg &amp;&amp; ans &gt; <span class="number">1L</span> + INT_MAX) &#123;</span><br><span class="line">             ans = <span class="number">1L</span> + INT_MAX;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (i != len) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不要此处，就是atoi()库函数的实现</span></span><br><span class="line">     <span class="keyword">return</span> !neg ? <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ans) : <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(-ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-编程实现strcpy函数"><a href="#2-编程实现strcpy函数" class="headerlink" title="2 编程实现strcpy函数"></a>2 编程实现strcpy函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dest_str,<span class="keyword">const</span> <span class="keyword">char</span> src_str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dest_str==<span class="literal">NULL</span>||src_str==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span>* strdestCopy = dest_str;</span><br><span class="line">    <span class="keyword">while</span>((*dest_str++=*src_str++)!=<span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> strdestCopy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="2-求第k大的数的方法及各自的复杂度"><a href="#2-求第k大的数的方法及各自的复杂度" class="headerlink" title="2. 求第k大的数的方法及各自的复杂度"></a>2. 求第k大的数的方法及各自的复杂度</h2><blockquote>
<p>1 首先使用<strong>快速排序算法</strong>将数组按照从大到小排序，然后取第k个，其时间复杂度最快为<code>O(nlogn)</code></p>
<p>2 使用<strong>堆排序</strong>，建立最大堆，然后调整堆，知道获得第k个元素，其时间复杂度为<code>O(n+klogn)</code></p>
<p>3 首先利用哈希表统计数组中个元素出现的次数，然后利用<strong>计数排序</strong>的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数</p>
<p>利用<strong>快排思想</strong>，从数组中随机选择一个数i，然后将数组分成两部分$D_l$,$D_r$，$D_l$的元素都小于i,Dr的元素都大于i。然后统计Dr元素个数，如果Dr元素个数等于k-1,那么第k大的数即为k，如果Dr元素个数小于k,那么继续求Dl中第k-Dr大的元素；如果Dr元素个数大于k,那么继续求Dr中第k大的元素。</p>
</blockquote>
<p>另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素</p>
<blockquote>
<p>当有相同元素的时候，首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数，平均情况下时间复杂度为O(n)</p>
</blockquote>
<h2 id="3-Top-K问题：海量数据"><a href="#3-Top-K问题：海量数据" class="headerlink" title="3.  Top K问题：海量数据"></a>3.  Top K问题：海量数据</h2><blockquote>
<h4 id="1-直接全部排序（只适用于内存够的情况）"><a href="#1-直接全部排序（只适用于内存够的情况）" class="headerlink" title="1. 直接全部排序（只适用于内存够的情况）"></a>1. 直接全部排序（只适用于内存够的情况）</h4><p>当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。</p>
<p>这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。</p>
<h4 id="2-快速排序的变形-（只使用于内存够的情况）"><a href="#2-快速排序的变形-（只使用于内存够的情况）" class="headerlink" title="2. 快速排序的变形 （只使用于内存够的情况）"></a>2. 快速排序的变形 （只使用于内存够的情况）</h4><p>这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。</p>
<p>这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index  &gt; K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index &lt; K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。</p>
<h4 id="3-最小堆法"><a href="#3-最小堆法" class="headerlink" title="3. 最小堆法"></a>3. 最小堆法</h4><p>这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。</p>
<h4 id="4-分治法"><a href="#4-分治法" class="headerlink" title="4. 分治法"></a>4. 分治法</h4><p>将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N<em>K个数据，如果内存不能容纳N</em>K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。</p>
<h4 id="5-Hash法"><a href="#5-Hash法" class="headerlink" title="5. Hash法"></a>5. Hash法</h4><p>如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。</p>
</blockquote>
<p>详细代码：</p>
<ol>
<li>利用快速排序的思想进行查找</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Finder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> quickfind(a,<span class="number">0</span>,n<span class="number">-1</span>,K);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickfind</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(a,low,high);</span><br><span class="line">        <span class="keyword">if</span>(pivot+<span class="number">1</span>&lt;K) <span class="comment">//中轴位置少于K个，在右子数组中继续查找</span></span><br><span class="line">            <span class="keyword">return</span> quickfind(a,pivot+<span class="number">1</span>,high,K);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pivot+<span class="number">1</span>&gt;K) <span class="comment">//中轴位置大于K个，在左子数组中继续查找</span></span><br><span class="line">            <span class="keyword">return</span> quickfind( a, low, pivot<span class="number">-1</span>,K);</span><br><span class="line">        <span class="keyword">return</span> a[pivot];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = a[low];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high&amp;&amp;a[high]&lt;=val) high--;    <span class="comment">// 从右往左扫描，直到遇到比基准元素大的元素</span></span><br><span class="line">            a[low] = a[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high&amp;&amp;a[low]&gt;=val) low++;    <span class="comment">//从左往右扫描，直到遇到比基准元素小的元素</span></span><br><span class="line">            a[high] = a[low];</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = val;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="1-LRU缓存机制"><a href="#1-LRU缓存机制" class="headerlink" title="1. LRU缓存机制"></a>1. <a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU缓存机制</a></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; ls;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;::iterator&gt; key_add; <span class="comment">//获取数据需要用哈希表 // 见与链表中的地址</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果要访问的节点不存在</span></span><br><span class="line">        <span class="keyword">if</span>(key_add.find(key)==key_add.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 把访问的节点移动到最前边的一个；</span></span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; kv = *key_add[key];</span><br><span class="line">        ls.erase(key_add[key]);</span><br><span class="line">        ls.push_front(kv);</span><br><span class="line">        key_add[key] = ls.begin();</span><br><span class="line">        <span class="keyword">return</span> kv.second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key_add.find(key)==key_add.end())&#123;</span><br><span class="line">            ls.push_front(&#123;key,value&#125;);</span><br><span class="line">            key_add[key] = ls.begin();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ls.size()&gt;capacity)&#123;</span><br><span class="line">                <span class="keyword">int</span> lastkey = ls.back().first;</span><br><span class="line">                key_add.erase(lastkey);</span><br><span class="line">                ls.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ls.erase(key_add[key]);</span><br><span class="line">            ls.push_front(&#123;key,value&#125;);</span><br><span class="line">            key_add[key] = ls.begin();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-合并n个有序数组"><a href="#2-合并n个有序数组" class="headerlink" title="2. 合并n个有序数组"></a>2. 合并n个有序数组</h2><p>假设你得到了k个排好序的数组，每个都有n个元素，希望将它们整体组合成一个有着kn个元素的有序数组。考虑以下方法：将k个数组分为k/2对，并使用归并排序来合并每对，则你有了k/2个排序好的数组；重复此方法，直到合并结束。那么程序运行的时间复杂度是<code>O(nklog⁡n)</code></p>
<h2 id="3-链表翻转"><a href="#3-链表翻转" class="headerlink" title="3. 链表翻转"></a>3. 链表翻转</h2><p>利用哨兵</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Void <span class="title">reversal_list</span><span class="params">(node * head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     node* pre_node = <span class="literal">nullptr</span>;</span><br><span class="line">     node* cur_node = head-&gt;next;</span><br><span class="line">     node* next_node = cur_node-&gt;next;</span><br><span class="line">     <span class="keyword">if</span>(cur_node == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         cur_node-&gt;next = forward_node;</span><br><span class="line">         pre_node = cur_node;</span><br><span class="line">         cur_node = next_node;</span><br><span class="line">         <span class="keyword">if</span>(cur_node == <span class="literal">nullptr</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">        next_node = cur_node-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line">     head-&gt;next = pre_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = <span class="literal">NULL</span>, *pre = head;</span><br><span class="line">        <span class="keyword">while</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ListNode* t = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            cur = pre;</span><br><span class="line">            pre = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简单的递归</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ret = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>妖魔化的双指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (head-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ListNode* t = head-&gt;next-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;next = cur;</span><br><span class="line">            cur = head-&gt;next;</span><br><span class="line">            head-&gt;next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-表示数值的字符串"><a href="#4-表示数值的字符串" class="headerlink" title="4. 表示数值的字符串"></a>4. 表示数值的字符串</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();       </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len&amp;&amp;s[i]==<span class="string">' '</span>) i++; <span class="comment">//忽略空格</span></span><br><span class="line">        <span class="keyword">bool</span> flag = GetSignedIntBaseNumber(s,len,i);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len&amp;&amp;s[i]==<span class="string">'.'</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            flag = GetUnSignedIntBaseNumber(s,len,i)||flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len&amp;&amp;i!=<span class="number">0</span> &amp;&amp; (s[i]==<span class="string">'e'</span>||s[i]==<span class="string">'E'</span>))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            flag=flag&amp;&amp;GetSignedIntBaseNumber(s,len,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len&amp;&amp;s[i]==<span class="string">' '</span>) i++; <span class="comment">//忽略空格</span></span><br><span class="line">        <span class="keyword">return</span> i&gt;=len&amp;&amp;flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">GetSignedIntBaseNumber</span><span class="params">(<span class="built_in">string</span> &amp;str,<span class="keyword">int</span> len,<span class="keyword">int</span> &amp;i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'+'</span>||str[i]==<span class="string">'-'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">return</span> GetUnSignedIntBaseNumber(str,len,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">GetUnSignedIntBaseNumber</span><span class="params">(<span class="built_in">string</span> &amp;str,<span class="keyword">int</span> len,<span class="keyword">int</span> &amp;i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len&amp;&amp;<span class="built_in">isdigit</span>(str[i]))</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">return</span> i&gt;tmp; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5-删除链表的重复元素"><a href="#5-删除链表的重复元素" class="headerlink" title="5. 删除链表的重复元素"></a>5. 删除链表的重复元素</h2><h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></h3><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">输出: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">输出: 2-&gt;3</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *root = <span class="keyword">new</span> ListNode(INT_MAX);</span><br><span class="line">        root -&gt; next = head;</span><br><span class="line">        ListNode *pre = root;</span><br><span class="line">        <span class="keyword">while</span>(pre&amp;&amp;pre-&gt;next)&#123;</span><br><span class="line">            ListNode *pcur = pre-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;next==<span class="literal">nullptr</span>||pcur-&gt;next&amp;&amp;pcur-&gt;val!=pcur-&gt;next-&gt;val)</span><br><span class="line">                pre = pcur;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(pcur-&gt;next&amp;&amp;pcur-&gt;next-&gt;val==pcur-&gt;val) </span><br><span class="line">                    pcur = pcur-&gt;next;</span><br><span class="line">                pre-&gt;next = pcur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="1-N皇后问题"><a href="#1-N皇后问题" class="headerlink" title="1. N皇后问题"></a>1. N皇后问题</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; columns;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; diagonals1;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; diagonals2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solutions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> queens = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>);</span><br><span class="line">        backtrack(queens, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> solutions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;queens, <span class="keyword">int</span> n, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board = generateBoard(queens, n);</span><br><span class="line">            solutions.push_back(board);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (columns.find(i) != columns.end()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> diagonal1 = row - i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals1.find(diagonal1) != diagonals1.end()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> diagonal2 = row + i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals2.find(diagonal2) != diagonals2.end()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queens[row] = i;</span><br><span class="line">                columns.insert(i);</span><br><span class="line">                diagonals1.insert(diagonal1);</span><br><span class="line">                diagonals2.insert(diagonal2);</span><br><span class="line">                backtrack(queens, n, row + <span class="number">1</span>);</span><br><span class="line">                queens[row] = <span class="number">-1</span>;</span><br><span class="line">                columns.erase(i);</span><br><span class="line">                diagonals1.erase(diagonal1);</span><br><span class="line">                diagonals2.erase(diagonal2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateBoard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;queens, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> board = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> row = <span class="built_in">string</span>(n, <span class="string">'.'</span>);</span><br><span class="line">            row[queens[i]] = <span class="string">'Q'</span>;</span><br><span class="line">            board.push_back(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="数字游戏"><a href="#数字游戏" class="headerlink" title="数字游戏"></a>数字游戏</h1><h2 id="1-求平方和"><a href="#1-求平方和" class="headerlink" title="1 求平方和"></a>1 求平方和</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=x;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        sum+=odd;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;x)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-判断一个数是不是二的倍数"><a href="#2-判断一个数是不是二的倍数" class="headerlink" title="2 判断一个数是不是二的倍数"></a>2 判断一个数是不是二的倍数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a % <span class="number">2</span> == <span class="number">0</span> 或者a &amp; <span class="number">0x0001</span> == <span class="number">0</span>。</span><br></pre></td></tr></table></figure>



<h2 id="3-不用-加减乘除做加法"><a href="#3-不用-加减乘除做加法" class="headerlink" title="3 不用+加减乘除做加法"></a>3 不用+加减乘除做加法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum,carry;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        sum = num1^num2;</span><br><span class="line">        carry = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        num1 = sum;</span><br><span class="line">        num2 = carry;</span><br><span class="line">    &#125;<span class="keyword">while</span>(num2!=<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="高楼扔鸡蛋"><a href="#高楼扔鸡蛋" class="headerlink" title="高楼扔鸡蛋"></a>高楼扔鸡蛋</h3><h4 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a><a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">887. 鸡蛋掉落</a></h4><p>你将获得 <code>K</code> 个鸡蛋，并可以使用一栋从 <code>1</code> 到 <code>N</code> 共有 <code>N</code> 层楼的建筑。</p>
<p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p>
<p>你知道存在楼层 <code>F</code> ，满足 <code>0 &lt;= F &lt;= N</code> 任何从高于 <code>F</code> 的楼层落下的鸡蛋都会碎，从 <code>F</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次<em>移动</em>，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 <code>X</code> 扔下（满足 <code>1 &lt;= X &lt;= N</code>）。</p>
<p>你的目标是<strong>确切地</strong>知道 <code>F</code> 的值是多少。</p>
<p>无论 <code>F</code> 的初始值如何，你确定 <code>F</code> 的值的最小移动次数是多少？</p>
<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h2 id="1-给定三角形ABC和一点P-x-y-z-，判断点P是否在ABC内"><a href="#1-给定三角形ABC和一点P-x-y-z-，判断点P是否在ABC内" class="headerlink" title="1. 给定三角形ABC和一点P(x,y,z)，判断点P是否在ABC内"></a>1. 给定三角形ABC和一点P(x,y,z)，判断点P是否在ABC内</h2><p>根据面积法，如果P在三角形ABC内，那么三角形ABP的面积+三角形BCP的面积+三角形ACP的面积应该等于三角形ABC的面积。算法如下：</p>
<p>计算三角形面积</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ABS_FLOAT_0 0.0001</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point_float</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">float</span> x;</span><br><span class="line"><span class="keyword">float</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetTriangleSquar</span><span class="params">(<span class="keyword">const</span> point_float pt0, <span class="keyword">const</span> point_float pt1, <span class="keyword">const</span> point_float pt2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">point_float AB,   BC;</span><br><span class="line">AB.x = pt1.x - pt0.x;</span><br><span class="line">AB.y = pt1.y - pt0.y;</span><br><span class="line">BC.x = pt2.x - pt1.x;</span><br><span class="line">BC.y = pt2.y - pt1.y;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fabs</span>((AB.x * BC.y - AB.y * BC.x)) / <span class="number">2.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsInTriangle</span><span class="params">(<span class="keyword">const</span> point_float A, <span class="keyword">const</span> point_float B, <span class="keyword">const</span> point_float C, <span class="keyword">const</span> point_float D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> SABC, SADB, SBDC, SADC;</span><br><span class="line">SABC = GetTriangleSquar(A, B, C);</span><br><span class="line">SADB = GetTriangleSquar(A, D, B);</span><br><span class="line">SBDC = GetTriangleSquar(B, D, C);</span><br><span class="line">SADC = GetTriangleSquar(A, D, C);</span><br><span class="line"><span class="keyword">float</span> SumSuqar = SADB + SBDC + SADC;</span><br><span class="line"><span class="keyword">return</span> ((-ABS_FLOAT_0 &lt; (SABC - SumSuqar)) &amp;&amp; ((SABC - SumSuqar) &lt; ABS_FLOAT_0))；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>排序</tag>
        <tag>回溯</tag>
        <tag>字符串</tag>
        <tag>数字计算，计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>层次聚类</title>
    <url>/2020/09/10/%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<p>本文主要为了了解聚类的分裂与合并。</p>
<a id="more"></a>

<h2 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>层次聚类（Hierarchical Clustering）考虑把n个样本聚成c类的情况。首先把所有样本分成n类，每类正好含有一个样本。其次，我们将样本分为n-1类，接着是n-2类，这样下去知道所有样本被分为一类。我们成聚类数目$c=n-k+1$对应层次结构的第k层，因此第1层对应n个类而第n层对应一个类别。对层次结构的任意一层及其该层中的任意n个样本，如果该层中属于同一类，而且在更高的层次一直属于同一类，那么这样的序列称为层次聚类。</p>
<h3 id="层次聚类的表达方式"><a href="#层次聚类的表达方式" class="headerlink" title="层次聚类的表达方式"></a>层次聚类的表达方式</h3><ol>
<li>树图</li>
<li>集合图<ol>
<li>纯文本集合：${x_1,{x_2,x_3},{x_4,x_5}}$</li>
<li>维恩图</li>
</ol>
</li>
</ol>
<p>其中，纯文本集合不能定量的体现相似性</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>层次聚类方法主要通过两种途径进行实现：合并和分裂。</p>
<p>合并是自底向上，先使得所有样本归入一类，然后通过后续分裂，来增加类别的数目。</p>
<h4 id="一-合并"><a href="#一-合并" class="headerlink" title="一 合并"></a>一 合并</h4><p>自底向上，先使得样本各成一类，然后通过合并不同的类，来减少类别数目。</p>
<h5 id="基于合并的聚类算法"><a href="#基于合并的聚类算法" class="headerlink" title="基于合并的聚类算法"></a>基于合并的聚类算法</h5><p>一开始一共有c类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 begin intialize: c,\hat&#123;c&#125; &lt;- n, D_i &lt;- &#123;x_i&#125;, i &#x3D; 1,...,n</span><br><span class="line">2 		do \hat&#123;c&#125;&lt;-\hat&#123;c&#125;-1</span><br><span class="line">3 			求最接近的聚类，如D_i和D_j</span><br><span class="line">4			合并D_i和D_j</span><br><span class="line">5 		until c &#x3D; \hat&#123;c&#125;</span><br><span class="line">6		return c个聚类</span><br><span class="line">7 end</span><br></pre></td></tr></table></figure>

<p>对合并方法来说，从一个层次到另一个层次所需的计算比较简单。但是如果样本过多而期望的类别样本数目又很少，这种计算会被反复多次地执行。</p>
<p>不同类别之间的相似性的度量：<br>$$<br>d_\min(D_i,D_j) = \min_{x\in D_i\x’D_j}||x-x’||\<br>d_\max(D_i,D_j) = \max_{x\in D_i\x’D_j}||x-x’||\<br>d_{avg}(D_i,D_j) = \frac{1}{n_in_j}\sum_{x\in D_i}\sum_{x\in D_j}||x-x’||\<br>d_{mean}(D_i,D_j) = ||m_i-m_j||<br>$$<br>在上述的这些距离度量中，最近距离度量$d_\min(.,.)$和$d_\max(.,.)$ 代表了类与类之间距离的两个极端。就像所有利用最大值或最小值的算法，它们对噪声和孤立点非常敏感。用平静值代替它们可以改善这些问题。</p>
<h4 id="二-分裂"><a href="#二-分裂" class="headerlink" title="二 分裂"></a>二 分裂</h4><p>先将样本都归入一类，然后通过后续分裂，来增加类别数目。</p>
<h3 id="基于优化的层次聚类"><a href="#基于优化的层次聚类" class="headerlink" title="基于优化的层次聚类"></a>基于优化的层次聚类</h3><p>任选一种距离度量来表示类与类之间的距离时，没有考虑到是否能使聚类准则函数取极值。</p>
<p>因此可以稍作修改，获得一个极值化准则函数的“逐步优化的层次聚类”的算法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 begin intialize: c,\hat&#123;c&#125; &lt;- n, D_i &lt;- &#123;x_i&#125;, i &#x3D; 1,...,n</span><br><span class="line">2 		do \hat&#123;c&#125;&lt;-\hat&#123;c&#125;-1</span><br><span class="line">3 			寻找其合并类，将准则函数改变为最小的聚类，例如D_i和D_j</span><br><span class="line">4			合并D_i和D_j</span><br><span class="line">5 		until c &#x3D; \hat&#123;c&#125;</span><br><span class="line">6		return c个聚类</span><br><span class="line">7 end</span><br></pre></td></tr></table></figure>

<p>可以看出，基于$d_\max(.,.)$的聚类方法使得划分半径增长最慢，可以看作是一种逐步求精的例子。</p>
<p>还有一种基于误差平方和的准则函数$J_e$的方法，如果我们找到两个类，若它们的合并类造成$J_e$的增加凉最少，就要求距离<br>$$<br>d_e(D_i,D_j) = \sqrt{\frac{n_in_j}{n_i+n_j}}||m_i-m_j||<br>$$<br>最小，当挑选用来合并的聚类的时候，这个准则除了考虑了类与类之间的距离，还考虑了类中所含样本的个数。一般来说，基于$d_e(.,.)$的算法倾向于将孤立点或较小的类与较大的类合并。虽然最后的结果不一定能最小化$J_e$，但这个结果可以向进一步的迭代优化提供非常好的初始点。</p>
<h3 id="层次聚类和导出度量"><a href="#层次聚类和导出度量" class="headerlink" title="层次聚类和导出度量"></a>层次聚类和导出度量</h3><p>假定可以衡量数据集中的任意两个样本之间的相异程度，$\delta(x,x’)$。而且$\delta(x,x’)\geq 0 $，等号当且仅当$x=x’$时成立。那么合并聚类算法还是可以使用，只要理解两个最近的聚类就是最不相异的类。</p>
<p>如果定义两个聚类的相异度为：<br>$$<br>\delta_\min(D_i,D_j) = \min_{x\in D_i\x’\in D_j} \delta(x,x’)\<br>\delta_\max(D_i,D_j) = \max_{x\in D_i\x’\in D_j} \delta(x,x’)<br>$$<br>层次聚类算法就可以对给定的n个样本集导出距离函数。</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>层次聚类</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库总结</title>
    <url>/2020/08/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文学习自：数据库系统概论、MySQL必知必会</p>
<a id="more"></a>

<p>SQL就是访问和处理关系数据库的计算机标准语言。也就是说，无论用什么编程语言（Java、Python、C++……）编写程序，只要涉及到操作关系数据库，比如，一个电商网站需要把用户和商品信息存入数据库，或者一个手机游戏需要把用户的道具、通关信息存入数据库，都必须通过SQL来完成。</p>
<h2 id="一-数据库概论"><a href="#一-数据库概论" class="headerlink" title="一 数据库概论"></a>一 数据库概论</h2><h3 id="一-数据库设计的六个阶段"><a href="#一-数据库设计的六个阶段" class="headerlink" title="一 数据库设计的六个阶段"></a>一 数据库设计的六个阶段</h3><ol>
<li><p>需求分析： 分析用户的需求，包括数据、功能和性能需求；</p>
</li>
<li><p>概念结构设计：主要采用E-R模型进行设计，包括画E-R图；</p>
</li>
<li><p>逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换，进行关系规范化；</p>
</li>
<li><p>数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存储路径；</p>
</li>
<li><p>数据库的实施：包括编程、测试和试运行；</p>
</li>
<li><p>数据库运行和维护：系统的运行和数据库的日常维护</p>
</li>
</ol>
<h3 id="二-数据模型"><a href="#二-数据模型" class="headerlink" title="二 数据模型"></a>二 数据模型</h3><p>数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型：</p>
<ol>
<li>层次模型</li>
<li>网状模型</li>
<li>关系模型</li>
</ol>
<ol>
<li><p>层次模型就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            ┌─────┐</span><br><span class="line">            │     │</span><br><span class="line">            └─────┘</span><br><span class="line">               │</span><br><span class="line">       ┌───────┴───────┐</span><br><span class="line">       │               │</span><br><span class="line">    ┌─────┐         ┌─────┐</span><br><span class="line">    │     │         │     │</span><br><span class="line">    └─────┘         └─────┘</span><br><span class="line">       │               │</span><br><span class="line">   ┌───┴───┐       ┌───┴───┐</span><br><span class="line">   │       │       │       │</span><br><span class="line">┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│     │ │     │ │     │ │     │</span><br><span class="line">└─────┘ └─────┘ └─────┘ └─────┘</span><br></pre></td></tr></table></figure>
</li>
<li><p>网状模型把每个数据节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     ┌─────┐      ┌─────┐</span><br><span class="line">   ┌─│     │──────│     │──┐</span><br><span class="line">   │ └─────┘      └─────┘  │</span><br><span class="line">   │    │            │     │</span><br><span class="line">   │    └──────┬─────┘     │</span><br><span class="line">   │           │           │</span><br><span class="line">┌─────┐     ┌─────┐     ┌─────┐</span><br><span class="line">│     │─────│     │─────│     │</span><br><span class="line">└─────┘     └─────┘     └─────┘</span><br><span class="line">   │           │           │</span><br><span class="line">   │     ┌─────┴─────┐     │</span><br><span class="line">   │     │           │     │</span><br><span class="line">   │  ┌─────┐     ┌─────┐  │</span><br><span class="line">   └──│     │─────│     │──┘</span><br><span class="line">      └─────┘     └─────┘</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，它的数据模型看起来就是一个Excel表：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────┬─────┬─────┬─────┬─────┐</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">├─────┼─────┼─────┼─────┼─────┤</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">├─────┼─────┼─────┼─────┼─────┤</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">├─────┼─────┼─────┼─────┼─────┤</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">└─────┴─────┴─────┴─────┴─────┘</span><br></pre></td></tr></table></figure></code></pre></li>
</ol>
<h3 id="三-数据类型"><a href="#三-数据类型" class="headerlink" title="三 数据类型"></a>三 数据类型</h3><p>对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INT</td>
<td align="left">整型</td>
<td align="left">4字节整数类型，范围约+/-21亿</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">长整型</td>
<td align="left">8字节整数类型，范围约+/-922亿亿</td>
</tr>
<tr>
<td align="left">REAL</td>
<td align="left">浮点型</td>
<td align="left">4字节浮点数，范围约+/-1038</td>
</tr>
<tr>
<td align="left">DOUBLE</td>
<td align="left">浮点型</td>
<td align="left">8字节浮点数，范围约+/-10308</td>
</tr>
<tr>
<td align="left">DECIMAL(M,N)</td>
<td align="left">高精度小数</td>
<td align="left">由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td>
</tr>
<tr>
<td align="left">CHAR(N)</td>
<td align="left">定长字符串</td>
<td align="left">存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td>
</tr>
<tr>
<td align="left">VARCHAR(N)</td>
<td align="left">变长字符串</td>
<td align="left">存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td>
</tr>
<tr>
<td align="left">BOOLEAN</td>
<td align="left">布尔类型</td>
<td align="left">存储True或者False</td>
</tr>
<tr>
<td align="left">DATE</td>
<td align="left">日期类型</td>
<td align="left">存储日期，例如，2018-06-22</td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">时间类型</td>
<td align="left">存储时间，例如，12:20:59</td>
</tr>
<tr>
<td align="left">DATETIME</td>
<td align="left">日期和时间类型</td>
<td align="left">存储日期+时间，例如，2018-06-22 12:20:59</td>
</tr>
</tbody></table>
<p>上面的表中列举了最常用的数据类型。很多数据类型还有别名，例如，<code>REAL</code>又可以写成<code>FLOAT(24)</code>。还有一些不常用的数据类型，例如，<code>TINYINT</code>（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如<code>JSON</code>。</p>
<p>选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，<code>BIGINT</code>能满足整数存储的需求，<code>VARCHAR(N)</code>能满足字符串存储的需求，这两种类型是使用最广泛的。</p>
<h3 id="四-关系数据库"><a href="#四-关系数据库" class="headerlink" title="四 关系数据库"></a>四 关系数据库</h3><h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p>目前<a href="https://baike.baidu.com/item/关系数据库" target="_blank" rel="noopener">关系数据库</a>有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、<a href="https://baike.baidu.com/item/第四范式" target="_blank" rel="noopener">第四范式</a>(4NF）和<a href="https://baike.baidu.com/item/第五范式" target="_blank" rel="noopener">第五范式</a>（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般来说，数据库只需满足第三范式(3NF）就行了。</p>
<h4 id="主流关系数据库"><a href="#主流关系数据库" class="headerlink" title="主流关系数据库"></a>主流关系数据库</h4><p>目前，主流的关系数据库主要分为以下几类：</p>
<ol>
<li>商用数据库，例如：<a href="https://www.oracle.com/" target="_blank" rel="noopener">Oracle</a>，<a href="https://www.microsoft.com/sql-server/" target="_blank" rel="noopener">SQL Server</a>，<a href="https://www.ibm.com/db2/" target="_blank" rel="noopener">DB2</a>等；</li>
<li>开源数据库，例如：<a href="https://www.mysql.com/" target="_blank" rel="noopener">MySQL</a>，<a href="https://www.postgresql.org/" target="_blank" rel="noopener">PostgreSQL</a>等；</li>
<li>桌面数据库，以微软<a href="https://products.office.com/access" target="_blank" rel="noopener">Access</a>为代表，适合桌面应用程序使用；</li>
<li>嵌入式数据库，以<a href="https://sqlite.org/" target="_blank" rel="noopener">Sqlite</a>为代表，适合手机应用和桌面程序。</li>
</ol>
<h3 id="五-SQL（Structured-Query-Language）"><a href="#五-SQL（Structured-Query-Language）" class="headerlink" title="五 SQL（Structured Query Language）"></a>五 SQL（Structured Query Language）</h3><p>什么是SQL？SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。</p>
<p>虽然SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为<code>PL/SQL</code>，Microsoft把自己扩展的SQL称为<code>T-SQL</code>。</p>
<p>现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。</p>
<p>总的来说，SQL语言定义了这么几种操作数据库的能力：</p>
<p><strong>DDL：Data Definition Language</strong></p>
<p>DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。</p>
<p><strong>DML：Data Manipulation Language</strong></p>
<p>DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。</p>
<p><strong>DQL：Data Query Language</strong></p>
<p>DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。</p>
<h4 id="SQL语法特点"><a href="#SQL语法特点" class="headerlink" title="SQL语法特点"></a>SQL语法特点</h4><p>SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。</p>
<p>所以，本教程约定：SQL关键字总是大写，以示突出，表名和列名均使用小写。</p>
<h2 id="二-关系模型"><a href="#二-关系模型" class="headerlink" title="二 关系模型"></a>二 关系模型</h2><p>关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。</p>
<ul>
<li>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。</li>
<li>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</li>
<li>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为<code>NULL</code>。注意<code>NULL</code>表示字段数据不存在。一个整型字段如果为<code>NULL</code>不表示它的值为<code>0</code>，同样的，一个字符串型字段为<code>NULL</code>也不表示它的值为空串<code>&#39;&#39;</code>。</li>
</ul>
<ul>
<li>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</li>
</ul>
<p>和Excel表有所不同的是，关系数据库的表和表之间需要建立“一对多”，“多对一”和“一对一”的关系，这样才能够按照应用程序的逻辑来组织和存储数据。</p>
<p>在关系数据库中，关系是通过主键和外键来维护的</p>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，<code>students</code>表的两行记录：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">class_id</th>
<th align="left">name</th>
<th align="left">gender</th>
<th align="left">score</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">小明</td>
<td align="left">M</td>
<td align="left">90</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">小红</td>
<td align="left">F</td>
<td align="left">95</td>
</tr>
</tbody></table>
<p>每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。</p>
<p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</p>
<p>对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p>
<p>所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。</p>
<p>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为<code>id</code>。常见的可作为<code>id</code>字段的类型有：</p>
<ol>
<li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li>
<li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li>
</ol>
<p>对于大部分应用来说，通常自增类型的主键就能满足需求。我们在<code>students</code>表中定义的主键也是<code>BIGINT NOT NULL AUTO_INCREMENT</code>类型。</p>
<h4 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h4><p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p>
<p>对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：</p>
<table>
<thead>
<tr>
<th align="left">id_num</th>
<th align="left">id_type</th>
<th align="left">other columns…</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">A</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">A</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">B</td>
<td align="left">…</td>
</tr>
</tbody></table>
<p>如果我们把上述表的<code>id_num</code>和<code>id_type</code>这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。</p>
<p>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</p>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>当我们用主键唯一标识记录时，我们就可以在<code>students</code>表中确定任意一个学生的记录：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">name</th>
<th align="left">other columns…</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">小明</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">小红</td>
<td align="left">…</td>
</tr>
</tbody></table>
<p>我们还可以在<code>classes</code>表中确定任意一个班级记录：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">name</th>
<th align="left">other columns…</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">一班</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">二班</td>
<td align="left">…</td>
</tr>
</tbody></table>
<p>但是我们如何确定<code>students</code>表的一条记录，例如，<code>id=1</code>的小明，属于哪个班级呢？</p>
<p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。</p>
<p>为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">class_id</th>
<th align="left">name</th>
<th align="left">other columns…</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">小明</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">小红</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">2</td>
<td align="left">小白</td>
<td align="left">…</td>
</tr>
</tbody></table>
<p>这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。</p>
<p>例如：</p>
<ul>
<li>小明的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li>
<li>小红的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li>
<li>小白的<code>class_id</code>是<code>2</code>，因此，对应的<code>classes</code>表的记录是<code>id=2</code>的二班。</li>
</ul>
<p>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<code>外键</code>。</p>
<p>外键并不是通过列名实现的，而是通过定义<strong>外键约束</strong>实现的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id</span><br><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure>

<p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p>
<p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在<code>id=99</code>的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。</p>
<p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p>
<p>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">DROP FOREIGN KEY fk_class_id;</span><br></pre></td></tr></table></figure>

<p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。</p>
<p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p>
<h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p>
<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p>
<p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过对数据库表创建索引，可以提高查询速度。</p>
<p>通过创建唯一索引，可以保证某一列的值具有唯一性。</p>
<p>数据库索引对于用户和应用程序来说都是透明的。</p>
<h2 id="三-查询数据"><a href="#三-查询数据" class="headerlink" title="三 查询数据"></a>三 查询数据</h2><h3 id="1-基本查询"><a href="#1-基本查询" class="headerlink" title="1 基本查询"></a>1 基本查询</h3><p>使用SELECT查询的基本语句<code>SELECT * FROM &lt;表名&gt;</code>可以查询一个表的所有行和所有列的数据。</p>
<p>SELECT查询的结果是一个二维表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt;</span><br></pre></td></tr></table></figure>

<p>知识点：SELECT语句的执行结果是<code>元组</code></p>
<p>元组（Tuple）：笛卡尔积中每一个元素<code>（d1，d2，…，dn）</code>叫作一个n元组（n-tuple）或简称元组。元组是关系数据库中的基本概念，关系是一张表，表中的每行就是一个元组，每列就是一个属性。</p>
<p>SELECT根据关系代数是进行投影操作，投影是将一个关系表中的属性投影出来</p>
<h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2 条件查询"></a>2 条件查询</h3><p>使用<code>SELECT * FROM &lt;表名&gt;</code>可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。</p>
<p>SELECT语句可以通过<code>WHERE</code>条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成<code>WHERE</code>条件就是<code>SELECT * FROM students WHERE score &gt;= 80</code>。</p>
<p>其中，<code>WHERE</code>关键字后面的<code>score &gt;= 80</code>就是条件。<code>score</code>是列名，该列存储了学生的成绩，因此，<code>score &gt;= 80</code>就筛选出了指定条件的记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM students WHERE score &gt;&#x3D; 80;</span><br></pre></td></tr></table></figure>

<h4 id="常用的条件表达式"><a href="#常用的条件表达式" class="headerlink" title="常用的条件表达式"></a>常用的条件表达式</h4><table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">表达式举例1</th>
<th align="left">表达式举例2</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">使用=判断相等</td>
<td align="left">score = 80</td>
<td align="left">name = ‘abc’</td>
<td align="left">字符串需要用单引号括起来</td>
</tr>
<tr>
<td align="left">使用&gt;判断大于</td>
<td align="left">score &gt; 80</td>
<td align="left">name &gt; ‘abc’</td>
<td align="left">字符串比较根据ASCII码，中文字符比较根据数据库设置</td>
</tr>
<tr>
<td align="left">使用&gt;=判断大于或相等</td>
<td align="left">score &gt;= 80</td>
<td align="left">name &gt;= ‘abc’</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">使用&lt;判断小于</td>
<td align="left">score &lt; 80</td>
<td align="left">name &lt;= ‘abc’</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">使用&lt;=判断小于或相等</td>
<td align="left">score &lt;= 80</td>
<td align="left">name &lt;= ‘abc’</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">使用&lt;&gt;判断不相等</td>
<td align="left">score &lt;&gt; 80</td>
<td align="left">name &lt;&gt; ‘abc’</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">使用LIKE判断相似</td>
<td align="left">name LIKE ‘ab%’</td>
<td align="left">name LIKE ‘%bc%’</td>
<td align="left">%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’</td>
</tr>
</tbody></table>
<p>条件查询的语法就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</span><br></pre></td></tr></table></figure>

<p>条件表达式可以用<code>&lt;条件1&gt; AND &lt;条件2&gt;</code>表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p>
<ul>
<li>条件1：根据score列的数据判断：<code>score &gt;= 80</code>；</li>
<li>条件2：根据gender列的数据判断：<code>gender = &#39;M&#39;</code>，注意<code>gender</code>列存储的是字符串，需要用单引号括起来。</li>
</ul>
<p>就可以写出<code>WHERE</code>条件：<code>score &gt;= 80 AND gender = &#39;M&#39;</code>：</p>
<p>很显然<code>OR</code>条件要比<code>AND</code>条件宽松，返回的符合条件的记录也更多。</p>
<p>第三种条件是<code>NOT &lt;条件&gt;</code>，表示“不符合该条件”的记录。例如，写一个“不是2班的学生”这个条件，可以先写出“是2班的学生”：<code>class_id = 2</code>，再加上<code>NOT</code>：<code>NOT class_id = 2</code>：</p>
<p>上述<code>NOT</code>条件<code>NOT class_id = 2</code>其实等价于<code>class_id &lt;&gt; 2</code>，因此，<code>NOT</code>查询不是很常用。</p>
<p>要组合三个或者更多的条件，就需要用小括号<code>()</code>表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生：</p>
<p>如果不加括号，条件运算按照<code>NOT</code>、<code>AND</code>、<code>OR</code>的优先级进行，即<code>NOT</code>优先级最高，其次是<code>AND</code>，最后是<code>OR</code>。加上括号可以改变优先级。</p>
<h3 id="3-投影查询"><a href="#3-投影查询" class="headerlink" title="3 投影查询"></a>3 投影查询</h3><ol>
<li><p>使用<code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;</code>可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。</p>
</li>
<li><p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>。</p>
</li>
<li><p>投影查询同样可以接<code>WHERE</code>条件，实现复杂的查询;</p>
</li>
</ol>
<h3 id="4-排序"><a href="#4-排序" class="headerlink" title="4 排序"></a>4 排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;</span><br></pre></td></tr></table></figure>

<p>SELECT查询时，细心的读者可能注意到，查询结果集通常是按照<code>id</code>排序的，也就是根据主键排序。这也是大部分数据库的做法。如果我们要根据其他条件排序怎么办？可以加上<code>ORDER BY</code>子句。</p>
<ol>
<li>如果要反过来，按照成绩从高到底排序，我们可以加上<code>DESC</code>表示“倒序”：</li>
<li>如果<code>score</code>列有相同的数据，要进一步排序，可以继续添加列名。例如，使用<code>ORDER BY score DESC, gender</code>表示先按<code>score</code>列倒序，如果有相同分数的，再按<code>gender</code>列排序：</li>
<li>默认的排序规则是<code>ASC</code>：“升序”，即从小到大。<code>ASC</code>可以省略，即<code>ORDER BY score ASC</code>和<code>ORDER BY score</code>效果一样。</li>
</ol>
<p>使用<code>ORDER BY</code>可以对结果集进行排序；</p>
<p>可以对多列进行升序、倒序排序。</p>
<h3 id="5-分页查询"><a href="#5-分页查询" class="headerlink" title="5 分页查询"></a>5 分页查询</h3><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p>
<p>要实现分页功能，实际上就是从结果集中显示第1<del>100条记录作为第1页，显示第101</del>200条记录作为第2页，以此类推。</p>
<p>因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>子句实现。我们先把所有学生按照成绩从高到低进行排序：</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC;</span><br></pre></td></tr></table></figure>

<p>现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用<code>LIMIT 3 OFFSET 0</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id,name,gender,score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 0;</span><br></pre></td></tr></table></figure>

<p>上述查询<code>LIMIT 3 OFFSET 0</code>表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。</p>
<p>如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把<code>OFFSET</code>设定为3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id,name,gender,score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 3;</span><br></pre></td></tr></table></figure>

<p>注意：<code>OFFSET</code>超过了查询的最大数量并不会报错，而是得到一个空的结果集。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><code>OFFSET</code>是可选的，如果只写<code>LIMIT 15</code>，那么相当于<code>LIMIT 15 OFFSET 0</code>。</p>
<p>在MySQL中，<code>LIMIT 15 OFFSET 30</code>还可以简写成<code>LIMIT 30, 15</code>。</p>
<p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>分页时，随着<code>N</code>越来越大，查询效率也会越来越低。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>可以对结果集进行分页，每次查询返回结果集的一部分；</p>
<p>分页查询需要先确定每页的数量和当前页数，然后确定<code>LIMIT</code>和<code>OFFSET</code>的值。</p>
<h3 id="6-聚合查询"><a href="#6-聚合查询" class="headerlink" title="6 聚合查询"></a>6 聚合查询</h3><p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) FROM students; #查询students表一共有多少条记录 COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)。</span><br><span class="line">SELECT COUNT(*) num FROM students; #通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：</span><br><span class="line">SELECT COUNT(*) boys FROM students WHERE gender &#x3D; &#39;M&#39;; #聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：</span><br></pre></td></tr></table></figure>

<p>除了<code>COUNT()</code>函数外，SQL还提供了如下聚合函数：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SUM</td>
<td align="left">计算某一列的合计值，该列必须为数值类型</td>
</tr>
<tr>
<td align="left">AVG</td>
<td align="left">计算某一列的平均值，该列必须为数值类型</td>
</tr>
<tr>
<td align="left">MAX</td>
<td align="left">计算某一列的最大值</td>
</tr>
<tr>
<td align="left">MIN</td>
<td align="left">计算某一列的最小值</td>
</tr>
</tbody></table>
<p>注意，<code>MAX()</code>和<code>MIN()</code>函数并不限于数值类型。如果是字符类型，<code>MAX()</code>和<code>MIN()</code>会返回排序最后和排序最前的字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT AVG(score) average FROM students WHERE gender &#x3D; &#39;M&#39;;要统计男生的平均成绩，我们用下面的聚合查询：</span><br><span class="line">SELECT AVG(score) average FROM students WHERE gender &#x3D; &#39;X&#39;; #如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL： 输出NULL</span><br></pre></td></tr></table></figure>



<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>可以用<code>SELECT COUNT(*) num FROM students WHERE class_id = 1;</code>。如果要继续统计二班、三班的学生数量，难道必须不断修改<code>WHERE</code>条件来执行<code>SELECT</code>语句吗？对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;	#对于聚合查询，SQL还提供了“分组聚合”的功能。</span><br><span class="line">SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;	#，GROUP BY子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。</span><br></pre></td></tr></table></figure>

<p><code>GROUP BY</code>子句指定了按<code>class_id</code>分组，因此，执行该<code>SELECT</code>语句时，会把<code>class_id</code>相同的列先分组，再分别计算，因此，得到了3行结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;	#执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，GROUP BY子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。</span><br><span class="line">SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;	#结果集就可以一目了然地看出各个班级的学生人数。</span><br><span class="line">SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;	#我们再试试把name放入结果集：</span><br></pre></td></tr></table></figure>

<h3 id="7-多表查询"><a href="#7-多表查询" class="headerlink" title="7 多表查询"></a>7 多表查询</h3><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：<code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM students, classes; # 从students表和classes表的“乘积”，即查询数据，可以这么写；</span><br></pre></td></tr></table></figure>

<p>这种一次查询两个表的数据，查询的结果也是一个二维表，它是<code>students</code>表和<code>classes</code>表的“乘积”，即<code>students</code>表的每一行与<code>classes</code>表的每一行都两两拼在一起返回。结果集的列数是<code>students</code>表和<code>classes</code>表的列数之和，行数是<code>students</code>表和<code>classes</code>表的行数之积。</p>
<p>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。</p>
<p>你可能还注意到了，上述查询的结果集有两列<code>id</code>和两列<code>name</code>，两列<code>id</code>是因为其中一列是<code>students</code>表的<code>id</code>，而另一列是<code>classes</code>表的<code>id</code>，但是在结果集中，不好区分。两列<code>name</code>同理</p>
<p>要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的<code>id</code>和<code>name</code>列起别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    students.id sid,</span><br><span class="line">    students.name,</span><br><span class="line">    students.gender,</span><br><span class="line">    students.score,</span><br><span class="line">    classes.id cid,</span><br><span class="line">    classes.name cname</span><br><span class="line">FROM students, classes;</span><br></pre></td></tr></table></figure>

<p>注意，多表查询时，要使用<code>表名.列名</code>这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用<code>表名.列名</code>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    s.id sid,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line">FROM students s, classes c;</span><br></pre></td></tr></table></figure>

<p>注意到<code>FROM</code>子句给表设置别名的语法是<code>FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名<code>s</code>和<code>c</code>分别表示<code>students</code>表和<code>classes</code>表。</p>
<p>多表查询也是可以添加<code>WHERE</code>条件的，我们来试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    s.id sid,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line">FROM students s, classes c</span><br><span class="line">WHERE s.gender &#x3D; &#39;M&#39; AND c.id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>这个查询的结果集每行记录都满足条件<code>s.gender = &#39;M&#39;</code>和<code>c.id = 1</code>。添加<code>WHERE</code>条件后结果集的数量大大减少了。</p>
<p>小结</p>
<ol>
<li>使用多表查询可以获取M x N行记录；</li>
<li>多表查询的结果集可能非常巨大，要小心使用。</li>
</ol>
<h3 id="8-连接查询"><a href="#8-连接查询" class="headerlink" title="8 连接查询"></a>8 连接查询</h3><p>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, s.gender, s.score FROM students s;	#我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成：</span><br></pre></td></tr></table></figure>

<p>假设我们希望结果集同时包含所在班级的名称，上面的结果集只有<code>class_id</code>列，缺少对应班级的<code>name</code>列。</p>
<p>现在问题来了，存放班级名称的<code>name</code>列存储在<code>classes</code>表中，只有根据<code>students</code>表的<code>class_id</code>，找到<code>classes</code>表对应的行，再取出<code>name</code>列，就可以获得班级名称。</p>
<p>这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">INNER JOIN classes c</span><br><span class="line">ON s.class_id &#x3D; c.id;</span><br></pre></td></tr></table></figure>

<p>注意INNER JOIN查询的写法是：</p>
<ol>
<li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li>
<li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li>
<li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li>
<li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li>
</ol>
<p>使用别名不是必须的，但可以更好地简化查询语句。</p>
<p>那什么是内连接（INNER JOIN）呢？先别着急，有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">RIGHT OUTER JOIN classes c</span><br><span class="line">ON s.class_id &#x3D; c.id;</span><br></pre></td></tr></table></figure>



<h2 id="四-修改数据"><a href="#四-修改数据" class="headerlink" title="四 修改数据"></a>四 修改数据</h2><h3 id="1-增-INSERT"><a href="#1-增-INSERT" class="headerlink" title="1. 增 INSERT"></a>1. 增 INSERT</h3><p>用途：向数据库插入一条记录</p>
<p><code>INSERT</code>语句的基本语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</span><br></pre></td></tr></table></figure>

<p>例如，我们向<code>students</code>表插入一条新记录，先列举出需要插入的字段名称，然后在<code>VALUES</code>子句中依次写出对应字段的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES (2, &#39;大牛&#39;, &#39;M&#39;, 80);</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure>

<p>意到我们并没有列出<code>id</code>字段，也没有列出<code>id</code>字段对应的值，这是因为<code>id</code>字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在<code>INSERT</code>语句中也可以不出现。</p>
<p>要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写<code>INSERT INTO students (score, gender, name, class_id) ...</code>，但是对应的<code>VALUES</code>就得变成<code>(80, &#39;M&#39;, &#39;大牛&#39;, 2)</code>。</p>
<p>还可以一次性添加多条记录，只需要在<code>VALUES</code>子句中指定多个记录值，每个记录是由<code>(...)</code>包含的一组值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line">  (1, &#39;大宝&#39;, &#39;M&#39;, 87),</span><br><span class="line">  (2, &#39;二宝&#39;, &#39;M&#39;, 81);</span><br><span class="line"></span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>INSERT</code>，我们就可以一次向一个表中插入一条或多条记录。</li>
</ul>
<p>​    </p>
<h3 id="2-改-UPDATE"><a href="#2-改-UPDATE" class="headerlink" title="2. 改 UPDATE"></a>2. 改 UPDATE</h3><p>用途：使用UPDATE更新数据库中的记录</p>
<p>UPDATE语句的基本语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE &lt;表名&gt; SET 字段1&#x3D;值1, 字段2&#x3D;值2, ... WHERE ...;</span><br></pre></td></tr></table></figure>

<p>我们想更新<code>students</code>表<code>id=1</code>的记录的<code>name</code>和<code>score</code>这两个字段，先写出<code>UPDATE students SET name=&#39;大牛&#39;, score=66</code>，然后在<code>WHERE</code>子句中写出需要更新的行的筛选条件<code>id=1</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE students SET name&#x3D;&#39;大牛&#39;, score&#x3D;66 WHERE id&#x3D;3;</span><br></pre></td></tr></table></figure>

<p>注意到<code>UPDATE</code>语句的<code>WHERE</code>条件和<code>SELECT</code>语句的<code>WHERE</code>条件其实是一样的，因此完全可以一次更新多条记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE students SET name&#x3D;&#39;小牛&#39;, score&#x3D;77 WHERE id&gt;&#x3D;5 AND id&lt;&#x3D;7;</span><br></pre></td></tr></table></figure>

<p>在<code>UPDATE</code>语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE students SET score&#x3D;score+10 WHERE score&lt;80;</span><br></pre></td></tr></table></figure>

<p>其中，<code>SET score=score+10</code>就是给当前行的<code>score</code>字段的值加上了10。</p>
<p>如果<code>WHERE</code>条件没有匹配到任何记录，<code>UPDATE</code>语句不会报错，也不会有任何记录被更新。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE students SET score&#x3D;100 WHERE id&#x3D;999;</span><br></pre></td></tr></table></figure>

<p>最后，要特别小心的是，<code>UPDATE</code>语句可以没有<code>WHERE</code>条件，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE students SET score&#x3D;60;</span><br></pre></td></tr></table></figure>

<p>这时，整个表的所有记录都会被更新。所以，在执行<code>UPDATE</code>语句时要非常小心，最好先用<code>SELECT</code>语句来测试<code>WHERE</code>条件是否筛选出了期望的记录集，然后再用<code>UPDATE</code>更新。</p>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>在使用MySQL这类真正的关系数据库时，<code>UPDATE</code>语句会返回更新的行数以及<code>WHERE</code>条件匹配的行数。</p>
<p>例如，更新<code>id=1</code>的记录时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; UPDATE students SET name&#x3D;&#39;大宝&#39; WHERE id&#x3D;1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>

<p>MySQL会返回<code>1</code>，可以从打印的结果<code>Rows matched: 1 Changed: 1</code>看到。</p>
<p>当更新<code>id=999</code>的记录时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; UPDATE students SET name&#x3D;&#39;大宝&#39; WHERE id&#x3D;999;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 0  Changed: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<p>MySQL会返回<code>0</code>，可以从打印的结果<code>Rows matched: 0 Changed: 0</code>看到。</p>
<h3 id="3-删-DELETE"><a href="#3-删-DELETE" class="headerlink" title="3. 删 DELETE"></a>3. 删 DELETE</h3><p>用途：删除数据库表中的记录</p>
<p><code>DELETE</code>语句的基本语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM &lt;表名&gt; WHERE ...;</span><br></pre></td></tr></table></figure>

<p>例如，我们想删除<code>students</code>表中<code>id=1</code>的记录，就需要这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM students WHERE id&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>注意到<code>DELETE</code>语句的<code>WHERE</code>条件也是用来筛选需要删除的行，因此和<code>UPDATE</code>类似，<code>DELETE</code>语句也可以一次删除多条记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM students WHERE id&gt;&#x3D;5 AND id&lt;&#x3D;7;</span><br></pre></td></tr></table></figure>

<p>如果<code>WHERE</code>条件没有匹配到任何记录，<code>DELETE</code>语句不会报错，也不会有任何记录被删除。</p>
<p>最后，要特别小心的是，和<code>UPDATE</code>类似，不带<code>WHERE</code>条件的<code>DELETE</code>语句会删除整个表的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM students;</span><br></pre></td></tr></table></figure>

<p>这时，整个表的所有记录都会被删除。所以，在执行<code>DELETE</code>语句时也要非常小心，最好先用<code>SELECT</code>语句来测试<code>WHERE</code>条件是否筛选出了期望的记录集，然后再用<code>DELETE</code>删除。</p>
<p>在使用MySQL这类真正的关系数据库时，<code>DELETE</code>语句也会返回删除的行数以及<code>WHERE</code>条件匹配的行数。</p>
<p>例如，分别执行删除<code>id=1</code>和<code>id=999</code>的记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DELETE FROM students WHERE id&#x3D;1;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELETE FROM students WHERE id&#x3D;999;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>



<h2 id="五-MySQL"><a href="#五-MySQL" class="headerlink" title="五 MySQL"></a>五 MySQL</h2><p>进入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。</p>
<p>打开命令提示符，输入命令<code>mysql -u root -p</code>，提示输入口令。填入MySQL的root口令，如果正确，就连上了MySQL Server，同时提示符变为<code>mysql&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────┐</span><br><span class="line">│Command Prompt                                    - □ x │</span><br><span class="line">├────────────────────────────────────────────────────────┤</span><br><span class="line">│Microsoft Windows [Version 10.0.0]                      │</span><br><span class="line">│(c) 2015 Microsoft Corporation. All rights reserved.    │</span><br><span class="line">│                                                        │</span><br><span class="line">│C:\&gt; mysql -u root -p                                   │</span><br><span class="line">│Enter password: ******                                  │</span><br><span class="line">│                                                        │</span><br><span class="line">│Server version: 5.7                                     │</span><br><span class="line">│Copyright (c) 2000, 2018, ...                           │</span><br><span class="line">│Type &#39;help;&#39; or &#39;\h&#39; for help.                          │</span><br><span class="line">│                                                        │</span><br><span class="line">│mysql&gt;                                                  │</span><br><span class="line">│                                                        │</span><br><span class="line">└────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>输入<code>exit</code>断开与MySQL Server的连接并返回到命令提示符。</p>
<p> MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。</p>
<p>MySQL Client和MySQL Server的关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌──────────────┐  SQL   ┌──────────────┐</span><br><span class="line">│ MySQL Client │───────&gt;│ MySQL Server │</span><br><span class="line">└──────────────┘  TCP   └──────────────┘</span><br></pre></td></tr></table></figure>

<p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是<code>127.0.0.1:3306</code>。</p>
<p>也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是<code>10.0.1.99</code>，那么就使用<code>-h</code>指定IP或域名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h 10.0.1.99 -u root -p</span><br></pre></td></tr></table></figure>



<h3 id="1-管理MYSQL"><a href="#1-管理MYSQL" class="headerlink" title="1 管理MYSQL"></a>1 管理MYSQL</h3><p>1: 创建表使用<code>CREATE TABLE</code>语句，而删除表使用<code>DROP TABLE</code>语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP TABLE students;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>2: 修改表就比较复杂。如果要给<code>students</code>表新增一列<code>birth</code>，使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></table></figure>

<p>要修改<code>birth</code>列，例如把列名改为<code>birthday</code>，类型改为<code>VARCHAR(20)</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure>

<p>3: 要删除列，使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br></pre></td></tr></table></figure>

<h3 id="2-退出MySQL"><a href="#2-退出MySQL" class="headerlink" title="2 退出MySQL"></a>2 退出MySQL</h3><p>使用<code>EXIT</code>命令退出MySQL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXIT</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure>

<p>注意<code>EXIT</code>仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。</p>
<h3 id="3-实用的SQL语句"><a href="#3-实用的SQL语句" class="headerlink" title="3 实用的SQL语句"></a>3 实用的SQL语句</h3><h4 id="A-插入或替换-REPLACE"><a href="#A-插入或替换-REPLACE" class="headerlink" title="A. 插入或替换 REPLACE"></a>A. 插入或替换 REPLACE</h4><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</span><br></pre></td></tr></table></figure>

<p>若<code>id=1</code>的记录不存在，<code>REPLACE</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被删除，然后再插入新记录。</p>
<h4 id="B-插入或更新-INSERT-INTO-ON-DUPLICATE-KEY-UPDATE"><a href="#B-插入或更新-INSERT-INTO-ON-DUPLICATE-KEY-UPDATE" class="headerlink" title="B. 插入或更新 INSERT INTO ON DUPLICATE KEY UPDATE"></a>B. 插入或更新 INSERT INTO ON DUPLICATE KEY UPDATE</h4><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用</p>
<p><code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99) ON DUPLICATE KEY UPDATE name&#x3D;&#39;小明&#39;, gender&#x3D;&#39;F&#39;, score&#x3D;99;</span><br></pre></td></tr></table></figure>

<p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被更新，更新的字段由<code>UPDATE</code>指定。</p>
<h4 id="C-插入或忽略-INSERT-IGNORE-INTO"><a href="#C-插入或忽略-INSERT-IGNORE-INTO" class="headerlink" title="C. 插入或忽略 INSERT IGNORE INTO"></a>C. 插入或忽略 INSERT IGNORE INTO</h4><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</span><br></pre></td></tr></table></figure>

<p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，不执行任何操作。</p>
<h4 id="D-快照-CREATE-TABLE-…-SELECT"><a href="#D-快照-CREATE-TABLE-…-SELECT" class="headerlink" title="D. 快照 CREATE TABLE … SELECT"></a>D. 快照 CREATE TABLE … SELECT</h4><p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合<code>CREATE TABLE</code>和<code>SELECT</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 对class_id&#x3D;1的记录进行快照，并存储为新表students_of_class1:</span><br><span class="line">CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>新创建的表结构和<code>SELECT</code>使用的表结构完全一致。</p>
<h4 id="E-写入查询结果集"><a href="#E-写入查询结果集" class="headerlink" title="E. 写入查询结果集"></a>E. 写入查询结果集</h4><p>如果查询结果集需要写入到表中，可以结合<code>INSERT</code>和<code>SELECT</code>，将<code>SELECT</code>语句的结果集直接插入到指定表中。</p>
<p>例如，创建一个统计成绩的表<code>statistics</code>，记录各班的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE statistics (</span><br><span class="line">    id BIGINT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    class_id BIGINT NOT NULL,</span><br><span class="line">    average DOUBLE NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>然后，我们就可以用一条语句写入各班的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure>

<p>确保<code>INSERT</code>语句的列和<code>SELECT</code>语句的列能一一对应，就可以在<code>statistics</code>表中直接保存查询的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; SELECT * FROM statistics;</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| id | class_id | average      |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">|  1 |        1 |         86.5 |</span><br><span class="line">|  2 |        2 | 73.666666666 |</span><br><span class="line">|  3 |        3 | 88.333333333 |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="F-强制使用指定索引"><a href="#F-强制使用指定索引" class="headerlink" title="F. 强制使用指定索引"></a>F. 强制使用指定索引</h4><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用<code>FORCE INDEX</code>强制查询使用指定的索引。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id &#x3D; 1 ORDER BY id DESC;</span><br></pre></td></tr></table></figure>

<p>指定索引的前提是索引<code>idx_class_id</code>必须存在。</p>
<h4 id="G-导出"><a href="#G-导出" class="headerlink" title="G 导出"></a>G 导出</h4><p>1.导出整个 <a href="http://www.2cto.com/database/" target="_blank" rel="noopener"><strong>数据库</strong></a></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名</span><br><span class="line"></span><br><span class="line">mysqldump -u wcnc -p smgp_apps_wcnc &gt; wcnc.sql</span><br></pre></td></tr></table></figure>



<p>2.导出一个表</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名</span><br><span class="line"></span><br><span class="line">mysqldump -u wcnc -p smgp_apps_wcnc users&gt; wcnc_users.sql</span><br></pre></td></tr></table></figure>

<p>3.导出一个数据库结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u wcnc -p -d --add-drop-table smgp_apps_wcnc &gt;d:\wcnc_db.sql</span><br><span class="line">-d 没有数据 --add-drop-table 在每个create语句之前增加一个drop table</span><br></pre></td></tr></table></figure>



<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>命令行程序<code>mysql</code>实际上是MySQL客户端，真正的MySQL服务器程序是<code>mysqld</code>，在后台运行。</p>
<h2 id="六-事务"><a href="#六-事务" class="headerlink" title="六 事务"></a>六 事务</h2><p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 从id&#x3D;1的账户给id&#x3D;2的账户转账100元</span><br><span class="line">-- 第一步：将id&#x3D;1的A账户余额减去100</span><br><span class="line">UPDATE accounts SET balance &#x3D; balance - 100 WHERE id &#x3D; 1;</span><br><span class="line">-- 第二步：将id&#x3D;2的B账户余额加上100</span><br><span class="line">UPDATE accounts SET balance &#x3D; balance + 100 WHERE id &#x3D; 2;</span><br></pre></td></tr></table></figure>

<p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。</p>
<p>这种把多条语句作为一个整体进行操作的功能，被称为数据库<em>事务</em>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p>
<p>数据库事务具有ACID这4个特性：</p>
<ul>
<li>A： Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li>
<li>C： Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li>
<li>I： Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li>
<li>D： Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li>
</ul>
<p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<em>隐式事务</em>。</p>
<p>要手动把多条SQL语句作为一个事务执行，使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<em>显式事务</em>，例如，把上述的转账操作作为一个显式事务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE accounts SET balance &#x3D; balance - 100 WHERE id &#x3D; 1;</span><br><span class="line">UPDATE accounts SET balance &#x3D; balance + 100 WHERE id &#x3D; 2;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。</p>
<p><code>COMMIT</code>是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果<code>COMMIT</code>语句执行失败了，整个事务也会失败。</p>
<p>有些时候，我们希望主动让事务失败，这时，可以用<code>ROLLBACK</code>回滚事务，整个事务会失败：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE accounts SET balance &#x3D; balance - 100 WHERE id &#x3D; 1;</span><br><span class="line">UPDATE accounts SET balance &#x3D; balance + 100 WHERE id &#x3D; 2;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<p>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。</p>
<p><strong>隔离级别</strong></p>
<p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。</p>
<p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p>
<table>
<thead>
<tr>
<th align="left">Isolation Level</th>
<th align="left">脏读（Dirty Read）</th>
<th align="left">不可重复读（Non Repeatable Read）</th>
<th align="left">幻读（Phantom Read）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Read Uncommitted</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Read Committed</td>
<td align="left">-</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Repeatable Read</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Serializable</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p>我们会依次介绍4种隔离级别的数据一致性问题。</p>
<h3 id="1-Read-Uncommitted"><a href="#1-Read-Uncommitted" class="headerlink" title="1 Read Uncommitted"></a>1 Read Uncommitted</h3><p>Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。</p>
<p>我们来看一个例子。</p>
<p>首先，我们准备好<code>students</code>表的数据，该表仅一行记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p>
<table>
<thead>
<tr>
<th align="left">时刻</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">BEGIN;</td>
<td align="left">BEGIN;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">UPDATE students SET name = ‘Bob’ WHERE id = 1;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">ROLLBACK;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"></td>
<td align="left">COMMIT;</td>
</tr>
</tbody></table>
<p>当事务A执行完第3步时，它更新了<code>id=1</code>的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。</p>
<p>随后，事务A在第5步进行了回滚，事务B再次读取<code>id=1</code>的记录，发现和上一次读取到的数据不一致，这就是脏读。</p>
<p>可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。</p>
<h3 id="2-Read-Committed"><a href="#2-Read-Committed" class="headerlink" title="2 Read Committed"></a>2 Read Committed</h3><p>在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。</p>
<p>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p>
<p>我们仍然先准备好<code>students</code>表的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p>
<table>
<thead>
<tr>
<th align="left">时刻</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">BEGIN;</td>
<td align="left">BEGIN;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">UPDATE students SET name = ‘Bob’ WHERE id = 1;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">COMMIT;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"></td>
<td align="left">COMMIT;</td>
</tr>
</tbody></table>
<p>当事务B第一次执行第3步的查询时，得到的结果是<code>Alice</code>，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了<code>Bob</code>，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。</p>
<h3 id="3-Repeatable-Read"><a href="#3-Repeatable-Read" class="headerlink" title="3 Repeatable Read"></a>3 Repeatable Read</h3><p>在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。</p>
<p>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。</p>
<p>我们仍然先准备好<code>students</code>表的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p>
<table>
<thead>
<tr>
<th align="left">时刻</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">BEGIN;</td>
<td align="left">BEGIN;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 99;</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">INSERT INTO students (id, name) VALUES (99, ‘Bob’);</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">COMMIT;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 99;</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"></td>
<td align="left">UPDATE students SET name = ‘Alice’ WHERE id = 99;</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 99;</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"></td>
<td align="left">COMMIT;</td>
</tr>
</tbody></table>
<p>事务B在第3步第一次读取<code>id=99</code>的记录时，读到的记录为空，说明不存在<code>id=99</code>的记录。随后，事务A在第4步插入了一条<code>id=99</code>的记录并提交。事务B在第6步再次读取<code>id=99</code>的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取<code>id=99</code>的记录时，记录出现了。</p>
<p>可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。</p>
<h3 id="4-Serializable"><a href="#4-Serializable" class="headerlink" title="4 Serializable"></a>4 Serializable</h3><p>Serializable 是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p>
<p>虽然 Serializable 隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</p>
<p><strong>默认隔离级别</strong></p>
<p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络传输层总结</title>
    <url>/2020/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文学习自计算机网络第七版</p>
<a id="more"></a>

<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</p>
<h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><ol>
<li>端到端的通信是应用进程之间的通信</li>
<li>运输层有一个很重要的功能——复用(multiplexing)和分用(demultiplexing)</li>
</ol>
<p>UDP在传送数据之前不需要先建立连接。远地主机的运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。</p>
<h4 id="表5-1-使用UDP和TCP协议的各种应用和应用层协议"><a href="#表5-1-使用UDP和TCP协议的各种应用和应用层协议" class="headerlink" title="表5-1 使用UDP和TCP协议的各种应用和应用层协议"></a>表5-1 使用UDP和TCP协议的各种应用和应用层协议</h4><p><img src="/2020/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/image-20200831234824786.png" alt="image-20200831234824786"></p>
<p>TCP/IP的运输层用一个16位端口号来标志一个端口。但请注意，端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在因特网不同计算机中，相同的端口号是没有关联的。</p>
<ol>
<li>服务器端使用的端口号这里又分为两类，最重要的一类叫做熟知端口号(well-known port number)或系统端口号，数值为0～1023；另一类叫做登记端口号，数值为1024～49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。</li>
<li>客户端使用的端口号 数值为49152～65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号[插图]</li>
</ol>
<h2 id="一-UDP"><a href="#一-UDP" class="headerlink" title="一 UDP"></a>一 UDP</h2><p>用户数据报协议UDP只在IP的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及差错检测的功能。</p>
<p>UDP的主要特点：</p>
<p>(1) UDP是无连接的，即发送数据之前不需要建立连接（当然，发送数据结束时也没有连接可释放），因此减少了开销和发送数据之前的时延。</p>
<p>(2) UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表（这里面有许多参数）。</p>
<p>(3) UDP是面向报文的。</p>
<p>(4) UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很多的实时应用（如IP电话、实时视频会议等）要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太大的时延。UDP正好适合这种要求。</p>
<p>(5) UDP支持一对一、一对多、多对一和多对多的交互通信。</p>
<p>(6) UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</p>
<p>用户数据报UDP有两个字段：数据字段和首部字段。首部字段很简单，只有8个字节(图5-5)，由四个字段组成，每个字段的长度都是两个字节。各字段意义如下：</p>
<p><img src="/2020/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/image-20200831235527173.png" alt="image-20200831235527173"></p>
<p>图5-5 UDP用户数据报的首部和伪首部</p>
<p>(1) 源端口 源端口号。在需要对方回信时选用。不需要时可用全0。</p>
<p>(2) 目的端口 目的端口号。这在终点交付报文时必须要使用到。</p>
<p>(3) 长度 UDP用户数据报的长度，其最小值是8（仅有首部）。</p>
<p>(4) 检验和 检测UDP用户数据报在传输中是否有错。有错就丢弃。</p>
<h2 id="二-TCP"><a href="#二-TCP" class="headerlink" title="二 TCP"></a>二 TCP</h2><p>TCP是TCP/IP体系中非常复杂的一个协议。下面介绍TCP最主要的特点。</p>
<p>(1) TCP是面向连接的运输层协议。这就是说，应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。也就是说，应用进程之间的通信好像在“打电话”：通话前要先拨号建立连接，通话结束后要挂机释放连接。</p>
<p>(2) 每一条TCP连接只能有两个端点(endpoint)，每一条TCP连接只能是点对点的（一对一）。这个问题后面还要进一步讨论。</p>
<p>(3) TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。</p>
<p>(4) TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而TCP在合适的时候把数据发送出去。在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。</p>
<p>(5) 面向字节流。TCP中的“流”(stream)指的是流入到进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据看成仅仅是一连串的无结</p>
<h3 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h3><p>我们知道，TCP发送的报文段是交给IP层传送的。但IP层只能提供尽最大努力服务，也就是说，TCP下面的网络所提供的是不可靠的传输。因此，TCP必须采用适当的措施才能使得两个运输层之间的通信变得可靠。</p>
<p>理想的传输条件有以下两个特点：</p>
<p>(1) 传输信道不产生差错。</p>
<p>(2) 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</p>
<p>可靠传输协议：</p>
<h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>全双工通信的双方既是发送方也是接收方。下面为了讨论问题的方便，我们仅考虑A发送数据而B接收数据并发送确认。因此A叫做发送方，而B叫做接收方。因为这里是讨论可靠传输的原理，因此把传送的数据单元都称为分组，而并不考虑数据是在哪一个层次上传送的[插图]。“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p>
<p>每发送完一个分组设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。</p>
<p>超时重传，就要在每发送完一个分组设置一个超时计时器，如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。</p>
<p><strong>注意点</strong></p>
<ul>
<li>第一，A在发送完一个分组后，必须暂时保留已发送的分组的副本（为发生超时重传时使用）。只有在收到相应的确认后才能清除暂时保留的分组副本。</li>
<li>第二，分组和确认分组都必须进行编号[插图]。这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。</li>
<li>第三，超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2020/08/29/redis/</url>
    <content><![CDATA[<p>本文用来学习 redis</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>C++开发面试题汇总</title>
    <url>/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>本文整理自网络：</p>
<ol>
<li><a href="https://www.nowcoder.com/tutorial/93/8f140fa03c084299a77459dc4be31c95" target="_blank" rel="noopener">C++面经宝典</a></li>
<li>现代操作系统</li>
<li>计算机网络</li>
<li>数据库系统概论</li>
<li>设计模式</li>
</ol>
<a id="more"></a>

<h1 id="一-C-基础"><a href="#一-C-基础" class="headerlink" title="一 C++基础"></a>一 C++基础</h1><h2 id="一-基本语言"><a href="#一-基本语言" class="headerlink" title="一 基本语言"></a>一 基本语言</h2><h3 id="零-编译过程"><a href="#零-编译过程" class="headerlink" title="零 编译过程"></a>零 编译过程</h3><h4 id="1-源文件从文本到可执行文件经历的过程"><a href="#1-源文件从文本到可执行文件经历的过程" class="headerlink" title="1. 源文件从文本到可执行文件经历的过程"></a>1. 源文件从文本到可执行文件经历的过程</h4><p><strong>简单版本</strong></p>
<p>对于C++源文件，从文本到可执行文件一般需要<strong>四个过程</strong></p>
<blockquote>
<p>1、<strong>预处理阶段</strong>：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</p>
<p>2、<strong>编译阶段</strong>：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</p>
<p>3、<strong>汇编阶段</strong>：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</p>
<p>4、<strong>链接阶段</strong>：将多个目标文件及所需要的库连接成最终的可执行目标文件</p>
</blockquote>
<p><strong>详细版本</strong></p>
<p><strong>1 预编译：主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</strong></p>
<blockquote>
<p>1、删除所有的#define，展开所有的<strong>宏定义</strong>。</p>
<p>2、处理所有的<strong>条件预编译指令</strong>，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p>
<p>3、处理“<strong>#include”预编译指令</strong>，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</p>
<p>4、删除所有的<strong>注释</strong>，“//”和“/**/”。</p>
<p>5、保留所有的<strong>#pragma 编译器指令</strong>，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</p>
<p>6、添加<strong>行号和文件标识</strong>，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</p>
</blockquote>
<p><strong>2 编译：把预编译之后生成的<code>xxx.i</code>或<code>xxx.ii</code>文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</strong></p>
<blockquote>
<p>1、<strong>词法分析</strong>：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p>
<p>2、<strong>语法分析</strong>：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</p>
<p>3、<strong>语义分析</strong>：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p>
<p>4、<strong>优化</strong>：源代码级别的一个优化过程。</p>
<p>5、<strong>目标代码生成</strong>：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p>
<p>6、<strong>目标代码优化</strong>：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p>
</blockquote>
<p><strong>3）汇编</strong></p>
<blockquote>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 </p>
<p>汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是<strong>根据汇编指令和机器指令的对照表一一翻译</strong>过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。</p>
</blockquote>
<p><strong>4）链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接</strong></p>
<blockquote>
<ul>
<li><p>静态库（.a 、.lib）：（Windows 下的 .lib，Linux 和 Mac 下的 .a）一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。</p>
</li>
<li><p>动态库（.so 、.dll ）：（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib）</p>
</li>
</ul>
<p>1、<strong>静态链接</strong></p>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p>
<ul>
<li>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</li>
<li>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</li>
<li>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</li>
</ul>
<p>2、<strong>动态链接</strong></p>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<ul>
<li>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</li>
<li>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</li>
<li>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</li>
</ul>
</blockquote>
<h4 id="2-include头文件的顺序，双引号””和尖括号-lt-gt-的区别？"><a href="#2-include头文件的顺序，双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="2. include头文件的顺序，双引号””和尖括号&lt;&gt;的区别？"></a>2. include头文件的顺序，双引号””和尖括号&lt;&gt;的区别？</h4><blockquote>
<p>Include头文件的顺序：对于include的头文件来说，如果在文件<code>a.h</code>中声明一个在文件<code>b.h</code>中定义的变量，而不引用<code>b.h</code>。那么要在<code>a.c</code>文件中引用<code>b.h</code>文件，并且要先引用<code>b.h</code>，后引用<code>a.h</code>,否则汇报变量类型未声明错误。</p>
<p><strong>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。</strong></p>
<p>对于使用双引号包含的头文件，查找头文件路径的顺序为</p>
<ol>
<li>当前头文件目录</li>
<li>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</li>
<li>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</li>
</ol>
<p>对于使用尖括号包含的头文件，查找头文件的路径顺序为：</p>
<ol>
<li>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</li>
<li>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</li>
</ol>
</blockquote>
<h3 id="一-变量和基本类型"><a href="#一-变量和基本类型" class="headerlink" title="一 变量和基本类型"></a>一 变量和基本类型</h3><h4 id="1-static"><a href="#1-static" class="headerlink" title="1. static"></a>1. static</h4><p><strong>简短回答</strong></p>
<blockquote>
<ol>
<li>对于函数定义和代码块之外的<strong>全局变量</strong>声明，static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。</li>
<li>对于代码块<strong>内部的变量</strong>声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。</li>
<li>对于被static修饰的<strong>普通函数</strong>，其只能在定义它的源文件中使用，不能在其他源文件中被引用</li>
<li>对于被static修饰的<strong>类成员变量和成员函数</strong>，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。</li>
</ol>
</blockquote>
<p><strong>其它解答</strong></p>
<blockquote>
<ol>
<li><p>加了static关键字的全局变量只能在本文件中使用。例如在a.c中定义了static int a=10;那么在b.c中用extern int a是拿不到a的，a的作用域只在a.c中。 </p>
</li>
<li><p>static定义的静态局部变量分配在数据段上，普通的局部变量分配在栈上，会因为函数栈的释放而被释放掉。</p>
</li>
<li><p>对一个类中成员变量和成员函数来说，加了static关键字，则此变量/函数就没有了this指针了，必须通过类名才能访问</p>
</li>
</ol>
</blockquote>
<p><strong>详细说明</strong></p>
<blockquote>
<ol>
<li><strong>全局静态变量</strong></li>
</ol>
<blockquote>
<p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.</p>
<p>静态存储区，在整个程序运行期间一直存在。</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
</blockquote>
<ol start="2">
<li><strong>局部静态变量</strong></li>
</ol>
<blockquote>
<p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p>
<p>内存中的位置：静态存储区</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
</blockquote>
<ol start="3">
<li><strong>静态函数</strong></li>
</ol>
<blockquote>
<p>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p>
<p>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>
<p>warning：不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p>
</blockquote>
<ol start="4">
<li><strong>类的静态成员</strong></li>
</ol>
<blockquote>
<p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>
</blockquote>
<ol start="5">
<li><strong>类的静态函数</strong></li>
</ol>
<blockquote>
<p>静态成员函数和静态数据成员一样，都属于类的静态成员，都不是对象成员。因此，对静态成员的引用不需要用对象名。</p>
<p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>
</blockquote>
</blockquote>
<h4 id="2-静态变量什么时候初始化"><a href="#2-静态变量什么时候初始化" class="headerlink" title="2. 静态变量什么时候初始化"></a>2. 静态变量什么时候初始化</h4><blockquote>
<p>静态变量存储在虚拟地址空间的数据段和bss段，</p>
<p>C语言中其在代码执行之前初始化，属于编译期初始化。</p>
<p>而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造</p>
</blockquote>
<h4 id="3-C-中四种cast类型转换"><a href="#3-C-中四种cast类型转换" class="headerlink" title="3. C++中四种cast类型转换"></a>3. C++中四种cast类型转换</h4><blockquote>
<p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast</p>
<p><strong>1、const_cast</strong></p>
<p>将const变量转为非const</p>
<p><strong>2、static_cast</strong></p>
<p>各种隐式转换， static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p>
<p><strong>3、dynamic_cast</strong></p>
<p>动态类型转换。</p>
<p>只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p>
<p>向上转换：指的是子类向基类的转换</p>
<p>向下转换：指的是基类向子类的转换</p>
<p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p>
<p><strong>4、reinterpret_cast</strong></p>
<p>几乎什么都可以转，比如将int转指针，可能会出问题，几乎什么都可以转，</p>
<p><strong>5、为什么不使用C的强制转换？</strong></p>
<p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
</blockquote>
<blockquote>
<table>
<thead>
<tr>
<th>类型转换</th>
<th>功能</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td>const_cast</td>
<td>把const变量转换为非const变量；<br>去掉变量const属性或者volatile属性的转换符</td>
<td align="left"></td>
</tr>
<tr>
<td>static_cast</td>
<td>各种隐式转换， <br>static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</td>
<td align="left">非const转const<br>void*转指针等,</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>动态类型转换。<br>只能用于含有虚函数的类，用于类层次间的向上和向下转化。<br>只能转指针或引用。<br>向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。<br>要深入了解内部转换的原理。</td>
<td align="left"></td>
</tr>
<tr>
<td>reinterpret_cast</td>
<td>重新解释（无理）转换</td>
<td align="left">将int转指针，可能会出问题，</td>
</tr>
</tbody></table>
<p>调用方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(str);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="4-const"><a href="#4-const" class="headerlink" title="4. const"></a>4. const</h4><blockquote>
<ol>
<li>const 修饰<strong>变量</strong>：可用于定义常量。const’定义的常量编译器可以对数据静态类型进行安全检查。</li>
<li>const修饰<strong>函数形式参数</strong>：当输入参数为用户自定义类型和抽象数据类型时，可将值传递改为const &amp;传递，可以提高效率。引用传递不需要产生临时对象，节省了临时对象的构造、复制、析构过程消耗的时间。但光用引用可能改变a，因此加const</li>
<li>const可以<strong>修饰函数返回值</strong>：如果要给指针传递的函数返回值加const，则返回值不能被直接修改，且该返回值只能被赋值给加const修饰的同类型指针。</li>
<li>const修饰的<strong>成员函数</strong>：表明函数调用不会对对象做出任何更改。事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">GetChar</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;;</span><br><span class="line"><span class="keyword">char</span> *ch = GetChar(); <span class="comment">//error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ch = GetChar(); <span class="comment">//right</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="5-C-怎么定义常量？常量存放在内存的哪个位置？"><a href="#5-C-怎么定义常量？常量存放在内存的哪个位置？" class="headerlink" title="5. C++怎么定义常量？常量存放在内存的哪个位置？"></a>5. C++怎么定义常量？常量存放在内存的哪个位置？</h4><blockquote>
<p>常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。</p>
<ol>
<li>对于局部对象，常量存放在栈区；</li>
<li>对于全局对象，常量存放在全局/静态存储区；</li>
<li>对于字面值常量，常量存放在常量存储区。</li>
</ol>
</blockquote>
<h4 id="6-以下四行const代码的区别？"><a href="#6-以下四行const代码的区别？" class="headerlink" title="6. 以下四行const代码的区别？"></a>6. 以下四行const代码的区别？</h4><blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * arr = <span class="string">"123"</span>; <span class="comment">//字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</span></span><br><span class="line"><span class="keyword">char</span> * brr = <span class="string">"123"</span>; <span class="comment">//字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改"123"的值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> crr[] = <span class="string">"123"</span>; <span class="comment">//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</span></span><br><span class="line"><span class="keyword">char</span> drr[] = <span class="string">"123"</span>; <span class="comment">//字符串123保存在栈区，可以通过drr去修改</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="7-隐式类型转换"><a href="#7-隐式类型转换" class="headerlink" title="7. 隐式类型转换"></a>7. 隐式类型转换</h4><blockquote>
<p>首先，对于内置类型，低精度变量赋值给高精度变量时会发生隐式类型转换；</p>
<p>其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。</p>
</blockquote>
<h4 id="8-RTTI"><a href="#8-RTTI" class="headerlink" title="8. RTTI"></a>8. <a href="https://www.cnblogs.com/xuelisheng/p/9479288.html" target="_blank" rel="noopener"><code>RTTI</code></a></h4><blockquote>
<p>RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法</p>
<p>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info。</p>
<p>typeid的主要作用就是让用户知道当前变量的类型，对于内置数据类型以及自定义数据类型都生效；</p>
<p>typeid函数返回的是一个结构体或者类，然后，再调用这个返回的结构体或类的name成员函数；</p>
</blockquote>
<h4 id="9-extern"><a href="#9-extern" class="headerlink" title="9. extern"></a>9. extern</h4><blockquote>
<p><strong>extern</strong>是一种“<strong>外部声明</strong>”的关键字，字面意思就是<strong>在此处声明</strong>某种变量或函数，<strong>在外部定义</strong>。</p>
</blockquote>
<blockquote>
<p>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。</p>
<p>extern也可用来进行链接指定。</p>
</blockquote>
<h5 id="extern-“c”的作用"><a href="#extern-“c”的作用" class="headerlink" title="*extern “c”的作用? *"></a>*<em>extern “c”的作用? *</em></h5><blockquote>
<p>Extern “C”是由Ｃ＋＋提供的一个连接交换指定符号，用于告诉Ｃ＋＋这段代码是Ｃ函数。这是因为C++编译后库中函数名会变得很长，与C生成的不一致，造成Ｃ＋＋不能直接调用C函数，加上extren “c”后，C++就能直接调用C函数了。</p>
<p>Extern “C”主要使用正规DLL函数的引用和导出和在C++包含C函数或C头文件时使用。使用时在前面加上extern “c” 关键字即可</p>
<p>extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。</p>
<p>记住下列语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>

<p>仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。</p>
<p>变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。</p>
<p>通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。</p>
<p>例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。</p>
</blockquote>
<blockquote>
<p>C++调用C函数需要extern “C”，因为C语言没有函数重载。</p>
</blockquote>
<blockquote>
<p><strong>extern对应的关键字是static，static表明变量或者函数只能在本模块中使用，因此，被static修饰的变量或者函数不可能被extern C修饰。</strong></p>
</blockquote>
<p><strong>extern “C”的使用要点总结</strong></p>
<blockquote>
<ul>
<li>可以是如下的单一语句</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> doublesqrt(<span class="keyword">double</span>`);</span><br></pre></td></tr></table></figure>

<ul>
<li>可以是复合语句, 相当于复合语句中的声明都加了extern “C”</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以包含头文件，相当于头文件中的声明都加了extern “C”</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line">    ＃include &lt;cmath&gt;</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure>

<ul>
<li>不可以将extern “C” 添加在函数内部</li>
<li>如果函数有多个声明，可以都加extern “C”, 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则。</li>
<li>除extern “C”, 还有extern “FORTRAN” 等。</li>
</ul>
</blockquote>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/carsonzhu/p/5272271.html" target="_blank" rel="noopener">extern “C”的作用详解</a></p>
</blockquote>
<h3 id="二-指针、引用"><a href="#二-指针、引用" class="headerlink" title="二 指针、引用"></a>二 指针、引用</h3><h4 id="1-指针和引用的区别"><a href="#1-指针和引用的区别" class="headerlink" title="1. 指针和引用的区别"></a>1. 指针和引用的区别</h4><p>回答要点：空间、大小、初始化、修改、const、级数、++运算、作为返回值返回。</p>
<blockquote>
<ol>
<li><p>指针有自己的一块空间，而引用只是一个别名；</p>
</li>
<li><p>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</p>
</li>
<li><p>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</p>
</li>
<li><p>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p>
</li>
<li><p>可以有const指针，但是没有const引用；</p>
</li>
<li><p>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p>
</li>
<li><p>指针可以有多级指针（**p），而引用至于一级；</p>
</li>
<li><p>指针和引用使用++运算符的意义不一样；</p>
</li>
<li><p>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p>
</li>
</ol>
</blockquote>
<h4 id="2-数组和指针的区别"><a href="#2-数组和指针的区别" class="headerlink" title="2. 数组和指针的区别"></a>2. 数组和指针的区别</h4><blockquote>
<table>
<thead>
<tr>
<th>指针</th>
<th>数组</th>
</tr>
</thead>
<tbody><tr>
<td>保存数据的地址</td>
<td>保存数据</td>
</tr>
<tr>
<td>间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据</td>
<td>直接访问数据，</td>
</tr>
<tr>
<td>通常用于动态的数据结构</td>
<td>通常用于固定数目且数据类型相同的元素</td>
</tr>
<tr>
<td>通过Malloc分配内存，free释放内存</td>
<td>隐式的分配和删除</td>
</tr>
<tr>
<td>通常指向匿名数据，操作匿名函数</td>
<td>自身即为数据名</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="3-野指针"><a href="#3-野指针" class="headerlink" title="3. 野指针"></a>3. 野指针</h4><blockquote>
<p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</p>
</blockquote>
<h4 id="4-函数指针"><a href="#4-函数指针" class="headerlink" title="4. 函数指针"></a>4. 函数指针</h4><blockquote>
<p><strong>1、定义</strong></p>
<p>函数指针是指向函数的指针变量。</p>
<p>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。</p>
<p>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>
<p><strong>2、用途</strong></p>
<p>调用函数和做函数的参数，比如回调函数。</p>
<p><strong>3、示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fun</span><span class="params">(<span class="keyword">char</span> * p)</span>  </span>&#123;…&#125;    <span class="comment">// 函数fun</span></span><br><span class="line"><span class="keyword">char</span> * (*pf)(<span class="keyword">char</span> * p);       <span class="comment">// 函数指针pf</span></span><br><span class="line">pf = fun;            <span class="comment">// 函数指针pf指向函数fun</span></span><br><span class="line">pf(p);            <span class="comment">// 通过函数指针pf调用函数fun</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="5-传值、传指针和传引用的区别和联系"><a href="#5-传值、传指针和传引用的区别和联系" class="headerlink" title="5. 传值、传指针和传引用的区别和联系"></a>5. 传值、传指针和传引用的区别和联系</h4><blockquote>
<p><strong>指针：</strong>指针就是一个变量，指针存放的是变量的地址。</p>
<p><strong>传值：</strong>传值即实参拷贝传递给形参，单向传递（实参-&gt;形参），赋值完毕后实参就和形参没有任何联系，对形参的修改就不会影响到实参。</p>
<p><strong>传地址：</strong>传地址也是一种传值呢？因为传地址是把实参地址的拷贝传递给形参。对形参地址所指向对象的修改却直接反应在实参中，因为形参指向的对象就是实参的对象。</p>
<p><strong>传引用：</strong>传引用本质没有任何实参的拷贝，其实就是让另外一个变量也执行该实参。就是两个变量指向同一个对象。这是对形参的修改，必然反映到实参上。</p>
<p><strong>分析</strong><br>值传递时函数操作的并不是实参本身，形参和实参是相互独立的，所以对形参进行操作并不会改变实参的值。</p>
<p>引用传递操作地址是实参地址 ，形参相当于实参的一个别名，对它的操作就是对实参的操作。</p>
<p><strong>总结</strong><br>传引用和传指针看上去效果一样的，但本质上有区别：</p>
<p><strong>指针传递</strong>参数本质上是值传递的方式，它所传递的是一个地址值。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。</p>
<p>在值传递过程中，被调函数的形式参数作为被调函数的局部变量，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，指针通过局部变量中存储的地址访空间。</p>
<p>既然形参和实参是相互独立的，在没有任何修饰形参时，形参是可以被修改的，形参指针可以指向任何地方，而且修改后就无法再访问到实参。</p>
<p>例如Pointer函数中n = &amp;b后，（*n）++不会再修改实参的值，这也是传递指针时通常会用const进行修饰的原因。</p>
</blockquote>
<h4 id="6-this指针"><a href="#6-this指针" class="headerlink" title="6. this指针"></a>6. this指针</h4><blockquote>
<p>（1）一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。</p>
<p>（2）this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。</p>
<h5 id="this指针的使用"><a href="#this指针的使用" class="headerlink" title="this指针的使用"></a>this指针的使用</h5><p>（1）在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this。</p>
<p>（2）当参数与成员变量名相同时，如this-&gt;n = n （不能写成n = n)。</p>
</blockquote>
<h3 id="三-智能指针"><a href="#三-智能指针" class="headerlink" title="三 智能指针"></a>三 智能指针</h3><h4 id="0-概念和作用"><a href="#0-概念和作用" class="headerlink" title="0. 概念和作用"></a>0. 概念和作用</h4><blockquote>
<p>智能指针主要用于管理在堆上分配的内存，它把普通的指针封装为一个栈对象。</p>
<p>当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。</p>
<p>因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。</p>
</blockquote>
<h4 id="1-四个智能指针"><a href="#1-四个智能指针" class="headerlink" title="1. 四个智能指针"></a>1. 四个智能指针</h4><p><strong>为什么要使用智能指针</strong></p>
<blockquote>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。</p>
<p>智能指针的作用：<strong>在函数结束时自动释放内存空间，不需要手动释放内存空间</strong>。</p>
</blockquote>
<blockquote>
<p>C++里面的四个智能指针: <strong>auto_ptr, shared_ptr, weak_ptr, unique_ptr</strong> 其中后三个是c++11支持，并且第一个已经被11弃用。</p>
<blockquote>
<p>C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。</p>
<p>只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。</p>
</blockquote>
</blockquote>
<h5 id="1-auto-ptr（c-98的方案，cpp11已经抛弃）"><a href="#1-auto-ptr（c-98的方案，cpp11已经抛弃）" class="headerlink" title="1. auto_ptr（c++98的方案，cpp11已经抛弃）"></a><strong>1. auto_ptr（c++98的方案，cpp11已经抛弃）</strong></h5><blockquote>
<p>采用所有权模式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"I reigned lonely as a cloud.”));</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br></pre></td></tr></table></figure>

<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。</p>
<p>auto_ptr的缺点是：存在潜在的内存崩溃问题！</p>
</blockquote>
<h5 id="2-unique-ptr（替换auto-ptr）"><a href="#2-unique-ptr（替换auto-ptr）" class="headerlink" title="2. unique_ptr（替换auto_ptr）"></a><strong>2. unique_ptr（替换auto_ptr）</strong></h5><blockquote>
<p><strong>unique_ptr实现独占式拥有或严格拥有的概念，保证同一时间内只有一个智能指针可以指向该对象。</strong></p>
<p>采用所有权模式，还是上面那个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"auto"</span>))</span></span>;  <span class="comment">//#4</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4；  <span class="comment">//#5</span></span><br><span class="line">p4 = p3; <span class="comment">//此时会报错！！</span></span><br></pre></td></tr></table></figure>

<p>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</p>
<p>另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"hello world"</span>))</span></span>;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));   <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>

<p>其中#1留下悬挂的<code>unique_ptr(pu1)</code>，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p>
<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。</p>
<p>C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(<span class="string">"hello"</span>);</span><br><span class="line">ps2 = <span class="built_in">move</span>(ps1);</span><br><span class="line">ps1 = demo(<span class="string">"alexia"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-shared-ptr"><a href="#3-shared-ptr" class="headerlink" title="3. shared_ptr"></a><strong>3. shared_ptr</strong></h5><blockquote>
<p><strong>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。</strong></p>
<p>资源可以被多个指针共享，它<strong>使用计数机制来表明资源被几个指针共享</strong>。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入<code>auto_ptr</code>,<code>unique_ptr</code>,<code>weak_ptr</code>来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>成员函数</p>
<ul>
<li>use_count 返回引用计数的个数</li>
<li>unique 返回是否是独占所有权( use_count 为 1)</li>
<li>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</li>
<li>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</li>
<li>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></li>
</ul>
</blockquote>
<h5 id="4-weak-ptr"><a href="#4-weak-ptr" class="headerlink" title="4. weak_ptr"></a><strong>4. weak_ptr</strong></h5><blockquote>
<p>weak_ptr 是<strong>一种不控制对象生命周期的智能指针</strong>。</p>
<p>它指向一个 <code>shared_ptr</code> 管理的对象. 进行该对象的内存管理的是那个强引用的 <code>shared_ptr</code>. </p>
<p>weak_ptr只是提供了对管理对象的一个访问手段。</p>
<p>weak_ptr设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。</p>
<p>它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">      ~A()&#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">	~B()&#123;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">      <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">      pb-&gt;pa_ = pa;</span><br><span class="line">      pa-&gt;pb_ = pb;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb； 改为<code>weak_ptr pb;</code> 这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p>
<p>注意的是我们<strong>不能通过weak_ptr直接访问对象的方法</strong>，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb_-&gt;print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</p>
</blockquote>
<h4 id="2-智能指针会不会内存泄露，如何解决？"><a href="#2-智能指针会不会内存泄露，如何解决？" class="headerlink" title="2. 智能指针会不会内存泄露，如何解决？"></a>2. 智能指针会不会内存泄露，如何解决？</h4><blockquote>
<p>当两个对象相互使用一个<code>shared_ptr</code>成员变量指向对方，会造成循环引用，使引用计数失效，导致内存泄漏。</p>
<p>为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; Child)</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>-&gt;ChildPtr = Child;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ChildPtr.use_count)&#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ~Parent()&#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; parent)</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ParentPtr.use_count)&#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ~Child()&#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">  <span class="built_in">std</span>::weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">      p-&gt;setChild(c);</span><br><span class="line">      p-&gt;setParent(p);</span><br><span class="line">      wpp = p;</span><br><span class="line">      wpc = c;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;p.use_count() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;c.use_count() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;wpp.use_count() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;wpc.use_count() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，parent有一个shared_ptr类型的成员指向孩子，而child也有一个shared_ptr类型的成员指向父亲。然后在创建孩子和父亲对象时也使用了智能指针c和p，随后将c和p分别又赋值给child的智能指针成员parent和parent的智能指针成员child。从而形成了一个循环引用：</p>
</blockquote>
<h4 id="3-智能指针shared-ptr的实现"><a href="#3-智能指针shared-ptr的实现" class="headerlink" title="3. 智能指针shared_ptr的实现"></a>3. 智能指针<code>shared_ptr</code>的实现</h4><p>核心：要理解引用计数，什么时候销毁底层指针，还有赋值，拷贝构造时候的引用计数的变化，析构的时候要判断底层指针的引用计数为0了才能真正释放底层指针的内存</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     T *ptr;    <span class="comment">//底层真实的指针</span></span><br><span class="line">     <span class="keyword">int</span> *use_count;<span class="comment">//保存当前对象被多少指针引用计数</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     SmartPtr(T *p); <span class="comment">//SmartPtr&lt;int&gt;p(new int(2));</span></span><br><span class="line">     SmartPtr(<span class="keyword">const</span> SmartPtr&lt;T&gt;&amp;orig);<span class="comment">//SmartPtr&lt;int&gt;q(p);</span></span><br><span class="line">     SmartPtr&lt;T&gt;&amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr&lt;T&gt; &amp;rhs);<span class="comment">//q=p</span></span><br><span class="line">     ~SmartPtr();</span><br><span class="line">     T <span class="keyword">operator</span>*();  <span class="comment">//为了能把智能指针当成普通指针操作定义解引用操作</span></span><br><span class="line">     T*<span class="keyword">operator</span>-&gt;();  <span class="comment">//定义取成员操作</span></span><br><span class="line">     T* <span class="keyword">operator</span>+(<span class="keyword">int</span> i);<span class="comment">//定义指针加一个常数</span></span><br><span class="line">     <span class="keyword">int</span> <span class="keyword">operator</span>-(SmartPtr&lt;T&gt;&amp;t1,SmartPtr&lt;T&gt;&amp;t2);<span class="comment">//定义两个指针相减</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">getcount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *use_count &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> SmartPtr&lt;T&gt;::<span class="keyword">operator</span>-(SmartPtr&lt;T&gt; &amp;t1, SmartPtr&lt;T&gt; &amp;t2) &#123; <span class="keyword">return</span> t1.ptr-t2.ptr; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; SmartPtr&lt;T&gt;::SmartPtr(T *p) &#123; </span><br><span class="line">     ptr=p; </span><br><span class="line">     <span class="keyword">try</span> &#123; </span><br><span class="line">         use_count=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>); </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">         <span class="keyword">delete</span> ptr;    <span class="comment">//申请失败释放真实指针和引用计数的内存</span></span><br><span class="line">         ptr= <span class="literal">nullptr</span>; <span class="keyword">delete</span> use_count; use_count= <span class="literal">nullptr</span>; </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; SmartPtr&lt;T&gt;::SmartPtr(<span class="keyword">const</span> SmartPtr&lt;T&gt; &amp;orig)&#123;<span class="comment">//复制构造函数</span></span><br><span class="line">     use_count=orig.use_count;<span class="comment">//引用计数保存在一块内存，所有的SmarPtr对象的引用计数都指向这里</span></span><br><span class="line">     <span class="keyword">this</span>-&gt;ptr=orig.ptr;</span><br><span class="line">     ++(*use_count);<span class="comment">//当前对象的引用计数加1</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; SmartPtr&lt;T&gt;&amp; SmartPtr&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr&lt;T&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="comment">//重载=运算符，例如SmartPtr&lt;int&gt;p,q; p=q;这个语句中，首先给q指向的对象的引用计数加1，因为p重新指向了q所指的对象，所以p需要先给原来的对象的引用计数减1，如果减一后为0，先释放掉p原来指向的内存，然后讲q指向的对象的引用计数加1后赋值给p</span></span><br><span class="line">     ++*(rhs.use_count); </span><br><span class="line">     <span class="keyword">if</span>((--*(use_count))==<span class="number">0</span>) &#123; </span><br><span class="line">         <span class="keyword">delete</span> ptr; </span><br><span class="line">         ptr= <span class="literal">nullptr</span>; </span><br><span class="line">         <span class="keyword">delete</span> use_count; </span><br><span class="line">         use_count= <span class="literal">nullptr</span>; </span><br><span class="line">     &#125; </span><br><span class="line"> 	<span class="comment">//SmartPtr的对象会在其生命周期结束的时候调用其析构函数，在析构函数中检测当前对象的引用计数是不是只有正在结束生命周期的这个SmartPtr引用，如果是，就释放掉，如果不是，就还有其他的SmartPtr引用当前对象，就等待其他的SmartPtr对象在其生命周期结束的时候调用析构函数释放掉</span></span><br><span class="line">     ptr=rhs.ptr; </span><br><span class="line">     *use_count=*(rhs.use_count); </span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; SmartPtr&lt;T&gt;::~SmartPtr() &#123; </span><br><span class="line">     getcount(); </span><br><span class="line">     <span class="keyword">delete</span> ptr;</span><br><span class="line">     ptr= <span class="literal">nullptr</span>;</span><br><span class="line">     <span class="keyword">delete</span> use_count;</span><br><span class="line">     use_count=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;T SmartPtr&lt;T&gt;::<span class="keyword">operator</span>*()&#123;</span><br><span class="line">	<span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;T*  SmartPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T* SmartPtr&lt;T&gt;::<span class="keyword">operator</span>+(<span class="keyword">int</span> i)&#123;</span><br><span class="line">     T *temp=ptr+i;</span><br><span class="line">     <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="四-表达式与函数"><a href="#四-表达式与函数" class="headerlink" title="四 表达式与函数"></a>四 表达式与函数</h3><h4 id="1-fork函数"><a href="#1-fork函数" class="headerlink" title="1. fork函数"></a>1. fork函数</h4><blockquote>
<p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
</blockquote>
<h4 id="2-strcpy和strlen的区别"><a href="#2-strcpy和strlen的区别" class="headerlink" title="2. strcpy和strlen的区别"></a>2. strcpy和strlen的区别</h4><blockquote>
<p>strcpy是字符串拷贝函数，原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure>

<p>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。</p>
<p>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</p>
</blockquote>
<h4 id="3-写个函数在main函数前运行"><a href="#3-写个函数在main函数前运行" class="headerlink" title="3. 写个函数在main函数前运行"></a>3. 写个函数在main函数前运行</h4><blockquote>
<p> <a href="https://blog.csdn.net/qq_30968657/article/details/55049341" target="_blank" rel="noopener">使用<code>_attribute_</code>机制</a></p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__attribute((constructor))<span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before main\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>void main_enter() <strong>attribute</strong>((constructor)); //main_enter函数在进入main函数前调用<ul>
<li>void main_exit() <strong>attribute</strong>((destructor)); //main_exit函数在main函数返回后调用</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="4-内联函数的作用"><a href="#4-内联函数的作用" class="headerlink" title="4. 内联函数的作用"></a>4. 内联函数的作用</h4><blockquote>
<p><strong>内联函数inline：</strong>引入内联函数的目的是为了解决程序中函数调用的效率问题。</p>
<p>程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x &gt; y)? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max (20,10): "</span> &lt;&lt; Max(<span class="number">20</span>,<span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max (0,200): "</span> &lt;&lt; Max(<span class="number">0</span>,<span class="number">200</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max (100,1010): "</span> &lt;&lt; Max(<span class="number">100</span>,<span class="number">1010</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="5-C语言怎么进行函数调用？"><a href="#5-C语言怎么进行函数调用？" class="headerlink" title="5. C语言怎么进行函数调用？"></a>5. C语言怎么进行函数调用？</h4><blockquote>
<p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。</p>
</blockquote>
<h4 id="6-C语言参数压栈顺序？"><a href="#6-C语言参数压栈顺序？" class="headerlink" title="6. C语言参数压栈顺序？"></a>6. C语言参数压栈顺序？</h4><blockquote>
<p>从右到左</p>
</blockquote>
<h4 id="7-C-如何处理返回值？"><a href="#7-C-如何处理返回值？" class="headerlink" title="7. C++如何处理返回值？"></a>7. C++如何处理返回值？</h4><blockquote>
<p> 函数的返回值用于初始化在调用函数是创建的临时对象。</p>
<p> 1、返回值为非引用类型：</p>
<p> 会将函数的返回值复制给临时对象。跟实参初始化形参的方式一样。</p>
<p> 2、返回值为引用类型：</p>
<p> 没有复制返回值，返回的是对象本身。返回引用时，在函数的参数中要有以引用方式或指针方式传入的要返回的参数</p>
<p> 不能返回局部对象的引用。（因为函数执行结束，将释放分配给局部对象的存储空间，对局部对象的引用就会指向不确定的内存）</p>
</blockquote>
<h4 id="8-说说fork-wait-exec函数"><a href="#8-说说fork-wait-exec函数" class="headerlink" title="8. 说说fork,wait,exec函数"></a>8. 说说fork,wait,exec函数</h4><blockquote>
<p>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。</p>
<p>fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。</p>
<p>exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1</p>
</blockquote>
<h4 id="9-i和i-的区别"><a href="#9-i和i-的区别" class="headerlink" title="9. ++i和i++的区别"></a>9. ++i和i++的区别</h4><blockquote>
<p>++i先自增1，再返回，i++先返回i,再自增1</p>
<p>內建数据类型的时候，效率没有区别；</p>
<p>自定义数据类型的时候，++i的效率更高；</p>
</blockquote>
<p><strong>具体实现</strong></p>
<blockquote>
<p><strong>++i  实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;  <span class="keyword">int</span>::<span class="keyword">operator</span>++（）&#123;</span><br><span class="line">  *<span class="keyword">this</span> +=<span class="number">1</span>；</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>i++实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  <span class="keyword">int</span>::<span class="keyword">operator</span>（<span class="keyword">int</span>）&#123;</span><br><span class="line">  <span class="keyword">int</span> oldValue = *<span class="keyword">this</span>；</span><br><span class="line">  ++（*<span class="keyword">this</span>）；</span><br><span class="line">  <span class="keyword">return</span> oldValue；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="五-Volatile"><a href="#五-Volatile" class="headerlink" title="五 Volatile"></a>五 Volatile</h3><h4 id="1-关键字volatile的含义？"><a href="#1-关键字volatile的含义？" class="headerlink" title="1. 关键字volatile的含义？"></a>1. 关键字volatile的含义？</h4><blockquote>
<p>volatile表示该变量可能会被意向不到的改变，因此编译器不要去假设这个变量的值。</p>
<p>精确地说，优化器在用到这个变量时必须每次都去内存中读取这个变量的值，而不是使用保存在寄存器里的备份。</p>
<p>下面是<code>volatile</code>变量的几个例子：</p>
<ol>
<li>并列设备的硬件寄存器</li>
<li>一个终端服务子程序会访问到的非自动变量</li>
<li>多线程应用中被几个任务共享的变量</li>
</ol>
<p><a href="https://www.runoob.com/w3cnote/c-volatile-keyword.html" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h4 id="2-volatile的特性？"><a href="#2-volatile的特性？" class="headerlink" title="2. volatile的特性？"></a>2. volatile的特性？</h4><blockquote>
<p> volatile 可以保证对特殊地址的稳定访问</p>
<p> 三个特性</p>
<ol>
<li>易变性。易变性在汇编层面，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。</li>
<li>“不可优化”性。volatile告诉编译器，不要这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。</li>
<li>”顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。</li>
</ol>
</blockquote>
<h4 id="3-为什么Volatile不能保证原子性"><a href="#3-为什么Volatile不能保证原子性" class="headerlink" title="3. 为什么Volatile不能保证原子性"></a>3. 为什么Volatile不能保证原子性</h4><p>volatile可以保证可见性和顺序性，但不能保证原子性</p>
<h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a><strong>可见性</strong></h5><blockquote>
<p>volatile保证了变量的可见性，变量经过volatile修饰后，对此变量进行写操作时，汇编指令中会有一个LOCK前缀指令，这个不需要过多了解，但是加了这个指令后，会引发两件事情：</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存</li>
<li>这个写回内存的操作会使得在其他处理器缓存了该内存地址无效</li>
</ul>
<p>什么意思呢？意思就是说<strong>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值，这就保证了可见性。</strong></p>
</blockquote>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><blockquote>
<p>问题来了，既然它可以保证修改的值立即能更新到主存，其他线程也会捕捉到被修改后的值，那么为什么不能保证原子性呢？<br>首先需要了解的是，Java中只有对基本类型变量的赋值和读取是原子操作，如i = 1的赋值操作，但是像j = i或者i++这样的操作都不是原子操作，因为他们都进行了多次原子操作，比如先读取i的值，再将i的值赋值给j，两个原子操作加起来就不是原子操作了。</p>
<p>所以，如果一个变量被volatile修饰了，那么肯定可以保证每次读取这个变量值的时候得到的值是最新的，但是一旦需要对变量进行自增这样的非原子操作，就不会保证这个变量的原子性了。</p>
</blockquote>
<h4 id="4-mutable关键字"><a href="#4-mutable关键字" class="headerlink" title="4. mutable关键字"></a>4. mutable关键字</h4><blockquote>
<ol>
<li>在类中修饰成员变量，当成员函数被const修饰时，可以在const函数中修改该变量的值</li>
<li>在Lambda表达式中，<strong>按值捕获</strong>（值传递）时，不可以在匿名函数体内部修改该值，当<code>[]()mutable{}</code>时可以在函数体内部进行修改，但是不会修改外部的数值</li>
</ol>
</blockquote>
<blockquote>
<p>在C++中，mutable是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中，甚至结构体变量或者类对象为const，其mutable成员也可以被修改。mutable在类中只能够修饰非静态数据成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">mutable</span> <span class="keyword">int</span> a;</span><br><span class="line">     <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">     test(<span class="keyword">int</span> _a,<span class="keyword">int</span> _b) :a(_a),b(_b)&#123;&#125;;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">const</span>            <span class="comment">//fun是const 函数，不能修改类的对象的数据成员，但由于a被mutable修饰，可以修改，但不能修改b</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">           a += b;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">","</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被<code>mutatle</code>来修饰。</p>
</blockquote>
<h3 id="六-异常处理"><a href="#六-异常处理" class="headerlink" title="六 异常处理"></a>六 异常处理</h3><blockquote>
<p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>
<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<ul>
<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>
<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>
<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>
</ul>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。</p>
<p>用 try/catch 语句的语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName e1 )&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName e2 )&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName eN )&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出异常</p>
<p>您可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">"Division by zero condition!"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捕获异常</p>
<p>catch 块跟在 try 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;   </span><br><span class="line">    <span class="comment">// 保护代码 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName e ) &#123;</span><br><span class="line">    <span class="comment">// 处理 ExceptionName 异常的代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码会捕获一个类型为 <strong>ExceptionName</strong> 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;   </span><br><span class="line">    <span class="comment">// 保护代码 </span></span><br><span class="line">&#125;<span class="keyword">catch</span>(...) &#123;  </span><br><span class="line">    <span class="comment">// 能处理任何异常的代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="七-其它操作"><a href="#七-其它操作" class="headerlink" title="七 其它操作"></a>七 其它操作</h3><blockquote>
<p>对输入流操作：seekg（）与tellg（）</p>
<p>对输出流操作：seekp（）与tellp（） seekg（）是对输入文件定位，它有两个参数：第一个参数是偏移量，第二个参数是基地址。 </p>
<p>对于第一个参数，可以是正负数值，正的表示向后偏移，负的表示向前偏移。而第二个参数可以是： ios：：beg：表示输入流的开始位置 ios：：cur：表示输入流的当前位置 ios：：end：表示输入流的结束位置 tellg（）函数不需要带参数，它返回当前定位指针的位置，也代表着输入流的大小。</p>
</blockquote>
<h2 id="二-类与数据抽象"><a href="#二-类与数据抽象" class="headerlink" title="二 类与数据抽象"></a>二 类与数据抽象</h2><h3 id="一-类"><a href="#一-类" class="headerlink" title="一  类"></a>一  类</h3><h4 id="1-若类里面有static、virtual等，类的内存如何分布"><a href="#1-若类里面有static、virtual等，类的内存如何分布" class="headerlink" title="1. 若类里面有static、virtual等，类的内存如何分布"></a>1. 若类里面有static、virtual等，类的内存如何分布</h4><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470920741_7D40CEF3951A10F626301148E06D89DA" alt="img"></p>
<blockquote>
<h4 id="1、static修饰符"><a href="#1、static修饰符" class="headerlink" title="1、static修饰符"></a>1、static修饰符</h4><blockquote>
<p>1）static修饰成员变量</p>
<p>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。</p>
<p>因为静态数据成员在<strong>全局数据区</strong>分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。</p>
<p>2）static修饰成员函数</p>
<p>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。</p>
<p>Static修饰的成员函数，在<strong>代码区</strong>分配内存。</p>
</blockquote>
<h4 id="2、virtual修饰符"><a href="#2、virtual修饰符" class="headerlink" title="2、virtual修饰符"></a>2、virtual修饰符</h4><p>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。</p>
<p>如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着函数指针，函数指针指向代码段中的具体函数。</p>
<p>如果类中成员是virtual属性，会隐藏父类对应的属性。</p>
</blockquote>
<h4 id="2-类中的数据成员-static、const"><a href="#2-类中的数据成员-static、const" class="headerlink" title="2 类中的数据成员(static、const)"></a>2 类中的数据成员(static、const)</h4><h5 id="const-数据成员"><a href="#const-数据成员" class="headerlink" title="const 数据成员"></a><strong>const 数据成员</strong></h5><blockquote>
<p>const 数据成员在某个对象生存期内是常量，对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其 const 数据成员的值可以不同。</p>
<p>不能在类声明中初始化 const 数据成员，因为类的对象未被创建时，编译器不知道const 数据成员的值是什么。</p>
<p> const 数据成员的初始化只能在类的构造函数的初始化表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static const。</p>
</blockquote>
<h5 id="static-数据成员"><a href="#static-数据成员" class="headerlink" title="static 数据成员"></a><strong>static 数据成员</strong></h5><blockquote>
<p>static 数据成员目的是作为类作用域的全局变量，被类里的所有对象共享，即使没有创建任何对象，该成员也存在。</p>
<p>static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。</p>
<p>在类的内部只是声明，定义必须在类定义体的外部，并且不能在函数体内，通常在类外定义时初始化，或者使用静态函数初始化。</p>
<p>借用 gcc 的话：<em>ISO C++ forbids in-class initialization of non-const static member</em></p>
<p>注意：static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在编译时在静态数据区分配内存，到程序结束时才释放。</p>
</blockquote>
<h5 id="const-static-数据成员"><a href="#const-static-数据成员" class="headerlink" title="const static 数据成员"></a><strong>const static 数据成员</strong></h5><blockquote>
<p>const static 数据成员被一个类的所有对象共享，常量，可以在类内定义处初始化，也可以在类外初始化。</p>
</blockquote>
<h5 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a><strong>const 成员函数</strong></h5><blockquote>
<p>const 成员函数主要是防止修改对象的成员变量（mutable 修饰的成员变量，static 变量除外）。</p>
<p>即const成员函数不能修改成员变量的值，但可以访问成员变量。注意 const 成员函数只能保证不修改当前 this 指针所指的对象的成员变量，若通过参数传递进来有别的对象名，是可以修改其成员变量的，还有就是在 const 成员函数里通过 const_cast 移除 *this 的 const 特性后调用一些非 const 成员函数也有可能会改变 *this 对象的成员变量，虽然这种做法其实是错误的。</p>
</blockquote>
<h5 id="static-成员函数"><a href="#static-成员函数" class="headerlink" title="static 成员函数"></a>static 成员函数</h5><blockquote>
<p>static成员函数主要目的是作为<strong>类作用域的全局函数</strong>，不能访问类的非静态数据成员。</p>
<p>类的静态成员函数没有this指针：</p>
<ol>
<li>静态成员函数可以直接访问类的静态数据和函数成员，而访问非静态成员必须通过参数传递的方式得到一个对象名，然后通过对象名来访问，与其不同的是非静态成员函数可以任意地（非）静态成员函数和（非）静态数据成员；</li>
<li>不能被声明为virtual。</li>
</ol>
</blockquote>
<h4 id="3-构造函数中的变量初始化顺序"><a href="#3-构造函数中的变量初始化顺序" class="headerlink" title="3 构造函数中的变量初始化顺序"></a>3 构造函数中的变量初始化顺序</h4><blockquote>
<p><strong>变量的初始化顺序</strong>就应该是：</p>
<p>1 基类的静态变量或全局变量</p>
<p>2 派生类的静态变量或全局变量</p>
<p>3 基类的成员变量</p>
<p>4 派生类的成员变量</p>
</blockquote>
<blockquote>
<ol>
<li>成员变量在使用初始化列表初始化时，<strong>与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关</strong>。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。这点在EffectiveC++中有详细介绍。</li>
<li>如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。</li>
<li><strong>注意：</strong>类成员在定义时，是不能初始化的</li>
<li><strong>注意：</strong>类中const成员常量必须在构造函数初始化列表中初始化。</li>
<li><strong>注意：</strong>类中static成员变量，必须在类外初始化。</li>
<li>静态变量进行初始化顺序是基类的静态变量先初始化，然后是它的派生类。直到所有的静态变量都被初始化。这里需要注意全局变量和静态变量的初始化是不分次序的。</li>
</ol>
</blockquote>
<h4 id="4-析构函数"><a href="#4-析构函数" class="headerlink" title="4 析构函数"></a>4 析构函数</h4><blockquote>
<p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数调用完毕时，系统会自动执行析构函数。</p>
<p>析构函数名应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>
<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>
<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>
</blockquote>
<p>析构函数的其它要点</p>
<blockquote>
<ol>
<li>与构造函数相对应</li>
<li>与构造函数的作用相反</li>
<li>析构函数的形式：~类名( ){…}特点：</li>
<li>固定的函数名称：~类名( )</li>
<li>没有返回类型</li>
<li>没有参数</li>
<li>不可以重载</li>
<li>一般由系统自动调用</li>
<li>当类中含有虚函数的时候，创建该类的对象时，该对象的首地址即为虚函数表的地址，无论对该对象进行怎样的类型转换，该对象都只能访问自己的虚函数表</li>
</ol>
</blockquote>
<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>
<h5 id="3-1-为什么析构函数必须是虚函数？而默认的析构函数不是虚函数？"><a href="#3-1-为什么析构函数必须是虚函数？而默认的析构函数不是虚函数？" class="headerlink" title="3.1. 为什么析构函数必须是虚函数？而默认的析构函数不是虚函数？"></a>3.1. 为什么析构函数必须是虚函数？而默认的析构函数不是虚函数？</h5><blockquote>
<p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<p>C++默认的析构函数不是虚函数是因为<strong>虚函数需要额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
</blockquote>
<h4 id="5-struct与class的区别"><a href="#5-struct与class的区别" class="headerlink" title="5 struct与class的区别"></a>5 struct与class的区别</h4><blockquote>
<p>C语言中，strcut只是一种复杂数据结构类型定义，struct只能定义成员变量，不能定义成员函数，不能使用面向对象编程。</p>
<p>C++中，如果没有标明成员函数或者成员变量的访问权限级别，那么在struct中默认的是public，而class中默认的是private；</p>
</blockquote>
<h4 id="6-C-中类成员的访问权限"><a href="#6-C-中类成员的访问权限" class="headerlink" title="6 C++中类成员的访问权限"></a>6 C++中类成员的访问权限</h4><blockquote>
<p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。</p>
<p>在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。</p>
<p>在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员</p>
</blockquote>
<h4 id="7-拷贝赋值函数的形参能否进行值传递？"><a href="#7-拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="7 拷贝赋值函数的形参能否进行值传递？"></a>7 拷贝赋值函数的形参能否进行值传递？</h4><blockquote>
<p>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。如此循环，无法完成拷贝，栈也会满。</p>
</blockquote>
<h4 id="8-This指针"><a href="#8-This指针" class="headerlink" title="8 This指针"></a>8 This指针</h4><blockquote>
<p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof（对象）的结果。this<a href="https://baike.baidu.com/item/作用域/10944767" target="_blank" rel="noopener">作用域</a>是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，<a href="https://baike.baidu.com/item/编译器/8853067" target="_blank" rel="noopener">编译器</a>会自动将对象本身的地址作为一个隐含<a href="https://baike.baidu.com/item/参数传递/9019335" target="_blank" rel="noopener">参数传递</a>给函数。</p>
</blockquote>
<h4 id="9-Sizeof-计算类的大小计算"><a href="#9-Sizeof-计算类的大小计算" class="headerlink" title="9 Sizeof() 计算类的大小计算"></a>9 Sizeof() 计算类的大小计算</h4><blockquote>
<ul>
<li>空类的大小为1字节</li>
<li>一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。</li>
<li>对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针vptr的大小。</li>
<li>普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小</li>
<li>虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！</li>
<li>虚继承, 继承基类的vptr。</li>
</ul>
</blockquote>
<h4 id="10-友元"><a href="#10-友元" class="headerlink" title="10 友元"></a>10 友元</h4><blockquote>
<p>友元提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员 的机制。也就是说有两种形式的友元：</p>
<p>（1）友元函数：普通函数对一个访问某个类中的私有或保护成员。</p>
<p>（2）友元类：类A中的成员函数访问类B中的私有或保护成员</p>
<p>优点：提高了程序的运行效率。</p>
<p>缺点：破坏了类的封装性和数据的透明性。</p>
<p>总结： - 能访问私有成员 - 破坏封装性 - 友元关系不可传递 - 友元关系的单向性 - 友元声明的形式及数量不受限制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="title">function</span><span class="params">(...)</span></span>;</span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> class <span class="title">B::memberfunction</span><span class="params">(...)</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为友元函数没有this指针，则参数要有三种情况： </p>
<ol>
<li>要访问非static成员时，需要对象做参数；</li>
<li>要访问static成员或全局变量时，则不需要对象做参数；</li>
<li>如果做参数的对象是全局对象，则不需要对象做参数.</li>
<li>可以直接调用友元函数，不需要通过对象或指针</li>
</ol>
<p>样例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">INTEGER</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> INTEGER&amp; obj)</span></span>;<span class="comment">//声明友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> INTEGER&amp; obj）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//函数体</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> main()&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    INTEGER obj;</span></span></span><br><span class="line"><span class="function"><span class="params">    Print(obj);<span class="comment">//直接调用</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="二-继承"><a href="#二-继承" class="headerlink" title="二 继承"></a>二 继承</h3><blockquote>
<p>多继承（Multiple Inheri<a href="http://c.biancheng.net/ref/tan.html" target="_blank" rel="noopener">tan</a>ce）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。</p>
<p>多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承。</p>
</blockquote>
<h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><blockquote>
<p>为了解决多继承时的命名冲突和冗余数据问题，<a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a> 提出了虚继承，使得在派生类中只保留一份间接基类的成员。</p>
<p>在继承方式前面加上 virtual 关键字就是虚继承。</p>
<p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p>
</blockquote>
<h3 id="三-多态"><a href="#三-多态" class="headerlink" title="三 多态"></a>三 多态</h3><blockquote>
<p>要点： 当类中含有虚函数的时候，创建该类的对象时，该对象的首地址即为虚函数表的地址，无论对该对象进行怎样的类型转换，该对象都只能访问自己的虚函数表</p>
<p>C++多态分为静态多态和动态多态。</p>
<blockquote>
<p>静态多态是通过重载和模板技术实现，在编译的时候确定。</p>
<p>动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。</p>
</blockquote>
<p>动态多态实现有几个条件：</p>
<blockquote>
<p>(1) 虚函数；</p>
<p>(2) 一个基类的指针或引用指向派生类的对象；</p>
</blockquote>
<p>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。</p>
<p>虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。</p>
<p>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象都指向这同一个虚函数表。</p>
<p>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。</p>
</blockquote>
<h4 id="1-多态及其作用"><a href="#1-多态及其作用" class="headerlink" title="1. 多态及其作用"></a>1. 多态及其作用</h4><blockquote>
<p>同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。</p>
<p>简单的说就是用基类的引用指向子类的对象。</p>
</blockquote>
<h4 id="2-虚函数和多态的区别"><a href="#2-虚函数和多态的区别" class="headerlink" title="2. 虚函数和多态的区别"></a>2. 虚函数和多态的区别</h4><blockquote>
<p>多态主要分为<strong>静态多态</strong>和<strong>动态多态</strong></p>
<blockquote>
<p>静态多态主要是<strong>重载</strong>，在编译的时候就已经确定；</p>
<p>动态多态是用<strong>虚函数机制</strong>实现的，在运行期间动态绑定。</p>
<p>举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。</p>
</blockquote>
<p><strong>虚函数</strong>的实现</p>
<blockquote>
<p>在有虚函数的类中，类的头部是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
</blockquote>
</blockquote>
<h4 id="3-重载和覆盖（重写）的区别"><a href="#3-重载和覆盖（重写）的区别" class="headerlink" title="3. 重载和覆盖（重写）的区别"></a>3. 重载和覆盖（重写）的区别</h4><blockquote>
<p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中<br>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>
</blockquote>
<blockquote>
<p>重载是编写一个与已有函数同名但是参数表不同的方法，具有如下特征：</p>
<blockquote>
<p>（1）方法名必须相同</p>
<p>（2）参数列表必须不同，与参数列表的顺序无关</p>
<p>（3）返回值类型可以不相同。</p>
</blockquote>
<p>重写是派生类重写基类的虚函数</p>
<blockquote>
<p>（1）只有虚函数和抽象方法才能被重写</p>
<p>（2）相同的函数名</p>
<p>（3）相同的参数列表</p>
<p>（4）相同的返回值类型</p>
</blockquote>
</blockquote>
<blockquote>
<p>重载是一种语法规则，由编译器在编译阶段完成，不属于面向对象的编程；</p>
<p>而重写是由运行阶段决定的，是面向对象编程的重要特征</p>
</blockquote>
<h4 id="4-虚函数表怎样实现运行时多态"><a href="#4-虚函数表怎样实现运行时多态" class="headerlink" title="4. 虚函数表怎样实现运行时多态?"></a>4. 虚函数表怎样实现运行时多态?</h4><blockquote>
<p>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换。</p>
<p>对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</p>
</blockquote>
<p>其它点：</p>
<blockquote>
<ul>
<li>虚函数表属于类，类的所有对象共享这个类的虚函数表。</li>
<li>不同对象虚函数表是一样的（虚函数表的第一个函数地址相同）；</li>
<li>每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象的vptr的存放地址都不一样，但是都指向同一虚函数表。</li>
</ul>
</blockquote>
<h4 id="5-虚函数与纯虚函数的区别"><a href="#5-虚函数与纯虚函数的区别" class="headerlink" title="5. 虚函数与纯虚函数的区别"></a>5. 虚函数与纯虚函数的区别</h4><ol>
<li>虚函数与纯虚函数 在他们的子类中都可以被重写.它们的区别是：</li>
</ol>
<blockquote>
<p>（1）纯虚函数只有定义,没有实现；而虚函数既有定义,也有实现的代码；纯虚函数一般没有代码实现部分，如  virtual void print() = 0;  </p>
<p>，而一般虚函数必须要有代码的实现部分，否则会出现函数未定义的错误。</p>
<p>（2）包含纯虚函数的类不能定义其对象,而包含虚函数的则可以.</p>
</blockquote>
<ol start="2">
<li>虚函数的引入主要是为了实现多态</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		a()&#123;      <span class="comment">//构造函数用内联函数的形式 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//虚函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span>  <span class="keyword">void</span>  <span class="title">xhs</span><span class="params">()</span></span>&#123;   	   <span class="comment">//这个虚函数必须得在基类中实现 </span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"我是基类的虚函数"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//即使是空的虚函数也要在基类中实现 </span></span><br><span class="line">		&#125;  <span class="comment">//派生类中可以不写这个函数，但是派生类对象调用时会调用积累的虚函数 	</span></span><br><span class="line">		<span class="comment">//纯虚函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cxhs</span><span class="params">()</span> </span>=<span class="number">0</span>;  <span class="comment">//这个纯虚函数不在基类中实现，必须在子类中实现 </span></span><br><span class="line">		</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="6-虚函数可以是内联函数吗？"><a href="#6-虚函数可以是内联函数吗？" class="headerlink" title="6. 虚函数可以是内联函数吗？"></a>6. 虚函数可以是内联函数吗？</h4><blockquote>
<ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
</blockquote>
<h4 id="7-静态函数和虚函数的区别"><a href="#7-静态函数和虚函数的区别" class="headerlink" title="7.  静态函数和虚函数的区别"></a>7.  静态函数和虚函数的区别</h4><blockquote>
<p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。</p>
<p>虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</p>
</blockquote>
<h2 id="三-模板与泛型编程"><a href="#三-模板与泛型编程" class="headerlink" title="三 模板与泛型编程"></a>三 模板与泛型编程</h2><h3 id="1-什么是右值引用，跟左值的区别？"><a href="#1-什么是右值引用，跟左值的区别？" class="headerlink" title="1. 什么是右值引用，跟左值的区别？"></a>1. 什么是右值引用，跟左值的区别？</h3><blockquote>
<p>右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。</p>
<p>主要目的有两个方面：</p>
<ol>
<li><p><strong>消除两个对象交互时不必要的对象拷贝</strong>，节省运算存储资源，提高效率。</p>
</li>
<li><p>能够更简洁明确地定义泛型函数。</p>
</li>
</ol>
<h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><ul>
<li>左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。</li>
<li>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</li>
</ul>
<h4 id="右值和左值的区别"><a href="#右值和左值的区别" class="headerlink" title="右值和左值的区别"></a>右值和左值的区别</h4><ol>
<li>左值可以寻址，而右值不可以。</li>
<li>左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。</li>
<li>左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）</li>
</ol>
</blockquote>
<h3 id="2-左值引用与右值引用。什么情况下使用右值引用"><a href="#2-左值引用与右值引用。什么情况下使用右值引用" class="headerlink" title="2. 左值引用与右值引用。什么情况下使用右值引用"></a>2. <a href="https://guodong.plus/2020/0307-190855/" target="_blank" rel="noopener">左值引用与右值引用</a>。什么情况下使用右值引用</h3><blockquote>
<p>要了解什么情况下使用右值引用，我们就要先了充分了解右值的特性。</p>
<p>首先与左值不同，右值是非常短暂的，它要么是字面常量，要么是在表达式求值过程中创建的临时对象。由于这样的特性我们可以总结：</p>
<ul>
<li>所引用的对象将要被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p>这就意味着，使用右值引用的代码可以自由的接管被引用对象的资源。</p>
</blockquote>
<blockquote>
<p>需要注意的是，所有的变量都是左值，我们不能将一个右值引用绑定到一个右值引用类型的变量上。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int &amp;&amp;rr1 &#x3D; 42;   &#x2F;&#x2F; 正确：字面量是右值</span><br><span class="line">int &amp;&amp;rr2 &#x3D; rr1;  &#x2F;&#x2F; 错误：rr1 是变量，虽然他是右值引用，但任然是左值Copy</span><br></pre></td></tr></table></figure>

<p>可以这样理解：变量 rr1 是持久的，它不会像字面值 42 那样转瞬即逝，所以它是左值。这就引出了下面两个主题：移动、转发。<br>[点击标题可以细看]</p>
</blockquote>
<h3 id="3-泛型算法"><a href="#3-泛型算法" class="headerlink" title="3. 泛型算法"></a>3. 泛型算法</h3><blockquote>
<p>只读算法：accumulate、count、equal；</p>
<p>写算法：fill、fill_n、back_inserter、copy;</p>
<p>重排：sort；unique(去掉重复元素); erase(真正的删除一个元素);</p>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span>&#123;</span><br><span class="line">    sort(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> end_unique = unique(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">    words.erase(end_unique,words.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-Lambda表达式"><a href="#4-Lambda表达式" class="headerlink" title="4. Lambda表达式"></a>4. Lambda表达式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 匿名lambda表达式</span></span><br><span class="line">sort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), [](<span class="built_in">string</span> a, <span class="built_in">string</span> b) &#123;</span><br><span class="line">     <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.具名lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> lam = [](<span class="built_in">string</span> a, <span class="built_in">string</span> b) &#123;</span><br><span class="line">     <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line"> &#125;;</span><br><span class="line">sort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), lam);;</span><br></pre></td></tr></table></figure>



<h3 id="5-模板"><a href="#5-模板" class="headerlink" title="5. 模板"></a>5. 模板</h3><blockquote>
<p>函数模板是一种抽象的函数定义，代表一类同构函数。</p>
<p>类模板是一种更高层次的抽象的类定义，用于使用相同代码创建不同的类。</p>
<p>函数模板的实例化是由编译程序在处理函数调用自动完成的，而类模板的实例化必须由程序员在程序中显式指定。</p>
</blockquote>
<h4 id="模板的缺点"><a href="#模板的缺点" class="headerlink" title="模板的缺点"></a>模板的缺点</h4><blockquote>
<p>不当的使用模板会导致代码膨胀，即二进制代码臃肿松散，会严重影响程序的运行效率</p>
<p>解决方法，把C++模板中与参数无关的代码分离出来</p>
</blockquote>
<h2 id="四-STL-标准模板库"><a href="#四-STL-标准模板库" class="headerlink" title="四 STL 标准模板库"></a>四 STL 标准模板库</h2><h3 id="0-STL基本组成"><a href="#0-STL基本组成" class="headerlink" title="0 STL基本组成"></a>0 STL基本组成</h3><blockquote>
<p>STL主要核心分为三大部分：容器（container）、算法（algorithm）和迭代器（iterator），另外还有容器适配器（container adaptor）和函数对象（functor）等其它标准组件。</p>
<p>其中的关系：</p>
<ol>
<li>分配器给容器分配存储空间；</li>
<li>算法通过迭代器获取容器中的内容；</li>
<li>仿函数可以协助算法完成各种操作；</li>
<li>配接器用来套接适配仿函数；</li>
</ol>
<p>STL算法部分主要由头文件<algorithm>,<numeric>,<functional>组成。要使用 STL中的算法函数必须包含头文件<algorithm>，对于数值算法须包含<numeric>，<functional>中则定义了一些模板类，用来声明函数对象。</functional></numeric></algorithm></functional></numeric></algorithm></p>
</blockquote>
<h3 id="1-分配器（allocator）"><a href="#1-分配器（allocator）" class="headerlink" title="1 分配器（allocator）"></a>1 分配器（allocator）</h3><blockquote>
<p><strong>STL的分配器用于封装STL容器在内存管理上的底层细节</strong>。</p>
<p>作用：分配内存和释放；构造和析构对象。</p>
<p>C++中的内存配置和释放过程如下：</p>
<ul>
<li><strong>new运算</strong>分两个阶段：(1)调用::operator new配置内存; (2)调用对象构造函数</li>
<li><strong>delete运算</strong>分两个阶段：(1)调用对象希构函数；(2)调用::operator delete释放内存</li>
</ul>
<p>而 STL allocator 将两个阶段操作分开：</p>
<ul>
<li>内存配置由alloc::allocate()负责，内存释放由alloc::deallocate()负责；</li>
<li>对象构造由::construct()负责，对象析构由::destroy()负责。</li>
</ul>
<p>为了提升内存管理效率，减少申请小内存造成的内存碎片问题，SGI STL中的<code>Allocator</code>采用了两级配置器</p>
<ol>
<li>当分配的空间大于128B时，使用第一级空间配置器；</li>
<li>当分配的空间小于128B时，使用第二级空间配置器。</li>
</ol>
<p>其中</p>
<ul>
<li><p>第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放;</p>
</li>
<li><p>第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。存在一个内存空间管理的链表，长度为16，分别指向内存大小为8、16…128字节大小的内存块，从内存链表上取所需内存向上扩充的内存块以供使用</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>以如下过程为例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A *a=<span class="keyword">new</span> A()</span><br></pre></td></tr></table></figure>

<ol>
<li>调用operator new分配一段内存</li>
<li>在这块内存上调用构造函数分配一个对象</li>
</ol>
<h5 id="1-operator-new"><a href="#1-operator-new" class="headerlink" title="1 operator new"></a>1 operator new</h5><p><code>operator new</code>是一个操作符，该操作符可以进行重载。</p>
<p>在<code>Allocator</code>这个模板类上，存在一组构造函数，该构造函数会调用<code>allocate</code>这个函数去分配内存。</p>
<ol>
<li><code>allocate</code>调用<code>operator new</code></li>
<li><code>operator new</code>再根据类型、元素个数去调用<code>malloc</code></li>
</ol>
<h5 id="2-在内存上调用构造函数"><a href="#2-在内存上调用构造函数" class="headerlink" title="2 在内存上调用构造函数"></a>2 在内存上调用构造函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> (p) T(value);</span><br></pre></td></tr></table></figure>

<ol>
<li>这里的<code>new</code>是一个<code>replacement new</code> ，意思是在<code>p</code>所指的内存空间上构造对象</li>
<li><code>T</code>是类名，也是构造函数名</li>
</ol>
<p>使用完毕的析构过程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先，在指定内存上调用析构内存释放对象</li>
<li>调用<code>operator delete</code>释放内存空间</li>
</ol>
<h5 id="3-operator-delete"><a href="#3-operator-delete" class="headerlink" title="3 operator delete"></a>3 operator delete</h5><p><code>operator delete</code>是一个可以重载的操作符，负责释放内存</p>
<ol>
<li>在<code>Allocator</code>中存在<code>deallocate</code>函数，该函数调用<code>operator delete</code></li>
<li><code>operator delete</code>会调用<code>free</code>进行内存释放</li>
</ol>
<h5 id="4-析构函数的调用"><a href="#4-析构函数的调用" class="headerlink" title="4 析构函数的调用"></a>4 析构函数的调用</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span></span>&#123;</span><br><span class="line">	p-&gt;~T();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据指针调用析构函数即可</p>
</blockquote>
<h3 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2  迭代器"></a>2  迭代器</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h4><blockquote>
<p>Iterator（迭代器）又称Cursor（游标），提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p>
<p>换个说法：Iterator是运用于聚合对象的一种模式，通过该模式，我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p>由于Iterator模式的以上特性：与聚合对象耦合，一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。</p>
<p>在不同容器的不同使用场景中，迭代器的种类和用途各不相同，因此，算法需要先来<strong>推导出迭代器类型，即萃取技术</strong></p>
<p>萃取技术用到<strong>模板偏特化</strong></p>
</blockquote>
<blockquote>
<p>迭代器是指向节点的指针，有如下操作</p>
<ol>
<li>前向查询 –</li>
<li>后向查询 ++</li>
<li>解引用</li>
<li>指针指向</li>
</ol>
</blockquote>
<blockquote>
<p>在迭代器中存储的有四个信息</p>
<ol>
<li><code>cur</code> 在当前缓冲区中的位置</li>
<li><code>first</code> 当前缓冲区中的第一个位置</li>
<li><code>last</code> 当前缓冲区中的最后一个位置</li>
<li><code>node</code> 指向当前当前缓冲区的map中的节点</li>
</ol>
</blockquote>
<h4 id="2-迭代器和指针的区别"><a href="#2-迭代器和指针的区别" class="headerlink" title="2 迭代器和指针的区别"></a>2 迭代器和指针的区别</h4><blockquote>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、–等。</p>
<p>迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p>迭代器返回的是对象引用而不是对象的值，所以<strong>cout只能输出迭代器使用*取值后的值而不能直接输出其自身</strong>。</p>
</blockquote>
<h4 id="3-迭代器产生原因"><a href="#3-迭代器产生原因" class="headerlink" title="3 迭代器产生原因"></a>3 迭代器产生原因</h4><blockquote>
<p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
</blockquote>
<h4 id="4-用迭代器删除元素"><a href="#4-用迭代器删除元素" class="headerlink" title="4 用迭代器删除元素"></a>4 用迭代器删除元素</h4><blockquote>
<ol>
<li><p>对于序列容器vector、deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;  <span class="comment">//容器删除元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span> (iter = val.begin(); iter != val.end();)&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">3</span> == *iter)  </span><br><span class="line">          iter = val.erase(iter);     <span class="comment">//返回下一个有效的迭代器，无需+1  </span></span><br><span class="line">     <span class="keyword">else</span>  </span><br><span class="line">          ++iter;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>对于关联容器map, set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的迭代器，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; valset = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;  </span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;  </span><br><span class="line"><span class="keyword">for</span> (iter = valset.begin(); iter != valset.end(); ) &#123;  </span><br><span class="line">     <span class="keyword">if</span> (<span class="number">3</span> == *iter)  </span><br><span class="line">          valset.erase(iter++);  </span><br><span class="line">     <span class="keyword">else</span>  </span><br><span class="line">          ++iter;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。</li>
</ol>
</blockquote>
<h5 id="5-迭代器失效的情况"><a href="#5-迭代器失效的情况" class="headerlink" title="5 迭代器失效的情况"></a>5 迭代器失效的情况</h5><blockquote>
<h6 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h6><ol>
<li>对于<code>vector</code>和<code>string</code>是连续空间，如果容器内存被重新分配，全部迭代器失效；否则，插入位置前的迭代器有效，插入位置后的迭代器失效</li>
<li>对于<code>deque</code>，如果插入点是<code>front</code>或<code>back</code>时，deque的迭代器失效，但<code>reference</code>和<code>pointer</code>有效；否则，全部失效</li>
<li>对于<code>list</code>和<code>forward_list</code>，所有的迭代器有效</li>
</ol>
<h6 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h6><ol>
<li>对于<code>vector</code>和<code>string</code>，删除位置前的迭代器有效，后面的无效</li>
<li>对于<code>deque</code>，如果删除点位于除<code>front</code>和<code>back</code>之外的其他位置，迭代器失效（移动）；否则，其余元素有效</li>
<li>对于<code>list</code>和<code>forward_list</code>所有的迭代器有效</li>
<li>对于<code>map</code>来说，如果一个元素被删除，其对应的迭代器失效</li>
</ol>
</blockquote>
<h3 id="3-容器"><a href="#3-容器" class="headerlink" title="3 容器"></a>3 容器</h3><p>容器主要包括顺序容器、关联容器、无序容器</p>
<h4 id="1-顺序容器"><a href="#1-顺序容器" class="headerlink" title="1 顺序容器"></a>1 顺序容器</h4><table>
<thead>
<tr>
<th>名称</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>模拟的数据结构式动态数组，在内存中是连续储存的，支持随机存取，支持在尾部快速插入和删除元素，搜索速度较慢</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列，在内存中的储存方式是小片连续，每片之间用链表连接起来，支持随机存取，支持在头部和尾部快速插入和删除元素，搜索速度较慢</td>
</tr>
<tr>
<td>list</td>
<td>称为双向链表，在内存中的储存是不连续的，每个元素的内存之间用指针相连，不支持随机存取（因为要从首或尾遍历至指定位置），但是支持在任意位置快速插入和删除元素，搜索速度最慢，扩展内存时无需复制和拷贝原元素</td>
</tr>
<tr>
<td>array</td>
<td>称为静态数组，在内存中是连续储存的，支持随机存取，不支持插入或删除元素</td>
</tr>
<tr>
<td>forward_list</td>
<td>称为前向链表，在内存中的储存是不连续的，同list一样支持在任意位置快速插入和删除元素，不支持随机存取，搜索速度也较慢，与list最大的区别在于其只能从头部遍历至尾部，不能反向遍历，因此没有保存后向指针，比list更省内存，插入和删除元素比list稍慢。</td>
</tr>
</tbody></table>
<h5 id="vector和list"><a href="#vector和list" class="headerlink" title="vector和list"></a>vector和list</h5><table>
<thead>
<tr>
<th align="center"></th>
<th align="left">Vector</th>
<th align="left">List</th>
</tr>
</thead>
<tbody><tr>
<td align="center">概念</td>
<td align="left">连续存储的容器，动态数组<br>在堆上分配空间</td>
<td align="left">动态链表<br>在堆上分配空间</td>
</tr>
<tr>
<td align="center">底层实现</td>
<td align="left">数组</td>
<td align="left">双向链表</td>
</tr>
<tr>
<td align="center">访问性能</td>
<td align="left">支持随机访问，O(1)</td>
<td align="left">不支持随机访问<br>随机访问性能很差<br>只能快速访问头尾节点。</td>
</tr>
<tr>
<td align="center">插入性能</td>
<td align="left">在最后插入（空间够）：很快<br>在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。<br>在中间插入（空间够）：内存拷贝<br>在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</td>
<td align="left">很快，一般是常数开销<br>每插入一个元数都会分配空间，<br>每删除一个元素都会释放空间。</td>
</tr>
<tr>
<td align="center">删除性能</td>
<td align="left">在最后删除：很快<br>在中间删除：内存拷贝</td>
<td align="left">很快，一般是常数开销</td>
</tr>
<tr>
<td align="center">适用场景</td>
<td align="left">经常随机访问，且不经常对非尾节点进行插入删除。</td>
<td align="left">经常插入删除大量数据</td>
</tr>
</tbody></table>
<p><strong>区别</strong></p>
<blockquote>
<p>1）vector底层实现是数组；list是双向链表。</p>
<p>2）vector支持随机访问，list不支持。</p>
<p>3）vector是顺序内存，list不是。</p>
<p>4）vector在中间节点进行插入删除会导致内存拷贝，list不会。</p>
<p>5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</p>
<p>6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</p>
</blockquote>
<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><blockquote>
<p>list使用一个双向链表来管理元素，list的内部结构和vector或deque截然不同，以下在主要方面与前述二者存在明显区别：</p>
<ul>
<li>list不支持随机存取</li>
<li>任何位置执行元素的安插和删除都非常快，始终是在常数时间内完成</li>
<li>对异常处理，要么成功，要么什么都不发生</li>
<li>由于不支持随机存储，既不提供下标操作符，也不提供at()</li>
<li>并未提供容量、空间重新分配等操作函数</li>
<li>提供不少成员 函数用于移动函数。</li>
</ul>
<p>List 是<strong>带头结点的</strong>双向循环链表，头结点本身是end()迭代器，同时，头结点是链表中唯一的元素</p>
<p>链表的优势是：元素的插入与删除是常数时间的</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>首部</td>
<td><code>push_front  emplace_front  pop_front   front</code></td>
</tr>
<tr>
<td>尾部</td>
<td><code>push_back   emplace_back   pop_back   back</code></td>
</tr>
<tr>
<td>任意位置</td>
<td><code>emplace</code>在迭代器指定的位置处构造元素并插入<br><code>insert</code>在指定的迭代器之前进行操作<br><code>erase</code></td>
</tr>
</tbody></table>
<p>其它操作</p>
<ol>
<li><code>remove  remova_if</code> 前者删除等于输入参数的全部节点，后者根据谓词条件进行删除</li>
<li><code>unique</code> 删除重复元素；同时可以传入二元谓词，来根据条件删除</li>
<li><code>sort</code> 链表的排序函数，默认是字典序增大的方向，可以自己传入函数指针</li>
<li><code>merge  reverse</code></li>
</ol>
</blockquote>
<h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><blockquote>
<p>vector是内存空间可动态变化的连续空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> _<span class="title">Ax</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">        :</span> <span class="keyword">public</span> _Vector_val&lt;_Ty, _Ax&gt;</span><br><span class="line">&#123;   <span class="comment">// varying size array of values</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/********/</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    pointer _Myfirst;<span class="comment">//pointer to beginning of array</span></span><br><span class="line">    pointer _Mylast;<span class="comment">// pointer to current end of sequence</span></span><br><span class="line">    pointer _Myend; <span class="comment">// pointer to end of array</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>维护了三个变量</p>
<ol>
<li><code>_Myfirst</code></li>
<li><code>_Mylast</code></li>
<li><code>_Myend</code></li>
</ol>
<p>在vector中与大小相关的属性有：当前元素个数，容器的容量，分别可以通过上述三个变量求得</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>=_Mylast-_Myfirst;<span class="comment">//已使用空间</span></span><br><span class="line">capcity=_Myend-_Myfirst;<span class="comment">//未使用空间</span></span><br></pre></td></tr></table></figure>

<p><strong>构造相关</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ector&lt;Elem&gt; c</span><br><span class="line"><span class="built_in">vector</span> &lt;Elem&gt; c1(c2)</span><br><span class="line"><span class="built_in">vector</span> &lt;Elem&gt; c(n)</span><br><span class="line"><span class="built_in">vector</span> &lt;Elem&gt; c(n, elem)</span><br><span class="line"><span class="built_in">vector</span> &lt;Elem&gt; c(beg,<span class="built_in">end</span>)</span><br><span class="line">c.~ <span class="built_in">vector</span> &lt;Elem&gt;()</span><br></pre></td></tr></table></figure>

<p><strong>插入、删除、赋值</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.push_back(elem)</span><br><span class="line">c.pop_back()</span><br><span class="line">c.insert(pos,elem)</span><br><span class="line">c.insert(pos,n,elem)</span><br><span class="line">c.insert(pos,beg,<span class="built_in">end</span>)</span><br><span class="line">c.erase(pos)</span><br><span class="line">c.erase(beg,<span class="built_in">end</span>)</span><br><span class="line">c.<span class="built_in">clear</span>()</span><br><span class="line">c.assign(beg,<span class="built_in">end</span>)</span><br><span class="line">c.assign(n,elem)</span><br></pre></td></tr></table></figure>

<p><strong>大小相关</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c.capacity()</span><br><span class="line">c.max_size()</span><br><span class="line">c.resize(num)</span><br><span class="line">c.reserve()</span><br><span class="line">c.size()</span><br></pre></td></tr></table></figure>

</blockquote>
<h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><blockquote>
<p>C++中数组是一种内置的数据类型。数组是存放类型相同的对象的容器，数组的大小确定不变，不能随意向数组中增加元素。</p>
<ol>
<li><p>元素在内存中连续存放，每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。</p>
</li>
<li><p>插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。</p>
</li>
<li><p>随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。</p>
</li>
<li><p>数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组。</p>
</li>
</ol>
<p>array也位于名称空间std中,与数组一样,array对象的长度也是固定的,也使用栈(静态内存分配),而不是自由存储区,因此其效率与数组相同,但更方便,更安全.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;typeName, nElem&gt; arr;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; ai;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; ad = &#123;<span class="number">1.1</span>,<span class="number">1.2</span>,<span class="number">1.2</span>,<span class="number">1.3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：不允许拷贝和赋值——不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。</p>
</blockquote>
<h6 id="array与vector的区别"><a href="#array与vector的区别" class="headerlink" title="array与vector的区别"></a>array与vector的区别</h6><table>
<thead>
<tr>
<th>数组</th>
<th>vector</th>
<th>array</th>
</tr>
</thead>
<tbody><tr>
<td>访问方式</td>
<td>支持随机访问</td>
<td>支持随机访问</td>
</tr>
<tr>
<td>存储位置</td>
<td>堆</td>
<td>栈</td>
</tr>
<tr>
<td>复制</td>
<td>逐个复制</td>
<td></td>
</tr>
<tr>
<td>大小</td>
<td>可以变化。可以增加元素</td>
<td>大小不变，定义时指定</td>
</tr>
<tr>
<td>初始化</td>
<td>可以初始化其他vector</td>
<td>不能将数组的内容拷贝给其他数组作为初始值<br>也不能用数组为其他数组赋值</td>
</tr>
<tr>
<td>效率</td>
<td>低（扩容需要消耗大量时间）</td>
<td>高</td>
</tr>
</tbody></table>
<h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><blockquote>
<p>deque是<strong>双向开口</strong>的<strong>连续线性空间</strong></p>
<ol>
<li>允许常数时间内在头尾进行元素的插入或移除</li>
<li>没有容量的概念，<strong>分段连续空间</strong>，可以随时增加一段新的空间并<strong>链接</strong>起来</li>
<li>提供<strong>随机访问迭代器</strong>，但是复杂度比vector高很多</li>
</ol>
<p><strong>deque的数据结构</strong></p>
<ol>
<li><code>start</code>  第一个缓冲区的第一个元素</li>
<li><code>finist</code> 最后一个缓冲区的最后一个元素的下一个位置</li>
<li><code>map</code> 指向缓冲区的指针数组</li>
<li><code>map</code>的大小，当<code>map</code>所能提供的节点不足，要配置一块更大的<code>map</code></li>
</ol>
<p><strong>deque的中控器</strong></p>
<p>deque在<strong>逻辑上</strong>是连续空间，由<strong>一段一段的定量连续空间构成</strong>，一旦有必要，在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端</p>
<p>deque采用一块<strong>所谓的map</strong>，map中的每个元素都是指针（map是指针数组，是二级指针），指向另一端<strong>连续线性空间</strong>，成为缓冲区，是deque的存储空间主体。当map满了，再申请一块更大的map，将map的数据搬过去</p>
<p><strong>deque的迭代器</strong></p>
<p>deque的迭代器在进行移动时，要判断是否到达缓冲区的边缘，如果下一个将要访问的位置不在本缓冲区中，要根据<code>node</code>和<code>map</code>跳跃到新的缓冲区上，更新迭代器信息</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>访问相关</td>
<td>at()<br>operator[]<br>front()<br>back()</td>
</tr>
<tr>
<td>容量相关</td>
<td>empty()<br>size();<br>max_size();<br>shrink_to_fit()<br>resize()</td>
</tr>
<tr>
<td><strong>修改相关</strong></td>
<td>clear()<br>insert()<br>emplace()<br>erase()</td>
</tr>
<tr>
<td></td>
<td>push_back()<br>push_front()<br>emplace_back()<br>emplace_front()</td>
</tr>
<tr>
<td></td>
<td>pop_back()<br>pop_front()</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>stack</td>
<td>默认用deque来实现数据结构的栈的功能</td>
</tr>
<tr>
<td>queue</td>
<td>默认用deque来实现数据结构的队列的功能</td>
</tr>
<tr>
<td>priority_queue</td>
<td>默认用vector来实现，其中保存的元素按照某种严格弱序进行排列，队首元素总是值最大的</td>
</tr>
</tbody></table>
</blockquote>
<h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><blockquote>
<p>stack是LIFO的数据结构，栈是一个单端开口的数据结构，提供在栈顶位置的插入、删除、读取，<strong>只能在栈顶操作</strong></p>
<p><strong>在STL中的实现</strong></p>
<p>封闭<strong>deque</strong>的前端开口，即可提供stack操作，这里称之为<strong>adapter</strong>，即配接器，除了deque，还可以使用list、vector作为其底层结构</p>
<p><strong>不提供迭代器和随机访问功能</strong></p>
<p><strong>提供的操作</strong></p>
<p><strong>访问</strong>：top()//栈顶元素</p>
<p><strong>容量相关</strong>：size(); empty();//判断栈空</p>
<p><strong>修改</strong>：push()；emplace()；pop()；</p>
</blockquote>
<h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><blockquote>
<p>队列是一种FIFO结构，两端分别称之为<strong>队头和队尾</strong>，只允许</p>
<ol>
<li>在队头取元素</li>
<li>在队尾存元素</li>
</ol>
<p><strong>不提供迭代器</strong></p>
<p>默认以deque为底层结构，可选list，不可以选择vector，进行简单的封装实现所需功能</p>
<p><strong>提供的操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">front()</span><br><span class="line">back()</span><br><span class="line">push()</span><br><span class="line">emplace()</span><br><span class="line">pop()</span><br><span class="line">empty()</span><br><span class="line"><span class="built_in">size</span>()</span><br></pre></td></tr></table></figure>

</blockquote>
<h6 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h6><blockquote>
<p>heap即堆是一种数据结构，它是<strong>优先队列</strong>的底层结构，支持</p>
<ol>
<li>允许以任何次序将元素插入容器</li>
<li>总是<strong>按照优先级最高的次序</strong>从容器中取数据</li>
</ol>
<p><code>binary heap</code>是一种<strong>完全二叉树</strong>，从根节点到最后一个节点没有空指针，可以利用<strong>数组</strong>进行存储</p>
<ol>
<li>保留数组的0号元素位置（不用）</li>
<li>对于编号为$i$的节点，其左子树编号为$2i$，右子树编号为$2i+1$</li>
<li>对于一个编号为$i$节点，其根节点的位置为$i/2$</li>
</ol>
<p>利用一个<code>vector</code>和一组<code>heap</code>算法（插入元素、删除元素、取极值、将一组数据排列成一个<code>heap</code>）</p>
<p><strong>sort heap</strong></p>
<p>不断的执行pop操作即可完成排序操作</p>
<p><strong>提供的操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">top()</span><br><span class="line">push()</span><br><span class="line">pop()</span><br><span class="line">emplace()</span><br><span class="line">empty()</span><br><span class="line"><span class="built_in">size</span>()</span><br></pre></td></tr></table></figure>

<p><strong>构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;T,<span class="built_in">vector</span>&lt;T&gt;,less&lt;T&gt;&gt; que;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">less</span>;</span></span><br><span class="line">less::<span class="keyword">operator</span>()(<span class="keyword">const</span> T &amp;lhs, <span class="keyword">const</span> T &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs&lt;rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认是构造一个最大堆</p>
<p>对于自定义数据类型，可以认为定义操作符</p>
<p><a href="https://blog.csdn.net/AAMahone/article/details/82787184" target="_blank" rel="noopener">自定义priority_queue比较</a></p>
<p><strong>不提供迭代器，不提供遍历</strong></p>
</blockquote>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><blockquote>
<p>可变长的字符串</p>
</blockquote>
<h5 id="1-resize和reserve的区别"><a href="#1-resize和reserve的区别" class="headerlink" title="1. resize和reserve的区别"></a>1. resize和reserve的区别</h5><p>主要在于改变大小之后，是否会填充元素；</p>
<h6 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h6><blockquote>
<p>改变当前容器内含有元素的数量(size())，eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v; </span><br><span class="line">v.resize(len);</span><br></pre></td></tr></table></figure>

<p>v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0. 当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；</p>
</blockquote>
<h6 id="reserve"><a href="#reserve" class="headerlink" title="reserve()"></a>reserve()</h6><blockquote>
<p>改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">      a.reserve(<span class="number">100</span>);</span><br><span class="line">      a.resize(<span class="number">50</span>);</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;         <span class="comment">//50  100</span></span><br><span class="line">      a.resize(<span class="number">150</span>);</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;        <span class="comment">//150  200</span></span><br><span class="line">      a.reserve(<span class="number">50</span>);</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;        <span class="comment">//150  200</span></span><br><span class="line">      a.resize(<span class="number">50</span>);</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;        <span class="comment">//50  200    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="2-push-back与emplace-back的区别"><a href="#2-push-back与emplace-back的区别" class="headerlink" title="2. push_back与emplace_back的区别"></a>2. push_back与emplace_back的区别</h5><blockquote>
<ol>
<li>调用push_back时，<strong>参数为元素类型的对象</strong>，这个对象被拷贝到容器中。</li>
<li>调用emplace_back时，<strong>参数与该元素类型构造函数的参数相同</strong>，会在容器管理的内存空间内直接创建对象。</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>push_back</th>
<th>emplace_back</th>
</tr>
</thead>
<tbody><tr>
<td>参数为未被构造的对象</td>
<td></td>
<td></td>
</tr>
<tr>
<td>涉及操作</td>
<td>新建临时对象<br>将该临时对象拷贝至容器末尾<br>销毁该临时对象<br></td>
<td>在容器末尾新建对象</td>
</tr>
<tr>
<td>参数为已构造对象</td>
<td></td>
<td></td>
</tr>
<tr>
<td>涉及操作</td>
<td>将该对象拷贝至容器末尾</td>
<td>将该对象拷贝至容器末尾</td>
</tr>
</tbody></table>
</blockquote>
<h5 id="3-Array-amp-List，-数组和链表的区别"><a href="#3-Array-amp-List，-数组和链表的区别" class="headerlink" title="3 Array&amp;List， 数组和链表的区别"></a>3 Array&amp;List， 数组和链表的区别</h5><blockquote>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>1. 随机访问性强<br>2. 查找速度快</td>
<td>1. 插入和删除效率低<br>2. 可能浪费内存<br>3. 内存空间要求高，必须有足够的连续内存空间。<br>4. 数组大小固定，不能动态拓展</td>
</tr>
<tr>
<td>链表</td>
<td>1. 插入删除速度快<br>2. 内存利用率高，不会浪费内存<br>3. 大小没有固定，拓展很灵活。</td>
<td>1. 不能随机查找，必须从第一个开始遍历，查找效率低</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="2-关联容器"><a href="#2-关联容器" class="headerlink" title="2 关联容器"></a>2 关联容器</h4><table>
<thead>
<tr>
<th>名称</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>set</td>
<td>以红黑树实现，内存中是不连续储存的，保存的是元素是唯一的键值且不可变，排列的方式根据指定的严格弱序排列，不支持随机存取，搜索速度较快</td>
</tr>
<tr>
<td>multiset</td>
<td>与set基本一致，差别就在于允许保存重复键值</td>
</tr>
<tr>
<td>map</td>
<td>同样以红黑树实现，保存的元素是一个pair类型{key, value}，每个键值对应一个值，且键值唯一不可变，键值的排列方式根据指定的严格弱序排列，支持用key进行随机存取，搜索速度较快</td>
</tr>
<tr>
<td>multimap</td>
<td>与map基本一致，差别在于键值可以重复</td>
</tr>
</tbody></table>
<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><blockquote>
<p><code>map</code>是一种映射表，元素是一组<code>pair</code>，即<code>key-value</code>，<code>map</code>根据<code>key</code>的大小进行排序，关键字是不能更改的，而关键值所对应的值是可以改变的。关键字不允许重复</p>
<p>支持的操作有</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clear</span>()</span><br><span class="line">insert()</span><br><span class="line"><span class="keyword">operator</span>[]</span><br><span class="line">empty()</span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line">max_size()</span><br><span class="line">emplace()</span><br><span class="line">insert_or_assign()</span><br><span class="line">erase()</span><br><span class="line">count()</span><br><span class="line"><span class="built_in">find</span>()...</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><blockquote>
<p><code>set</code>不同于<code>map</code>，<code>set</code>只有关键字，无对应的实值，相同的地方</p>
<ol>
<li>底层使用红黑树</li>
<li>关键字不允许重复</li>
<li>有序排列</li>
</ol>
<p>允许的操作和map基本一致</p>
</blockquote>
<h5 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h5><blockquote>
<p>允许关键字相同的<code>set</code>，差别在于使用的插入函数</p>
<ol>
<li><code>set</code>使用的是<code>insert_unique</code></li>
<li><code>multiset</code>使用的是<code>insert_equal</code></li>
</ol>
</blockquote>
<h5 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h5><h5 id="1-map和set的区别及各自的实现方法"><a href="#1-map和set的区别及各自的实现方法" class="headerlink" title="1 map和set的区别及各自的实现方法"></a>1 map和set的区别及各自的实现方法</h5><blockquote>
<p><strong>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）</strong>。</p>
<p>由于map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。</p>
<h5 id="map和set区别"><a href="#map和set区别" class="headerlink" title="map和set区别"></a>map和set区别</h5><p>（1）map中的<strong>元素</strong>是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。</p>
<p>（2）set的<strong>迭代器</strong>是const的，不允许修改元素的值；map允许修改value，但不允许修改key。</p>
<p>其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p>
<p>（3）map支持<strong>下标操作</strong>，set不支持下标操作。</p>
<p>map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p>
</blockquote>
<h5 id="2-Map与Multimap"><a href="#2-Map与Multimap" class="headerlink" title="2 Map与Multimap"></a>2 Map与Multimap</h5><blockquote>
<p>1、Map映射，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p>
<ul>
<li><p>底层实现：红黑树</p>
</li>
<li><p>适用场景：有序键值对不重复映射</p>
</li>
</ul>
<p>2、Multimap</p>
<p>多重映射。multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许键值重复。</p>
<ul>
<li><p>底层实现：红黑树</p>
</li>
<li><p>适用场景：有序键值对可重复映射</p>
</li>
</ul>
</blockquote>
<h4 id="3-无序容器"><a href="#3-无序容器" class="headerlink" title="3 无序容器"></a>3 无序容器</h4><blockquote>
<p>无序容器的底层结构是哈希表，哈希表采用的避免碰撞方法普遍是拉链法</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>unordered_set</td>
<td>以哈希表实现，内存中是不连续储存的，保存的是元素是唯一的键值且不可变，无序的排列方式，不支持随机存取，搜索速度比红黑树实现的set要快</td>
</tr>
<tr>
<td>unordered_multiset</td>
<td>与unordered_set基本一致，差别就在于允许保存重复键值</td>
</tr>
<tr>
<td>unordered_map</td>
<td>以哈希表实现，保存的元素是一个pair类型{key, value}，每个键值对应一个值，且键值唯一不可变，key值无序排列，支持用key进行随机存取，搜索速度比红黑树实现的map要快</td>
</tr>
<tr>
<td>unordered_multimap</td>
<td>与unordered_map基本一致，差别在于键值可以重复</td>
</tr>
</tbody></table>
<h3 id="4-容器适配器"><a href="#4-容器适配器" class="headerlink" title="4 容器适配器"></a>4 容器适配器</h3><blockquote>
<p>allocator模板类定义在头文件memory.h中，它帮助我们将内存分配和对象构造分开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。利用allocate方法分配一段内存，当利用allocator对象分配了内存以后，要再用construct方法来再这块内存中构造指定类型的对象。当使用完这块内存中的对象后，可以利用destroy方法来销毁这个对象，这块内存又变为原始的未构造的内存，可以再次在这块内存中构造指定类型的对象。当使用完这块内存后，要先销毁其中保存的对象，再利用deallocate方法销毁这块内存。</p>
<p>均可以用vector, list和deque来实现，没有提供迭代器</p>
</blockquote>
<h3 id="5-线程安全"><a href="#5-线程安全" class="headerlink" title="5 线程安全"></a>5 线程安全</h3><blockquote>
<p>STL容器提供的线程安全性只有两点：</p>
<ol>
<li>多个线程<strong>读取</strong>是安全的</li>
<li>多个线程<strong>对不同容器的写入</strong>是安全的</li>
</ol>
</blockquote>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="* 其他操作"></a>* 其他操作</h3><h4 id="1-vector与set之间的相互转化"><a href="#1-vector与set之间的相互转化" class="headerlink" title="1 vector与set之间的相互转化"></a>1 vector与set之间的相互转化</h4><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v</span><span class="params">(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>())</span></span>;</span><br></pre></td></tr></table></figure>

</blockquote>
<h4 id="2-vector的扩容原理"><a href="#2-vector的扩容原理" class="headerlink" title="2 vector的扩容原理"></a>2 vector的扩容原理</h4><p>在VS 下，扩容都是以 1.5 倍扩大，但是，在 gcc 编译环境下，是以 2 倍的方式扩容。</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_Count == <span class="number">0</span>)<span class="comment">//这里进行了判断，但是什么都不做，不知道为什么？？？？？？？  </span></span><br><span class="line">    ;  </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (max_size() - size() &lt; _Count)<span class="comment">//编译器可以申请的最大容量也装不下，抛出异常_THROW(length_error, "vector&lt;T&gt; too long");  </span></span><br><span class="line">    _Xlen();     </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_Capacity &lt; size() + _Count) <span class="comment">//当前空间不足，需要扩容  </span></span><br><span class="line">&#123;   <span class="comment">// not enough room, reallocate  </span></span><br><span class="line">    _Capacity = max_size() - _Capacity / <span class="number">2</span> &lt; _Capacity  </span><br><span class="line">        ? <span class="number">0</span> : _Capacity + _Capacity / <span class="number">2</span>;    <span class="comment">// 先保证扩容后的内存大小不超限。如果满足，就扩容50%  </span></span><br><span class="line">    <span class="keyword">if</span> (_Capacity &lt; size() + _Count)<span class="comment">// 扩容50%后依然不够容下，则使容量等于当前数据个数加上新增数据个数（有时候是好多数据（存在文件夹）一起push进去  </span></span><br><span class="line">        _Capacity = size() + _Count;  </span><br><span class="line">    pointer _Newvec = <span class="keyword">this</span>-&gt;_Alval.allocate(_Capacity);<span class="comment">//申请新的空间  </span></span><br><span class="line">    pointer _Ptr = _Newvec;  </span><br><span class="line"></span><br><span class="line">    _TRY_BEGIN  </span><br><span class="line">        _Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),  </span><br><span class="line">                      _Newvec);   <span class="comment">// copy prefix      //拷贝原有数据到新的内存中  </span></span><br><span class="line">    _Ptr = _Ucopy(_First, _Last, _Ptr); <span class="comment">//  //拷贝新增数据到新的内存的后面  </span></span><br><span class="line">    _Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);  <span class="comment">// copy suffix  </span></span><br><span class="line">    _CATCH_ALL  </span><br><span class="line">        _Destroy(_Newvec, _Ptr);  </span><br><span class="line">    <span class="keyword">this</span>-&gt;_Alval.deallocate(_Newvec, _Capacity);<span class="comment">//释放原来申请的内存  </span></span><br><span class="line">    _RERAISE;  </span><br><span class="line">    _CATCH_END  </span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="五-内存管理"><a href="#五-内存管理" class="headerlink" title="五 内存管理"></a>五 内存管理</h2><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552467921124_13956548C4BB199139A2744C39350272" alt="img"></p>
<h3 id="1-C-的内存管理"><a href="#1-C-的内存管理" class="headerlink" title="1. C++的内存管理"></a>1. C++的内存管理</h3><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</p>
<blockquote>
<ol>
<li>代码段：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</li>
<li>数据段：存储程序中已初始化的全局变量和静态变量，（虚函数表)</li>
<li>bss 段：存储未初始化以及所有被初始化为0的全局变量和静态变量（局部+全局）。</li>
<li>堆区：调用new/malloc函数时在堆区动态分配内存，需要调用delete/free来手动释放申请的内存。</li>
<li>映射区：存储动态链接库以及调用mmap函数进行的文件映射</li>
<li>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</li>
</ol>
</blockquote>
<p><strong>示例说明</strong></p>
<blockquote>
<p>32bit CPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0<del>3G是用户态空间，3</del>4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：</p>
<p>各个段说明如下：</p>
<p><code>3G</code>用户空间和<code>1G</code>内核空间</p>
<p>静态区域：</p>
<ol>
<li><code>text segment</code>(代码段)：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</li>
<li><code>data segment</code>(数据段)：存储程序中已初始化的全局变量和静态变量</li>
<li><code>bss segment</code>：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0。</li>
</ol>
<p>动态区域：</p>
<ol>
<li>heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时会分配一个堆，并在程序运行过程中动态增加堆大小 (移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。 堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。</li>
<li>memory mapping segment (映射区) :    存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）</li>
<li>stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。</li>
</ol>
</blockquote>
<h3 id="2-malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#2-malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="2. malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>2. malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h3><blockquote>
<p>答：Malloc函数用于动态分配内存。</p>
<p>为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。</p>
<p>当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</p>
<p>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p>
</blockquote>
<h3 id="3-内存泄漏？"><a href="#3-内存泄漏？" class="headerlink" title="3. 内存泄漏？"></a>3. 内存泄漏？</h3><blockquote>
<p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。</p>
<p>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p>
<p>内存泄漏的分类：</p>
<ol>
<li><strong>堆内存泄漏 （Heap leak）</strong>。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</li>
<li><strong>系统资源泄露（Resource Leak）</strong>。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li>
<li><strong>没有将基类的析构函数定义为虚函数</strong>。<strong>当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用</strong>，子类的资源没有正确是释放，因此造成内存泄露。</li>
</ol>
</blockquote>
<h3 id="4-如何判断及处理内存泄漏？"><a href="#4-如何判断及处理内存泄漏？" class="headerlink" title="4. 如何判断及处理内存泄漏？"></a>4. 如何判断及处理内存泄漏？</h3><blockquote>
<p>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。</p>
<p>判断方法：可以使用linux环境下的内存泄漏检查工具Valgrind；另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</p>
<p>处理方法：使用varglind，mtrace检测。</p>
</blockquote>
<p>例子：在未把析构函数定义为虚函数的情况下，父类指针指向子类对象或者父类引用子类对象</p>
<h3 id="5-段错误"><a href="#5-段错误" class="headerlink" title="5. 段错误"></a>5. 段错误</h3><blockquote>
<p>段错误通常发生在访问非法内存地址的时候, 比如：</p>
<ol>
<li>使用野指针</li>
<li>试图修改字符串常量的内容</li>
</ol>
</blockquote>
<h3 id="6-new和malloc的区别"><a href="#6-new和malloc的区别" class="headerlink" title="6. new和malloc的区别"></a>6. new和malloc的区别</h3><blockquote>
<p>1、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；</p>
<p>2、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。</p>
<p>3、new不仅分配一段内存，而且会调用构造函数，malloc不会。</p>
<p>4、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。</p>
<p>5、new是一个操作符可以重载，malloc 是一个库函数。</p>
<p>6、malloc分配的内存不够的时候，可以用realloc 扩容。new没这样操作。new如果分配失败了会抛出bad_malloc 的异常，而malloc失败了会返回NULL。</p>
<p>7、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。</p>
</blockquote>
<h4 id="new-delete与malloc-free的区别"><a href="#new-delete与malloc-free的区别" class="headerlink" title="new/delete与malloc/free的区别"></a><strong>new/delete与malloc/free的区别</strong></h4><blockquote>
<p>首先，new/delete是C++的关键字，而malloc/free是C语言的库函数。</p>
<p>malloc需要给定申请内存的大小，返回的指针需要强转。</p>
<p>new会调用构造函数，不用指定内存大小，返回的指针不用强转。</p>
</blockquote>
<h3 id="7-共享内存相关API"><a href="#7-共享内存相关API" class="headerlink" title="7. 共享内存相关API"></a>7. 共享内存相关API</h3><blockquote>
<p>Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在<code>sys/shm.h</code>中。</p>
<ol>
<li><p>新建共享内存shmget</p>
<p>int shmget(key_t key,size_t size,int shmflg);</p>
<p>key：共享内存键值，可以理解为共享内存的唯一性标记。</p>
<p>size：共享内存大小</p>
<p>shmflag：创建进程和其他进程的读写权限标识。</p>
<p>返回值：相应的共享内存标识符，失败返回-1</p>
</li>
<li><p>连接共享内存到当前进程的地址空间shmat</p>
<p>void *shmat(int shm_id,const void *shm_addr,int shmflg);</p>
<p>shm_id：共享内存标识符</p>
<p>shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</p>
<p>shmflg：标志位</p>
<p>返回值：指向共享内存第一个字节的指针，失败返回-1</p>
</li>
<li><p>当前进程分离共享内存shmdt</p>
<p>int shmdt(const void *shmaddr);</p>
</li>
<li><p>控制共享内存shmctl</p>
<p>和信号量的semctl函数类似，控制共享内存</p>
<p>int shmctl(int shm_id,int command,struct shmid_ds *buf);</p>
<p>shm_id：共享内存标识符</p>
<p>command: 有三个值</p>
<p>IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</p>
<p>IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</p>
<p>IPC_RMID:删除共享内存</p>
<p>buf：共享内存管理结构体。</p>
</li>
</ol>
</blockquote>
<h3 id="8-STL的内存优化"><a href="#8-STL的内存优化" class="headerlink" title="8. STL的内存优化"></a>8. STL的内存优化</h3><blockquote>
<h4 id="1）二级配置器结构"><a href="#1）二级配置器结构" class="headerlink" title="1）二级配置器结构"></a>1）二级配置器结构</h4><p>STL内存管理使用二级内存配置器。</p>
<h5 id="1、第一级配置器"><a href="#1、第一级配置器" class="headerlink" title="1、第一级配置器"></a>1、第一级配置器</h5><p>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。<br>一级空间配置器分配的是大于128字节的空间<br>如果分配不成功，调用句柄释放一部分内存<br>如果还不能分配成功，抛出异常</p>
<h5 id="2、第二级配置器"><a href="#2、第二级配置器" class="headerlink" title="2、第二级配置器"></a>2、第二级配置器</h5><p>在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。</p>
<h5 id="3、分配原则"><a href="#3、分配原则" class="headerlink" title="3、分配原则"></a>3、分配原则</h5><p>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。<br>当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表<br>如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块<br>如果内存池空间足够，则取出内存<br>如果不够分配20块，则分配最多的块数给自由链表，并且更新每次申请的块数<br>如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器</p>
</blockquote>
<h4 id="2）二级内存池"><a href="#2）二级内存池" class="headerlink" title="2）二级内存池"></a>2）二级内存池</h4><blockquote>
<p>二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190414/970829_1555246716341_19203EAD1152E0317EE9B5F6BFE090C6" alt="img"></p>
<h5 id="1、空间配置函数allocate"><a href="#1、空间配置函数allocate" class="headerlink" title="1、空间配置函数allocate"></a>1、空间配置函数allocate</h5><p>首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数据块，则调用refill重新填充空间。</p>
<h5 id="2、空间释放函数deallocate"><a href="#2、空间释放函数deallocate" class="headerlink" title="2、空间释放函数deallocate"></a>2、空间释放函数deallocate</h5><p>首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。</p>
<h5 id="3、重新填充空闲链表refill"><a href="#3、重新填充空闲链表refill" class="headerlink" title="3、重新填充空闲链表refill"></a>3、重新填充空闲链表refill</h5><p>在用allocate配置空间时，如果空闲链表中没有可用数据块，就会调用refill来重新填充空间，新的空间取自内存池。缺省取20个数据块，如果内存池空间不足，那么能取多少个节点就取多少个。<br>从内存池取空间给空闲链表用是chunk_alloc的工作，首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去，如果内存连一个数据块的空间都无法供应，需要用malloc取堆中申请内存。<br>假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。</p>
<h4 id="3、总结："><a href="#3、总结：" class="headerlink" title="3、总结："></a>3、总结：</h4><ol>
<li>使用allocate向内存池请求size大小的内存空间，如果需要请求的内存大小大于128bytes，直接使用malloc。</li>
<li>如果需要的内存大小小于128bytes，allocate根据size找到最适合的自由链表。<ol>
<li>a. 如果链表不为空，返回第一个node，链表头改为第二个node。</li>
<li>b. 如果链表为空，使用blockAlloc请求分配node。</li>
<li>x. 如果内存池中有大于一个node的空间，分配竟可能多的node(但是最多20个)，将一个node返回，其他的node添加到链表中。</li>
<li>y. 如果内存池只有一个node的空间，直接返回给用户。</li>
<li>z. 若果如果连一个node都没有，再次向操作系统请求分配内存。<ol>
<li>①分配成功，再次进行b过程。</li>
<li>②分配失败，循环各个自由链表，寻找空间。</li>
<li>I. 找到空间，再次进行过程b。</li>
<li>II. 找不到空间，抛出异常。</li>
</ol>
</li>
</ol>
</li>
<li>用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。</li>
<li>否则按照其大小找到合适的自由链表，并将其插入。</li>
</ol>
</blockquote>
<h3 id="9-select-epoll的区别、原理、性能、限制"><a href="#9-select-epoll的区别、原理、性能、限制" class="headerlink" title="9. select/epoll的区别、原理、性能、限制"></a>9. select/epoll的区别、原理、性能、限制</h3><blockquote>
<h4 id="1-IO多路复用"><a href="#1-IO多路复用" class="headerlink" title="1 IO多路复用"></a>1 IO多路复用</h4></blockquote>
<blockquote>
<p>IO复用模型在阻塞IO模型上多了一个select函数，select函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。</p>
<p>这种IO模型是属于阻塞的IO。但是由于它可以对多个文件描述符进行阻塞监听，所以它的效率比阻塞IO模型高效。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/826546_1552638064152_94DD1FAB6C2E289FF496A8013E092EA5" alt="img"></p>
<p>IO多路复用就是我们说的select，poll，epoll。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>I/O多路复用和阻塞I/O其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h4 id="2-select"><a href="#2-select" class="headerlink" title="2 select"></a>2 select</h4><p>select：是最初解决IO阻塞问题的方法。用结构体fd_set来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。</p>
<p>存在的问题：</p>
<ol>
<li><p>内置数组的形式使得select的最大文件数受限与FD_SIZE；</p>
</li>
<li><p>每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态；</p>
</li>
<li><p>轮寻排查当文件描述符个数很多时，效率很低；</p>
</li>
</ol>
<h4 id="3-poll"><a href="#3-poll" class="headerlink" title="3 poll"></a>3 poll</h4><p>poll：通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。</p>
<h4 id="4-epoll"><a href="#4-epoll" class="headerlink" title="4 epoll"></a>4 epoll</h4><ul>
<li>epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。</li>
<li>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式</li>
</ul>
<ol>
<li><h6 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h6></li>
</ol>
<p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<ol start="2">
<li><h6 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h6></li>
</ol>
<ul>
<li>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。</li>
<li>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</li>
</ul>
<ol start="3">
<li><h6 id="LT模式与ET模式的区别"><a href="#LT模式与ET模式的区别" class="headerlink" title="LT模式与ET模式的区别"></a>LT模式与ET模式的区别</h6></li>
</ol>
<ul>
<li>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li>
</ul>
</blockquote>
<h3 id="10-堆和栈的概念"><a href="#10-堆和栈的概念" class="headerlink" title="10. 堆和栈的概念"></a>10. 堆和栈的概念</h3><blockquote>
<p>堆（Heap）与栈（Stack）的理解需要放到具体的场景下，因为不同场景下，堆与栈代表不同的含义。</p>
<ol>
<li>程序内存布局场景下，堆与栈表示两种内存管理方式；</li>
<li>数据结构场景下，堆与栈表示两种常用的数据结构。</li>
</ol>
<h4 id="内存场景"><a href="#内存场景" class="headerlink" title="内存场景"></a>内存场景</h4><p>堆上内存空间的分配过程</p>
<ul>
<li><p>首先，操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点；</p>
</li>
<li><p>然后，将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。</p>
</li>
<li><p>另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。</p>
<p>由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。</p>
</li>
</ul>
<p>栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>栈是一种运算受限的线性表，其限制是指只仅允许在表的一端进行插入和删除操作，这一端被称为栈顶（Top），相对地，把另一端称为栈底（Bottom）。</p>
<p>堆是一种常用的树形结构，是一种特殊的完全二叉树，当且仅当满足所有节点的值总是不大于或不小于其父节点的值的完全二叉树被称之为堆。</p>
</blockquote>
<h3 id="11-堆和栈的区别"><a href="#11-堆和栈的区别" class="headerlink" title="11. 堆和栈的区别"></a>11. <a href="https://www.cnblogs.com/yiluyisha/p/9049051.html" target="_blank" rel="noopener">堆和栈的区别</a></h3><blockquote>
<p>  1、管理方式；<br>  2、空间大小；<br>  3、能否产生碎片；<br>  4、生长方向；<br>  5、分配方式；<br>  6、分配效率；</p>
</blockquote>
<blockquote>
<p>（1）管理方式：堆中资源由程序员控制（通过malloc/free、new/delete，容易产生memory leak），栈资源由编译器自动管理。</p>
<p>（2）系统响应：对于堆，系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个大于所申请空间的空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外，系统会将多余的部分重新放入空闲链表中）。对于栈，只要栈的剩余空间大于所申请空间，系统就会为程序分配内存，否则报异常出现栈空间溢出错误。</p>
<p>（3）空间大小：堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址的，自然不是连续），堆的大小受限于计算机系统中有效的虚拟内存（32位机器上理论上是4G大小），所以堆的空间比较灵活，比较大。栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在编译时确定，VC中可设置）。</p>
<p>（4）碎片问题：对于堆，频繁的new/delete会造成大量内存碎片，降低程序效率。栈是一个先进后出（first-in-last-out）的结构，进出一一对应，不会产生碎片。</p>
<p>（5）生长方向：堆向上，向高地址方向增长；栈向下，向低地址方向增长。</p>
<p>（6）分配方式：堆是动态分配（没有静态分配的堆）。栈有静态分配和动态分配，静态分配由编译器完成（如函数局部变量），动态分配由alloca函数分配，但栈的动态分配资源由编译器自动释放，无需程序员实现。</p>
<p>（7）分配效率：堆由C/C++函数库提供，机制复杂，因此堆的效率比栈低很多。栈是机器系统提供的数据结构，计算机在底层对栈提供支持，分配专门的寄存器存放栈地址，提供栈操作专门的指令。</p>
</blockquote>
<h3 id="12-分堆和栈的原因"><a href="#12-分堆和栈的原因" class="headerlink" title="12. 分堆和栈的原因"></a>12. 分堆和栈的原因</h3><blockquote>
<p>第一，从软件设计的角度看，栈代表处理逻辑，而堆代表数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</p>
<p>第二，堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</p>
<p>第三，栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</p>
<p>第四，面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。</p>
<h4 id="反证法"><a href="#反证法" class="headerlink" title="反证法"></a>反证法</h4><p>仅使用栈</p>
<p>假设我们的程序代码仅仅使用栈，那么我们的代码会变得非常的简单，程序在执行函数的时候，只需要依次的将变量压入堆栈就好了，当要释放的时候取出来就好了，针对实现的时候，只需要让指针上下移动就好。这么一看栈似乎很完美，它性能优越快速，而且不会产生内存碎片。但是假设我们现在有这么一个操作现在有两个变量 A,B 我们先依次把他们入栈，入栈后的后续操作我们主要是围绕 B 进行的，与 A 已经没有关系了，但是 A 依旧占用着空间，如果我们希望释放 A 的内存空间，那么根据后进先出的原则，那么我们必须先释放 B 才能释放 A，但是后续的计算又需要 B 这就导致我们无法释放 A，在后续的过程中 A 已经没有价值了，但是它还是必须驻留在内存中。而这个时候如果将 A 放入堆中，那么当 A 不在使用的时候，我们可以很容易的在堆中释放 A 所占用的空间，提高内存的有效使用率。这就是堆出现的初衷。</p>
<p>仅使用堆</p>
<p>堆之所以能与比栈更好的动态分配的性能是因为堆往往使用了较为复杂的数据结构，这就会导致操作堆的成本要远远大于栈的成本，所以如果仅仅使用堆会使的程序整体效率变慢。</p>
</blockquote>
<h3 id="13-C-函数栈空间的最大值"><a href="#13-C-函数栈空间的最大值" class="headerlink" title="13. C++函数栈空间的最大值"></a>13. C++函数栈空间的最大值</h3><blockquote>
<p>默认是1M，不过可以调整</p>
</blockquote>
<h3 id="14-说说stack-overflow，并举个简单例子"><a href="#14-说说stack-overflow，并举个简单例子" class="headerlink" title="14. 说说stack overflow，并举个简单例子"></a>14. 说说stack overflow，并举个简单例子</h3><blockquote>
<p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，导致栈中与其相邻的变量的值被改变。</p>
<h4 id="栈溢出的原因"><a href="#栈溢出的原因" class="headerlink" title="栈溢出的原因"></a>栈溢出的原因</h4><ol>
<li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。</li>
<li>递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</li>
<li>指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</li>
</ol>
<h4 id="栈溢出例子"><a href="#栈溢出例子" class="headerlink" title="栈溢出例子"></a>栈溢出例子</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input:%s\n"</span>,buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的<code>strcpy(buf,argv[1])</code>;这一行发生了缓冲区溢出错误，因为源缓冲区内容是用户输入的。</p>
</blockquote>
<h3 id="15-栈和堆的区别，以及为什么栈要快"><a href="#15-栈和堆的区别，以及为什么栈要快" class="headerlink" title="15.  栈和堆的区别，以及为什么栈要快"></a>15.  栈和堆的区别，以及为什么栈要快</h3><blockquote>
<h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><ol>
<li>堆是由低地址向高地址扩展；栈是由高地址向低地址扩展</li>
<li>堆中的内存需要手动申请和手动释放；栈中内存是由OS自动申请和自动释放，存放着参数、局部变量等内存</li>
<li>堆中频繁调用malloc和free,会产生内存碎片，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片</li>
<li>堆的分配效率较低，而栈的分配效率较高</li>
</ol>
<h4 id="栈的效率高的原因"><a href="#栈的效率高的原因" class="headerlink" title="栈的效率高的原因"></a>栈的效率高的原因</h4><p>栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。</p>
</blockquote>
<h3 id="16-A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？"><a href="#16-A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？" class="headerlink" title="16.  A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？"></a>16.  A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？</h3><blockquote>
<p>1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4/8字节的空间（0x000m），分配给指针a。</p>
<p>2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。</p>
<p>3）a = new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）=0x000n。</p>
<p>4）a-&gt;i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。</p>
</blockquote>
<h3 id="17-大端小端及如何判断"><a href="#17-大端小端及如何判断" class="headerlink" title="17. 大端小端及如何判断"></a>17. 大端小端及如何判断</h3><blockquote>
<p>大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。</p>
<p>我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。</p>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">union</span> test&#123;</span><br><span class="line">         <span class="keyword">int</span> i;</span><br><span class="line">         <span class="keyword">char</span> c;</span><br><span class="line">     &#125;;</span><br><span class="line">     test t;</span><br><span class="line">     t.i = <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//如果是大端，则t.c为0x00,则t.c!=1;否则 t.c为0x01,则t.c==1，返回1</span></span><br><span class="line">     <span class="keyword">return</span> (it.c == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="六-C-特性"><a href="#六-C-特性" class="headerlink" title="六 C++ 特性"></a>六 C++ 特性</h2><h3 id="1-C-和C的区别"><a href="#1-C-和C的区别" class="headerlink" title="1 C++和C的区别"></a>1 C++和C的区别</h3><blockquote>
<ol>
<li>(设计思想上) C++是面向对象的语言，而C是面向过程的结构化编程语言;</li>
<li>(语法上)</li>
</ol>
<ul>
<li><p>C++具有封装、继承和多态三种特性；C不支持</p>
</li>
<li><p>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</p>
</li>
<li><p>C++支持范式编程，比如模板类、函数模板等</p>
</li>
</ul>
</blockquote>
<h3 id="2-C-高级特性"><a href="#2-C-高级特性" class="headerlink" title="2 C++高级特性"></a>2 C++高级特性</h3><blockquote>
<ol>
<li>auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导</li>
<li>nullptr关键字：nullptr 是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。</li>
<li>智能指针：C++11新增了<code>std::shared_ptr</code>、<code>std::weak_ptr</code>等类型的智能指针，用于解决内存管理的问题。</li>
<li>初始化列表：使用初始化列表来对类进行初始化</li>
<li>右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</li>
<li><code>atomic</code>原子操作用于多线程资源互斥操作</li>
<li>新增<code>STL</code>容器<code>array</code>以及<code>tuple</code></li>
</ol>
</blockquote>
<h4 id="Auto的初始化"><a href="#Auto的初始化" class="headerlink" title="Auto的初始化"></a>Auto的初始化</h4><blockquote>
<p>为了让编译器能够根据初始值的类型推断变量的类型，C++重新定义了auto的含义。</p>
<p>在初始化声明中，如果使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同；但自动推断类型并不是为这种简单情况而设计的，如果永用于简单情形，会出错，假设要将x,y,z都指定为double</p>
</blockquote>
<h3 id="3-GDB调试"><a href="#3-GDB调试" class="headerlink" title="3 GDB调试"></a>3 GDB调试</h3><h4 id="1-请问GDB调试用过吗，什么是条件断点"><a href="#1-请问GDB调试用过吗，什么是条件断点" class="headerlink" title="1. 请问GDB调试用过吗，什么是条件断点"></a>1. 请问GDB调试用过吗，什么是条件断点</h4><blockquote>
<h4 id="1、GDB调试"><a href="#1、GDB调试" class="headerlink" title="1、GDB调试"></a>1、GDB调试</h4><p>GDB 是一种软件工具，作用是协助程序员找到代码中的错误。如果没有GDB的帮助，程序员要想跟踪代码的执行流程，唯一的办法就是添加大量的语句来产生特定的输出。但这一手段本身就可能会引入新的错误，从而也就无法对那些导致程序崩溃的错误代码进行分析。</p>
<p>GDB 的出现减轻了开发人员的负担，他们可以在程序运行的时候单步跟踪自己的代码，或者通过断点暂时中止程序的执行。此外还能够随时察看变量和内存的当前状态，并监视关键的数据结构是如何影响代码运行的。</p>
<h4 id="2、条件断点"><a href="#2、条件断点" class="headerlink" title="2、条件断点"></a>2、条件断点</h4><p>条件断点是当满足条件就中断程序运行，命令：break line-or-function if expr。</p>
<p>例如：(gdb)break 666 if testsize==100</p>
</blockquote>
<h1 id="二-算法与数据结构"><a href="#二-算法与数据结构" class="headerlink" title="二 算法与数据结构"></a>二 算法与数据结构</h1><h2 id="一-堆、栈、队列、字符串"><a href="#一-堆、栈、队列、字符串" class="headerlink" title="一 堆、栈、队列、字符串"></a>一 堆、栈、队列、字符串</h2><h3 id="1-堆"><a href="#1-堆" class="headerlink" title="1. 堆"></a>1. 堆</h3><blockquote>
<p>堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。</p>
<p>小根堆：若根节点存在左子女则根节点的值小于左子女的值；若根节点存在右子女则根节点的值小于右子女的值。</p>
<p>大根堆：若根节点存在左子女则根节点的值大于左子女的值；若根节点存在右子女则根节点的值大于右子女的值。</p>
</blockquote>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><blockquote>
<p><strong>push heap</strong>算法</p>
<ol>
<li>将新元素放入vector的末尾，即heap的尾元素</li>
<li>将当前元素与父节点进行比较<ol>
<li>如果满足交换的需求（最大堆中，当前节点大于父节点）则交换</li>
<li>否则，停止，退出</li>
</ol>
</li>
<li>重复2直至条件不再满足，或者到达根节点</li>
</ol>
<p>$log(n)$的时间复杂度</p>
<p><strong>pop heap</strong>算法</p>
<p>每一次pop操作都是将vector元素的首元素取出，并从原vector中删除，以最大堆的操作为例</p>
<ol>
<li>取vector的首元素</li>
<li>将vector的尾元素取出放在vector的首元素</li>
<li>将当前元素与左右子树中权值较大的节点进行交换，不断地向下回溯</li>
</ol>
</blockquote>
<h3 id="2-栈"><a href="#2-栈" class="headerlink" title="2. 栈"></a>2. 栈</h3><blockquote>
<p>栈是允许在同一端进行插入和删除操作的特殊线性表。允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈底固定，而栈顶浮动；栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。</p>
</blockquote>
<h2 id="二-数组与链表"><a href="#二-数组与链表" class="headerlink" title="二 数组与链表"></a>二 数组与链表</h2><h3 id="1-合并两个有序链表"><a href="#1-合并两个有序链表" class="headerlink" title="1 合并两个有序链表"></a>1 合并两个有序链表</h3><blockquote>
<h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>)	<span class="keyword">return</span> l2;</span><br><span class="line">      <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>)   <span class="keyword">return</span> l1;</span><br><span class="line">      <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">         l1-&gt;next=mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">         <span class="keyword">return</span> l1;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">         l2-&gt;next=mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">          <span class="keyword">return</span> l2;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-反转链表"><a href="#2-反转链表" class="headerlink" title="2 反转链表"></a>2 反转链表</h3><blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Void <span class="title">reversal_list</span><span class="params">(node * head)</span></span>&#123;</span><br><span class="line">      node* pre_node = <span class="literal">nullptr</span>;</span><br><span class="line">       node* cur_node = head-&gt;next;</span><br><span class="line">       node* next_node = cur_node-&gt;next;</span><br><span class="line">       <span class="keyword">if</span>(cur_node == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           cur_node-&gt;next = forward_node;</span><br><span class="line">           pre_node = cur_node;</span><br><span class="line">           cur_node = next_node;</span><br><span class="line">           <span class="keyword">if</span>(cur_node == <span class="literal">nullptr</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           next_node = cur_node-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">     head-&gt;next = pre_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-判断回文链表"><a href="#3-判断回文链表" class="headerlink" title="3 判断回文链表"></a>3 判断回文链表</h3><blockquote>
<p>使用栈来判断</p>
</blockquote>
<h3 id="4-判断公共节点"><a href="#4-判断公共节点" class="headerlink" title="4 判断公共节点"></a>4 判断公共节点</h3><blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">       ListNode *node1 = headA;</span><br><span class="line">       ListNode *node2 = headB;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (node1 != node2) &#123;</span><br><span class="line">           node1 = node1 != <span class="literal">NULL</span> ? node1-&gt;next : headB;</span><br><span class="line">           node2 = node2 != <span class="literal">NULL</span> ? node2-&gt;next : headA;</span><br><span class="line">       &#125;</span><br><span class="line">    	<span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-判断数组否有重复的数"><a href="#5-判断数组否有重复的数" class="headerlink" title="5 判断数组否有重复的数"></a>5 判断数组否有重复的数</h3><blockquote>
<p>一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数</p>
<p>把每个数放到自己对应序号的位置上，如果其他位置上有和自己对应序号相同的数，那么即为有重复的数值。时间复杂度为O(N),同时为了节省空间复杂度，可以在原数组上进行操作，空间复杂度为O(1)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsDuplicateNumber</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">array</span>==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">int</span> i,temp;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="built_in">array</span>[i]!=i)&#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="built_in">array</span>[<span class="built_in">array</span>[i]]==<span class="built_in">array</span>[i])</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">               temp=<span class="built_in">array</span>[<span class="built_in">array</span>[i]];</span><br><span class="line">               <span class="built_in">array</span>[<span class="built_in">array</span>[i]]=<span class="built_in">array</span>[i];</span><br><span class="line">               <span class="built_in">array</span>[i]=temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="三-树"><a href="#三-树" class="headerlink" title="三 树"></a>三 树</h2><h3 id="零-二叉树的性质"><a href="#零-二叉树的性质" class="headerlink" title="零 二叉树的性质"></a>零 二叉树的性质</h3><blockquote>
<p><strong>性质1</strong> ：在二叉树的第i层上至多有$2^{i-1}$ 个结点（i≥1）。（数学归纳法可证）</p>
<p><strong>性质2</strong> ：深度为k的二叉树最多有$2^{k-1}$个结点（k≥1）。（由性质1，通过等比数列求和可证）</p>
<p><strong>性质3</strong> ：一棵二叉树的叶子结点数为n0 ，度为2的结点数为n2 ，则n0 = n2 + 1。</p>
<p><strong>性质4</strong> ：具有n个结点的完全二叉树的深度为floor(log2n) + 1 。</p>
<p><strong>性质5</strong> ：如果对一棵有n个结点的完全二叉树（其深度为floor(log2n) + 1 ）的结点按层序编号，则对任一结点i（1≤i≤n）有：</p>
<p>（1） 如果i = 1，则结点i是二叉树的根，无双亲；如果i &gt; 1，则其双亲PARENT(i)是结点 floor((i)/2)。</p>
<p>（2）如果2i &gt; n，则结点i无左孩子；否则其左孩子LCHILD(i)是结点2i。</p>
<p>（3）如果2i + 1 &gt; n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2i + 1</p>
</blockquote>
<h4 id="树与二叉树的关系"><a href="#树与二叉树的关系" class="headerlink" title="树与二叉树的关系"></a>树与二叉树的关系</h4><blockquote>
<ol>
<li>树的先序对应二叉树的先序</li>
<li>树的后序对应二叉树的中序</li>
</ol>
</blockquote>
<h4 id="树与二叉树的转换"><a href="#树与二叉树的转换" class="headerlink" title="树与二叉树的转换"></a>树与二叉树的转换</h4><blockquote>
<p>1-加线：在所有的兄弟节点之间加一条线<br>2-去线：对树中每个结点，只保留它与第一个孩子节点的连线，删除它与其他孩子节点之间的连线。<br>3-层次调整：以树的根节点为轴心，将整颗树顺时针旋转一定的角度，使之结构层次分明。</p>
</blockquote>
<h3 id="一-递归遍历"><a href="#一-递归遍历" class="headerlink" title="一 递归遍历"></a>一 递归遍历</h3><h3 id="二-非递归遍历"><a href="#二-非递归遍历" class="headerlink" title="二 非递归遍历"></a>二 非递归遍历</h3><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       node* p = root;</span><br><span class="line">       <span class="built_in">stack</span>&lt;node*&gt; st;</span><br><span class="line">       <span class="keyword">while</span>(!st.empty()||p)&#123;</span><br><span class="line">           <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">               st.push(p);</span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">               p = p-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           p = st.top();</span><br><span class="line">           st.pop();</span><br><span class="line">           p = p-&gt;right;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     node* p = root;</span><br><span class="line">     <span class="built_in">stack</span>&lt;node*&gt; st;</span><br><span class="line">     <span class="keyword">while</span>(!st.empty()||p)&#123;</span><br><span class="line">           <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">               st.push(p);</span><br><span class="line">               p = p-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           p = st.top();</span><br><span class="line">           st.pop();</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//与前序遍历相比，输出位置有区别</span></span><br><span class="line">           p = p-&gt;right;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这种方法不需要辅助空间保存结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;node*&gt; st;</span><br><span class="line">    node *pcur,*plast;</span><br><span class="line">    pcur = root;</span><br><span class="line">    plast = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(pcur)&#123;</span><br><span class="line">        st.push(pcur);</span><br><span class="line">        pcur = pcur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">        pcur = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span>(pcur-&gt;left==<span class="literal">nullptr</span>||pcur-&gt;right==plast)&#123; </span><br><span class="line">            <span class="comment">// 如果左右子树都访问过，则输出根节点；</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;pcur-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            plast = pcur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 否则，再次入栈，并挪到右子树的左端点</span></span><br><span class="line">            st.push(pcur);</span><br><span class="line">            pcur = pcur-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(pcur)&#123;</span><br><span class="line">                st.push(pcur);</span><br><span class="line">                pcur = pcur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">PostOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">           <span class="keyword">return</span> ret;</span><br><span class="line">       TreeNode* cur = root;</span><br><span class="line">       <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(cur || st.size()) &#123;</span><br><span class="line">           <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">               ret.push_back(cur-&gt;val);</span><br><span class="line">               st.push(cur);</span><br><span class="line">               cur = cur-&gt;right;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = st.top();</span><br><span class="line">           st.pop();</span><br><span class="line">           cur = cur-&gt;left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(ret.rbegin(), ret.rend());<span class="comment">//最后需要逆序输出，或者做个转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="三-Huffman树"><a href="#三-Huffman树" class="headerlink" title="三 Huffman树"></a>三 Huffman树</h3><blockquote>
<p>Huffman树的带权路劲长度WPL等于个叶子节点的带权路劲长度之和。</p>
</blockquote>
<h3 id="四-红黑树"><a href="#四-红黑树" class="headerlink" title="四 红黑树"></a>四 红黑树</h3><blockquote>
<p>红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在<a href="https://baike.baidu.com/item/计算机" target="_blank" rel="noopener">计算机</a>科学中用到的一种<a href="https://baike.baidu.com/item/数据结构/1450" target="_blank" rel="noopener">数据结构</a>，典型的用途是实现<a href="https://baike.baidu.com/item/关联数组/3317025" target="_blank" rel="noopener">关联数组</a>。</p>
<p>红黑树是一种特化的AVL树（<a href="https://baike.baidu.com/item/平衡二叉树/10421057" target="_blank" rel="noopener">平衡二叉树</a>），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。 [2] </p>
<p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。</p>
<p>红黑树是一种特定类型的<a href="https://baike.baidu.com/item/二叉树" target="_blank" rel="noopener">二叉树</a>，是在计算机科学中用来组织数据比如数字的块的一种结构。若一棵二叉查找树是红黑树，则它的任一子树必为红黑树。红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的<a href="https://baike.baidu.com/item/平衡二叉树/10421057" target="_blank" rel="noopener">平衡二叉树</a>（AVL），但 对之进行平衡的代价较低， 其平均统计性能要强于 AVL 。 由于每一颗红黑树都是一颗二叉排序树，因此对红黑树进行查找时，可以采用运用于普通二叉排序树上的查找算法，在查找过程中不需要颜色信息。</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>节点是红色或黑色。 </li>
<li>根节点是黑色。 </li>
<li>所有叶子都是黑色。（叶子是NULL节点） </li>
<li>每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 </li>
</ol>
<p><strong>应用</strong>：广泛应用于C++的STL中，map和set底层都是用红黑树实现的。</p>
</blockquote>
<p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/1732651-20190821151029589-676793772.png" alt="img"></p>
<blockquote>
<h6 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h6><ol>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li>
<li>任何相邻的节点（父子节点）都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li>
</ol>
<p><a href="https://time.geekbang.org/column/article/68638" target="_blank" rel="noopener">近似平衡的原因</a></p>
</blockquote>
<h4 id="1-红黑树与平衡二叉树的区别"><a href="#1-红黑树与平衡二叉树的区别" class="headerlink" title="1. 红黑树与平衡二叉树的区别"></a>1. 红黑树与平衡二叉树的区别</h4><blockquote>
<p>说它不严格是因为它不是严格控制左、右子树高度或节点数之差小于等于1。<br>但红黑树高度依然是平均log(n)，且最坏情况高度不会超过<code>2log(n)</code>，这有数学证明。所以它算平衡树，只是不严格。不过严格与否并不影响数据结构的复杂度。</p>
</blockquote>
<h3 id="五-B树与B-树"><a href="#五-B树与B-树" class="headerlink" title="五 B树与B+树"></a>五 B树与B+树</h3><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><blockquote>
<p>m阶B树满足以下条件：</p>
<ul>
<li>每个节点至多可以拥有m棵子树。</li>
<li>根节点，只有至少有2个节点（要么极端情况，就是一棵树就一个根节点，单细胞生物，即是根，也是叶，也是树)。</li>
<li>非根非叶的节点至少有的Ceil(m/2)个子树(Ceil表示向上取整，图中5阶B树，每个节点至少有3个子树，也就是至少有3个叉)。</li>
<li>非叶节点中的信息包括[n,A0,K1,A1,K2,A2,…,Kn,An]，，其中n表示该节点中保存的关键字个数，K为关键字且Ki&lt;Ki+1，A为指向子树根节点的指针。</li>
<li>从根到叶子的每一条路径都有相同的长度，也就是说，叶子节在相同的层，并且这些节点不带信息，实际上这些节点就表示找不到指定的值，也就是指向这些节点的指针为空。</li>
</ul>
</blockquote>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><blockquote>
<p>作为B树的加强版，B+树与B树的差异在于</p>
<ul>
<li>有n棵子树的节点含有n个关键字（也有认为是n-1个关键字）。</li>
<li>所有的关键字全部存储在叶子节点上，且叶子节点本身根据关键字自小而大顺序连接。</li>
<li>非叶子节点可以看成索引部分，节点中仅含有其子树（根节点）中的最大（或最小）关键字。</li>
</ul>
<p>B+树的查找过程，与B树类似，只不过查找时，如果在非叶子节点上的关键字等于给定值，并不终止，而是继续沿着指针直到叶子节点位置。因此在B+树，不管查找成功与否，每次查找都是走了一条从根到叶子节点的路径。</p>
<img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/758447-20180126171338850-1455023219.png" alt="img" style="zoom:67%;">

<p>B+树的特性如下：</p>
<ul>
<li>所有关键字都存储在叶子节上，且链表中的关键字恰好是有序的。</li>
<li>不可能非叶子节点命中返回。</li>
<li>非叶子节点相当于叶子节点的索引，叶子节点相当于是存储（关键字）数据的数据层。</li>
<li>更适合文件索引系统。</li>
</ul>
<h4 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h4><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p>
<p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/758447-20180126172151522-1626747450.png" alt="img"></p>
<p>如上图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提高了区间查询效率。</p>
</blockquote>
<h3 id="六-平衡二叉树"><a href="#六-平衡二叉树" class="headerlink" title="六 平衡二叉树"></a>六 平衡二叉树</h3><blockquote>
<ul>
<li><code>平衡因子</code> : 树中某结点其左子树的高度和右子树的高度之差</li>
<li><code>AVL树</code>：中的任意一个结点, 其<code>平衡因子</code>的<strong>绝对值小于2</strong></li>
<li><code>AVL树</code>是一种特殊的二叉搜索树 (BST树), 相对于数据极端情况下, 二叉搜索树会退化成为单链表, <code>AVL树</code>定义了<strong>旋转操作</strong>, 在<code>平衡因子</code>大于等于2时, <code>AVL树</code>会旋转来调整树的结构, 来重新满足<code>平衡因子</code>小于2</li>
</ul>
<h4 id="树的平衡"><a href="#树的平衡" class="headerlink" title="树的平衡"></a>树的平衡</h4><ul>
<li>左子树的左子树插入结点 (左左)；（右旋）</li>
<li>右子树的右子树插入节点 (右右)；（左旋）</li>
<li>左子树的右子树插入节点 (左右)；（先左旋 后右旋）</li>
<li>右子树的左子树插入节点 (右左)；（先右旋 后左旋）</li>
</ul>
</blockquote>
<h2 id="四-图"><a href="#四-图" class="headerlink" title="四 图"></a>四 图</h2><h3 id="1-最小生成树是否唯一"><a href="#1-最小生成树是否唯一" class="headerlink" title="1. 最小生成树是否唯一"></a>1. 最小生成树是否唯一</h3><blockquote>
<p>最小生成树不唯一，最小生成树代价唯一</p>
<p>解释：Kruskal与prim算法都是贪婪算法，特别的Kruskal算法是Dijkstra算法的变种。</p>
<p>对于一个权重各不相同的无向图来说，这两种算法的最小生成树唯一（权值和自然唯一）。</p>
<p>但是如果在无向图中有两个边的权值相同，则在Kruskal算法中选择更新该边的顶点，还是其他权值相同的边的顶点会导致不同的结论。</p>
<p>与使用不相交集合实现的prim同理，这是贪婪算法的特性，因为局部最优，结果唯一。</p>
<p>特别的贪婪与动态规划都具有唯一确定性，结果都是唯一。不要指望用greed或者dp去求最优解的全集。但两者的区别就是greed保证局部最优，我不管你前因后果，我就管现在我做出最佳选择。DP保证全局最优（通过状态转移方程实现）</p>
</blockquote>
<h3 id="2-如何判断一个图是否有环"><a href="#2-如何判断一个图是否有环" class="headerlink" title="2. 如何判断一个图是否有环"></a>2. 如何判断一个图是否有环</h3><blockquote>
<ol>
<li><p>DFS，如果要访问的元素已经访问过，它在当前的栈内还没出栈，那么就是有环。BFS不行是因为可能有多个节点指向该节点，不一定是因为有环。</p>
</li>
<li><p>拓扑排序，拓扑排序会循环执行以下两步：</p>
<ol>
<li>选择一个入度为0的顶点，输出</li>
<li>从图中删除此顶点以及所有的出边<br>循环结束后，若输出的顶点数小于网中的顶点数，则说明有回路</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="五-哈希表"><a href="#五-哈希表" class="headerlink" title="五 哈希表"></a>五 哈希表</h2><h3 id="0-哈希表"><a href="#0-哈希表" class="headerlink" title="0. 哈希表"></a>0. <a href="https://www.cnblogs.com/zzdbullet/p/10512670.html" target="_blank" rel="noopener">哈希表</a></h3><blockquote>
<p><a href="https://baike.baidu.com/item/散列表/10027933" target="_blank" rel="noopener">散列表</a>（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的<a href="https://baike.baidu.com/item/数据结构/1450" target="_blank" rel="noopener">数据结构</a>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a href="https://baike.baidu.com/item/散列函数/2366288" target="_blank" rel="noopener">散列函数</a>，存放记录的<a href="https://baike.baidu.com/item/数组/3794097" target="_blank" rel="noopener">数组</a>叫做<a href="https://baike.baidu.com/item/散列表/10027933" target="_blank" rel="noopener">散列表</a>。</p>
</blockquote>
<h3 id="1-哈希表的构造方法"><a href="#1-哈希表的构造方法" class="headerlink" title="1. 哈希表的构造方法"></a>1. 哈希表的构造方法</h3><blockquote>
<p> <strong>构造哈希函数的原则</strong></p>
<p> ① 函数本身便于计算；② 计算出来的地址分布均匀，即对任一关键字k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突。</p>
<p> <strong>构造方法</strong></p>
<ol>
<li><p>数字分析法 </p>
<blockquote>
<p>  如果事先知道关键字集合，并且每个关键字的位数比哈希表的地址码位数多时，可以从关键字中选出分布较均匀的若干位，构成哈希地址。</p>
</blockquote>
</li>
<li><p>平方取中法</p>
<blockquote>
<p>  当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。</p>
</blockquote>
</li>
<li><p>分段叠加法</p>
<blockquote>
<p>  按哈希表地址位数将关键字分成位数相等的几部分（最后一部分可以较短），然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。具体方法有<strong>折叠法</strong>与<strong>移位法。</strong></p>
<p>  移位法是将分割后的每部分低位对齐相加；</p>
<p>  折叠法是从一端向另一端沿分割界来回折叠（奇数段为正序，偶数段为倒序），然后将各段相加。</p>
</blockquote>
</li>
<li><p>除留余数法</p>
<blockquote>
<p>  假设哈希表长为m，p为小于等于m的最大素数，则哈希函数为</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">h（k）= k % p; <span class="comment">//其中%为模p取余运算。</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>伪随机数法</p>
<blockquote>
<p> 采用一个伪随机函数做哈希函数，即h(key)=random(key)。</p>
<p>  在实际应用中，应根据具体情况，灵活采用不同的方法，并用实际数据测试它的性能，以便做出正确判定。通常应考虑以下五个因素 ：</p>
<ol>
<li><p>l     计算哈希函数所需时间 （简单）。</p>
</li>
<li><p>l     关键字的长度。</p>
</li>
<li><p>l     哈希表大小。</p>
</li>
<li><p>l     关键字分布情况。</p>
</li>
<li><p>l     记录查找频率</p>
</li>
</ol>
</blockquote>
</li>
</ol>
</blockquote>
<h3 id="2-处理冲突的四种方法"><a href="#2-处理冲突的四种方法" class="headerlink" title="2. 处理冲突的四种方法"></a>2. 处理冲突的四种方法</h3><h4 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1 开放寻址法"></a><strong>1 开放寻址法</strong></h4><blockquote>
<p>这种方法也称<strong>再散列法，</strong>其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：</p>
<p>$     Hi=（H（key）+di）% m  i=1，2，…，n$</p>
<p>其中H（key）为哈希函数，m 为表长，di称为<strong>增量序列。</strong>增量序列的取值方式不同，相应的再散列方式也不同。</p>
<p>主要有以下三种：</p>
<ol>
<li><p>线性探测再散列</p>
<p>  $d_ii=1，2，3，…，m-1$</p>
<p>这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p>
</li>
<li><p>二次探测再散列<br>$$<br>di=12，-12，22，-22，…，k2，-k2  ( k&lt;=m/2 )<br>$$<br>这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。</p>
</li>
<li><p>伪随机探测再散列</p>
<p>$di=伪随机数序列。$</p>
<p>具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。</p>
</li>
</ol>
</blockquote>
<h4 id="2-再哈希法"><a href="#2-再哈希法" class="headerlink" title="2 再哈希法"></a><strong>2 再哈希法</strong></h4><blockquote>
<p>这种方法是同时构造多个不同的哈希函数：<br>$$<br>H_i=RH_1（key） i=1，2，…，k<br>$$<br>当哈希地址$H_i=RH_1(key)$，发生冲突时，再计算$Hi=RH_2(key)$……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
</blockquote>
<h4 id="3-拉链法"><a href="#3-拉链法" class="headerlink" title="3 拉链法"></a>3 拉链法</h4><blockquote>
<p>基本思想：将所有哈希地址为i的元素构成一个称为<strong>同义词链</strong>的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>
</blockquote>
<h4 id="4-建立一个公共的溢出区"><a href="#4-建立一个公共的溢出区" class="headerlink" title="4 建立一个公共的溢出区"></a><strong>4 建立一个公共的溢出区</strong></h4><blockquote>
<p>基本思想是：将哈希表分为<strong>基本表</strong>和<strong>溢出表</strong>两部分，凡是和基本表发生冲突的元素，一律填入溢出表</p>
</blockquote>
<h3 id="3-哈希表的优缺点"><a href="#3-哈希表的优缺点" class="headerlink" title="3. 哈希表的优缺点"></a>3. 哈希表的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><blockquote>
<ol>
<li>冲突少的情况下，访问速度很快</li>
</ol>
</blockquote>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><blockquote>
<ol>
<li>哈希函数的设计需要一些策略</li>
<li>当数的数目较少时，哈希表会有冗余；</li>
<li>当数的数目很多时，哈希表冲突的可能性很大。</li>
<li>扩容机制复杂：在决定建立哈希表之前，最好可以估计输入的数据的size。否则，resize哈希表的过程将会是一个非常消耗时间的过程。例如，如果现在你的哈希表的长度是100，但是现在有第101个数要插入。这时，不仅哈希表的长度可能要扩展到150，且扩展之后所有的数都需要重新rehash。</li>
<li>元素没有被排序：然而有些情况下，我们希望储存的数据是有序的。</li>
</ol>
</blockquote>
<h2 id="六-查找与排序"><a href="#六-查找与排序" class="headerlink" title="六 查找与排序"></a>六 查找与排序</h2><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/849589-20180402133438219-1946132192.png" alt="img" style="zoom: 50%;">



<h3 id="1-各种排序算法及时间复杂度"><a href="#1-各种排序算法及时间复杂度" class="headerlink" title="1 各种排序算法及时间复杂度"></a>1 各种排序算法及时间复杂度</h3><blockquote>
<ol>
<li><p><strong>插入排序</strong>：对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素，插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前元素的下一位中。</p>
</li>
<li><p><strong>希尔排序</strong>：先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关，其最后一个值必须为1.</p>
</li>
<li><p><strong>归并排序</strong>：该算法采用分治法；对于包含m个元素的待排序序列，将其看成m个长度为1的子序列。然后两两合归并，得到n/2个长度为2或者1的有序子序列；然后再两两归并，直到得到1个长度为m的有序序列。</p>
</li>
<li><p><strong>冒泡排序</strong>：对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前前n-i个元素中的最大的元素移到n-i位置。遍历n次，完成排序。</p>
</li>
<li><p><strong>快速排序</strong>：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
</li>
<li><p><strong>选择排序</strong>：每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空。</p>
</li>
<li><p><strong>堆排序</strong>：堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆（升序）/最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素交换位置，此时末尾元素就是最大/最小的值。然后将剩余n-1个元素重新构造成最大堆/最小堆。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>稳定的排序算法：基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序</p>
<p>不稳定的排序算法：快些选堆（快速，希尔排序，直接选择排序（可以改造成稳定的），堆排序）。</p>
</blockquote>
<h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2 快速排序"></a>2 快速排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">     quicksort(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">return</span> nums;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">int</span> num = nums[low];</span><br><span class="line">     <span class="keyword">int</span> left = low+<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> right = high;</span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">         <span class="keyword">while</span>(left&lt;=right &amp;&amp; nums[left]&lt;=num) left++;</span><br><span class="line">         <span class="keyword">while</span>(left&lt;=right &amp;&amp; nums[right]&gt;=num) right--;</span><br><span class="line">         <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         swap(nums[left],nums[right]);</span><br><span class="line">     &#125;</span><br><span class="line">     nums[low] = nums[right];</span><br><span class="line">     nums[right] = num;</span><br><span class="line">     quicksort(nums,low,right<span class="number">-1</span>);</span><br><span class="line">     quicksort(nums,right+<span class="number">1</span>,high);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3    堆排序"></a>3    堆排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Max_Heapify</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> i,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>*i;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> large = i;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= size &amp;&amp; A[l] &gt; A[i])</span><br><span class="line">        large = l;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        large = i;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= size &amp;&amp; A[r] &gt; A[large])</span><br><span class="line">        large = r;</span><br><span class="line">    <span class="keyword">if</span>(large != i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = A[large];</span><br><span class="line">        A[large] = A[i];</span><br><span class="line">        A[i] = t;</span><br><span class="line">        Max_Heapify(A, large, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build_Max_Heap</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=size/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        Max_Heapify(A,i,size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    Build_Max_Heap(A, len);</span><br><span class="line">    <span class="keyword">while</span>(len<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = A[<span class="number">1</span>];</span><br><span class="line">        A[<span class="number">1</span>] = A[i];</span><br><span class="line">        A[i] = t;</span><br><span class="line">        len--;</span><br><span class="line">        Max_Heapify(A,<span class="number">1</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="七-高级算法"><a href="#七-高级算法" class="headerlink" title="七 高级算法"></a>七 高级算法</h2><h3 id="1-KMP算法"><a href="#1-KMP算法" class="headerlink" title="1. KMP算法"></a>1. KMP算法</h3><blockquote>
<p>核心：部分匹配表（PMT）<strong>PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度</strong></p>
<p>PMT的意义：例如，对于”aba”，它的前缀集合为{”a”, ”ab”}，后缀 集合为{”ba”, ”a”}。两个集合的交集为{”a”}，那么长度最长的元素就是字符串”a”了，长 度为1，所以对于”aba”而言，它在PMT表中对应的值就是1。再比如，对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。</p>
<p>主要思路：简言之，以图中的例子来说，在 i 处失配，那么主字符串和模式字符串的前边6位就是相同的。又因为模式字符串的前6位，它的前4位前缀和后4位后缀是相同的，所以我们推知主字符串i之前的4位和模式字符串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p>
<img src="https://pic2.zhimg.com/80/v2-03a0d005badd0b8e7116d8d07947681c_720w.jpg?source=1940ef5c" alt="img" style="zoom:80%;">

<p>有了上面的思路，我们就可以使用PMT加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值，所以为了编程的方便， 我们不直接使用PMT数组，而是将PMT数组向后偏移一位。我们把新得到的这个数组称为next数组。下面给出根据next数组进行字符串匹配加速的字符串匹配程序。其中要注意的一个技巧是，在把PMT进行向右偏移时，第0位的值，我们将其设成了-1，这只是为了编程的方便，并没有其他的意义。在本节的例子中，next数组如下表所示。</p>
<img src="https://pic3.zhimg.com/80/v2-40b4885aace7b31499da9b90b7c46ed3_720w.jpg?source=1940ef5c" alt="img" style="zoom:67%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> * t, <span class="keyword">char</span> * p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(t) &amp;&amp; j &lt; <span class="built_in">strlen</span>(p))&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || t[i] == p[j]) &#123;</span><br><span class="line">			i++;</span><br><span class="line">     	j++;</span><br><span class="line">		&#125;</span><br><span class="line">	 	<span class="keyword">else</span> &#123;</span><br><span class="line">      j = next[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="built_in">strlen</span>(p))</span><br><span class="line"> <span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们再看一下如何编程快速求得next数组。其实，求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。</p>
<p>具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。如下图所示。</p>
<p>求next数组的程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> * p, <span class="keyword">int</span> * next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(p))&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || p[i] == p[j])&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">			next[i] = j;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j = next[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="拓展题目"><a href="#拓展题目" class="headerlink" title="拓展题目"></a>拓展题目</h4><h5 id="1392-最长快乐前缀"><a href="#1392-最长快乐前缀" class="headerlink" title="1392. 最长快乐前缀"></a><a href="https://leetcode-cn.com/problems/longest-happy-prefix/" target="_blank" rel="noopener">1392. 最长快乐前缀</a></h5><p>「快乐前缀」是在原字符串中既是 <strong>非空</strong> 前缀也是后缀（不包括原字符串自身）的字符串。给你一个字符串 <code>s</code>，请你返回它的 <strong>最长快乐前缀</strong>。如果不存在满足题意的前缀，则返回一个空字符串。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;level&quot;</span><br><span class="line">输出：&quot;l&quot;</span><br><span class="line">解释：不包括 s 自己，一共有 4 个前缀（&quot;l&quot;, &quot;le&quot;, &quot;lev&quot;, &quot;leve&quot;）和 4 个后缀（&quot;l&quot;, &quot;el&quot;, &quot;vel&quot;, &quot;evel&quot;）。最长的既是前缀也是后缀的字符串是 &quot;l&quot; 。</span><br></pre></td></tr></table></figure>

<p>使用KMP算法进行求解</p>
<p>思想：「最长快乐前缀」就是最长的既是前缀也是后缀的字符串，因此我们使用 KMP 算法计算出数组 \textit{fail}<em>fail<em>，那么 s</em>s</em> 的长度为 \textit{fail}[s.\textit{length} - 1] + 1<em>fail</em>[<em>s</em>.<em>length</em>−1]+1 的前缀（或者后缀）即为答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPrefix</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">          <span class="keyword">int</span> j = next[i<span class="number">-1</span>];</span><br><span class="line">          <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;s[j+<span class="number">1</span>]!=s[i])&#123;</span><br><span class="line">              j = next[j];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(s[j+<span class="number">1</span>]==s[i])&#123;</span><br><span class="line">              next[i] = j+<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> s.substr(<span class="number">0</span>,next[n<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-Manacher算法-马拉车算法"><a href="#2-Manacher算法-马拉车算法" class="headerlink" title="2. Manacher算法(马拉车算法)"></a>2. Manacher算法(马拉车算法)</h3><blockquote>
<p><strong>Manacher算法是一个用来查找一个字符串中的最长回文子串(不是最长回文序列)的线性算法。它的优点就是把时间复杂度为O(n2)的暴力算法优化到了O(n)。</strong></p>
<p><strong>基本概念</strong></p>
<ol>
<li>ManacherString：经过Manacher预处理的字符串，以下的概念都是基于ManasherString产生的。</li>
<li>回文半径和回文直径：因为处理后回文字符串的长度一定是奇数，所以回文半径是包括回文中心在内的回文子串的一半的长度，回文直径则是回文半径的2倍减1。比如对于字符串 “aba”，在字符 ‘b’ 处的回文半径就是2，回文直径就是3。</li>
<li>最右回文边界R：在遍历字符串时，每个字符遍历出的最长回文子串都会有个右边界，而R则是所有已知右边界中最靠右的位置，也就是说R的值是只增不减的。</li>
<li>回文中心C：取得当前R的第一次更新时的回文中心。由此可见R和C时伴生的。</li>
<li>半径数组：这个数组记录了原字符串中每一个字符对应的最长回文半径。</li>
</ol>
<p><strong>基本步骤</strong>：</p>
<ol>
<li>字符串预处理。把偶数回文串都变成奇数回文串</li>
<li>R和C的初始值为-1，创建半径数组pArr</li>
<li>开始从下标 i = 0去遍历字符串S<ol>
<li>i &gt; R ，也就是i在R外，此时没有什么花里胡哨的方法，直接暴力匹配，此时记得看看C和R要不要更新。</li>
<li>i &lt;= R，也就是i在R内，此时分三种情况，在讨论这三个情况前，我们先构建一个模型。L是当前R关于C的对称点，i’是i关于C的对称点，可知 i’ = 2*C - i，并且我们会发现，i’的回文区域是我们已经求过的，从这里我们就可以开始判断是不是可以进行加速处理了<ol>
<li>i’的回文区域在L-R的内部，此时i的回文直径与 i’ 相同，我们可以直接得到i的回文半径；</li>
<li>i’的回文区域左边界超过了L，此时i的回文半径则是i到R；</li>
<li>i’ 的回文区域左边界恰好和L重合，此时i的回文半径最少是i到R，回文区域从R继续向外部匹配。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>我们可以计算出时间复杂度为何是线性的，分支一的情况下时间时间复杂度是O(n)，分支二的前两种情况都是O(1)，分支二的第三种情况，我们可能会出现O(1)——无法从R继续向后匹配，也可能出现O(n)——可以从R继续匹配，即使可以继续匹配，R的值也会增大，这样会影响到后续的遍历匹配复杂度，所以综合起来整个算法的时间复杂度就是线性的，也就是O(n)。</p>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">     <span class="built_in">string</span> t = <span class="string">"$#"</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> &amp;c: s) &#123;</span><br><span class="line">         t += c;</span><br><span class="line">         t += <span class="string">'#'</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     n = t.<span class="built_in">size</span>();</span><br><span class="line">     t += <span class="string">'!'</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">auto</span> f = <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; (n);</span><br><span class="line">     <span class="keyword">int</span> iMax = <span class="number">0</span>, rMax = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">         <span class="comment">// 初始化 f[i]</span></span><br><span class="line">         f[i] = (i &lt;= rMax) ? <span class="built_in">min</span>(rMax - i + <span class="number">1</span>, f[<span class="number">2</span> * iMax - i]) : <span class="number">1</span>;</span><br><span class="line">         <span class="comment">// 中心拓展</span></span><br><span class="line">         <span class="keyword">while</span> (t[i + f[i]] == t[i - f[i]]) ++f[i];</span><br><span class="line">         <span class="comment">// 动态维护 iMax 和 rMax</span></span><br><span class="line">         <span class="keyword">if</span> (i + f[i] - <span class="number">1</span> &gt; rMax) &#123;</span><br><span class="line">             iMax = i;</span><br><span class="line">             rMax = i + f[i] - <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整</span></span><br><span class="line">         ans += (f[i] / <span class="number">2</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-洗牌算法"><a href="#3-洗牌算法" class="headerlink" title="3. 洗牌算法"></a>3. 洗牌算法</h3><blockquote>
<h4 id="1、Fisher-Yates-Shuffle算法"><a href="#1、Fisher-Yates-Shuffle算法" class="headerlink" title="1、Fisher-Yates Shuffle算法"></a>1、Fisher-Yates Shuffle算法</h4><p>最早提出这个洗牌方法的是 Ronald A. Fisher 和 Frank Yates，即 Fisher–Yates Shuffle。</p>
<p>基本思想就是<strong>从原始数组中随机取一个之前没取过的数字到新的数组中</strong>，具体如下：</p>
<ol>
<li>初始化原始数组和新数组，原始数组长度为n(已知)。</li>
<li>还没处理的数组（假如还剩k个）中，随机产生一个[0, k)之间的数字p（假设数组从0开始）。</li>
<li>剩下的k个数中把第p个数取出。</li>
<li>重复步骤2和3直到数字全部取完。</li>
<li>从步骤3取出的数字序列便是一个打乱了的数列。</li>
</ol>
<p>时间复杂度为O(n*n)，空间复杂度为O(n)。</p>
<h4 id="2、Knuth-Durstenfeld-Shuffle"><a href="#2、Knuth-Durstenfeld-Shuffle" class="headerlink" title="2、Knuth-Durstenfeld Shuffle"></a>2、Knuth-Durstenfeld Shuffle</h4><p>Knuth 和 Durstenfeld  在Fisher 等人的基础上对算法进行了改进，在原始数组上对数字进行交互，省去了额外O(n)的空间。该算法的基本思想和 Fisher 类似，每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。</p>
<p>算法步骤为：</p>
<ol>
<li>建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值；</li>
<li>生成一个从 0 到 n - 1 的随机数 x；</li>
<li>输出 arr 下标为 x 的数值，即为第一个随机数；</li>
<li>将 arr 的尾元素和下标为 x 的元素互换；</li>
<li>同2，生成一个从 0 到 n - 2 的随机数 x；</li>
<li>输出 arr 下标为 x 的数值，为第二个随机数；</li>
<li>将 arr 的倒数第二个元素和下标为 x 的元素互换；</li>
</ol>
<p>……</p>
<p>如上，直到输出m 个数为止</p>
<p>时间复杂度为O(n)，空间复杂度为O(1)，缺点必须知道数组长度n。</p>
</blockquote>
<h1 id="三-操作系统"><a href="#三-操作系统" class="headerlink" title="三 操作系统"></a>三 操作系统</h1><h2 id="一-系统概念"><a href="#一-系统概念" class="headerlink" title="一 系统概念"></a>一 系统概念</h2><h3 id="1-并发和并行"><a href="#1-并发和并行" class="headerlink" title="1. 并发和并行"></a>1. 并发和并行</h3><blockquote>
<p>并发（concurrency）：指宏观上看起来两个程序在同时运行。</p>
<p>比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p>
<p>并行（parallelism）：指严格物理意义上的同时运行。</p>
<p>比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p>
<ul>
<li>并发不加以控制会带来数据的不一致性问题，而对并发加以控制了，也就是加锁了，但是锁的控制没有弄好，才会带来死锁问题</li>
</ul>
</blockquote>
<h3 id="2-用户态和内核态的区别"><a href="#2-用户态和内核态的区别" class="headerlink" title="2. 用户态和内核态的区别"></a>2. 用户态和内核态的区别</h3><blockquote>
<p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。</p>
<p>用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。</p>
<p>内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</p>
</blockquote>
<h3 id="3-为什么要分内核态和用户态"><a href="#3-为什么要分内核态和用户态" class="headerlink" title="3. 为什么要分内核态和用户态"></a>3. 为什么要分内核态和用户态</h3><blockquote>
<p>为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。</p>
<p>分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。</p>
</blockquote>
<h3 id="4-用户态到内核态的方式"><a href="#4-用户态到内核态的方式" class="headerlink" title="4. 用户态到内核态的方式"></a>4. 用户态到内核态的方式</h3><blockquote>
<p>1、<strong>系统调用</strong></p>
<p>这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。</p>
<p>2、<strong>异常</strong></p>
<p>当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此异常的内核相关程序中，也就到了内核态，比如缺页异常。</p>
<p>3、<strong>外围设备的中断</strong></p>
<p>当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</blockquote>
<p>2）切换操作</p>
<blockquote>
<p>从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的。</p>
</blockquote>
<p>用户态切换到内核态的步骤主要包括：</p>
<blockquote>
<p>1、从当前进程的描述符中提取其内核栈的ss0及esp0信息。</p>
<p>2、使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</p>
<p>3、将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</p>
</blockquote>
<h3 id="5-微内核与宏内核"><a href="#5-微内核与宏内核" class="headerlink" title="5. 微内核与宏内核"></a>5. 微内核与宏内核</h3><p>宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。</p>
<blockquote>
<p>优点：效率高。</p>
<p>缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。</p>
</blockquote>
<p>微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。</p>
<blockquote>
<p>优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃</p>
<p>缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。</p>
</blockquote>
<h3 id="6-中断和异常"><a href="#6-中断和异常" class="headerlink" title="6. 中断和异常"></a>6. 中断和异常</h3><h4 id="操作系统中的中断"><a href="#操作系统中的中断" class="headerlink" title="操作系统中的中断"></a>操作系统中的中断</h4><blockquote>
<p>中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。中断一般三类，一种是由CPU外部引起的，如I/O中断、时钟中断，一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出），最后一种是在程序中使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。</p>
</blockquote>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><blockquote>
<p>中断指 <strong>CPU</strong> 对系统发生某事件时的这样一种响应<strong>:</strong> </p>
<p>CPU 暂停正在执行的程序，在保留现场后自动地转去执行该事件的中断处理程序；执行完后，再返回到原程序的断点处继续执行。</p>
</blockquote>
<h4 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h4><blockquote>
<ul>
<li>外中断——就是我们指的<strong>中断</strong>——是指由于外部设备事件所引起的中断，如通常的磁盘中断、打印机中断等；</li>
<li>内中断——就是<strong>异常</strong>——是指由于 CPU 内部事件所引起的中断，如程序出错(非法指令、地址越界)。内中断(trap)也被译为“<strong>捕获</strong>”或“<strong>陷入</strong>”。</li>
</ul>
</blockquote>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><blockquote>
<p>异常是由于执行了现行指令所引起的。由于系统调用引起的中断属于异常。</p>
</blockquote>
<h4 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h4><blockquote>
<ul>
<li><p>相同点：都是CPU对系统发生的某个事情做出的一种反应。</p>
</li>
<li><p>区别：中断由外因引起，异常由CPU本身原因引起。</p>
</li>
</ul>
</blockquote>
<h4 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h4><blockquote>
<p><strong>中断的引入</strong>——为了支持CPU和设备之间的并行操作</p>
<p><strong>异常的引入</strong>——表示CPU执行指令时本身出现的问题</p>
</blockquote>
<h4 id="引发中断或异常的事件"><a href="#引发中断或异常的事件" class="headerlink" title="引发中断或异常的事件"></a>引发中断或异常的事件</h4><blockquote>
<ul>
<li><strong>中断</strong>——<strong>外部事件引起</strong>，<strong>正在运行的程序所不期望的</strong></li>
<li><strong>异常</strong>——<strong>内部执行指令引起</strong></li>
</ul>
</blockquote>
<img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/20190328033536613.png" alt="img" style="zoom: 80%;">

<img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/20190328033643556.png" alt="img" style="zoom:80%;">



<h2 id="二-进程与线程"><a href="#二-进程与线程" class="headerlink" title="二 进程与线程"></a>二 进程与线程</h2><h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1 进程与线程"></a>1 进程与线程</h3><blockquote>
<p><strong>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位</strong>，实现了操作系统的并发；</p>
<p><strong>线程是进程的子任务，是CPU调度和分派的基本单位</strong>，用于保证程序的实时性，实现进程内部的并发；每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p>
</blockquote>
<h4 id="1-进程与线程的区别"><a href="#1-进程与线程的区别" class="headerlink" title="1 进程与线程的区别"></a>1 进程与线程的区别</h4><blockquote>
<ol>
<li><p><strong>一个线程只能属于一个进程，而一个进程可以有多个线程</strong>，但至少有一个线程。线程依赖于进程而存在。</p>
</li>
<li><p><strong>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</strong>（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</p>
</li>
<li><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位；</strong></p>
</li>
<li><p><strong>系统开销</strong>： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。</p>
<p>类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，<strong>进程切换的开销也远大于线程切换的开销。</strong></p>
</li>
<li><p><strong>通信：</strong>由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信—需要进程同步和互斥手段的辅助，以保证数据的一致性。</p>
</li>
<li><p><strong>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</strong></p>
</li>
</ol>
</blockquote>
<h4 id="2-线程产生的原因"><a href="#2-线程产生的原因" class="headerlink" title="2 线程产生的原因"></a>2 线程产生的原因</h4><blockquote>
<p>进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量；但有一些缺点：</p>
<ol>
<li><p>进程在同一时间只能干一件事</p>
</li>
<li><p>进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。</p>
</li>
</ol>
<p>因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。</p>
<p>和进程相比，线程的优势如下：</p>
<ul>
<li><p>从<strong>资源</strong>上来讲，线程是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。</p>
</li>
<li><p>从<strong>切换效率</strong>上来讲，运行于进程中的多个线程将使用相同的地址空间，线程间切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。</p>
</li>
<li><p>从<strong>通信机制</strong>上来讲，线程间方便的通信机制。不同进程具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。</p>
</li>
</ul>
<p>除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：</p>
<p>1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</p>
<p>2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。</p>
</blockquote>
<h4 id="3-多进程和多线程的使用场景"><a href="#3-多进程和多线程的使用场景" class="headerlink" title="3 多进程和多线程的使用场景"></a>3 多进程和多线程的使用场景</h4><blockquote>
<ol>
<li>多线程模型主要优势为线程间切换代价较小，因此适用于I/O密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多核分布式场景。</li>
<li>多进程模型的优势是CPU，适用于CPU密集型。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。</li>
</ol>
</blockquote>
<h3 id="2-进程的通信方式"><a href="#2-进程的通信方式" class="headerlink" title="2 进程的通信方式"></a>2 进程的通信方式</h3><p><strong>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket</strong>。</p>
<blockquote>
<ol>
<li><p>管道：速度慢，容量有限，只有父子进程能通讯   </p>
</li>
<li><p>命名管道：任何进程间都能通讯，但速度慢   </p>
</li>
<li><p>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题   </p>
</li>
<li><p>信号量：不能传递复杂消息，只能用来同步   </p>
</li>
<li><p>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存</p>
</li>
</ol>
</blockquote>
<p><strong>linux下的多个进程间的通信机制叫做IPC(Inter-Process Communication)，它是多个进程之间相互沟通的一种方法</strong></p>
<blockquote>
<ol>
<li>管道(pipe)：管道用于具有亲缘关系的进程间的通信，是一种半双工的方式，数据只能单向流动，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li>
<li>命名管道(named pipe)：命名管道克服了管道没有名字的限制，同时除了具有管道的功能外（也是半双工），它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li>
<li>信号（signal）：信号是比较复杂的通信方式，用于通知接收进程有某种事件发生，除了进程间通信外，进程还可以发送信号给进程本身。</li>
<li>消息队列：消息队列是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</li>
<li>共享内存：使多个进程可访问同一块内存空间，是最快的可用IPC形式。往往与信号量等通信机制结合使用，来实现进程间的同步及互斥。</li>
<li>内存映射：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>
<li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li>
<li>套接字（Socket）：可用于不同机器之间的进程间通信。</li>
</ol>
</blockquote>
<h4 id="1-管道"><a href="#1-管道" class="headerlink" title="1 管道"></a>1 管道</h4><blockquote>
<p><strong>本质</strong></p>
<blockquote>
<p>管道是由内核管理的一个缓冲区，是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。</p>
</blockquote>
<p><strong>特点</strong></p>
<blockquote>
<p>1、管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；<br>2、只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。比如fork或exec创建的新进程，在使用exec创建新进程时，需要将管道的文件描述符作为参数传递给exec创建的新进程。当父进程与使用fork创建的子进程直接通信时，发送数据的进程关闭读端，接受数据的进程关闭写端。<br>3、单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。<br>4、数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p>
</blockquote>
<p><strong>分类</strong></p>
<blockquote>
<p>管道主要包括无名管道和命名管道；</p>
<p>管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p>
<p>1 普通管道PIPE</p>
<ul>
<li><p>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p>
</li>
<li><p>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p>
</li>
<li><p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
</li>
</ul>
<p>2 命名管道FIFO</p>
<p>命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了管道的弊端，他可以允许没有亲缘关系的进程间通信。 </p>
<ul>
<li>FIFO可以在无关的进程之间交换数据</li>
<li>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2 消息队列"></a>2 消息队列</h4><blockquote>
<p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。</p>
<p>消息队列是内核地址空间中的内部链表，通过linux内核在各个进程直接传递内容，消息顺序地发送到消息队列中，并以几种不同的方式从队列中获得，每个消息队列可以用IPC标识符唯一地进行识别。内核中的消息队列是通过IPC的标识符来区别，不同的消息队列直接是相互独立的。每个消息队列中的消息，又构成一个独立的链表。</p>
<p>(消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p>
</blockquote>
<p><strong>特点</strong></p>
<blockquote>
<ul>
<li><p>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
</li>
<li><p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
</li>
<li><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
</li>
</ul>
</blockquote>
<h4 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3 信号量"></a>3 信号量</h4><blockquote>
<p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。</p>
<p>信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
</blockquote>
<p>特点</p>
<blockquote>
<ul>
<li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</li>
<li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</li>
<li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li>
<li>支持信号量组。</li>
</ul>
</blockquote>
<h4 id="4-信号"><a href="#4-信号" class="headerlink" title="4 信号"></a>4 信号</h4><blockquote>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
</blockquote>
<h4 id="5-共享内存"><a href="#5-共享内存" class="headerlink" title="5 共享内存"></a>5 共享内存</h4><blockquote>
<p>共享内存使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。</p>
<p>这种方式需要依靠某种同步操作，如互斥锁和信号量等</p>
</blockquote>
<p>特点</p>
<blockquote>
<ul>
<li>共享内存是最快的一种IPC，因为进程是直接对内存进行存取</li>
<li>因为多个进程可以同时操作，所以需要进行同步</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</li>
</ul>
</blockquote>
<h4 id="6-套接字SOCKET"><a href="#6-套接字SOCKET" class="headerlink" title="6 套接字SOCKET"></a>6 套接字SOCKET</h4><blockquote>
<p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p>
</blockquote>
<h3 id="3-线程的通信方式和同步方式"><a href="#3-线程的通信方式和同步方式" class="headerlink" title="3 线程的通信方式和同步方式"></a>3 线程的通信方式和同步方式</h3><h4 id="线程之间的通信方式"><a href="#线程之间的通信方式" class="headerlink" title="线程之间的通信方式"></a>线程之间的通信方式</h4><blockquote>
<ol>
<li><p>全局变量</p>
<p>主要由于多个线程可能更改全局变量，因此全局变量最好声明为volatile</p>
</li>
<li><p>使用消息实现通信<br> 在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。</p>
</li>
<li><p>使用事件CEvent类实现线程间通信<br>Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。</p>
</li>
</ol>
</blockquote>
<h4 id="线程间的同步方式"><a href="#线程间的同步方式" class="headerlink" title="线程间的同步方式"></a>线程间的同步方式</h4><blockquote>
<ol>
<li>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</li>
<li>互斥量<code>Synchronized/Lock</code>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</li>
<li>信号量<code>Semphare</code>：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</li>
<li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li>
</ol>
</blockquote>
<h5 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1 临界区"></a>1 临界区</h5><blockquote>
<p>通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p>
<p>临界区对应着一个CcriticalSection对象，当线程需要访问保护数据时，调用EnterCriticalSection函数；当对保护数据的操作完成之后，调用LeaveCriticalSection函数释放对临界区对象的拥有权，以使另一个线程可以夺取临界区对象并访问受保护的数据。</p>
</blockquote>
<h5 id="2-互斥量"><a href="#2-互斥量" class="headerlink" title="2 互斥量"></a>2 互斥量</h5><blockquote>
<p>互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：</p>
<ul>
<li>pthread_mutex_init:初始化互斥锁</li>
<li>pthread_mutex_destroy：销毁互斥锁</li>
<li>pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。</li>
<li>pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。</li>
</ul>
</blockquote>
<h5 id="3-信号量-1"><a href="#3-信号量-1" class="headerlink" title="3 信号量"></a>3 信号量</h5><blockquote>
<p>信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：</p>
<p>P(SV)：如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。wait()</p>
<p>V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。notify()</p>
<p>其系统调用为：</p>
<ul>
<li>sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</li>
<li>sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</li>
</ul>
<p>× 信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程访问同一个资源，PV操作</p>
</blockquote>
<h5 id="4-条件变量"><a href="#4-条件变量" class="headerlink" title="4 条件变量"></a>4 条件变量</h5><blockquote>
<p>条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：</p>
<ul>
<li>pthread_cond_init:初始化条件变量</li>
<li>pthread_cond_destroy：销毁条件变量</li>
<li>pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。</li>
<li>pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。</li>
</ul>
</blockquote>
<h4 id="5-事件-信号-，Wait-Notify："><a href="#5-事件-信号-，Wait-Notify：" class="headerlink" title="5 事件(信号)，Wait/Notify："></a>5 事件(信号)，Wait/Notify：</h4><blockquote>
<p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>
</blockquote>
<h3 id="4-线程之间共享-独享的资源？"><a href="#4-线程之间共享-独享的资源？" class="headerlink" title="4 线程之间共享/独享的资源？"></a>4 线程之间共享/独享的资源？</h3><p>共享的资源</p>
<blockquote>
<ol>
<li><p>堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）</p>
</li>
<li><p>全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的</p>
</li>
<li><p>静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的</p>
</li>
<li><p>文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。</p>
</li>
</ol>
</blockquote>
<p>独享的资源有</p>
<blockquote>
<p>a. 栈 栈是独享的</p>
<p>b. 寄存器  这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC</p>
</blockquote>
<p><strong>线程共享的环境包括：</strong></p>
<blockquote>
<p>进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p>
</blockquote>
<h3 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5 线程池"></a>5 线程池</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。</p>
</blockquote>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><blockquote>
<p>在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。</p>
<p>一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</p>
</blockquote>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><blockquote>
<p>多线程运行时间，系统不断的启动和关闭新线程，成本非常高，会过渡消耗系统资源，以及过渡切换线程的危险，从而可能导致系统资源的崩溃。这时，线程池就是最好的选择了。</p>
</blockquote>
<h4 id="死循环-来连接时新建线程的方法效率有点低，怎么改进？"><a href="#死循环-来连接时新建线程的方法效率有点低，怎么改进？" class="headerlink" title="死循环+来连接时新建线程的方法效率有点低，怎么改进？"></a>死循环+来连接时新建线程的方法效率有点低，怎么改进？</h4><blockquote>
<p>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll 这样的技术。</p>
</blockquote>
<h3 id="6-进程和线程的状态"><a href="#6-进程和线程的状态" class="headerlink" title="6 进程和线程的状态"></a>6 进程和线程的状态</h3><h4 id="进程的五种基本状态"><a href="#进程的五种基本状态" class="headerlink" title="进程的五种基本状态"></a>进程的五种基本状态</h4><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470678794_F9BF116BD97A95A5E655DF9E1672186F" alt="img"></p>
<blockquote>
<p>1）创建状态：进程正在被创建</p>
<p>2）就绪状态：进程被加入到就绪队列中等待CPU调度运行</p>
<p>3）执行状态：进程正在被运行</p>
<p>4）等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。</p>
<p>5）终止状态：进程运行完毕</p>
</blockquote>
<h4 id="线程的五种状态"><a href="#线程的五种状态" class="headerlink" title="线程的五种状态"></a>线程的五种状态</h4><p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/20161017181631639" alt="img"></p>
<blockquote>
<ol>
<li><p>新建状态：当用new操作符创建一个线程时。此时程序还没有开始运行线程中的代码。</p>
</li>
<li><p>就绪状态：一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。</p>
<p>处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序来调度的。</p>
</li>
<li><p>运行状态（running）当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法。</p>
</li>
<li><p>阻塞状态（blocked）</p>
<p>线程运行过程中，可能由于各种原因进入阻塞状态：</p>
<p>① 线程通过调用sleep方法进入睡眠状态；</p>
<p>② 线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；</p>
<p>③ 线程试图得到一个锁，而该锁正被其他线程持有；</p>
<p>④ 线程在等待某个触发条件；</p>
<p>所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。</p>
</li>
<li><p>死亡状态（dead）</p>
<p>有两个原因会导致线程死亡：</p>
<p>① run方法正常退出而自然死亡；</p>
<p>② 一个未捕获的异常终止了run方法而使线程猝死；</p>
<p>为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法，如果是可运行或被阻塞，这个方法返回true；如果线程仍旧是new状态且不是可运行的，或者线程死亡了，则返回false。</p>
</li>
</ol>
</blockquote>
<h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><blockquote>
<p>当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O。</p>
<p>针对以上问题，提出了两种解决方法：</p>
<p>1）交换技术：换出一部分进程到外存，腾出内存空间。</p>
<p>2）虚拟存储技术：每个进程只能装入一部分程序和数据。</p>
<p>在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。</p>
<p>从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。</p>
</blockquote>
<p>3、活动阻塞，静止阻塞，活动就绪，静止就绪</p>
<blockquote>
<p>1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。</p>
<p>2）静止阻塞：进程在外存，同时被某种原因阻塞了。</p>
<p>3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。</p>
<p>4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。</p>
</blockquote>
<p>从而出现了：</p>
<blockquote>
<p>活动就绪 ——  静止就绪    （内存不够，调到外存）</p>
<p>活动阻塞 ——  静止阻塞    （内存不够，调到外存）</p>
<p>执行   ——  静止就绪     （时间片用完）</p>
</blockquote>
<h3 id="7-多线程同步、锁的机制"><a href="#7-多线程同步、锁的机制" class="headerlink" title="7 多线程同步、锁的机制"></a>7 多线程同步、锁的机制</h3><blockquote>
<p>同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。</p>
<p>对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。</p>
<p>如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。</p>
<p>在这种方式下，每次只有一个线程可以向前执行</p>
</blockquote>
<h3 id="8-常用的线程模型"><a href="#8-常用的线程模型" class="headerlink" title="8 常用的线程模型"></a>8 常用的线程模型</h3><h4 id="1-Future模型"><a href="#1-Future模型" class="headerlink" title="1 Future模型"></a>1 Future模型</h4><blockquote>
<p>该模型通常在使用的时候需要结合Callable接口配合使用。</p>
<p>Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。</p>
<p>Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。</p>
</blockquote>
<h4 id="2-fork-amp-join模型"><a href="#2-fork-amp-join模型" class="headerlink" title="2 fork&amp;join模型"></a>2 fork&amp;join模型</h4><blockquote>
<p>该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。</p>
<p>这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。</p>
</blockquote>
<h4 id="3-actor模型"><a href="#3-actor模型" class="headerlink" title="3 actor模型"></a>3 actor模型</h4><blockquote>
<p>actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。</p>
</blockquote>
<h4 id="4-生产者消费者模型"><a href="#4-生产者消费者模型" class="headerlink" title="4 生产者消费者模型"></a>4 生产者消费者模型</h4><blockquote>
<p>生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。</p>
</blockquote>
<h4 id="5-master-worker模型"><a href="#5-master-worker模型" class="headerlink" title="5 master-worker模型"></a>5 master-worker模型</h4><blockquote>
<p>master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。</p>
</blockquote>
<h3 id="9-协程"><a href="#9-协程" class="headerlink" title="9 协程"></a>9 协程</h3><blockquote>
<p><strong>概念</strong></p>
<p>协程，又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执<strong>行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</strong></p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span> :</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">'1'</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">'2'</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">'3'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span> :</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">'x'</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">'y'</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">'z'</span></span><br></pre></td></tr></table></figure>

<p>由协程运行结果可能是<code>12x3yz</code>。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。</p>
</blockquote>
<p><strong>协程和线程区别</strong></p>
<blockquote>
<p>那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p><strong>其他</strong></p>
<p>在协程上利用多核CPU呢——多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p>
</blockquote>
<h3 id="10-进程的种类"><a href="#10-进程的种类" class="headerlink" title="10 进程的种类"></a>10 进程的种类</h3><h4 id="正常进程"><a href="#正常进程" class="headerlink" title="正常进程"></a>正常进程</h4><blockquote>
<p>正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p>
<p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：</p>
<p>1 进程号the process ID</p>
<p>2 退出状态the termination status of the process</p>
<p>3 运行时间the amount of CPU time taken by the process等</p>
</blockquote>
<h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><blockquote>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
</blockquote>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><blockquote>
<p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</p>
<p>僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。</p>
<p><strong>查看僵尸进程</strong></p>
<p>如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。</p>
<p>如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>
<p><strong>危害</strong></p>
<p>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p><strong>外部消灭</strong></p>
<p>通过<code>kill</code>发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源</p>
<p><strong>内部解决</strong></p>
<p>1、子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</p>
<p>2、fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。</p>
</blockquote>
<h3 id="11-线程需要保存哪些上下文，SP、PC、EAX-这些寄存器的作用。"><a href="#11-线程需要保存哪些上下文，SP、PC、EAX-这些寄存器的作用。" class="headerlink" title="11 线程需要保存哪些上下文，SP、PC、EAX 这些寄存器的作用。"></a>11 线程需要保存哪些上下文，SP、PC、EAX 这些寄存器的作用。</h3><blockquote>
<p>线程在切换的过程中需要保存<strong>当前线程Id、线程状态、堆栈、寄存器状态</strong>等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：</p>
<ul>
<li>SP:堆栈指针，指向当前栈的栈顶地址</li>
<li>PC:程序计数器，存储下一条将要执行的指令</li>
<li>EAX:累加寄存器，用于加法乘法的缺省寄存器</li>
</ul>
</blockquote>
<h3 id="12-fork和vfork的区别"><a href="#12-fork和vfork的区别" class="headerlink" title="12 fork和vfork的区别"></a>12 fork和vfork的区别</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><blockquote>
<p>fork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>成功调用<code>fork( )</code>会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
</blockquote>
<h4 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h4><blockquote>
<p>在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">vfork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用所产生的结果和fork( )是一样的。vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像。通过这样的方式，vfork( )避免了地址空间的按页复制。在这个过程中，父进程和子进程共享相同的地址空间和页表项。实际上vfork( )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。</p>
<p>vfork( )是一个历史遗留产物，Linux本不应该实现它。需要注意的是，即使增加了写时复制，vfork( )也要比fork( )快，因为它没有进行页表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork( )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可行的。</p>
</blockquote>
<h4 id="补充知识点：写时复制"><a href="#补充知识点：写时复制" class="headerlink" title="补充知识点：写时复制"></a>补充知识点：写时复制</h4><blockquote>
<p>Linux采用了写时复制的方法，以减少fork时对父进程空间进程整体复制带来的开销。</p>
<p>写时复制是一种采取了惰性优化方法来避免复制时的系统开销。它的前提很简单：如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。</p>
<p>写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。</p>
<p>在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork( )调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。</p>
<p>写时复制在内核中的实现非常简单。与内核页相关的数据结构可以被标记为只读和写时复制。如果有进程试图修改一个页，就会产生一个缺页中断。内核处理缺页中断的方式就是对该页进行一次透明复制。这时会清除页面的COW属性，表示着它不再被共享。</p>
<p>现代的计算机系统结构中都在内存管理单元（MMU）提供了硬件级别的写时复制支持，所以实现是很容易的。</p>
<p>在调用fork( )时，写时复制是有很大优势的。因为大量的fork之后都会跟着执行exec，那么复制整个父进程地址空间中的内容到子进程的地址空间完全是在浪费时间：如果子进程立刻执行一个新的二进制可执行文件的映像，它先前的地址空间就会被交换出去。写时复制可以对这种情况进行优化。</p>
</blockquote>
<h4 id="fork和vfork的区别"><a href="#fork和vfork的区别" class="headerlink" title="fork和vfork的区别"></a>fork和vfork的区别</h4><blockquote>
<ol>
<li><p>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</p>
</li>
<li><p>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</p>
</li>
<li><p>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</p>
</li>
<li><p>当需要改变共享数据段中变量的值，则拷贝父进程。</p>
</li>
</ol>
</blockquote>
<h3 id="13-进程切换与线程切换的区别"><a href="#13-进程切换与线程切换的区别" class="headerlink" title="13 进程切换与线程切换的区别"></a>13 进程切换与线程切换的区别</h3><blockquote>
<p><strong>进程切换涉及到虚拟地址空间的切换</strong>而线程切换则不会。</p>
<p>因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</p>
</blockquote>
<h2 id="三-互斥-同步"><a href="#三-互斥-同步" class="headerlink" title="三 互斥 同步"></a>三 互斥 同步</h2><h3 id="1-单核机器上写多线程程序是否需要加锁？"><a href="#1-单核机器上写多线程程序是否需要加锁？" class="headerlink" title="1 单核机器上写多线程程序是否需要加锁？"></a>1 单核机器上写多线程程序是否需要加锁？</h3><blockquote>
<p>在单核机器上写多线程程序，仍然需要线程锁。</p>
<p>因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</p>
</blockquote>
<h3 id="2-Linux的4种锁-C"><a href="#2-Linux的4种锁-C" class="headerlink" title="2 Linux的4种锁(C++)"></a>2 Linux的4种锁(C++)</h3><blockquote>
<ol>
<li><p>互斥锁：<code>mutex</code>，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p>
</li>
<li><p>读写锁：<code>rwlock</code>，分为读锁和写锁。</p>
<p>处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p>
</li>
<li><p>自旋锁：<code>spinlock</code>，在任何时刻同样只能有一个线程访问对象。</p>
<p>当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</p>
</li>
<li><p>RCU：即<code>read-copy-update</code>，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。</p>
</li>
</ol>
</blockquote>
<h3 id="3-互斥锁、读写锁的区别"><a href="#3-互斥锁、读写锁的区别" class="headerlink" title="3 互斥锁、读写锁的区别"></a>3 互斥锁、读写锁的区别</h3><blockquote>
<ol>
<li>读写锁区分读者和写者，而互斥锁不区分</li>
<li>互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</li>
</ol>
</blockquote>
<h3 id="4-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#4-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="4 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>4 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h3><blockquote>
<p>单核CPU，并且开了抢占可以造成这种情况。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;   <span class="comment">//实现对文件的互斥访问</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//实现对count变量的互斥访问</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(rw); <span class="comment">//写之前“加锁”</span></span><br><span class="line">        写文件</span><br><span class="line">        V(rw); <span class="comment">//写之后“解锁”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader ()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);     <span class="comment">//各读进程互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)  <span class="comment">//第一个读进程负责“加锁”</span></span><br><span class="line">        &#123;</span><br><span class="line">            P(rw);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;      <span class="comment">//访问文件的进程数+1</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        读文件</span><br><span class="line">        P(mutex);     <span class="comment">//各读进程互斥访问count</span></span><br><span class="line">        count--;      <span class="comment">//访问文件的进程数-1</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)  <span class="comment">//最后一个读进程负责“解锁”</span></span><br><span class="line">        &#123;</span><br><span class="line">            V(rw);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四-死锁"><a href="#四-死锁" class="headerlink" title="四 死锁"></a>四 死锁</h2><h3 id="1-死锁的条件及解决方法"><a href="#1-死锁的条件及解决方法" class="headerlink" title="1 死锁的条件及解决方法"></a>1 死锁的条件及解决方法</h3><blockquote>
<p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的相互等待的现象。</p>
</blockquote>
<h4 id="死锁发生的四个必要条件"><a href="#死锁发生的四个必要条件" class="headerlink" title="死锁发生的四个必要条件"></a>死锁发生的四个必要条件</h4><blockquote>
<ol>
<li>互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；</li>
<li>请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源</li>
<li>不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</li>
<li>循环等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链</li>
</ol>
</blockquote>
<h4 id="1-死锁预防"><a href="#1-死锁预防" class="headerlink" title="1 死锁预防"></a>1 死锁预防</h4><blockquote>
<ol>
<li>资源一次性分配，从而剥夺请求和保持条件</li>
<li>可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件</li>
<li>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件</li>
</ol>
</blockquote>
<h4 id="2-死锁避免（银行家算法）"><a href="#2-死锁避免（银行家算法）" class="headerlink" title="2 死锁避免（银行家算法）"></a><strong>2 死锁避免（银行家算法）</strong></h4><blockquote>
<p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入<a href="http://metc.gdut.edu.cn/os/oscai/chapter2/pages/ch29.htm#概念" target="_blank" rel="noopener">不安全状态</a>，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是<strong>银行家算法</strong>。</p>
</blockquote>
<h4 id="3-死锁检测"><a href="#3-死锁检测" class="headerlink" title="3 死锁检测"></a><strong>3 死锁检测</strong></h4><blockquote>
<p>首先为每个进程和每个资源指定一个唯一的号码；然后建立资源分配表和进程等待表，</p>
</blockquote>
<h4 id="4-死锁解除"><a href="#4-死锁解除" class="headerlink" title="4 死锁解除"></a><strong>4 死锁解除</strong></h4><blockquote>
<p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来.</p>
<p>常采用的方法有：</p>
<ol>
<li><p><strong>剥夺资源</strong>：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</p>
</li>
<li><p><strong>撤消进程</strong>：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p>
</li>
</ol>
</blockquote>
<h3 id="2-生产者-消费者问题"><a href="#2-生产者-消费者问题" class="headerlink" title="2 生产者-消费者问题"></a>2 生产者-消费者问题</h3><blockquote>
<p>两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者（将信息放入缓冲区），另一个是消费者（从缓冲区去除信息）。</p>
<p>问题在于当缓冲区已满，而此时生产者还想向其中放入一个新的数据项的情况。其解决方法是，让生产者睡眠，等消费者从缓冲区中去取一个数据项或者多个数据项时再唤醒它。同样的，当消费者试图从缓冲区中取数据而发现缓冲区为空时，消费者就睡眠，知道生产者向其中放入一些数据时再将其唤醒。</p>
<p>竞争条件</p>
<ol>
<li>跟踪数据项数需要一个变量 count（互斥访问）；</li>
</ol>
<p>有问题的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100;	<span class="comment">//缓冲区的槽数目</span></span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;	<span class="comment">//缓冲区的数据项数目</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        item = produce_item();</span><br><span class="line">        <span class="keyword">if</span>(count == N) sleep();</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count = count+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) wakeup(consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) sleep();</span><br><span class="line">        item = remove_item();</span><br><span class="line">        count = count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(count == N<span class="number">-1</span>) wakeup(producer);</span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在的问题：1. 未对count的访问进行限制，可能会导致wakeup信号丢失。</p>
<p>用信号量解决生产者-消费者问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10;</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">//控制对临界区的访问</span></span><br><span class="line">semaphore tmpty = N;	<span class="comment">//计数缓冲区的空槽数目</span></span><br><span class="line">semaphore full = <span class="number">0</span>;		<span class="comment">//计数缓冲区的满槽数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        item = produce_item();</span><br><span class="line">        P(&amp;empty);		<span class="comment">//将空槽数目减1</span></span><br><span class="line">        P(&amp;mutex);		<span class="comment">//进入临界区</span></span><br><span class="line">        insert_item(item);	<span class="comment">//将新数据项放到缓冲区中</span></span><br><span class="line">        V(&amp;mutex);		<span class="comment">//离开临界区</span></span><br><span class="line">        V(&amp;full);		<span class="comment">//将满槽的数目加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        P(&amp;full);		<span class="comment">//将满槽数目减1</span></span><br><span class="line">        V(&amp;mutex);		<span class="comment">//进入临界区</span></span><br><span class="line">        item = remove_item();	<span class="comment">//从缓冲区中去除数据项</span></span><br><span class="line">        V(&amp;mutex);		<span class="comment">//离开临界区</span></span><br><span class="line">        V(&amp;empty);		<span class="comment">//将空槽数目加1</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="3-银行家算法"><a href="#3-银行家算法" class="headerlink" title="3 银行家算法"></a>3 银行家算法</h3><blockquote>
<p>银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。</p>
<blockquote>
<p><strong>银行家算法中的数据结构</strong></p>
<p>​        为了实现银行家算法，在系统中必须设置这样四个数据结构，分别用来描述系统中可利用的资源、所有进程对资源的最大需求、系统中的资源分配，以及所有进程还需要多少资源的情况。</p>
<p>(1)    可利用资源向量 Available。这是一个含有 m 个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果 Available[j] = K，则表示系统中现Rj类资源K个。<br>(2)    最大需求矩阵Max。这是一个n x m的矩阵，它定义了系统中n个进程中的每个进程对m类资源的最大需求。如果Max[i,j] = K，则表示进程i需要Rj 类资源的最大数目为K。<br>(3)    分配矩阵 Allocation。这也是一个n x m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果 Allocation[i,jl = K，则表示进程i当前己分得Rj类资源的数目为K。<br>(4)    需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j] = K，则表示进程i还需要Rj类资源K个方能完成其任务。</p>
<p>上述三个矩阵间存在下述关系<br>　　　　　　　　　　　　　　$Need[i,j] = Max[i,j] - allocation[i, j]$<br>　　　　　　　　　　　　　　<br><strong>银行家算法</strong></p>
<p>设 Request；是进程Pi的请求向量，如果 Requesti[j] = K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检査:</p>
<p>(1)    如果 Requesti[j] ≤ Need[i,j]便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</p>
<p>(2)    如果 Requesti[j] ≤ Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。</p>
<p>(3)    系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值<br>$$<br>Available[j] = Available[j] - Requesti[j];\<br>　　　　Allocation[i,j] = Allocation[i,j] + Requesti[j];\<br>　　　　Need[i,j] = Need[i,j] - Requesti[j];<br>$$</p>
<p>(4)    系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。</p>
</blockquote>
</blockquote>
<h3 id="4-死锁避免和死锁预防的区别"><a href="#4-死锁避免和死锁预防的区别" class="headerlink" title="4 死锁避免和死锁预防的区别"></a>4 死锁避免和死锁预防的区别</h3><blockquote>
<p>死锁预防是设法至少破坏产生死锁的四个必要条件之一, 严格的防止死锁的出现.</p>
<p>死锁避免则不那么严格的限制产生死锁的必要条件, 因为即使死锁的必要条件存在,也不一定发生死锁.</p>
<p>死锁避免是在系统运行过程中注意避免死锁的发生.</p>
</blockquote>
<h2 id="五-内存管理-1"><a href="#五-内存管理-1" class="headerlink" title="五 内存管理"></a>五 内存管理</h2><img src="https://img-blog.csdn.net/20180923212410372?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pdWJpcWlnYWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="计算机系统组成" style="zoom: 50%;">

<p><strong>内存储器</strong></p>
<img src="https://img-blog.csdn.net/20180923212521350?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pdWJpcWlnYWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="冯·诺依曼体系结构" style="zoom:80%;">

<ul>
<li>运算器:　负责数据的算术运算和逻辑运算，即数据的加工处理。</li>
<li>控制器:　是整个计算机的中枢神经，分析程序规定的控制信息，并根据程序要求进行控制，协调计算机各部分组件工作及内存与外设的访问等。</li>
<li>运算器和控制器统称中央处理器（即CPU)</li>
<li>存储器:　实现记忆功能的部件，用来存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。</li>
<li>输入设备:　实现将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。</li>
<li>输出设备:　实现将计算机处理后生成的中间结果或最后结果（各种数据符号及文字或各种控制信号等信息）输出出来。</li>
</ul>
<h3 id="1-程序的内存结构"><a href="#1-程序的内存结构" class="headerlink" title="1 程序的内存结构"></a>1 程序的内存结构</h3><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153" alt="img"></p>
<p>一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</p>
<blockquote>
<ol>
<li><p>BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</p>
</li>
<li><p>数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配</p>
</li>
<li><p>代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量</p>
</li>
<li><p>text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。</p>
</li>
<li><p>bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。</p>
</li>
<li><p>data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。</p>
<p>数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。</p>
</li>
</ol>
<p><strong>可执行程序在运行时又多出两个区域：栈区和堆区。</strong></p>
<ol start="7">
<li><p>栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p>
</li>
<li><p>堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p>
</li>
</ol>
</blockquote>
<h3 id="2-虚拟内存"><a href="#2-虚拟内存" class="headerlink" title="2 虚拟内存"></a>2 虚拟内存</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>目的：为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。</p>
<p>作用：虚拟内存是计算机系统内存管理的一种技术。能使程序在只有一部分被调入内存的情况下运行；它使程序有一个连续完整的地址空间，而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
</blockquote>
<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><blockquote>
<p>每个程序都有自己的地址空间，这个空间被分割成多个快，每一块被分割成多块，每一块称作一页或页面。每一页有连续的传值范围。这些也被映射到物理内存，但不是所有的页都必须在内存中才能运行程序。</p>
<ul>
<li><p>当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。</p>
</li>
<li><p>当程序引用到一部分不在物理内存中的地址空间时，这些页被映射到物理内存并重新执行失败的指令。</p>
</li>
</ul>
</blockquote>
<h4 id="虚拟内存的好处"><a href="#虚拟内存的好处" class="headerlink" title="虚拟内存的好处"></a>虚拟内存的好处</h4><blockquote>
<ol>
<li><p>扩大地址空间；</p>
</li>
<li><p>内存保护：</p>
<p>每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还能对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</p>
</li>
<li><p>公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。</p>
</li>
<li><p>当进程通信时，可采用虚存共享的方式实现。</p>
</li>
<li><p>当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存。</p>
</li>
<li><p>虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高</p>
</li>
<li><p>在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</p>
</li>
</ol>
</blockquote>
<h4 id="虚拟内存的代价"><a href="#虚拟内存的代价" class="headerlink" title="虚拟内存的代价"></a>虚拟内存的代价</h4><blockquote>
<ol>
<li>虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</li>
<li>虚拟地址到物理地址的转换，增加了指令的执行时间。</li>
<li>页面的换入换出需要磁盘I/O，这是很耗时的</li>
<li>如果一页中只有一部分数据，会浪费内存。</li>
</ol>
</blockquote>
<h3 id="3-缺页中断"><a href="#3-缺页中断" class="headerlink" title="3 缺页中断"></a>3 缺页中断</h3><blockquote>
<p>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。</p>
<p>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<blockquote>
<p>1、保护CPU现场</p>
<p>2、分析中断原因</p>
<p>3、转入缺页中断处理程序进行处理</p>
<p>4、恢复CPU现场，继续执行</p>
</blockquote>
<p>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</p>
<blockquote>
<p>1、在指令执行期间产生和处理缺页中断信号</p>
<p>2、一条指令在执行期间，可能产生多次缺页中断</p>
<p>3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。</p>
</blockquote>
</blockquote>
<h3 id="4-页表寻址"><a href="#4-页表寻址" class="headerlink" title="4 页表寻址"></a>4 页表寻址</h3><blockquote>
<p>页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。</p>
<p>Linux最初的两级页表机制：</p>
<p>两级分页机制将32位的虚拟空间分成三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。</p>
<ol>
<li>PGD(Page Global Directory): 最高10位，全局页目录表索引</li>
<li>PTE(Page Table Entry)：中间10位，页表入口索引</li>
</ol>
<p>当在进行地址转换时，结合在CR3寄存器中存放的页目录(page directory, PGD)的这一页的物理地址，再加上从虚拟地址中抽出高10位叫做页目录表项(内核也称这为pgd)的部分作为偏移, 即定位到可以描述该地址的pgd；从该pgd中可以获取可以描述该地址的页表的物理地址，再加上从虚拟地址中抽取中间10位作为偏移, 即定位到可以描述该地址的pte；在这个pte中即可获取该地址对应的页的物理地址, 加上从虚拟地址中抽取的最后12位，即形成该页的页内偏移, 即可最终完成从虚拟地址到物理地址的转换。从上述过程中，可以看出，对虚拟地址的分级解析过程，实际上就是不断深入页表层次，逐渐定位到最终地址的过程，所以这一过程被叫做page talbe walk。</p>
<p>Linux的三级页表机制：</p>
<p>当X86引入物理地址扩展(Pisycal Addrress Extension, PAE)后，可以支持大于4G的物理内存(36位），但虚拟地址依然是32位，原先的页表项不适用，它实际多4 bytes被扩充到8 bytes，这意味着，每一页现在能存放的pte数目从1024变成512了(4k/8)。相应地，页表层级发生了变化，Linus新增加了一个层级，叫做页中间目录(page middle directory, PMD), 变成：</p>
<p>字段      描述            位数</p>
<p>cr3      指向一个PDPT      crs寄存器存储</p>
<p>PGD    指向PDPT中4个项中的一个  位31~30</p>
<p>PMD    指向页目录中512项中的一个  位29~21</p>
<p>PTE      指向页表中512项中的一个  位20~12</p>
<p>page offset  4KB页中的偏移      位11~0</p>
<p>现在就同时存在2级页表和3级页表，在代码管理上肯定不方便。巧妙的是，Linux采取了一种抽象方法：所有架构全部使用3级页表: 即PGD -&gt; PMD -&gt; PTE。那只使用2级页表(如非PAE的X86)怎么办？</p>
<p>办法是针对使用2级页表的架构，把PMD抽象掉，即虚设一个PMD表项。这样在page table walk过程中，PGD本直接指向PTE的，现在不了，指向一个虚拟的PMD，然后再由PMD指向PTE。这种抽象保持了代码结构的统一。</p>
<p>Linux的四级页表机制：</p>
<p>硬件在发展，3级页表很快又捉襟见肘了，原因是64位CPU出现了, 比如X86_64， 它的硬件是实实在在支持4级页表的。它支持48位的虚拟地址空间1。如下：</p>
<p>字段      描述            位数</p>
<p>PML4    指向一个PDPT      位47~39</p>
<p>PGD    指向PDPT中4个项中的一个  位38~30</p>
<p>PMD    指向页目录中512项中的一个  位29~21</p>
<p>PTE      指向页表中512项中的一个  位20~12</p>
<p>page offset  4KB页中的偏移      位11~0</p>
<p>Linux内核针为使用原来的3级列表(PGD-&gt;PMD-&gt;PTE)，做了折衷。即采用一个唯一的，共享的顶级层次，叫PML4。这个PML4没有编码在地址中，这样就能套用原来的3级列表方案了。不过代价就是，由于只有唯一的PML4, 寻址空间被局限在(239=)512G, 而本来PML4段有9位, 可以支持512个PML4表项的。现在为了使用3级列表方案，只能限制使用一个， 512G的空间很快就又不够用了，解决方案呼之欲出。</p>
</blockquote>
<h3 id="5-缺页置换算法"><a href="#5-缺页置换算法" class="headerlink" title="5 缺页置换算法"></a>5 缺页置换算法</h3><blockquote>
<p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。</p>
<p>当前操作系统最常采用的缺页置换算法如下：</p>
<ol>
<li><p>先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。</p>
</li>
<li><p>最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。</p>
</li>
</ol>
<p>当前最常采用的就是LRU算法。</p>
<p>比较常见的内存替换算法有：<strong>FIFO，LRU，LFU，LRU-K，2Q</strong>。</p>
<h4 id="1、FIFO（先进先出淘汰算法）"><a href="#1、FIFO（先进先出淘汰算法）" class="headerlink" title="1、FIFO（先进先出淘汰算法）"></a>1、FIFO（先进先出淘汰算法）</h4><p>思想：最近刚访问的，将来访问的可能性比较大。</p>
<p>实现：使用一个队列，新加入的页面放入队尾，每次淘汰队首的页面，即最先进入的数据，最先被淘汰。</p>
<p>弊端：无法体现页面冷热信息 BELADY</p>
<h4 id="2、LFU（最不经常访问淘汰算法）"><a href="#2、LFU（最不经常访问淘汰算法）" class="headerlink" title="2、LFU（最不经常访问淘汰算法）"></a>2、LFU（最不经常访问淘汰算法）</h4><p>思想：如果数据过去被访问多次，那么将来被访问的频率也更高。</p>
<p>实现：每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。</p>
<p>开销：排序开销。</p>
<p>弊端：缓存颠簸。</p>
<p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/311436_1552470476683_909843CE326FD7243A252E09C80772B8" alt="img"></p>
<h4 id="3、LRU（最近最少使用替换算法）"><a href="#3、LRU（最近最少使用替换算法）" class="headerlink" title="3、LRU（最近最少使用替换算法）"></a>3、LRU（最近最少使用替换算法）</h4><p>思想：如果数据最近被访问过，那么将来被访问的几率也更高。</p>
<p>实现：使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。</p>
<p>优点：LRU算法对热点数据命中率是很高的。</p>
<p>缺陷：</p>
<p>1）缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。</p>
<p>2）缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。</p>
<h4 id="4、LRU-K（LRU-2、LRU-3）"><a href="#4、LRU-K（LRU-2、LRU-3）" class="headerlink" title="4、LRU-K（LRU-2、LRU-3）"></a>4、LRU-K（LRU-2、LRU-3）</h4><p>思想：最久未使用K次淘汰算法。</p>
<p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</p>
<p>实现：</p>
<p>1）数据第一次被访问，加入到访问历史列表；</p>
<p>2）如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</p>
<p>3）当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</p>
<p>4）缓存数据队列中被再次访问后，重新排序；</p>
<p>5）需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</p>
<p>针对问题：</p>
<p>LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<h4 id="5、2Q"><a href="#5、2Q" class="headerlink" title="5、2Q"></a>5、2Q</h4><p>类似LRU-2。使用一个FIFO队列和一个LRU队列。</p>
<p>实现：</p>
<p>1）新访问的数据插入到FIFO队列；</p>
<p>2）如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</p>
<p>3）如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；</p>
<p>4）如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；</p>
<p>5）LRU队列淘汰末尾的数据。</p>
<p>针对问题：LRU的缓存污染</p>
<p>弊端：</p>
<p>当FIFO容量为2时，访问负载是：ABCABCABC会退化为FIFO，用不到LRU。</p>
</blockquote>
<h3 id="6-虚拟内存与物理内存的对应关系"><a href="#6-虚拟内存与物理内存的对应关系" class="headerlink" title="6 虚拟内存与物理内存的对应关系"></a>6 虚拟内存与物理内存的对应关系</h3><blockquote>
<p>物理地址：用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。</p>
<p>虚拟地址：对整个内存的抽像描述。它是相对于物理内存来讲的，可以直接理解成“不直实的”，“假的”内存，例如，一个0x08000000内存地址，它并不对就物理地址上那个大数组中0x08000000 - 1那个地址元素；</p>
<p>现代操作系统都提供了一种内存管理的抽像，即虚拟内存（virtual memory）。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。这个“转换”，是所有问题讨论的关键。有了这样的抽像，一个程序，就可以使用比真实物理地址大得多的地址空间。甚至多个进程可以使用相同的地址。不奇怪，因为转换后的物理地址并非相同的</p>
</blockquote>
<h4 id="2、地址转换"><a href="#2、地址转换" class="headerlink" title="2、地址转换"></a>2、地址转换</h4><blockquote>
<p><strong>逻辑地址转线性地址</strong></p>
<p>CPU要利用其段式内存管理单元，先将为个逻辑地址转换成一个线程地址。</p>
<p>一个逻辑地址由两部份组成，【段标识符：段内偏移量】。</p>
<p>段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，如图：</p>
<p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/311436_1552470210037_13DB46E4DEE567FEF6756A26C5A0EC62" alt="img"></p>
<p>通过段标识符中的索引号从GDT或者LDT找到该段的段描述符，段描述符中的base字段是段的起始地址。</p>
<p>段描述符：Base字段，它描述了一个段的开始位置的线性地址。</p>
<p>一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。</p>
<p>段起始地址+ 段内偏移量 = 线性地址</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470239469_B327A1776BDD614C1FA189B123676D44" alt="img"></p>
<p>首先，给定一个完整的逻辑地址 [段选择符：段内偏移地址]，</p>
<p>1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。</p>
<p>2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。</p>
<p>3、把Base + offset，就是要转换的线性地址了。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470270211_A8B080AAD8609459CD745F5E2480B919" alt="img"></p>
<p>第一步：页式管理——线性地址转物理地址</p>
<p>再利用其页式内存管理单元，转换为最终物理地址。</p>
<p>linux假的段式管理</p>
<p>Intel要求两次转换，这样虽说是兼容了，但是却是很冗余，但是这是intel硬件的要求。其它某些硬件平台，没有二次转换的概念，Linux也需要提供一个高层抽像，来提供一个统一的界面。所以，Linux的段式管理，事实上只是“哄骗”了一下硬件而已。按照Intel的本意，全局的用GDT，每个进程自己的用LDT——不过Linux则对所有的进程都使用了相同的段来对指令和数据寻址。即用户数据段，用户代码段，对应的，内核中的是内核数据段和内核代码段。</p>
<p>在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。</p>
<p>linux页式管理</p>
<p>CPU的页式内存管理单元，负责把一个线性地址，最终翻译为一个物理地址。</p>
<p>线性地址被分为以固定长度为单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，可以用4KB为一个页来划分，这页，整个线性地址就被划分为一个tatol_page[2^20]的大数组，共有2的20个次方个页。</p>
<p>另一类“页”，我们称之为物理页，或者是页框、页桢的。是分页单元把所有的物理内存也划分为固定长度的管理单位，它的长度一般与内存页是一一对应的。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470300375_E395C4896EA5D7621E9211A0C3817BB5" alt="img"></p>
<p>每个进程都有自己的页目录，当进程处于运行态的时候，其页目录地址存放在cr3寄存器中。</p>
<p>每一个32位的线性地址被划分为三部份，【页目录索引(10位)：页表索引(10位)：页内偏移(12位)】</p>
<p>依据以下步骤进行转换：</p>
<p>从cr3中取出进程的页目录地址（操作系统负责在调度进程的时候，把这个地址装入对应寄存器）；</p>
<p>根据线性地址前十位，在数组中，找到对应的索引项，因为引入了二级管理模式，页目录中的项，不再是页的地址，而是一个页表的地址。（又引入了一个数组），页的地址被放到页表中去了。</p>
<p>根据线性地址的中间十位，在页表（也是数组）中找到页的起始地址；</p>
<p>将页的起始地址与线性地址中最后12位相加。</p>
<p>目的：</p>
<p>内存节约：如果一级页表中的一个页表条目为空，那么那所指的二级页表就根本不会存在。这表现出一种巨大的潜在节约，因为对于一个典型的程序，4GB虚拟地址空间的大部份都会是未分配的；</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470330729_28397F90C2D7C059A122BFF0B4DFD63A" alt="img"></p>
<p>32位，PGD = 10bit，PUD = PMD = 0，table = 10bit，offset = 12bit</p>
<p>64位，PUD和PMD ≠ 0</p>
</blockquote>
<h3 id="7-内存溢出和内存泄漏"><a href="#7-内存溢出和内存泄漏" class="headerlink" title="7 内存溢出和内存泄漏"></a>7 内存溢出和内存泄漏</h3><h4 id="1、内存溢出"><a href="#1、内存溢出" class="headerlink" title="1、内存溢出"></a>1、内存溢出</h4><blockquote>
<p>指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</p>
</blockquote>
<h5 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h5><blockquote>
<ol>
<li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据</li>
<li>集合类中有对对象的引用，使用完后未清空，使得不能回收</li>
<li>代码中存在死循环或循环产生过多重复的对象实体</li>
<li>使用的第三方软件中的BUG</li>
<li>启动参数内存值设定的过小</li>
</ol>
</blockquote>
<h4 id="2、内存泄漏"><a href="#2、内存泄漏" class="headerlink" title="2、内存泄漏"></a>2、内存泄漏</h4><blockquote>
<p>内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p>
</blockquote>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><blockquote>
<ol>
<li>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</li>
<li>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li>
<li>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li>
</ol>
</blockquote>
<h3 id="8-为什么要有page-cache，操作系统怎么设计的page-cache"><a href="#8-为什么要有page-cache，操作系统怎么设计的page-cache" class="headerlink" title="8 为什么要有page cache，操作系统怎么设计的page cache"></a>8 为什么要有page cache，操作系统怎么设计的page cache</h3><blockquote>
<p>加快从磁盘读取文件的速率。</p>
<p>page cache中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。</p>
<p>在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache项，一个是radix tree，另一个是双向链表。Radix tree 是一种搜索树，Linux内核利用这个数据结构来通过文件内偏移快速定位Cache 项</p>
</blockquote>
<h3 id="9-动态重定位分区法"><a href="#9-动态重定位分区法" class="headerlink" title="9 动态重定位分区法"></a>9 动态重定位分区法</h3><blockquote>
<p>虽然动态分区法比固定分区法的内存利用率高，但动态分区法有零头（碎片）的问题。</p>
<p>碎片是不连续的小块空闲区，可能所有碎片的综合超过某作业的容量要求，但由于不连续也无法分配。</p>
<p>解决碎片的问题方法是拼接，即当出现上述这种无法分配的情况时，向一个方向（例如向低地址端）移动已分配的作业，使那些零碎的小空闲区在另一个方向连成一片，这就是 “ 紧缩 ” 技术。在紧缩过程中，因为内存中已经存在的作业需要 “ 移动 ” ，因而其中所有关于地址的项均需得到相应的修改，也就是需要进行地址重定位。</p>
<p>因此这种分区方法被称为可重定位分区法</p>
</blockquote>
<h2 id="六-文件系统"><a href="#六-文件系统" class="headerlink" title="六 文件系统"></a>六 文件系统</h2><h3 id="1-修改文件最大句柄数？"><a href="#1-修改文件最大句柄数？" class="headerlink" title="1. 修改文件最大句柄数？"></a>1. 修改文件最大句柄数？</h3><blockquote>
<p>linux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报”too many open files”的错误。故在linux服务器高并发调优时，往往需要预先调优Linux参数，修改Linux最大文件句柄数。</p>
<p>有两种方法：</p>
<ol>
<li>ulimit -n &lt;可以同时打开的文件数&gt;，将当前进程的最大句柄数修改为指定的参数（注：该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值）</li>
</ol>
<p>首先用ulimit -a查询Linux相关的参数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 94739</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 94739</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>

<p>其中，open files就是最大文件句柄数，默认是1024个。修改Linux最大文件句柄数：  ulimit -n 2048， 将最大句柄数修改为 2048个。</p>
<ol start="2">
<li>对所有进程都有效的方法，修改Linux系统参数  <code>vi /etc/security/limits.conf</code> 添加</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soft　　nofile　　65536</span><br><span class="line">hard　　nofile　　65536</span><br></pre></td></tr></table></figure>

<p>将最大句柄数改为65536</p>
<p>修改以后保存，注销当前用户，重新登录，修改后的参数就生效了。</p>
</blockquote>
<h3 id="2-操作系统中的结构体对齐，字节对齐"><a href="#2-操作系统中的结构体对齐，字节对齐" class="headerlink" title="2. 操作系统中的结构体对齐，字节对齐"></a>2. 操作系统中的结构体对齐，字节对齐</h3><p>1、原因：</p>
<blockquote>
<p>1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
<p>2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p>
</blockquote>
<p>2、规则</p>
<blockquote>
<p>1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</p>
<p>2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p>
<p>3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</p>
<p>3、定义结构体对齐</p>
<p>可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</p>
</blockquote>
<p>4、举例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AA</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;    <span class="comment">//长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]</span></span><br><span class="line">    <span class="keyword">char</span> b;  <span class="comment">//长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]</span></span><br><span class="line">    short c;   <span class="comment">//长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</span></span><br><span class="line">    <span class="keyword">char</span> d;  <span class="comment">//长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>



<h3 id="3-软链接和硬链接的区别"><a href="#3-软链接和硬链接的区别" class="headerlink" title="3. 软链接和硬链接的区别"></a>3. 软链接和硬链接的区别</h3><blockquote>
<p>为了解决文件共享问题，Linux引入了软链接和硬链接。</p>
<p>除了为Linux解决文件共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若1个inode号对应多个文件名，则为硬链接，即硬链接就是同一个文件使用了不同的别名,使用ln创建。若文件用户数据块中存放的内容是另一个文件的路径名指向，则该文件是软连接。</p>
<p>软连接是一个普通文件，有自己独立的inode,但是其数据块内容比较特殊。</p>
</blockquote>
<h2 id="七-输入和输出"><a href="#七-输入和输出" class="headerlink" title="七 输入和输出"></a>七 输入和输出</h2><h3 id="1-5种IO模型"><a href="#1-5种IO模型" class="headerlink" title="1. 5种IO模型"></a>1. 5种IO模型</h3><blockquote>
<ol>
<li>阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li>
<li>非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。</li>
<li>信号驱动IO:信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</li>
<li>IO复用/多路转接IO:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</li>
<li>异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li>
</ol>
</blockquote>
<h3 id="2-异步编程的事件循环"><a href="#2-异步编程的事件循环" class="headerlink" title="2.  异步编程的事件循环"></a>2.  异步编程的事件循环</h3><blockquote>
<p>事件循环就是不停循环等待时间的发生，然后将这个事件的所有处理器，以及他们订阅这个事件的时间顺序依次依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。当同时并发地处理多个请求时，以上的概念也是正确的，可以这样理解：在单个的线程中，事件处理器是一个一个按顺序执行的。即如果某个事件绑定了两个处理器，那么第二个处理器会在第一个处理器执行完毕后，才开始执行。在这个事件的所有处理器都执行完毕之前，事件循环不会去检查是否有新的事件触发。在单个线程中，一切都是有顺序地一个一个地执行的！</p>
</blockquote>
<h1 id="四-计算机网络"><a href="#四-计算机网络" class="headerlink" title="四 计算机网络"></a>四 计算机网络</h1><h2 id="一-整体架构"><a href="#一-整体架构" class="headerlink" title="一 整体架构"></a>一 整体架构</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><table>
<thead>
<tr>
<th align="center">OSI模型</th>
<th>作用</th>
<th align="center">传输单位</th>
<th align="center">协议</th>
<th>设备</th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用层</td>
<td>允许访问OSI环境的手段</td>
<td align="center">APDU</td>
<td align="center">FTP HTTP DNS</td>
<td></td>
</tr>
<tr>
<td align="center">表示层</td>
<td>对数据进行翻译、加密、压缩</td>
<td align="center">PPDU</td>
<td align="center">JPEG ASII</td>
<td></td>
</tr>
<tr>
<td align="center">会话层</td>
<td>建立、管理和终止对话</td>
<td align="center">SPDU</td>
<td align="center">RPC NFS</td>
<td></td>
</tr>
<tr>
<td align="center">运输层</td>
<td>提供端到端的可靠报文传递和错误恢复</td>
<td align="center">报文</td>
<td align="center">TCP UDP</td>
<td></td>
</tr>
<tr>
<td align="center">网络层</td>
<td>负责数据包从源到宿的传递和网际互连</td>
<td align="center">包</td>
<td align="center">IP ARP ICMP</td>
<td>路由器、网关</td>
</tr>
<tr>
<td align="center">数据链路层</td>
<td>将比特组装成帧和点到点的传递</td>
<td align="center">帧</td>
<td align="center">MAC VLAN PPP</td>
<td>网桥、交换机</td>
</tr>
<tr>
<td align="center">物理层</td>
<td>通过媒介传输比特,确定机械及电气规范</td>
<td align="center">比特</td>
<td align="center">IEEE802.3 CLOCK RJ45</td>
<td>中继器、集线器</td>
</tr>
</tbody></table>
<h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><table>
<thead>
<tr>
<th align="center">TCP/IP模型</th>
<th align="center">协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用层</td>
<td align="center">HTTP DNS SMTP</td>
</tr>
<tr>
<td align="center">传输层</td>
<td align="center">TCP UDP</td>
</tr>
<tr>
<td align="center">网络层</td>
<td align="center">IP ARP ICMP</td>
</tr>
<tr>
<td align="center">网络接口层</td>
<td align="center">MAC VLAN</td>
</tr>
</tbody></table>
<h2 id="二-物理层和数据链路层"><a href="#二-物理层和数据链路层" class="headerlink" title="二 物理层和数据链路层"></a>二 物理层和数据链路层</h2><h3 id="1-ARP协议与RARP协议"><a href="#1-ARP协议与RARP协议" class="headerlink" title="1 ARP协议与RARP协议"></a>1 ARP协议与RARP协议</h3><blockquote>
<p>ARP协议和RARP协议是作用于数据链路层的；</p>
<p>ARP协议的作用是将IP地址转换为物理地址;</p>
<p>工作原理：将ARP请求报文广播到所在网络上的所有主机，报文中含有目的主机的IP地址，只有目标主机可以返回一个ARP应答报文，报文中含有该主机的物理地址。</p>
</blockquote>
<h3 id="2-ARP协议如何查询MAC地址"><a href="#2-ARP协议如何查询MAC地址" class="headerlink" title="2 ARP协议如何查询MAC地址"></a>2 ARP协议如何查询MAC地址</h3><blockquote>
<p>现在路由器要给主机B发送一条消息，必须得知道主机B的MAC地址才能进行通信。</p>
<p>路由器会以广播的形式发送一个ARP请求，每一台连接到该路由器的主机都收到得到这条消息。</p>
<p>但是只有主机B检查到自己的IP地址符合要求。</p>
<p>于是主机B发送给路由器一条ARP响应，把自己的MAC的地址告诉了路由器。就像下面图示的那样：</p>
<p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/640" alt="img"></p>
<p>每次路由器发送一个ARP请求的时候，就会增加一条数据，这一条数据记录了IP地址对应的MAC地址，这样路由器下次再给该主机发送消息的时候就不用广播了。当然如同交换机的CAM表中的数据有生存了时间一样，路由表中的数据也有生存时间。试想一下，如果数据一直存在，那么路由器岂不是需要花大量的存储空间来缓存已经失效的数据。</p>
</blockquote>
<h2 id="三-网络层"><a href="#三-网络层" class="headerlink" title="三 网络层"></a>三 网络层</h2><h3 id="1-IP地址以及MAC地址的作用"><a href="#1-IP地址以及MAC地址的作用" class="headerlink" title="1  IP地址以及MAC地址的作用"></a>1  IP地址以及MAC地址的作用</h3><blockquote>
<p>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。</p>
<p>IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>
</blockquote>
<h3 id="2-TCP-IP数据链路层的交互过程"><a href="#2-TCP-IP数据链路层的交互过程" class="headerlink" title="2 TCP/IP数据链路层的交互过程"></a>2 TCP/IP数据链路层的交互过程</h3><blockquote>
<p>网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候。</p>
<p>首先会去自己的arp缓存表(存着ip-mac对应关系)去查找目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：<code>who is ip XXX tell ip XXX</code>,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器</p>
</blockquote>
<h3 id="3-IP层怎么知道报文该给哪个应用程序，如何区分UDP报文还是TCP报文"><a href="#3-IP层怎么知道报文该给哪个应用程序，如何区分UDP报文还是TCP报文" class="headerlink" title="3 IP层怎么知道报文该给哪个应用程序，如何区分UDP报文还是TCP报文"></a>3 IP层怎么知道报文该给哪个应用程序，如何区分UDP报文还是TCP报文</h3><blockquote>
<p>根据端口区分；</p>
<p>看ip头中的协议标识字段，17是udp，6是tcp</p>
</blockquote>
<h3 id="4-电脑接入局域网后，怎么分配IP地址"><a href="#4-电脑接入局域网后，怎么分配IP地址" class="headerlink" title="4 电脑接入局域网后，怎么分配IP地址"></a>4 电脑接入局域网后，怎么分配IP地址</h3><blockquote>
<ol>
<li><p>手动完成</p>
<p>配置主机连接到网络时，可以手动完成，也可以由网络管理员或DHCP服务器完成。对于家庭网络，手动配置非常简单。而在大型网络中，网络管理员可能会面临许多问题。</p>
</li>
<li><p>使用DHCP配置主机</p>
<p>动态主机配置协议，用于获取网络设置信息的应用层协议。DHCP由DHCP服务器控制，动态分配网络配置参数，如IP地址，子网掩码和网关地址</p>
</li>
</ol>
</blockquote>
<h3 id="5-ICMP协议-Internet-Control-Message-Protocol-ICMP"><a href="#5-ICMP协议-Internet-Control-Message-Protocol-ICMP" class="headerlink" title="5 ICMP协议(Internet Control Message Protocol, ICMP)"></a>5 ICMP协议(Internet Control Message Protocol, ICMP)</h3><blockquote>
<p>IP协议是不可靠的传输协议，网络中进行可靠传输的是TCP协议，这个后面在讲传输层的时候会说到。那么，如果在消息没有送达的情况下，网络层是怎么解决的了？这个时候，就需要用到ICMP协议。什么是ICMP协议</p>
<p>ICMP是网络控制报文协议(Internet Control Message Protocol, ICMP)。</p>
<p>它的作用：更加有效地转发IP数据报作为IP数据报的数据部分，可以分为ICMP差错报文，和ICMP查询报文。差错报文是用来简单的报告错误的, 至于对于错误怎么处理是高层协议的职责。同时, 差错报文总是发送给最初的数据源(这是因为在ICMP数据报中唯一可以使用的就是源IP和目的IP)，查询报文总是成对出现。</p>
</blockquote>
<h2 id="四-传输层"><a href="#四-传输层" class="headerlink" title="四 传输层"></a>四 传输层</h2><h3 id="零-TCP和UDP的区别"><a href="#零-TCP和UDP的区别" class="headerlink" title="零 TCP和UDP的区别"></a>零 TCP和UDP的区别</h3><table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>连接</td>
<td>面向连接<br>传输数据之前必须先建立好连接。</td>
<td>无连接</td>
</tr>
<tr>
<td>服务对象</td>
<td>是点对点的两点间服务，即一条TCP连接只能有两个端点；</td>
<td>支持一对一，一对多，多对一，多对多的交互通信。</td>
</tr>
<tr>
<td>可靠性</td>
<td>可靠交付：无差错，不丢失，不重复，按序到达。</td>
<td>尽最大努力交付，不保证可靠交付。</td>
</tr>
<tr>
<td>拥塞控制<br>流量控制</td>
<td>有拥塞控制和流量控制保证数据传输的安全性。</td>
<td>没有拥塞控制，网络拥塞不会影响源主机的发送效率。</td>
</tr>
<tr>
<td>报文长度</td>
<td>根据接收方的窗口大小和当前网络拥塞情况决定的</td>
<td>面向报文，不合并，不拆分，保留上面传下来报文的边界。</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销大，首部20个字节。</td>
<td>首部开销小，8字节。<br>（源端口，目的端口，数据长度，校验和）</td>
</tr>
<tr>
<td>使用场景</td>
<td>通信数据完整性需让位与通信实时性<br>文件传输、重要状态的更新等</td>
<td>通信实时性不重要<br>视频传输、实时通信等</td>
</tr>
</tbody></table>
<h3 id="一-TCP协议"><a href="#一-TCP协议" class="headerlink" title="一 TCP协议"></a>一 TCP协议</h3><h4 id="1-TCP怎么保证可靠性。"><a href="#1-TCP怎么保证可靠性。" class="headerlink" title="1 TCP怎么保证可靠性。"></a>1 TCP怎么保证可靠性。</h4><blockquote>
<p>（1）序列号、确认应答、超时重传</p>
<p>数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送方迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</p>
<p>（2）窗口控制与高速重发控制/快速重传（重复确认应答）</p>
<p>TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。</p>
<p>使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒……</p>
<p>（3）拥塞控制</p>
<p>如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。</p>
<ol>
<li><p>慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</p>
</li>
<li><p>拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。</p>
<p>将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。</p>
</li>
<li><p>快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。</p>
<p>然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。</p>
</li>
</ol>
<p>这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。</p>
</blockquote>
<h4 id="2-TCP建立连接和断开连接的过程："><a href="#2-TCP建立连接和断开连接的过程：" class="headerlink" title="2. TCP建立连接和断开连接的过程："></a>2. TCP建立连接和断开连接的过程：</h4><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzA5MzY3" alt="这里写图片描述" style="zoom:50%;">

<blockquote>
<ol>
<li><p>Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ol>
</blockquote>
<h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzU2MjU1" alt="这里写图片描述"></p>
<blockquote>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<ol>
<li>数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。</li>
<li>服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。</li>
<li>当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认</li>
<li>客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。</li>
</ol>
</blockquote>
<p>三次握手确认了什么？</p>
<blockquote>
<ul>
<li><strong>「第一次握手」</strong>：Client 什么都不能确认；Server 确认了Client发送正常。</li>
<li><strong>「第二次握手」</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，Client发送正常。</li>
<li><strong>「第三次握手」</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常。</li>
</ul>
</blockquote>
<p>既然三次握手的需要发送方和接收方确认，那么四次挥手也要得到发送方和接收方的确认。</p>
<blockquote>
<ul>
<li><strong>「第一次挥手」</strong>：Client向Server发送断开的连接的请求。</li>
<li><strong>「第二次挥手」</strong>：Server向Client发送断开连接的确认。Client收到以后，这个时候TCP进入了半连接的状态，从Client向Server发送数据的通道被关闭了。</li>
<li><strong>「第三次挥手」</strong>：Server向Client发送一个断开连接的请求。</li>
<li><strong>「第四次挥手」</strong>：Client向Server发送断开连接的确认。Server收到以后，这个时候TCP连接就完全断开了。</li>
</ul>
</blockquote>
<h4 id="3-为什么客户端最后还要等待2MSL？"><a href="#3-为什么客户端最后还要等待2MSL？" class="headerlink" title="3. 为什么客户端最后还要等待2MSL？"></a>3. 为什么客户端最后还要等待2MSL？</h4><blockquote>
<p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>2MSL意义：</p>
<blockquote>
<p>1、保证最后一次握手报文能到B，能进行超时重传。</p>
<p>2、2MSL后，这次连接的所有报文都会消失，不会影响下一次连接。</p>
</blockquote>
<p>详细解答 </p>
<blockquote>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
</blockquote>
</blockquote>
<h4 id="4-TCP的状态转移模型（有限状态机）"><a href="#4-TCP的状态转移模型（有限状态机）" class="headerlink" title="4. TCP的状态转移模型（有限状态机）"></a>4. TCP的状态转移模型（有限状态机）</h4><blockquote>
<ul>
<li>TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态。</li>
<li>每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。</li>
<li>状态之间的箭头表示可能发生的状态变迁。</li>
<li>箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。</li>
</ul>
<p>图中有三种不同的箭头。</p>
<ol>
<li>粗实线箭头表示对客户进程的正常变迁。</li>
<li>粗虚线箭头表示对服务器进程的正常变迁。</li>
<li>另一种细线箭头表示异常变迁。</li>
</ol>
</blockquote>
<p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/730879-20170219170921285-996689810.png" alt="img"></p>
<h4 id="5-TCP的三次握手和四次挥手的过程及原因"><a href="#5-TCP的三次握手和四次挥手的过程及原因" class="headerlink" title="5. TCP的三次握手和四次挥手的过程及原因"></a>5. TCP的三次握手和四次挥手的过程及原因</h4><blockquote>
<p>TCP的三次握手过程如下：</p>
<ol>
<li>C-&gt; SYN -&gt; S</li>
<li>S-&gt;SYN/ACK-&gt;C</li>
<li>C-&gt;ACK-&gt;S</li>
</ol>
<p>三次握手的原因：<strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</strong></p>
<p>例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。</p>
<p>TCP的四次挥手过程如下：</p>
<ul>
<li>C-&gt;FIN-&gt;S</li>
<li>S-&gt;ACK-&gt;C</li>
<li>S-&gt;FIN-&gt;C</li>
<li>C-&gt;ACK-&gt;S</li>
</ul>
<p>四次挥手的原因：<strong>由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到FIN包时，TCP协议栈会直接发送一个ACK确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送FIN包</strong>。应用层可以使用系统调用函数read==0来判断对端是否关闭连接。</p>
</blockquote>
<h5 id="5-1-TCP为什么不用两次握手？为什么不用四次？"><a href="#5-1-TCP为什么不用两次握手？为什么不用四次？" class="headerlink" title="5.1  TCP为什么不用两次握手？为什么不用四次？"></a>5.1  TCP为什么不用两次握手？为什么不用四次？</h5><blockquote>
<p>两次不可以</p>
<blockquote>
<p>tcp是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常</p>
</blockquote>
<p>不用四次：</p>
<blockquote>
<p>本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：</p>
</blockquote>
<blockquote>
<ol>
<li>客户端发送syn0给服务器</li>
<li>服务器收到syn0，回复ack(syn0+1)</li>
<li>服务器发送syn1</li>
<li>客户端收到syn1，回复ack(syn1+1) </li>
</ol>
<p>因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。</p>
</blockquote>
</blockquote>
<h5 id="5-2-在三次握手的过程中可以传输数据吗？为什么"><a href="#5-2-在三次握手的过程中可以传输数据吗？为什么" class="headerlink" title="5.2 在三次握手的过程中可以传输数据吗？为什么"></a>5.2 在三次握手的过程中可以传输数据吗？为什么</h5><blockquote>
<p>可以</p>
<ul>
<li>在三次握手的过程中，SYN报文段不能携数据，但需要消耗掉一个序号</li>
<li>ACK报文段可以携带数据，但要消耗一个序号；但不携带数据话，不需要消耗序列号</li>
<li>因此在第三次握手的时候可以携带数据</li>
</ul>
</blockquote>
<h4 id="6-TCP的拥塞控制？"><a href="#6-TCP的拥塞控制？" class="headerlink" title="6 TCP的拥塞控制？"></a>6 TCP的拥塞控制？</h4><blockquote>
<p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>
<p>过程cwnd的大小呈指数增长，直到超过慢启动门限，然后进入拥塞避免阶段，cwnd的大小线性增长，当出现网络拥塞(三个重复的ack或者超时)时候，将慢启动门限设置为出现拥塞时候大小的一半，cwnd的大小重新从0开始进入慢启动阶段。<br>快重传和快恢复：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p>拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口——cwnd。</p>
<p>1、慢开始</p>
<p>最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。</p>
<p>2、拥塞避免</p>
<p>每经过一个往返时间RTT，cwnd就增长1。</p>
<p>在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）</p>
<p>3、快重传</p>
<p>接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。</p>
<p>4、快恢复</p>
<p>当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。</p>
<p>采用快恢复算法时，慢开始只在建立连接和网络超时才使用。</p>
</blockquote>
<h4 id="7-拥塞控制什么时候减慢增长速度？"><a href="#7-拥塞控制什么时候减慢增长速度？" class="headerlink" title="7 拥塞控制什么时候减慢增长速度？"></a>7 拥塞控制什么时候减慢增长速度？</h4><blockquote>
<p>采用慢开始和拥塞避免算法的时候</p>
<ol>
<li><p>一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</p>
</li>
<li><p>一旦出现丢包的情况，就重新进行慢开始，减慢增长速度</p>
</li>
</ol>
<p>采用快恢复和快重传算法的时候</p>
<ol>
<li><p>一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</p>
</li>
<li><p>一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度</p>
</li>
</ol>
</blockquote>
<h4 id="8-介绍滑动窗口协议"><a href="#8-介绍滑动窗口协议" class="headerlink" title="8. 介绍滑动窗口协议"></a>8. 介绍滑动窗口协议</h4><p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/926914251_1582337620808_94597327B024F1B694D69B3314AC9532" alt="img"></p>
<blockquote>
<p>当发送窗口和接收窗口的大小都等于 1时，就是停止等待协议。每发完一个分组就停止发送，等待下一个。</p>
<p>当发送窗口大于1，接收窗口等于1时，就是回退N步协议。</p>
<p>当发送窗口和接收窗口的大小均大于1时，就是选择重发协议。</p>
</blockquote>
<h4 id="9-粘包问题"><a href="#9-粘包问题" class="headerlink" title="9. 粘包问题"></a>9. 粘包问题</h4><h5 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1 概念"></a>1 概念</h5><blockquote>
<p><strong>端到端通信</strong>，由客户端端口+服务端端口+客户端IP+服务端IP+传输协议组成的五元组可以明确的标识一条连接。</p>
<p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</p>
</blockquote>
<h5 id="2-原因"><a href="#2-原因" class="headerlink" title="2 原因"></a>2 原因</h5><blockquote>
<p>1 发送方原因</p>
<p>TCP默认使用<code>Nagle</code>算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：</p>
<ol>
<li>只有上一个分组得到确认，才会发送下一个分组</li>
<li>收集多个小分组，在一个确认到来时一起发送</li>
</ol>
<p>Nagle算法造成了发送方可能会出现粘包问题</p>
<p>2 接收方原因</p>
<p>TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p>
</blockquote>
<h5 id="3-什么时候需要处理沾包现象"><a href="#3-什么时候需要处理沾包现象" class="headerlink" title="3 什么时候需要处理沾包现象"></a>3 什么时候需要处理沾包现象</h5><blockquote>
<ol>
<li>如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象</li>
<li>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了</li>
</ol>
</blockquote>
<h5 id="4-如何处理沾包现象"><a href="#4-如何处理沾包现象" class="headerlink" title="4 如何处理沾包现象"></a>4 如何处理沾包现象</h5><blockquote>
<p>（1）发送方</p>
<p>对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</p>
<p>（2）接收方</p>
<p>接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。</p>
<p>（2）应用层</p>
<p>应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。</p>
<p>解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？</p>
<ol>
<li>格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。</li>
<li>发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。</li>
</ol>
</blockquote>
<h3 id="二-UDP协议"><a href="#二-UDP协议" class="headerlink" title="二 UDP协议"></a>二 UDP协议</h3><blockquote>
<p>UDP协议全称用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p>它有以下特点：</p>
<ol>
<li><p>面向无连接</p>
<p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>
<p>具体来说就是：</p>
</li>
</ol>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<ol start="2">
<li><p>有单播，多播，广播的功能</p>
<p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
</li>
<li><p>UDP是面向报文的</p>
<p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
</li>
<li><p>不可靠性</p>
<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>
<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
</li>
</ol>
<p>5.头部开销小，传输数据报文时是很高效的。</p>
</blockquote>
<h4 id="1-UDP的connect函数"><a href="#1-UDP的connect函数" class="headerlink" title="1. UDP的connect函数"></a>1. UDP的connect函数</h4><blockquote>
<p>除非套接字已连接，否则异步错误是不会返回到UDP套接字的。我们确实可以给UDP套接字调用connect，然而这样做的结果却与TCP连接不同的是没有三路握手过程。内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回调用进程。</p>
<p>对于已连接UDP套接字，与默认的未连接UDP套接字相比，发生了三个变化。</p>
<p>UDP套接字调用了connect系统调用，那么这个UDP上的连接就变成一对一的连接，但是通过这个UDP连接传输数据的性质还是不变的，仍然是不可靠的UDP连接。一旦变成一对一的连接，在调用系统调用发送和接受数据时也就可以使用TCP那一套系统调用了。</p>
<ul>
<li>1、我们再也不能给输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。可以给已连接的UDP套接字调用sendto，但是不能指定目的地址。sendto的第五个参数必须为空指针，第六个参数应该为0.</li>
<li>2、不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect指定协议地址的数据报。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报。</li>
<li>3、由已连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接的UDP套接字不接收任何异步错误。</li>
</ul>
<p>来自任何其他IP地址或断开的数据报不投递给这个已连接套接字，因为它们要么源IP地址要么源UDP端口不与该套接字connect到的协议地址相匹配。</p>
<p>UDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect。调用connect的通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信TFTP，这种情况下，客户和服务器都可能调用connect。</p>
</blockquote>
<h4 id="2-UDP会不会产生粘包问题呢？"><a href="#2-UDP会不会产生粘包问题呢？" class="headerlink" title="2 UDP会不会产生粘包问题呢？"></a>2 UDP会不会产生粘包问题呢？</h4><blockquote>
<p>TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。</p>
<p>UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<p>举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。</p>
</blockquote>
<h2 id="五-应用层"><a href="#五-应用层" class="headerlink" title="五 应用层"></a>五 应用层</h2><h3 id="一-HTTP-HTTPs协议"><a href="#一-HTTP-HTTPs协议" class="headerlink" title="一 HTTP/HTTPs协议"></a>一 HTTP/HTTPs协议</h3><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>1 概念</p>
<blockquote>
<p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件，图片文件，查询结果等）。</p>
<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
</blockquote>
<p>2 特点</p>
<blockquote>
<p>1、<strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。<strong>HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话</strong>。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p>2、无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>3、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>4、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>
<p>5、支持B/S及C/S模式。</p>
<p>6、默认端口80</p>
<p>7、基于TCP协议</p>
</blockquote>
<p>3 HTTP过程概述</p>
<blockquote>
<p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。</p>
<p>HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。</p>
<p>服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
</blockquote>
<p>HTTP 请求/响应的步骤如下：</p>
<blockquote>
<p>1、客户端连接到Web服务器    </p>
<p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com</a>。</p>
<p>2、发送HTTP请求</p>
<p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>
<p>3、服务器接受请求并返回HTTP响应</p>
<p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
<p>4、释放连接TCP连接</p>
<p>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
<p>5、客户端浏览器解析HTML内容</p>
<p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
</blockquote>
<p>4、举例</p>
<blockquote>
<p>在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；</p>
<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口80，和服务器建立TCP连接；</p>
<p>3、浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；</p>
<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；</p>
<p>5、释放 TCP连接；</p>
<p>6、浏览器将该 html 文本并显示内容；</p>
</blockquote>
<h4 id="1-HTTP返回码"><a href="#1-HTTP返回码" class="headerlink" title="1 HTTP返回码"></a>1 HTTP返回码</h4><p>HTTP协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下：</p>
<blockquote>
<p><code>1xx</code>：指示信息–表示请求已接收，继续处理。</p>
<p><code>2xx</code>：成功–表示请求已被成功接收、理解、接受。</p>
<p><code>3xx</code>：重定向–要完成请求必须进行更进一步的操作。</p>
<p><code>4xx</code>：客户端错误–请求有语法错误或请求无法实现。</p>
<p><code>5xx</code>：服务器端错误–服务器未能实现合法的请求。</p>
</blockquote>
<p>常见状态代码、状态描述的详细说明如下。</p>
<blockquote>
<ul>
<li>200 OK：客户端请求成功。</li>
<li>206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围</li>
<li>300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。</li>
<li>301 moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。</li>
<li>302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得，</li>
<li>304 not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li>
<li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li>
</ul>
</blockquote>
<h4 id="2-HTTP报文"><a href="#2-HTTP报文" class="headerlink" title="2 HTTP报文"></a>2 HTTP报文</h4><blockquote>
<p><strong>请求报文构成</strong></p>
<ol>
<li>请求行：包括请求方法、URL、协议/版本</li>
<li>请求头(Request Header)</li>
<li>请求正文(body)</li>
</ol>
<p><strong>响应报文构成</strong></p>
<ol>
<li>状态行</li>
<li>响应头</li>
<li>响应正文</li>
</ol>
</blockquote>
<h4 id="3-HTTP中常见的方法"><a href="#3-HTTP中常见的方法" class="headerlink" title="3 HTTP中常见的方法"></a>3 HTTP中常见的方法</h4><blockquote>
<ul>
<li>GET: 请求指定的页面信息，并返回实体主体。</li>
<li>POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>
<li>HEAD: 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
<li>PUT: 从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li>DELETE: 请求服务器删除指定的页面。</li>
</ul>
</blockquote>
<p>详细内容</p>
<blockquote>
<p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p>
<ol>
<li>GET ：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。</li>
<li>HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</li>
<li>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</li>
<li>PUT：向指定资源位置上传其最新内容。</li>
<li>DELETE：请求服务器删除Request-URI所标识的资源。</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>
<li>OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</li>
<li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</li>
</ol>
</blockquote>
<p>注意事项：</p>
<blockquote>
<ol>
<li>方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。</li>
<li>HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源<em>。</em></li>
</ol>
</blockquote>
<p>请求方式: get与post请求（通过form表单我们自己写写看）</p>
<blockquote>
<ul>
<li>GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输数据，参数之间以&amp;相连，如EditBook?name=test1&amp;id=123456.（请求头里面那个content-type做的这种参数形式，后面讲） POST方法是把提交的数据放在HTTP包的请求体中.</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</li>
<li>GET与POST请求在服务端获取请求数据方式不同，就是我们在服务端取请求数据的时候的方式不同。</li>
</ul>
</blockquote>
<h4 id="4-GET和POST的区别"><a href="#4-GET和POST的区别" class="headerlink" title="4 GET和POST的区别"></a>4 GET和POST的区别</h4><blockquote>
<p>对于GET的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>对于POST的请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p>
</blockquote>
<blockquote>
<ul>
<li>都包含请求头请求行，post多了请求body。</li>
<li>get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入body中。</li>
<li>GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。</li>
<li>GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。</li>
</ul>
</blockquote>
<p>区别：</p>
<blockquote>
<p>1、get参数通过url传递，post放在request body中。</p>
<p>2、get请求在url中传递的参数是有长度限制的，而post没有。</p>
<p>3、get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</p>
<p>4、get请求只能进行url编码，而post支持多种编码方式。</p>
<p>5、get请求会浏览器主动cache，而POST不会，除非手动设置。</p>
<p>6、get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</p>
<p>7、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>
<p>8、GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
</blockquote>
<h5 id="产生两次TCP连接的原因"><a href="#产生两次TCP连接的原因" class="headerlink" title="产生两次TCP连接的原因"></a>产生两次TCP连接的原因</h5><blockquote>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
</blockquote>
<h4 id="5-http协议会话的结束标志"><a href="#5-http协议会话的结束标志" class="headerlink" title="5 http协议会话的结束标志"></a>5 http协议会话的结束标志</h4><blockquote>
<p>看tcp连接是否有断开的四部挥手阶段。</p>
</blockquote>
<h4 id="6-Cookie"><a href="#6-Cookie" class="headerlink" title="6 Cookie"></a>6 Cookie</h4><blockquote>
<p>Cookie，类型为“<strong>小型文本文件</strong>”，是某些网站为了辨别用户身份，进行<a href="https://baike.baidu.com/item/Session/479100" target="_blank" rel="noopener">Session</a>跟踪而储存在用户本地终端上的数据（通常经过加密），由用户<a href="https://baike.baidu.com/item/客户端/101081" target="_blank" rel="noopener">客户端</a>计算机暂时或永久保存的信息</p>
<p>Cookie诞生的最初目的是<strong>为了存储web中的状态信息，以方便服务器端使用</strong>。</p>
<p>Cookie是一个保存在客户机中的简单的文本文件, 这个文件与特定的 <a href="https://baike.baidu.com/item/Web/150564" target="_blank" rel="noopener">Web</a> 文档关联在一起, 保存了该客户机访问这个Web 文档时的信息, 当客户机再次访问这个 Web 文档时这些信息可供该文档使用</p>
</blockquote>
<blockquote>
<p><strong>会话（Session）</strong>跟踪是Web程序中常用的技术，用来<strong>跟踪用户的整个会话</strong>。常用的会话跟踪技术是Cookie与Session。<strong>Cookie通过在客户端记录信息确定用户身份</strong>，<strong>Session通过在服务器端记录信息确定用户身份</strong>。在程序中，会话跟踪是很重要的事情。理论上，<strong>一个用户的所有请求操作都应该属于同一个会话</strong>，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。<strong>HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话</strong>。Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p>
</blockquote>
<p>补充：HTTP的cookie是明文传送的，HTTPS的cooike是密文传送的。</p>
<h4 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h4><blockquote>
<p>HTTPS是身披SSL外壳的HTTP。</p>
<p>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p>
<p>PS: TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。</p>
</blockquote>
<h4 id="2-HTTPS协议的优缺点"><a href="#2-HTTPS协议的优缺点" class="headerlink" title="2 HTTPS协议的优缺点"></a>2 HTTPS协议的优缺点</h4><p>HTTPS优点：</p>
<blockquote>
<ul>
<li>HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</li>
<li>HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</li>
</ul>
</blockquote>
<p>HTTPS缺点：</p>
<blockquote>
<ul>
<li><p>HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</p>
</li>
<li><p>HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</p>
</li>
</ul>
</blockquote>
<h4 id="3-HTTP和HTTPS的区别"><a href="#3-HTTP和HTTPS的区别" class="headerlink" title="3 HTTP和HTTPS的区别"></a>3 HTTP和HTTPS的区别</h4><p>HTTP协议和HTTPS协议区别如下：</p>
<blockquote>
<p>1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</p>
<p>2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</p>
<p>3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</p>
<p>4）HTTP协议端口是80，HTTPS协议端口是443</p>
</blockquote>
<h4 id="4-HTTPS的加密方法"><a href="#4-HTTPS的加密方法" class="headerlink" title="4 HTTPS的加密方法"></a>4 HTTPS的加密方法</h4><p>加密方法主要有对称加密和费对称加密</p>
<h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><blockquote>
<p>需要对加密和解密使用相同密钥的加密算法。所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。</p>
<p>对称加密也叫密钥加密 </p>
<p>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。<br>缺点：对称加密，密钥管理的安全性很低，因为加密和解密都使用同一个密钥，在密钥的发送过程中，密钥可能被第三方截取，导致第三方也可以破解密文。</p>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>在每次发送真实数据之前，服务器先生成一把密钥，然后先把密钥传输给客户端。之后服务器给客户端发送真实数据的时候，会用这把密钥对数据进行加密，客户端收到加密数据之后，用刚才收到的密钥进行解密。</p>
</blockquote>
<h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><blockquote>
<h5 id="密钥的形式"><a href="#密钥的形式" class="headerlink" title="密钥的形式"></a>密钥的形式</h5><p>公钥与私钥是一对。传输双方均有自己的一对密钥（也就是双方每方均有：公、私密钥一把，双方加起来共4把）</p>
<p>例子:传输双方比如是甲乙双方，甲方有配对的公、私密钥一对，且公钥负责加密，私钥负责解对应的公钥加的密。乙方同理。</p>
<h6 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h6><p>非对称密钥的算法强度复杂（是优点也是缺点），安全性依赖于算法与密钥。<br>优点：安全性较高，比对称密钥安全性高很多。 非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要。<br>缺点：由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。</p>
<h6 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h6><ol>
<li>客户端要向服务器发送信息，客户端和服务器都要产生一对用于加密和解密的公钥和私钥。</li>
<li>客户端的私钥保密，客户端的公钥告诉服务器；服务器的私钥保密，服务器的公钥告诉客户端。</li>
<li>客户端要给服务器发送信息时，客户端用服务器的公钥加密信息，因为服务器的公钥是公开的，客户端可以得到。</li>
<li>客户端将这个消息发给服务器（已经用服务器的公钥加密消息）。</li>
<li>服务器收到这个消息后，服务器用自己的私钥解密客户端的消息。其他所有收到这个报文的人都无法解密，因为只有服务器才有服务器的私钥。 </li>
</ol>
</blockquote>
<h4 id="5-HTTPS采用的加密"><a href="#5-HTTPS采用的加密" class="headerlink" title="5 HTTPS采用的加密"></a>5 HTTPS采用的加密</h4><p>HTTPS结合了对称加密+非对称加密这两种方式。</p>
<ul>
<li>首先用非对称加密的方式来传输对称加密过程中的密钥，</li>
<li>其次采取对称加密的方式来传输数据了。</li>
</ul>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><blockquote>
<p>非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
</blockquote>
<h5 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h5><blockquote>
<p>HTTPS采用的是处理信息的方式是：结合对称加密+非对称加密这两种方式，我们可以用非对称加密的方式来传输对称加密过程中的密钥，之后我们就可以采取对称加密的方式来传输数据了。具体是这样子的：</p>
<p>服务器用明文的方式给客户端发送自己的公钥，客户端收到公钥之后，会生成一把密钥(对称加密用的)，然后用服务器的公钥对这把密钥进行加密，之后再把密钥传输给服务器，服务器收到之后进行解密，最后服务器就可以安全得到这把密钥了，而客户端也有同样一把密钥，他们就可以进行对称加密了。</p>
</blockquote>
<h4 id="6-证书"><a href="#6-证书" class="headerlink" title="6 证书"></a>6 证书</h4><blockquote>
<p>事实上，在没有引入证书之前，非对称加密也并非传输安全的，在此举个例子：</p>
<p>服务器以明文的方式给客户端传输公钥的时候，中间人截取了这把属于服务器的公钥，并且把中间人自己的公钥冒充服务器的公钥传输给了客户端。</p>
<p>之后客户端就会用中间人的公钥来加密自己生成的密钥。然后把被加密的密钥传输给服务器，这个时候中间人又把密钥给截取了，中间人用自己的私钥对这把被加密的密钥进行解密，解密后中间人就可以获得这把密钥了。</p>
<p>最后中间人再对这把密钥用刚才服务器的公钥进行加密，再发给服务器。</p>
<p>毫无疑问，在这个过程中，中间人获取了对称加密中的密钥，在之后服务器和客户端的对称加密传输中，这些加密的数据对中间人来说，和明文没啥区别。</p>
<p>非对称性加密之所以不安全，是应为客户端不知道，这把公钥是不是服务器的。因此，我们需要找到一种策略来证明这把公钥就是服务器的，而不是别人冒充的。解决这个问题的方式就是使用数字证书，具体是这样的：</p>
<p>1、我们需要找到一个第三方机构，它是一个拥有公信力、大家都认可的认证中心，那就是数字证书认证机构(简称CA)。<br>2、服务器在给客户端传输公钥的过程中，会把公钥以及服务器的个人信息通过Hash算法生成信息摘要。为了防止信息摘要被人调换，客户端还会用CA提供的私钥对信息摘要进行加密来形成数字签名。并且，最后还会把原来没Hash算法之前的个人信息以及公钥和数字签名合并在一起，形成数字证书。<br>3、当客户端拿到这份数字证书之后，就会用CA提供的公钥来对数字证书里面的数字签名进行解密来得到信息摘要，然后对数字证书里服务器的公钥以及个人信息进行Hash得到另外一份信息摘要。最后把两份信息摘要进行对比，如果一样，则证明这个人是服务器，否则就不是。这样，就可以保证服务器的公钥安全着交给客户端了。</p>
<p>一个重要的问题是，如何安全转交认证机构的公钥是一件很困难的事，因此，大多数浏览器开发商发布版本时，会事先植入常用认证机关的公钥。</p>
</blockquote>
<h4 id="7-数字证书是什么，里面包含哪些内容"><a href="#7-数字证书是什么，里面包含哪些内容" class="headerlink" title="7. 数字证书是什么，里面包含哪些内容"></a>7. 数字证书是什么，里面包含哪些内容</h4><blockquote>
<p>1）概念：</p>
<p>数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系的基础。在用户使用数字证书之前必须首先下载和安装。</p>
<p>认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。</p>
<p>2）数字证书颁发过程：</p>
<p>数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。</p>
<p>3）内容：</p>
<p>数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容：</p>
<ol>
<li><p>证书的版本信息；</p>
</li>
<li><p>证书的序列号，每个证书都有一个唯一的证书序列号；</p>
</li>
<li><p>证书所使用的签名算法；</p>
</li>
<li><p>证书的发行机构名称，命名规则一般采用X.500格式；</p>
</li>
<li><p>证书的有效期，通用的证书一般采用UTC时间格式；</p>
</li>
<li><p>证书所有人的名称，命名规则一般采用X.500格式；</p>
</li>
<li><p>证书所有人的公开密钥；</p>
</li>
<li><p>证书发行者对证书的签名。</p>
</li>
</ol>
</blockquote>
<h3 id="二-DNS协议"><a href="#二-DNS协议" class="headerlink" title="二 DNS协议"></a>二 DNS协议</h3><h4 id="1-DNS解析过程"><a href="#1-DNS解析过程" class="headerlink" title="1. DNS解析过程"></a>1. DNS解析过程</h4><blockquote>
<ol>
<li><p>检查浏览器缓存中是否缓存过该域名对应的IP地址</p>
</li>
<li><p>如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP</p>
</li>
<li><p>向本地域名解析服务系统发起域名解析的请求</p>
</li>
<li><p>向根域名解析服务器发起域名解析请求</p>
</li>
<li><p>根域名服务器返回gTLD域名解析服务器地址</p>
</li>
<li><p>向gTLD服务器发起解析请求</p>
</li>
<li><p>gTLD服务器接收请求并返回Name Server服务器</p>
</li>
<li><p>Name Server服务器返回IP地址给本地服务器</p>
</li>
<li><p>本地域名服务器缓存解析结果</p>
</li>
<li><p>返回解析结果给用户</p>
</li>
</ol>
</blockquote>
<h4 id="2-DNS的查询方式"><a href="#2-DNS的查询方式" class="headerlink" title="2. DNS的查询方式"></a>2. DNS的查询方式</h4><p>递归查询</p>
<p>迭代查询</p>
<h4 id="3-搜索baidu，会用到计算机网络中的什么层？每层是干什么的"><a href="#3-搜索baidu，会用到计算机网络中的什么层？每层是干什么的" class="headerlink" title="3. 搜索baidu，会用到计算机网络中的什么层？每层是干什么的"></a>3. 搜索baidu，会用到计算机网络中的什么层？每层是干什么的</h4><blockquote>
<p>浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p>
<p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p>
<p>其中：</p>
<h4 id="1、DNS协议，http协议，https协议属于应用层"><a href="#1、DNS协议，http协议，https协议属于应用层" class="headerlink" title="1、DNS协议，http协议，https协议属于应用层"></a>1、DNS协议，http协议，https协议属于应用层</h4><p>应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。</p>
<h4 id="2、TCP-UDP属于传输层"><a href="#2、TCP-UDP属于传输层" class="headerlink" title="2、TCP/UDP属于传输层"></a>2、TCP/UDP属于传输层</h4><p>传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>，和无连接的用户数据报协议<a href="https://www.baidu.com/s?wd=UDP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">UDP</a>。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。</p>
<h4 id="3、IP协议，ARP协议属于网络层"><a href="#3、IP协议，ARP协议属于网络层" class="headerlink" title="3、IP协议，ARP协议属于网络层"></a>3、IP协议，ARP协议属于网络层</h4><p>网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。</p>
<h4 id="4、数据链路层"><a href="#4、数据链路层" class="headerlink" title="4、数据链路层"></a>4、数据链路层</h4><p>当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及<a href="https://www.baidu.com/s?wd=流量控制&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">流量控制</a>信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。</p>
<h4 id="5、物理层"><a href="#5、物理层" class="headerlink" title="5、物理层"></a>5、物理层</h4><p>物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如<a href="https://www.baidu.com/s?wd=双绞线&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">双绞线</a>、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。</p>
</blockquote>
<h2 id="六-网络编程"><a href="#六-网络编程" class="headerlink" title="六 网络编程"></a>六 网络编程</h2><h3 id="1-网络编程的基本步骤"><a href="#1-网络编程的基本步骤" class="headerlink" title="1. 网络编程的基本步骤"></a>1. 网络编程的基本步骤</h3><blockquote>
<p>服务端：socket-bind-listen-accept</p>
<p>客户端：socket-connect</p>
</blockquote>
<h3 id="2-请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"><a href="#2-请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？" class="headerlink" title="2. 请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"></a>2. 请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？</h3><blockquote>
<p>这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了epoll,select等这样的io复用情况下，处于运行状态</p>
</blockquote>
<h3 id="3-socket编程中服务器端和客户端主要用到哪些函数"><a href="#3-socket编程中服务器端和客户端主要用到哪些函数" class="headerlink" title="3. socket编程中服务器端和客户端主要用到哪些函数"></a>3. socket编程中服务器端和客户端主要用到哪些函数</h3><blockquote>
<h4 id="1）基于TCP的socket："><a href="#1）基于TCP的socket：" class="headerlink" title="1）基于TCP的socket："></a>1）基于TCP的socket：</h4><p>1、服务器端程序：</p>
<ul>
<li>1 创建一个socket，用函数socket()</li>
<li>2 绑定IP地址、端口等信息到socket上，用函数bind()</li>
<li>3 设置允许的最大连接数，用函数listen()</li>
<li>4 接收客户端上来的连接，用函数accept()</li>
<li>5 收发数据，用函数send()和recv()，或者read()和write()</li>
<li>6 关闭网络连接</li>
</ul>
<p>2、客户端程序：</p>
<ul>
<li>1 创建一个socket，用函数socket()</li>
<li>2 设置要连接的对方的IP地址和端口等属性</li>
<li>3 连接服务器，用函数connect()</li>
<li>4 收发数据，用函数send()和recv()，或read()和write()</li>
<li>5 关闭网络连接</li>
</ul>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552654678444_69CF8398BCC9F204991E623723D022E7" alt="img"></p>
<h4 id="2）基于UDP的socket："><a href="#2）基于UDP的socket：" class="headerlink" title="2）基于UDP的socket："></a>2）基于UDP的socket：</h4><p>1、服务器端流程</p>
<ul>
<li>1 建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</li>
<li>2 设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</li>
<li>3 绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</li>
<li>4 接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</li>
<li>5 向客户端发送数据，使用sendto()函数向服务器主机发送数据。</li>
<li>6 关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</li>
</ul>
<p>2、客户端流程</p>
<ul>
<li>1 建立套接字文件描述符，socket()。</li>
<li>2 设置服务器地址和端口，struct sockaddr。</li>
<li>3 向服务器发送数据，sendto()。 </li>
<li>4 接收服务器的数据，recvfrom()。</li>
<li>5 关闭套接字，close()。</li>
</ul>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552654687053_263E6AFD1A48F8511D04B67EB12AA24C" alt="img"></p>
</blockquote>
<h3 id="4-Socket编程的send-、recv-、accept-、socket-函数？"><a href="#4-Socket编程的send-、recv-、accept-、socket-函数？" class="headerlink" title="4. Socket编程的send()、recv()、accept()、socket()函数？"></a>4. Socket编程的send()、recv()、accept()、socket()函数？</h3><blockquote>
<ol>
<li>send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。</li>
<li>recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。</li>
<li>accept函数用了接收一个连接，内核维护了半连接队列和一个已完成连接队列，当队列为空的时候，accept函数阻塞，不为空的时候accept函数从上边取下来一个已完成连接，返回一个文件描述符。</li>
</ol>
</blockquote>
<h3 id="5-Socket的connect函数"><a href="#5-Socket的connect函数" class="headerlink" title="5 Socket的connect函数"></a>5 Socket的connect函数</h3><p><strong>当用socket建立了套接口后，可以调用connect为这个套接字指明远程端的地址；如果是字节流套接口，connect就使用三次握手建立一个连接；如果是数据报套接口，connect仅指明远程端地址，而不向它发送任何数据。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;　　 　 　</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr * servaddr,socklen_taddrlen)</span></span>; 　</span><br><span class="line"><span class="comment">//返回：0－－－成功　　　-1－－－失败</span></span><br></pre></td></tr></table></figure>

<p>第一个参数是socket函数返回的套接口描述字；第二和第三个参数分别是一个指向套接口地址结构的指针和该结构的大小。</p>
<h1 id="五-数据库"><a href="#五-数据库" class="headerlink" title="五 数据库"></a>五 数据库</h1><p>事物 索引 底层结构 隔离性的几个级别</p>
<h2 id="一-数据库基础"><a href="#一-数据库基础" class="headerlink" title="一 数据库基础"></a>一 数据库基础</h2><h3 id="一-事务"><a href="#一-事务" class="headerlink" title="一 事务"></a>一 事务</h3><blockquote>
<p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。</p>
</blockquote>
<h4 id="0-概念"><a href="#0-概念" class="headerlink" title="0 概念"></a>0 概念</h4><blockquote>
<p>事务就是一组SQL语句; 主要是为了在数据库增删查改的过程中，保证数据的正确和安全。</p>
<p>事务处理(transaction processing)可以用来维护数据库的完整性,它保证成批的MySQL操作要么完全执行,要么完全不执行。</p>
<p>事务处理是一种机制,用来管理必须成批执行的MySQL操作,以保证数据库不包含不完整的操作结果。利用事务处理,可以保证一组操作不会中途停止,它们或者作为整体执行,或者完全不执行(除非明确指示)  。如果没有错误发生,整组语句提交给(写到)数据库表。如果发生错误,则进行回退(撤销)以恢复数据库到某个已知且安全的状态。</p>
<p>事务是访问数据库的一个操作序列，数据库应用系统通过事务集来完成对数据库的存取。<strong>事务的正确执行使得数据库从一种状态转换为另一种状态</strong>。</p>
</blockquote>
<h4 id="1-事物的性质"><a href="#1-事物的性质" class="headerlink" title="1 事物的性质"></a>1 事物的性质</h4><blockquote>
<p><strong>1、原子性</strong></p>
<p>即不可分割，事务要么全部被执行，要么全部不执行。如果事务的所有子事务全部提交成功，则所有的数据库操作被提交，数据库状态发生变化；如果有子事务失败，则其他子事务的数据库操作被回滚，即数据库回到事务执行前的状态，不会发生状态转换</p>
<p><strong>2、一致性</strong></p>
<p>事务的执行使得数据库从一种正确状态转换成另外一种正确状态</p>
<p><strong>3、隔离性</strong></p>
<p>在事务正确提交之前，不允许把事务对该数据的改变提供给任何其他事务，即在事务正确提交之前，它可能的结果不应该显示给其他事务</p>
<p><strong>4、持久性</strong></p>
<p>事务正确提交之后，其结果将永远保存在数据库之中，即使在事务提交之后有了其他故障，事务的处理结果也会得到保存</p>
</blockquote>
<h4 id="2-事务的隔离"><a href="#2-事务的隔离" class="headerlink" title="2 事务的隔离"></a>2 事务的隔离</h4><p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<h5 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h5><blockquote>
<h4 id="1-Read-uncommitted"><a href="#1-Read-uncommitted" class="headerlink" title="1 Read uncommitted"></a>1 Read uncommitted</h4><p><code>读未提交</code>：隔离级别最低的一种事务级别。在这种隔离级别下，会引发脏读、不可重复读和幻读。</p>
<h4 id="2-Read-Committed"><a href="#2-Read-Committed" class="headerlink" title="2 Read Committed"></a>2 Read Committed</h4><p><code>读已提交</code>读到的都是别人提交后的值。这种隔离级别下，会引发不可重复读和幻读，但避免了脏读。</p>
<h4 id="3-Repeatable-Reads"><a href="#3-Repeatable-Reads" class="headerlink" title="3 Repeatable Reads"></a>3 Repeatable Reads</h4><p><code>可重复读</code>这种隔离级别下，会引发幻读，但避免了脏读、不可重复读。</p>
<h4 id="4-Serializable"><a href="#4-Serializable" class="headerlink" title="4 Serializable"></a>4 Serializable</h4><p><code>串行化</code>是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行。脏读、不可重复读、幻读都不会出现。</p>
</blockquote>
<h4 id="3-事物隔离级别查看及修改"><a href="#3-事物隔离级别查看及修改" class="headerlink" title="3 事物隔离级别查看及修改"></a>3 事物隔离级别查看及修改</h4><blockquote>
<p>首先说明一下MySQL查看和修改事务隔离级别的几个命令：</p>
<ul>
<li>查看事务隔离级别使用select @@tx_isolation</li>
<li>修改当前会话事务隔离级别使用<strong>SET session TRANSACTION ISOLATION LEVEL Serializable;</strong>（参数可以为：Read uncommitted|Read committed|Repeatable read|Serializable）</li>
<li>修改全局事务隔离级别使用<strong>SET global TRANSACTION ISOLATION LEVEL Serializable;</strong>（参数可以为：Read uncommitted|Read committed|Repeatable read|Serializable）</li>
</ul>
<p>修改了会话的事务隔离级别，比如MyBatis，getSqlSession()的时候，只针对这一次拿到的Session有效；比如CMD命令行，只对这一次的窗口有效。</p>
<p>修改了全局的事务隔离级别，那么针对此后所有的会话有效，<strong>当前已经存在的会话不受影响</strong>。</p>
<p>关于MySQL事务隔离级别，推荐大家一篇文章，很详细地测试了四种事务隔离级别<a href="https://www.cnblogs.com/snsdzjlz320/p/5761387.html，相信大家读了一定有所进步。" target="_blank" rel="noopener">https://www.cnblogs.com/snsdzjlz320/p/5761387.html，相信大家读了一定有所进步。</a></p>
</blockquote>
<h3 id="二-索引"><a href="#二-索引" class="headerlink" title="二 索引"></a>二 索引</h3><blockquote>
<p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。<br>索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</p>
</blockquote>
<h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1 概念"></a>1 概念</h4><blockquote>
<p>索引<strong>是一个排序的列表</strong>，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。</p>
<p>因为索引并不是关系模型的组成部分，因此不同的DBMS有不同的实现，我们针对MySQL数据库的实现进行说明。</p>
</blockquote>
<h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h4><blockquote>
<p>常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引</p>
<p>1、主键索引：即主索引，根据主键pk_clolum(length)建立索引，不允许重复，不允许空值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD PRIMARY KEY pk_index(&#39;col&#39;)</span><br></pre></td></tr></table></figure>

<p>2、唯一索引：用来建立索引的列的值必须是唯一的，允许空值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;)</span><br></pre></td></tr></table></figure>

<p>3、普通索引：用表中的普通列构造的索引，没有限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;)</span><br></pre></td></tr></table></figure>

<p>4、全文索引：用大文本对象的列构造的索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;) </span><br></pre></td></tr></table></figure>

<p>5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;)</span><br></pre></td></tr></table></figure>

<p>遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。</p>
<p>在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(col1(4),col2(3));</span><br></pre></td></tr></table></figure>

<p>表示使用col1的前4个字符和col2的前3个字符作为索引</p>
</blockquote>
<h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a>3 优缺点</h4><blockquote>
<p>优点：优缺点，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组的排序；</p>
<p>缺点：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间是数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据凉的增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表。</p>
</blockquote>
<blockquote>
<p>优点：</p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ol>
<p>缺点：</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
</blockquote>
<h4 id="4-添加索引原则"><a href="#4-添加索引原则" class="headerlink" title="4 添加索引原则"></a>4 添加索引原则</h4><blockquote>
<p>在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
<p>只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
<p>定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p>
<p>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
</blockquote>
<h4 id="5-索引的底层实现原理"><a href="#5-索引的底层实现原理" class="headerlink" title="5 索引的底层实现原理"></a>5 索引的底层实现原理</h4><blockquote>
<p>MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等等，</p>
<p>1、哈希索引</p>
<p>只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</p>
<p>2、全文索引</p>
<p>FULLTEXT（全文）索引，仅可用于<strong>MyISAM和InnoDB</strong>，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，<strong>在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引</strong>。</p>
<p>3、BTree索引和B+Tree索引</p>
</blockquote>
<h4 id="6-使用策略"><a href="#6-使用策略" class="headerlink" title="6 使用策略"></a>6 使用策略</h4><table>
<thead>
<tr>
<th></th>
<th>MyISAM</th>
<th>innoDB</th>
</tr>
</thead>
<tbody><tr>
<td>索引类型</td>
<td>非聚簇</td>
<td>聚簇</td>
</tr>
<tr>
<td>支持事务</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>支持表锁</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>支持行锁</td>
<td>否</td>
<td>是（默认）</td>
</tr>
<tr>
<td>支持外键</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>支持全文索引</td>
<td>是</td>
<td>是（5.6以后支持）</td>
</tr>
<tr>
<td>适用操作类型</td>
<td>大量select下使用</td>
<td>大量insert、delete和update下使用</td>
</tr>
</tbody></table>
<p><strong>MyISAM—非聚簇索引</strong></p>
<p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。</p>
<p>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>下图是MyISAM索引的原理图：</p>
<p><img src="https://images2017.cnblogs.com/blog/758447/201801/758447-20180127161009725-1788644003.png" alt="img"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="https://images2017.cnblogs.com/blog/758447/201801/758447-20180127161153647-1802334548.png" alt="img"></p>
<ul>
<li>MyISAM存储引擎采用的是非聚簇索引，非聚簇索引的<strong>主索引和辅助索引几乎是一样的</strong>，只是主索引不允许重复，不允许空值，他们的<strong>叶子结点的key都存储指向键值对应的数据的物理地址</strong>。</li>
<li>非聚簇索引的<strong>数据表和索引表是分开存储</strong>的。</li>
<li>非聚簇索引中的数据是根据数据的插入顺序保存。因此非聚簇索引更适合单个数据的查询。插入顺序不受键值影响。</li>
<li>只有在MyISAM中才能使用FULLTEXT索引。(mysql5.6以后innoDB也支持全文索引)</li>
</ul>
<p><strong>InnoDB——聚簇索引</strong></p>
<blockquote>
<p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p><img src="https://images2017.cnblogs.com/blog/758447/201801/758447-20180127161454428-323630182.png" alt="img"></p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<ul>
<li>聚簇索引的<strong>主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值</strong>。因此主键的值长度越小越好，类型越简单越好。</li>
<li>聚簇索引的<strong>数据和主键索引存储在一起</strong>。</li>
<li>聚簇索引的数据是根据主键的顺序保存。因此适合按主键索引的区间查找，可以有更少的磁盘I/O，加快查询速度。但是也是因为这个原因，聚簇索引的插入顺序最好按照主键单调的顺序插入，否则会频繁的引起页分裂，严重影响性能。</li>
<li>在InnoDB中，如果只需要查找索引的列，就尽量不要加入其它的列，这样会提高查询效率。</li>
</ul>
</blockquote>
<h3 id="三-脏读"><a href="#三-脏读" class="headerlink" title="三 脏读"></a>三 脏读</h3><blockquote>
<p><code>脏读</code>指一个事务读取了另外一个事务未提交的数据。</p>
<p><code>不可重复读</code>指在一个事务内读取表中的某一行数据，多次读取结果不同。<br>不可重复读和脏读的区别是，脏读是读取前一事务未提交的脏数据，不可重复读是重新读取了前一事务已提交的数据。</p>
<p><code>幻读(虚读)</code>指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。</p>
</blockquote>
<h3 id="四-数据库范式"><a href="#四-数据库范式" class="headerlink" title="四 数据库范式"></a>四 数据库范式</h3><blockquote>
<p>第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分</p>
<p>第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式</p>
<p>第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码</p>
</blockquote>
<h2 id="二-MySQL"><a href="#二-MySQL" class="headerlink" title="二 MySQL"></a>二 MySQL</h2><h3 id="1-mysql的四种隔离状态"><a href="#1-mysql的四种隔离状态" class="headerlink" title="1 mysql的四种隔离状态"></a>1 mysql的四种隔离状态</h3><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="2-MySQL的端口号是多少，如何修改"><a href="#2-MySQL的端口号是多少，如何修改" class="headerlink" title="2 MySQL的端口号是多少，如何修改"></a>2 MySQL的端口号是多少，如何修改</h3><p>查看端口号：</p>
<p>使用命令show global variables like ‘port’;查看端口号 ，mysql的默认端口是3306。（补充：sqlserver默认端口号为：1433；oracle默认端口号为：1521；DB2默认端口号为：5000；PostgreSQL默认端口号为：5432）</p>
<p>修改端口号：</p>
<p>修改端口号：编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。</p>
<h3 id="3-mysql引擎以及其区别"><a href="#3-mysql引擎以及其区别" class="headerlink" title="3 mysql引擎以及其区别"></a>3 mysql引擎以及其区别</h3><blockquote>
<p>在Mysql数据库中，常用的引擎为Innodb和MyIASM。</p>
<p>其中Innodb是一个事务型的存储引擎，有行级锁定和外键约束，提供了对数据库ACID事物的支持，实现了SQL标准的四种隔离级别，即读未提交，不可重复读，可重复读以及串行,其涉及目标就是处理大数据容量的数据库系统。</p>
<p>而MyIASM引擎是Mysql默认的引擎，不提供数据库事务的支持，也不支持行级锁和外键，因此当写操作时需要锁定整个表，效率较低。不过其保存了表的行数，当金星select count(*)form table时，可直接读取已经保存的值，不需要进行全表扫描。因此当表的读操作远多于写操作，并且不需要事务支持时，可以优先选择MyIASM</p>
</blockquote>
<blockquote>
<p>MyISAM：</p>
<ol>
<li>不支持事务，但是每次查询都是原子的；</li>
<li>支持表级锁，即每次操作是对整个表加锁；</li>
<li>存储表的总行数；</li>
<li>一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；</li>
<li>采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。</li>
</ol>
<p>InnoDb：</p>
<ol>
<li>支持ACID的事务，支持事务的四种隔离级别；</li>
<li>支持行级锁及外键约束：因此可以支持写并发；</li>
<li>不存储总行数；</li>
<li>一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；</li>
<li>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</li>
</ol>
</blockquote>
<h3 id="4-MySQL索引语法"><a href="#4-MySQL索引语法" class="headerlink" title="4 MySQL索引语法"></a>4 MySQL索引语法</h3><p>创建索引</p>
<p>根据索引查询</p>
<p>删除索引</p>
<p>查看表中索引</p>
<p>查看查询语句使用索引的情况</p>
<h3 id="5-MySQL语法"><a href="#5-MySQL语法" class="headerlink" title="5 MySQL语法"></a>5 MySQL语法</h3><h4 id="1-请你说一说inner-join和left-join"><a href="#1-请你说一说inner-join和left-join" class="headerlink" title="1. 请你说一说inner join和left join"></a>1. 请你说一说inner join和left join</h4><p>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录<br>inner join(等值连接) 只返回两个表中联结字段相等的行</p>
<h3 id="6-请你介绍一下mysql的MVCC机制"><a href="#6-请你介绍一下mysql的MVCC机制" class="headerlink" title="6 请你介绍一下mysql的MVCC机制"></a>6 请你介绍一下mysql的MVCC机制</h3><p>MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p>
<h3 id="7-请问SQL优化方法有哪些"><a href="#7-请问SQL优化方法有哪些" class="headerlink" title="7 请问SQL优化方法有哪些"></a>7 请问SQL优化方法有哪些</h3><p>通过建立索引对查询进行优化</p>
<p>对查询进行优化，应尽量避免全表扫描</p>
<h3 id="8-请你说一下MySQL引擎和区别"><a href="#8-请你说一下MySQL引擎和区别" class="headerlink" title="8 请你说一下MySQL引擎和区别"></a>8 请你说一下MySQL引擎和区别</h3><p>1、MySQL引擎</p>
<p>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p>
<p>数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。</p>
<p>MySQL存储引擎主要有： MyIsam、InnoDB、Memory、Blackhole、CSV、Performance_Schema、Archive、Federated、Mrg_Myisam。</p>
<p>但是最常用的是InnoDB和Mylsam。</p>
<p>2、InnoDB</p>
<p>InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。</p>
<p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这类型的文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p>
<p>适用场景：</p>
<p>经常更新的表，适合处理多重并发的更新请求。</p>
<p>支持事务。</p>
<p>可以从灾难中恢复（通过bin-log日志等）。</p>
<p>外键约束。只有他支持外键。</p>
<p>支持自动增加列属性auto_increment。</p>
<p>索引结构：</p>
<p>InnoDB也是B+Treee索引结构。Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p>
<p>3、Mylsam</p>
<p>MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整个表，效率便会低一些。MyIsam 存储引擎独立于操作系统，也就是可以在windows上使用，也可以比较简单的将数据转移到linux操作系统上去。</p>
<p>适用场景：</p>
<p>不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。</p>
<p>不支持外键的表设计。</p>
<p>查询速度很快，如果数据库insert和update的操作比较多的话比较适用。</p>
<p>整天对表进行加锁的场景。</p>
<p>MyISAM极度强调快速读取操作。</p>
<p>MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</p>
<p>缺点：就是不能在表损坏后主动恢复数据。</p>
<p>索引结构：</p>
<p>MyISAM索引结构：MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。</p>
<p>3、InnoDB和Mylsam的区别：</p>
<p>1）事务：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。</p>
<p>2）性能：MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。</p>
<p>3）行数保存：InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。</p>
<p>4）索引存储：对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持。</p>
<p>MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</p>
<p>InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。</p>
<p>5）服务器数据备份：InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p>
<p>MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p>
<p>InnoDB是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p>
<p>6）锁的支持：MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p>
<h2 id="三-redis"><a href="#三-redis" class="headerlink" title="三 redis"></a>三 redis</h2><h3 id="1-mongodb和redis的区别"><a href="#1-mongodb和redis的区别" class="headerlink" title="1 mongodb和redis的区别"></a>1 mongodb和redis的区别</h3><blockquote>
<p>内存管理机制上：Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。</p>
</blockquote>
<p>支持的数据结构上：Redis 支持的数据结构丰富，包括hash、set、list等。</p>
<p>MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富</p>
<h3 id="3-Redis的定时机制怎么实现的"><a href="#3-Redis的定时机制怎么实现的" class="headerlink" title="3 Redis的定时机制怎么实现的"></a>3 Redis的定时机制怎么实现的</h3><blockquote>
<p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：文件事件（服务器对套接字操作的抽象）和时间事件（服务器对定时操作的抽象）。Redis的定时机制就是借助时间事件实现的。</p>
<p>一个时间事件主要由以下三个属性组成：id：时间事件标识号；when：记录时间事件的到达时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件</p>
<p>一个时间事件主要由以下三个属性组成：id：时间事件标识号；when：记录时间事件的到达时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件。</p>
</blockquote>
<h3 id="4-Redis是单线程的，为什么高效"><a href="#4-Redis是单线程的，为什么高效" class="headerlink" title="4 Redis是单线程的，为什么高效?"></a>4 Redis是单线程的，为什么高效?</h3><blockquote>
<p>虽然Redis文件事件处理器以单线程方式运行，但是通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p>
</blockquote>
<h3 id="5-Redis的数据类型有哪些，底层怎么实现"><a href="#5-Redis的数据类型有哪些，底层怎么实现" class="headerlink" title="5 Redis的数据类型有哪些，底层怎么实现?"></a>5 Redis的数据类型有哪些，底层怎么实现?</h3><blockquote>
<p>1）字符串：整数值、embstr编码的简单动态字符串、简单动态字符串（SDS)</p>
<p>2）列表：压缩列表、双端链表</p>
<p>3）哈希：压缩列表、字典</p>
<p>4）集合：整数集合、字典</p>
<p>5）有序集合：压缩列表、跳跃表和字典</p>
</blockquote>
<h3 id="6-Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的"><a href="#6-Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的" class="headerlink" title="6 Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的?"></a>6 Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的?</h3><blockquote>
<p>因为redis是单线程，当K很多时，如果一次性将键值对全部rehash，庞大的计算量会影响服务器性能，甚至可能会导致服务器在一段时间内停止服务。不可能一步完成整个rehash操作，所以redis是分多次、渐进式的rehash。渐进性哈希分为两种：</p>
<p>1）操作redis时，额外做一步rehash</p>
<p>对redis做读取、插入、删除等操作时，会把位于table[dict-&gt;rehashidx]位置的链表移动到新的dictht中，然后把rehashidx做加一操作，移动到后面一个槽位。</p>
<p>2）后台定时任务调用rehash</p>
<p>后台定时任务rehash调用链，同时可以通过server.hz控制rehash调用频率</p>
</blockquote>
<h3 id="7-Redis和memcached的区别"><a href="#7-Redis和memcached的区别" class="headerlink" title="7 Redis和memcached的区别"></a>7 Redis和memcached的区别</h3><blockquote>
<p>1）数据类型 ：redis数据类型丰富，支持set liset等类型；memcache支持简单数据类型，需要客户端自己处理复杂对象</p>
<p>2）持久性：redis支持数据落地持久化存储；memcache不支持数据持久存储。)</p>
<p>3）分布式存储：redis支持master-slave复制模式；memcache可以使用一致性hash做分布式。</p>
<p>4）value大小不同：memcache是一个内存缓存，key的长度小于250字符，单个item存储要小于1M，不适合虚拟机使用</p>
<p>5）数据一致性不同：redis使用的是单线程模型，保证了数据按顺序提交；memcache需要使用cas保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作</p>
<p>6）cpu利用：redis单线程模型只能使用一个cpu，可以开启多个redis进程</p>
</blockquote>
<h1 id="六-设计模式"><a href="#六-设计模式" class="headerlink" title="六 设计模式"></a>六 设计模式</h1><blockquote>
<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
</blockquote>
<h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一 简介"></a>一 简介</h2><h4 id="1-概念-3"><a href="#1-概念-3" class="headerlink" title="1. 概念"></a>1. 概念</h4><blockquote>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p>
</blockquote>
<h4 id="2-六大原则"><a href="#2-六大原则" class="headerlink" title="2. 六大原则"></a>2. 六大原则</h4><blockquote>
<p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：<strong>对扩展开放，对内修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
</blockquote>
<h2 id="二-分类"><a href="#二-分类" class="headerlink" title="二 分类"></a>二 分类</h2><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">模式 &amp; 描述</th>
<th align="left">包括</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>创建型模式</strong> <br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。<br>这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>
<td align="left"><strong>工厂模式（</strong>Factory Pattern）<br><strong>抽象工厂模式（Abstract Factory Pattern）</strong><br><strong>单例模式（Singleton Pattern）</strong><br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>结构型模式</strong><br>这些设计模式关注类和对象的组合。<br>继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td align="left"><strong>代理模式（Proxy Pattern）</strong><br><strong>装饰器模式（Decorator Pattern）</strong><br>适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>行为型模式</strong> <br>这些设计模式特别关注对象之间的通信。</td>
<td align="left"><strong>观察者模式（Observer Pattern）<br></strong>责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>J2EE 模式</strong> <br>这些设计模式特别关注表示层。<br>这些模式是由 Sun Java Center 鉴定的。</td>
<td align="left">MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）<br>组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）<br>拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern）</td>
</tr>
</tbody></table>
<h4 id="设计模式之间的关系"><a href="#设计模式之间的关系" class="headerlink" title="设计模式之间的关系"></a>设计模式之间的关系</h4><p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/../../Nutstore/aseets/image-20200818164627077.png" alt="image-20200818164627077"></p>
<h2 id="三-设计模式"><a href="#三-设计模式" class="headerlink" title="三 设计模式"></a>三 设计模式</h2><h3 id="0-常见设计模式"><a href="#0-常见设计模式" class="headerlink" title="0 常见设计模式"></a>0 常见设计模式</h3><ol>
<li>单例模式：单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</li>
<li>工厂模式：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。</li>
<li>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li>
</ol>
<h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><h4 id="A-简介"><a href="#A-简介" class="headerlink" title="A. 简介"></a>A. 简介</h4><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h4 id="B-介绍"><a href="#B-介绍" class="headerlink" title="B.介绍"></a>B.介绍</h4><table>
<thead>
<tr>
<th></th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>意图</td>
<td>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</td>
</tr>
<tr>
<td>主要解决</td>
<td>一个全局使用的类频繁地创建与销毁。</td>
</tr>
<tr>
<td>何时使用</td>
<td>当您想控制实例数目，节省系统资源的时候。</td>
</tr>
<tr>
<td>如何解决</td>
<td>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</td>
</tr>
<tr>
<td>关键代码</td>
<td>构造函数是私有的。</td>
</tr>
<tr>
<td>优点</td>
<td>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 <br>2、避免对资源的多重占用（比如写文件操作）。</td>
</tr>
<tr>
<td>缺点</td>
<td>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</td>
</tr>
<tr>
<td><strong>应用实例</strong></td>
<td>1、一个班级只有一个班主任。<br> 2、Windows 是多进程多线程的，<br>在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，<br>所以所有文件的处理必须通过唯一的实例来进行。 <br>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</td>
</tr>
<tr>
<td>使用场景</td>
<td>1、要求生产唯一序列号。<br>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 <br>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</td>
</tr>
<tr>
<td>注意事项</td>
<td>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</td>
</tr>
</tbody></table>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>单例模式有许多种实现方法，在C++中，甚至可以直接用一个全局变量做到这一点，但这样的代码显的很不优雅。 使用全局对象能够保证方便地访问实例，但是不能保证只声明一个对象——也就是说除了一个全局实例外，仍然能创建相同类的本地实例。<br>《设计模式》一书中给出了一种很不错的实现，定义一个单例类，使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。 单例模式通过类本身来管理其唯一实例，这种特性提供了解决问题的方法。唯一的实例是类的一个普通对象，但设计这个类时，让它只能创建一个实例并提供对此实例的全局访问。唯一实例类Singleton在静态成员函数中隐藏创建实例的操作。习惯上把这个成员函数叫做Instance()，它的返回值是唯一实例的指针。</p>
<h4 id="C-的实现"><a href="#C-的实现" class="headerlink" title="C++的实现"></a>C++的实现</h4><ol>
<li><p>一种通过局部静态变量，利用其只初始化一次的特点，返回对象。</p>
</li>
<li><p>另外一种，则是定义全局的指针，<code>getInstance</code>判断该指针是否为空，为空时才实例化对象</p>
</li>
</ol>
<p><strong>1. 饿汉式：基于class loader机制避免多线程的同步问题，不过，instance在类装载时就实例化，可能会产生垃圾对象。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Csingleton m_pInstance = <span class="keyword">new</span> CSingleton();<span class="comment">// 直接初始化一个实例对象</span></span><br><span class="line">    <span class="keyword">private</span>: CSingleton()&#123;    <span class="comment">//构造函数是私有的,保证其他类对象不能直接new一个该对象的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">static</span> CSingleton <span class="title">GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>2. 懒汉式：通过双重锁机制实现线程安全</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CSingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CSingleton *m_pInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CSingleton</span><span class="params">()</span></span>&#123;	<span class="comment">//构造函数是私有的</span></span><br><span class="line">        &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CSingleton * <span class="title">GetInstance</span><span class="params">()</span></span>&#123; <span class="comment">//对获取实例的方法进行同步</span></span><br><span class="line">		<span class="keyword">if</span>(m_pInstance == <span class="literal">NULL</span>)  <span class="comment">//判断是否第一次调用</span></span><br><span class="line">        &#123;</span><br><span class="line">            synchronnized(CSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(m_pInstance == <span class="literal">NULL</span>)</span><br><span class="line">                	m_pInstance = <span class="keyword">new</span> CSingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;			</span><br><span class="line">		<span class="keyword">return</span> m_pInstance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>另一个写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/////////////////// 内部静态变量的懒汉实现（C++11 线程安全）////////////////// </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// 获取单实例对象 </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Single &amp;<span class="title">GetInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="comment">// 局部静态特性的方式实现单实例 </span></span><br><span class="line">        <span class="keyword">static</span> Single signal;  <span class="comment">// 如果含有数据成员，需要修改构造函数对数据进行初始化</span></span><br><span class="line">        <span class="keyword">return</span> signal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还需要定义一些外部函数 </span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">// 禁止外部构造 </span></span><br><span class="line">    Single(); </span><br><span class="line">    <span class="comment">// 禁止外部析构 </span></span><br><span class="line">    ~Single(); </span><br><span class="line">    <span class="comment">// 禁止外部复制构造 </span></span><br><span class="line">    Single(<span class="keyword">const</span> Single &amp;signal); </span><br><span class="line">    <span class="comment">// 禁止外部赋值操作 </span></span><br><span class="line">    <span class="keyword">const</span> Single &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Single &amp;signal); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/////////////////// 内部静态变量的懒汉实现 //////////////////</span></span><br></pre></td></tr></table></figure>



<h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h3><p>工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。</p>
<p>优点：解耦，代码复用，更改功能容易。</p>
<h3 id="5-装饰器模式"><a href="#5-装饰器模式" class="headerlink" title="5. 装饰器模式"></a>5. 装饰器模式</h3><p>装饰器模式主要是为了动态的为一个对象增加新的功能，装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</p>
<p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p>缺点：多层装饰比较复杂。</p>
<p>使用场景：1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>
<h3 id="6-观察者模式"><a href="#6-观察者模式" class="headerlink" title="6. 观察者模式"></a>6. 观察者模式</h3><p>观察者模式中分为观察者和被观察者，当被观察者发生装填改变时，观察者会受到通知。主要为了解决对象状态改变给其他对象通知的问题，其实现类似于观察者在被观察者那注册了一个回调函数。</p>
<h1 id="七-其他内容"><a href="#七-其他内容" class="headerlink" title="七 其他内容"></a>七 其他内容</h1><h2 id="一-Git"><a href="#一-Git" class="headerlink" title="一 Git"></a>一 Git</h2><h3 id="0-Git常用指令"><a href="#0-Git常用指令" class="headerlink" title="0 Git常用指令"></a>0 Git常用指令</h3><h4 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init <span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init [project-name]	<span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]	<span class="comment"># 下载一个项目和它的整个代码历史</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h4><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --list <span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config -e [--global]	<span class="comment"># 编辑Git配置文件</span></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">"[name]"</span></span><br><span class="line">$ git config [--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add [file1] [file2] ... 	<span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [dir]		<span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add .		<span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line">$ git add -p	<span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git rm [file1] [file2] ...<span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm --cached [file]	<span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]	<span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m [message]	<span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]	<span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit -a		<span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -v		<span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line">$ git commit --amend -m [message]	<span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...	<span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch	<span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch -r		<span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -a		<span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch [branch-name]	<span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git checkout -b [branch]	<span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git branch [branch] [commit]	<span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]	<span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git checkout [branch-name]	<span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout -	<span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]	<span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git merge [branch]	<span class="comment"># 合并指定分支到当前分</span></span><br><span class="line">$ git cherry-pick [commit]	<span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git branch -d [branch-name]	<span class="comment"># 删除分支</span></span><br><span class="line">$ git push origin --delete [branch-name]	<span class="comment"># 删除远程分支</span></span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag	<span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag [tag]		<span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag] [commit]	<span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag -d [tag]		<span class="comment"># 删除本地tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]	<span class="comment"># 删除远程tag</span></span><br><span class="line">$ git show [tag]	<span class="comment"># 查看tag信息</span></span><br><span class="line">$ git push [remote] [tag]	<span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] --tags	<span class="comment"># 提交所有tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]	<span class="comment"># 新建一个分支，指向某个tag</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status	<span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span>	<span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span>	<span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]	<span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s	<span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature	<span class="comment"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]	</span><br><span class="line">$ git whatchanged [file]	</span><br><span class="line">$ git <span class="built_in">log</span> -p [file]		<span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline 	<span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git shortlog -sn <span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git blame [file]	<span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git diff	<span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff --cached [file]	<span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff HEAD	<span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]	<span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span>	<span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git show [commit]	<span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show --name-only [commit]	<span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show [commit]:[filename]	<span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git reflog	<span class="comment"># 显示当前分支的最近几次提交</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch [remote]	<span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git remote -v	<span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote show [remote]	<span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote add [shortname] [url]	<span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git pull [remote] [branch]	<span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git push [remote] [branch]	<span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] --force		<span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --all	<span class="comment"># 推送所有分支到远程仓库</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout [file]	<span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [commit] [file]	<span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout .	<span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git reset [file]	<span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset --hard	<span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset [commit]	<span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset --hard [commit]	<span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --keep [commit]	<span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-请你回答一下git中Merge和rebase区别"><a href="#1-请你回答一下git中Merge和rebase区别" class="headerlink" title="1. 请你回答一下git中Merge和rebase区别"></a>1. 请你回答一下git中Merge和rebase区别</h3><blockquote>
<p>Merge会自动根据两个分支的共同祖先和两个分支的最新提交 进行一个三方合并，然后将合并中修改的内容生成一个新的 commit，即merge合并两个分支并生成一个新的提交,并且仍然后保存原来分支的commit记录。</p>
<p>Rebase会从两个分支的共同祖先开始提取当前分支上的修改，然后将当前分支上的所有修改合并到目标分支的最新提交后面，如果提取的修改有多个，那git将依次应用到最新的提交后面。Rebase后只剩下一个分支的commit记录</p>
</blockquote>
<h2 id="二-Linux"><a href="#二-Linux" class="headerlink" title="二 Linux"></a>二 Linux</h2><h3 id="1-Linux下怎么得到一个文件的100到200行"><a href="#1-Linux下怎么得到一个文件的100到200行" class="headerlink" title="1. Linux下怎么得到一个文件的100到200行"></a>1. Linux下怎么得到一个文件的100到200行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &#39;100,200p&#39; inputfile</span><br><span class="line">awk &#39;NR&gt;&#x3D;100&amp;&amp;NR&lt;&#x3D;200&#123;print&#125;&#39; inputfile</span><br><span class="line">### head -200 inputfile|tail -100</span><br></pre></td></tr></table></figure>



<h3 id="2-linux内核中的Timer-定时器机制"><a href="#2-linux内核中的Timer-定时器机制" class="headerlink" title="2. linux内核中的Timer 定时器机制"></a>2. linux内核中的Timer 定时器机制</h3><h4 id="1）低精度时钟"><a href="#1）低精度时钟" class="headerlink" title="1）低精度时钟"></a>1）低精度时钟</h4><blockquote>
<p>Linux 2.6.16之前，内核只支持低精度时钟，内核定时器的工作方式</p>
<p>1、系统启动后，会读取时钟源设备(RTC, HPET，PIT…)，初始化当前系统时间。</p>
<p>2、内核会根据HZ(系统定时器频率，节拍率)参数值，设置时钟事件设备，启动tick(节拍)中断。HZ表示1秒种产生多少个时钟硬件中断，tick就表示连续两个中断的间隔时间。</p>
<p>3、设置时钟事件设备后，时钟事件设备会定时产生一个tick中断，触发时钟中断处理函数，更新系统时钟,并检测timer wheel，进行超时事件的处理。</p>
<p>在上面工作方式下，Linux 2.6.16 之前，内核软件定时器采用timer wheel多级时间轮的实现机制，维护操作系统的所有定时事件。timer wheel的触发是基于系统tick周期性中断。</p>
<p>所以说这之前，linux只能支持ms级别的时钟，随着时钟源硬件设备的精度提高和软件高精度计时的需求，有了高精度时钟的内核设计。</p>
</blockquote>
<h4 id="2）高精度时钟"><a href="#2）高精度时钟" class="headerlink" title="2）高精度时钟"></a>2）高精度时钟</h4><blockquote>
<p>Linux 2.6.16 ，内核支持了高精度的时钟，内核采用新的定时器hrtimer，其实现逻辑和Linux 2.6.16 之前定时器逻辑区别：</p>
<p>hrtimer采用红黑树进行高精度定时器的管理，而不是时间轮；</p>
<p>高精度时钟定时器不在依赖系统的tick中断，而是基于事件触发。</p>
<p>旧内核的定时器实现依赖于系统定时器硬件定期的tick，基于该tick，内核会扫描timer wheel处理超时事件，会更新jiffies，wall time(墙上时间，现实时间)，process的使用时间等等工作。</p>
<p>新的内核不再会直接支持周期性的tick，新内核定时器框架采用了基于事件触发，而不是以前的周期性触发。新内核实现了hrtimer(high resolution timer)：于事件触发。</p>
</blockquote>
<h4 id="hrtimer的工作原理"><a href="#hrtimer的工作原理" class="headerlink" title="hrtimer的工作原理"></a>hrtimer的工作原理</h4><blockquote>
<p>通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的Timer 的时间，时钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。</p>
<p>在高精度时钟模式下，操作系统内核仍然需要周期性的tick中断，以便刷新内核的一些任务。hrtimer是基于事件的，不会周期性出发tick中断，所以为了实现周期性的tick中断(dynamic tick)：系统创建了一个模拟 tick 时钟的特殊 hrtimer，将其超时时间设置为一个tick时长，在超时回来后，完成对应的工作，然后再次设置下一个tick的超时时间，以此达到周期性tick中断的需求。</p>
<p>引入了dynamic tick，是为了能够在使用高精度时钟的同时节约能源，这样会产生tickless 情况下，会跳过一些 tick。</p>
<p>新内核对相关的时间硬件设备进行了统一的封装，定义了主要有下面两个结构：</p>
<p>时钟源设备(closk source device)：抽象那些能够提供计时功能的系统硬件，比如 RTC(Real Time Clock)、TSC(Time Stamp Counter)，HPET，ACPI PM-Timer，PIT等。不同时钟源提供的精度不一样，现在pc大都是支持高精度模式(high-resolution mode)也支持低精度模式(low-resolution mode)。</p>
<p>时钟事件设备(clock event device)：系统中可以触发 one-shot（单次）或者周期性中断的设备都可以作为时钟事件设备。</p>
<p>当前内核同时存在新旧timer wheel 和 hrtimer两套timer的实现，内核启动后会进行从低精度模式到高精度时钟模式的切换，hrtimer模拟的tick中断将驱动传统的低精度定时器系统（基于时间轮）和内核进程调度。</p>
</blockquote>
<h3 id="3-awk的使用"><a href="#3-awk的使用" class="headerlink" title="3. awk的使用"></a>3. awk的使用</h3><blockquote>
<p>AWK 是Linux下一种处理文本文件的语言，是一个强大的文本分析工具。</p>
<h4 id="1）作用"><a href="#1）作用" class="headerlink" title="1）作用"></a>1）作用</h4><p>样式扫描和处理语言。它允许创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p>
<h4 id="2）用法"><a href="#2）用法" class="headerlink" title="2）用法"></a>2）用法</h4><p>awk [-F  field-separator]  ‘commands’  input-file(s)</p>
<h4 id="3）内置变量"><a href="#3）内置变量" class="headerlink" title="3）内置变量"></a>3）内置变量</h4><table>
<thead>
<tr>
<th>ARGC</th>
<th>命令行参数个数</th>
</tr>
</thead>
<tbody><tr>
<td>ARGV</td>
<td>命令行参数排列</td>
</tr>
<tr>
<td>ENVIRON</td>
<td>支持队列中系统环境变量的使用</td>
</tr>
<tr>
<td>FILENAME</td>
<td>awk浏览的文件名</td>
</tr>
<tr>
<td>FNR</td>
<td>浏览文件的记录数</td>
</tr>
<tr>
<td>FS</td>
<td>设置输入域分隔符，等价于命令行 -F选项</td>
</tr>
<tr>
<td>NF</td>
<td>浏览记录的域的个数</td>
</tr>
<tr>
<td>NR</td>
<td>已读的记录数</td>
</tr>
<tr>
<td>OFS</td>
<td>输出域分隔符</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符</td>
</tr>
<tr>
<td>RS</td>
<td>控制记录分隔符</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="4）实例"><a href="#4）实例" class="headerlink" title="4）实例"></a>4）实例</h4><blockquote>
<p>1、找到当前文件夹下所有的文件和子文件夹,并显示文件大小</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">\&gt; ls -l | awk <span class="string">'&#123;print $5 "\t" $9&#125;'</span></span><br></pre></td></tr></table></figure>

<p>读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域。$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”。</p>
<p>2、找到当前文件夹下所有的文件和子文件夹，并显示文件大小，并显示排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ls -l | awk &#39;BEGIN &#123;COUNT &#x3D; -1; print &quot;BEGIN COUNT&quot;&#125;</span><br><span class="line">&#123;COUNT &#x3D; COUNT + 1; print COUNT&quot;\t&quot;$5&quot;\t&quot;$9&#125;</span><br><span class="line">END &#123;print &quot;END, COUNT &#x3D; &quot;COUNT&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>先处理BEGIN， 然后进行文本分析，进行第二个{}的操作，分析完进行END操作。</p>
<p>3、找到当前文件夹下所有的子文件夹,并显示排序</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">\&gt; ls -l | awk 'BEGIN &#123;<span class="built_in">print</span> "BEGIN COUNT"&#125; /<span class="number">4096</span>/&#123;<span class="built_in">print</span> NR"\t"$<span class="number">5</span>"\t"$<span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line">END &#123;<span class="built_in">print</span> "END"&#125;'</span><br></pre></td></tr></table></figure>

<p>* /4096/ 正则匹配式子</p>
<p>* 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推。</p>
</blockquote>
<h3 id="4-linux-的索引节点"><a href="#4-linux-的索引节点" class="headerlink" title="4. linux 的索引节点"></a>4. linux 的索引节点</h3><blockquote>
<p>inode包含文件的元信息，具体来说有以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 文件的字节数</span><br><span class="line">* 文件拥有者的User ID</span><br><span class="line">* 文件的Group ID</span><br><span class="line">* 文件的读、写、执行权限</span><br><span class="line">* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</span><br><span class="line">* 链接数，即有多少文件名指向这个inode</span><br><span class="line">* 文件数据block的位置</span><br></pre></td></tr></table></figure>

<p>至于为什么没有文件名，是因为由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</span><br><span class="line">2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。</span><br><span class="line">3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-Linux-文件操作"><a href="#5-Linux-文件操作" class="headerlink" title="5. Linux 文件操作"></a>5. Linux 文件操作</h3><blockquote>
<p>&gt;        输出重定向到一个文件或设备 覆盖原来的文件<br>&gt;!       输出重定向到一个文件或设备 强制覆盖原来的文件<br>&gt;&gt;       输出重定向到一个文件或设备 追加原来的文件<br>&lt;        输入重定向到一个程序 </p>
</blockquote>
<h3 id="awk-命令"><a href="#awk-命令" class="headerlink" title="awk 命令"></a>awk 命令</h3><blockquote>
<ul>
<li>-F fs or –field-separator fs<br>指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。</li>
<li>-v var=value or –asign var=value<br>赋值一个用户定义变量。</li>
<li>-f scripfile or –file scriptfile<br>从脚本文件中读取awk命令。</li>
<li>-mf nnn and -mr nnn<br>对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li>
<li>-W compact or –compat, -W traditional or –traditional<br>在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</li>
<li>-W copyleft or –copyleft, -W copyright or –copyright<br>打印简短的版权信息。</li>
<li>-W help or –help, -W usage or –usage<br>打印全部awk选项和每个选项的简短说明。</li>
<li>-W lint or –lint<br>打印不能向传统unix平台移植的结构的警告。</li>
<li>-W lint-old or –lint-old<br>打印关于不能向传统unix平台移植的结构的警告。</li>
<li>-W posix<br>打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符<strong>和</strong>=不能代替^和^=；fflush无效。</li>
<li>-W re-interval or –re-inerval<br>允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。</li>
<li>-W source program-text or –source program-text<br>使用program-text作为源代码，可与-f命令混用。</li>
<li>-W version or –version<br>打印bug报告信息的版本。</li>
</ul>
</blockquote>
<h2 id="三-GDB调试"><a href="#三-GDB调试" class="headerlink" title="三 GDB调试"></a>三 GDB调试</h2><p>GNU symbolic debugger，简称「<strong>GDB 调试器</strong>」，是 Linux 平台下最常用的一款程序调试器。GDB 编译器通常以 gdb 命令的形式在终端（Shell）中使用，它有很多选项，这是我们要重点学习的。</p>
<p>发展至今，GDB 调试器已经对 C、C++、Go、Objective-C、OpenCL、Ada 等多种编程语言提供了支持。实际场景中，GDB 更常用来调试 C 和 C++ 程序，虽然 Linux 平台下有很多能编写 C、C++ 代码的集成开发工具（IDE），但它们调试代码的能力往往都源自 GDB 调试器。</p>
<p>调试是开发流程中一个非常重要的环境，每个程序员都应具备调试代码的能力，尤其对于从事 Linux C/C++ 开发的读者，必须具备熟练使用 GDB 调试器的能力。</p>
<p>通过调试程序，我们可以监控程序执行的每一个细节，包括变量的值、函数的调用过程、内存中数据、线程的调度等，从而发现隐藏的错误或者低效的代码。</p>
<h2 id="四-Cmake"><a href="#四-Cmake" class="headerlink" title="四 Cmake"></a>四 Cmake</h2><h1 id="八-面试经历"><a href="#八-面试经历" class="headerlink" title="八 面试经历"></a>八 面试经历</h1><h2 id="一-网易雷火"><a href="#一-网易雷火" class="headerlink" title="一 网易雷火"></a>一 网易雷火</h2><table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>C++</td>
<td>Volatile<br>C++的编译过程</td>
</tr>
<tr>
<td>操作系统</td>
<td>1. 进程与线程的区别；<br>2. 自旋锁 互斥锁<br>3.</td>
</tr>
<tr>
<td></td>
<td>死锁的四个条件</td>
</tr>
<tr>
<td></td>
<td>生产者消费者问题</td>
</tr>
<tr>
<td>计算机网络</td>
<td>四次挥手</td>
</tr>
<tr>
<td>手撕代码</td>
<td>根据前序遍历结果和中序遍历结果得到后序遍历结果<br>#define</td>
</tr>
<tr>
<td></td>
<td>1-n丢了两个数 怎么找出来？</td>
</tr>
<tr>
<td></td>
<td>首先：位运算中异或的性质：<strong>两个相同数字异或=0</strong>，<strong>一个数和0异或还是它本身</strong>。<br>当<strong>只有一个数出现一次</strong>时，我们把数组中所有的数，依次异或运算，最后剩下的就是落单的数，因为成对儿出现的都抵消了。<br>依照这个思路，我们来看两个数（我们假设是AB）出现一次的数组。<br>我们首先还是先异或，剩下的数字肯定是A、B异或的结果，<strong>这个结果的二进制中的1，表现的是A和B的不同的位</strong>。<br>我们就取第一个1所在的位数，假设是第3位，接着把原数组分成<strong>两组</strong>，分组标准是第3位是否为1。<br>如此，<strong>相同的数肯定在一个组</strong>，因为相同数字所有位都相同，而不同的数，<strong>肯定不在一组</strong>。<br>然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。</td>
</tr>
<tr>
<td>反问环节</td>
<td></td>
</tr>
<tr>
<td>结果</td>
<td>人才库</td>
</tr>
</tbody></table>
<p>找丢失的数可以使用异或位运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k:data) ret^=k;</span><br><span class="line">    ret &amp;= (-ret);</span><br><span class="line">    *num1 = <span class="number">0</span>,*num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k:data)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;ret) *num1^=k;</span><br><span class="line">        <span class="keyword">else</span> *num2^=k;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-猿辅导"><a href="#二-猿辅导" class="headerlink" title="二 猿辅导"></a>二 猿辅导</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><blockquote>
<p>做了两个算法题，题目：</p>
<ol>
<li><p>给定一个vector&lt;vector<string>&gt;表示一个段落，其中的vector<string> 表示段落，string表示句子，我们希望一个页面中最多有五句话，同一个段落尽量在同一个页面。因此需要重新划分段落，让他们尽量在同一个页面。</string></string></p>
<p>如果给定的大小为<code>{3,2,1,6,1}</code>，则最后得到的应该是<code>{5,1,5,2}</code></p>
</li>
</ol>
<ol start="2">
<li><h4 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">K 个一组翻转链表</a></h4><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p><strong>示例：</strong></p>
<p>给你这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>当 <em>k</em> = 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>当 <em>k</em> = 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
</li>
</ol>
<p>   我用了一个迭代的思路去做，写题用了10min 最后给面试官讲题用了10分钟，没有时间问我基础知识了，很开心</p>
</blockquote>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>准备：专心致志把网络+算法+数据结构+CPP+操作系统搞定。据说数据库没那么重要之后再学习吧。</p>
<table>
<thead>
<tr>
<th>二面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>C++</td>
<td>1. 指针与引用的区别<br>2. C++中的智能指针</td>
</tr>
<tr>
<td>操作系统</td>
<td>进程与线程的区别；<br>线程共享的是什么东西；<br>一个线程崩溃会不会影响别的线程</td>
</tr>
<tr>
<td></td>
<td>进程中有哪些锁及其机制</td>
</tr>
<tr>
<td></td>
<td>讲讲虚拟内存</td>
</tr>
<tr>
<td>计算机网络</td>
<td>1. HTTP协议中有哪些方法（GET、POST）细说；<br>2. 谈谈Cookie</td>
</tr>
<tr>
<td>手撕代码</td>
<td>删除第K个链表结点（双指针）<br><br>需要注意一下细节；</td>
</tr>
<tr>
<td></td>
<td>之字形遍历二叉树；<br>我用了一个栈把偶数层的数字倒腾一下，然后逆序输出；<br>面试官想要一个更优的解法，没有想出来。<br>最后LeetCode上说是需要用一个双端队列。</td>
</tr>
<tr>
<td>反问环节</td>
<td>数据库的内容相对于客户端开发来说有多重要<br>答：没那么重要，一般都是封装好的。只有数据分析的时候才会用到</td>
</tr>
<tr>
<td>结果</td>
<td>人才库</td>
</tr>
</tbody></table>
<h2 id="三-小米"><a href="#三-小米" class="headerlink" title="三 小米"></a>三 小米</h2><table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td>面试官做过SLAM和可穿戴算法。对项目比较感兴趣。<br>讲过的点主要有：<br>1. 相机的投影模型；IMU的测量模型；相机与IMU的联合标定<br>2. 卡尔曼滤波跟非线性优化的区别，以及为什么要用非线性优化<br>3. 高斯牛顿法和随机梯度下降 凸优化问题<br>4. 雅克比矩阵、海森矩阵与上述两种方法的对应关系</td>
</tr>
<tr>
<td>代码题</td>
<td>股票收益问题（买入和卖出一次，收益的最大值）。</td>
</tr>
<tr>
<td>反问</td>
<td>可穿戴的产品主要有哪些：手环和手表<br>可穿戴产品中的信息源主要有哪些？PPG(生理信号，心率 血糖 血氧)；ECG(运动用户)<br>如果后续有面试，会安排在什么时候？面试官说肯定有，想要个算法的还是工程的，我选了工程的</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>二面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td>工程面直接手撕了三个题</td>
</tr>
<tr>
<td>C语言基础知识</td>
<td>C语言纠错题<br>   1. return 0;表示的意思<br>   2. malloc free一一要对应<br>   3. sizeof()的大小；strlen统计字符串长度<br></td>
</tr>
<tr>
<td>代码题</td>
<td>2. 翻转链表<br>   1. 最好不要用哨兵节点，面试官嫌弃浪费空间；<br>3. 判断数字是不是回文数字<br>   1. 不要用C++转换为字符串来做（不要调string类）<br>   2. 最后的做法 a除10取余， b = b*10+m;保存到另外一个数字b中，最后看a和b是不是相等</td>
</tr>
<tr>
<td>反问</td>
<td>算法与工程之间的关系：<br>没有高下之分，都很重要，但可穿戴算法岗还是更偏算法</td>
</tr>
</tbody></table>
<h2 id="四-奇安信"><a href="#四-奇安信" class="headerlink" title="四 奇安信"></a>四 奇安信</h2><table>
<thead>
<tr>
<th>一面</th>
<th>聊了20分钟项目和常用的环境 面试官说没有啥想问的了，之后可能是看我笔试成绩不错 给了二面机会</th>
</tr>
</thead>
<tbody><tr>
<td>二面</td>
<td>sizeof()；<br>删除链表中的重复元素II<br>删除容器中的偶数元素（尽量用优雅一点的方法）；<br>函数指针的定义等等</td>
</tr>
<tr>
<td>三面</td>
<td>平常的学习方法；<br>城市要求；<br>自己的学习优势</td>
</tr>
</tbody></table>
<h2 id="五-深信服"><a href="#五-深信服" class="headerlink" title="五 深信服"></a>五 深信服</h2><table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td></td>
</tr>
<tr>
<td>C++</td>
<td>多态；虚函数</td>
</tr>
<tr>
<td>算法与数据结构</td>
<td>哈希表</td>
</tr>
<tr>
<td>操作系统</td>
<td>进程的通信方式</td>
</tr>
<tr>
<td>计算机网络</td>
<td>1. TCP与UDP的区别<br>2. TCP/IP五层网络模型</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td></td>
</tr>
<tr>
<td>C++</td>
<td>多态的介绍</td>
</tr>
<tr>
<td></td>
<td>虚函数重写机制及原理（虚函数表指针）</td>
</tr>
<tr>
<td></td>
<td>内存对齐的介绍</td>
</tr>
<tr>
<td></td>
<td>智能指针的原理</td>
</tr>
<tr>
<td>算法与数据结构</td>
<td>哈希表<br>哈希表冲突的解决方式<br>扩容原理</td>
</tr>
<tr>
<td></td>
<td>红黑树与B树介绍一下（答不上来）</td>
</tr>
<tr>
<td>操作系统</td>
<td>进程的通信方式</td>
</tr>
<tr>
<td>手撕代码</td>
<td>白纸上手写翻转链表</td>
</tr>
<tr>
<td>开放性问题</td>
<td>1千万条域名怎么找出其中的一条域名</td>
</tr>
<tr>
<td></td>
<td>马走日，从一个起点到终点的最短距离</td>
</tr>
</tbody></table>
<h2 id="六-腾讯"><a href="#六-腾讯" class="headerlink" title="六 腾讯"></a>六 腾讯</h2><table>
<thead>
<tr>
<th>一面挂流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td>面试官深问过后 觉得我没有什么工作量</td>
</tr>
<tr>
<td>C++</td>
<td></td>
</tr>
<tr>
<td></td>
<td>static关键字的作用</td>
</tr>
<tr>
<td></td>
<td>array与list 的区别</td>
</tr>
<tr>
<td></td>
<td>哈希表；stl；map；unordered_map</td>
</tr>
<tr>
<td></td>
<td>多态 cpp struct A {     int a;     virtual int func(); }; sizeof(A);</td>
</tr>
<tr>
<td>其它工具</td>
<td>gdb；</td>
</tr>
<tr>
<td>Linux</td>
<td>awk；</td>
</tr>
<tr>
<td>Git</td>
<td>git</td>
</tr>
<tr>
<td>代码题</td>
<td>二分查找</td>
</tr>
<tr>
<td></td>
<td>链表翻转</td>
</tr>
<tr>
<td></td>
<td>层序遍历；按行输出</td>
</tr>
<tr>
<td>结果</td>
<td>人才库</td>
</tr>
</tbody></table>
<h2 id="七-字节跳动（头条）"><a href="#七-字节跳动（头条）" class="headerlink" title="七 字节跳动（头条）"></a>七 字节跳动（头条）</h2><table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td>Git<br>怎么做的滤波</td>
</tr>
<tr>
<td>C++</td>
<td>多态与虚函数机制</td>
</tr>
<tr>
<td></td>
<td>vector的扩容原理</td>
</tr>
<tr>
<td></td>
<td>map与unordered_map的区别；<br>哈希表的缺点<br>哈希表与红黑树相比有什么缺点</td>
</tr>
<tr>
<td>数据结构</td>
<td>哈希表的优点和缺点<br>哈希表怎么解决冲突的</td>
</tr>
<tr>
<td>OS</td>
<td>进程与线程的区别</td>
</tr>
<tr>
<td></td>
<td>进程的通信方式<br>管道为什么不属于系统IPC？<br>进程有哪些状态<br>线程有哪些状态<br>异常和中断</td>
</tr>
<tr>
<td>计算机网络</td>
<td>TCP与UDP协议的区别<br>HTTP与HTTPS协议</td>
</tr>
<tr>
<td>代码题</td>
<td>决策树的剪枝<br>使用递归的方法进行剪枝，先减掉左右子树的枝子，再减根节点的就可一</td>
</tr>
<tr>
<td></td>
<td>层序遍历；按行输出</td>
</tr>
<tr>
<td>面试官建议</td>
<td>下一次复习操作系统的知识点，可能会考很多；包括锁什么的`</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>二面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>C++</td>
<td>多态与虚函数机制</td>
</tr>
<tr>
<td></td>
<td>模板与define的区别（答错了）</td>
</tr>
<tr>
<td></td>
<td>new和malloc的区别</td>
</tr>
<tr>
<td></td>
<td>右值引用（瞎答了）</td>
</tr>
<tr>
<td>数据结构</td>
<td>不需要辅助空间的排序算法（快排不算）</td>
</tr>
<tr>
<td></td>
<td>归并排序</td>
</tr>
<tr>
<td></td>
<td>快速排序和归并排序的区别（中招了）</td>
</tr>
<tr>
<td>OS</td>
<td>进程与线程的区别</td>
</tr>
<tr>
<td></td>
<td>进程调度算法</td>
</tr>
<tr>
<td></td>
<td>僵尸进程（不清楚）</td>
</tr>
<tr>
<td></td>
<td>异常和中断</td>
</tr>
<tr>
<td></td>
<td>虚拟内存；分块的程序被加载到了哪里（想不起来）；其实是（cache）</td>
</tr>
<tr>
<td>设计模式</td>
<td>观察者模式</td>
</tr>
<tr>
<td></td>
<td>怎么实现观察者模式（乱说一通）</td>
</tr>
<tr>
<td>Git</td>
<td>怎么合并分支</td>
</tr>
<tr>
<td>代码题</td>
<td>单链表中，奇数节点有序、偶数节点有序，试着在O（n）的时间复杂度内重排整个链表</td>
</tr>
</tbody></table>
<p>代码题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1-&gt;8-&gt;3-&gt;6-&gt;5-&gt;4-&gt;7-&gt;2-&gt;9&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;重排之后如下:</span><br><span class="line">1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9</span><br><span class="line">&#x2F;&#x2F;我的思路，拆分链表，翻转链表，合并链表</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>三面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>算法与数据结构</td>
<td>讲一下快排和归并的区别</td>
</tr>
<tr>
<td></td>
<td>单链表怎么进行快排</td>
</tr>
<tr>
<td>代码题</td>
<td>判断当前是否发生了死锁</td>
</tr>
<tr>
<td>聊天</td>
<td></td>
</tr>
</tbody></table>
<h2 id="八-网易互娱"><a href="#八-网易互娱" class="headerlink" title="八 网易互娱"></a>八 网易互娱</h2><table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td>Git<br>怎么做的滤波</td>
</tr>
<tr>
<td>C++</td>
<td>多态与虚函数机制<br>C++中的智能指针<br>虚函数与纯虚函数<br>泛型编程（不会）</td>
</tr>
<tr>
<td></td>
<td>vector的扩容原理</td>
</tr>
<tr>
<td></td>
<td>map与unordered_map的区别；<br>vector与list的区别</td>
</tr>
<tr>
<td>数据结构</td>
<td>哈希表的构造方法<br>哈希表怎么解决冲突的</td>
</tr>
<tr>
<td>OS</td>
<td>进程与线程的区别<br>僵尸进程</td>
</tr>
<tr>
<td></td>
<td>进程的通信方式<br>介绍一下虚拟内存<br>异常和中断</td>
</tr>
<tr>
<td>计算机网络</td>
<td>TCP与UDP协议的区别<br>TCP的三次握手与四次挥手<br>HTTP与HTTPS协议</td>
</tr>
<tr>
<td>代码题</td>
<td>1、实现一个循环队列<br>2、LRU算法</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">p = p+<span class="number">1</span>; <span class="comment">//地址+1被重载</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,p); <span class="comment">//输出是4</span></span><br></pre></td></tr></table></figure>



<h2 id="九-58同城"><a href="#九-58同城" class="headerlink" title="九 58同城"></a>九 58同城</h2><table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>二面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td>发明怎么写的</td>
</tr>
<tr>
<td></td>
<td>项目怎么做的</td>
</tr>
<tr>
<td>C++</td>
<td>C++的三大特性描述</td>
</tr>
<tr>
<td>计算机网络</td>
<td>TCP有哪些协议</td>
</tr>
<tr>
<td></td>
<td>一个报文发送的时候主要由什么组成（各种报头+数据）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>HR面</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td></td>
</tr>
<tr>
<td>意向薪资 当前offer状况</td>
<td></td>
</tr>
<tr>
<td>应聘优势</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>工作</tag>
        <tag>笔试</tag>
        <tag>计算机网络</tag>
        <tag>算法</tag>
        <tag>操作系统</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 笔试注意事项</title>
    <url>/2020/08/17/C-%E7%AC%94%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>本文主要目的就是为了排除笔试与面试之中写C++代码时候的坑及各种低级错误。</p>
<a id="more"></a>

<h2 id="一-常见错误"><a href="#一-常见错误" class="headerlink" title="一 常见错误"></a>一 常见错误</h2><ol>
<li>声明指针数组时</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">new</span> a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>千万不要用<code>（）</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A (*ga)[n] = <span class="keyword">new</span> A[m][n]; </span><br><span class="line">... </span><br><span class="line"><span class="keyword">delete</span> []ga;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>条件表达式中的<code>==</code>与<code>=</code>区分开</li>
<li>变量名不要抄错</li>
<li>过不了的时候 尝试使用long换int</li>
</ol>
<h2 id="二-标准输入输出"><a href="#二-标准输入输出" class="headerlink" title="二 标准输入输出"></a>二 标准输入输出</h2><h2 id="2-1-常见输入"><a href="#2-1-常见输入" class="headerlink" title="2.1 常见输入"></a>2.1 常见输入</h2><h3 id="基础：cin-cin-getline-cin-get-getline（string）简单用法"><a href="#基础：cin-cin-getline-cin-get-getline（string）简单用法" class="headerlink" title="基础：cin / cin.getline / cin.get / getline（string）简单用法"></a>基础：cin / cin.getline / cin.get / getline（string）简单用法</h3><ol>
<li>Tab、space结束符。enter是判断输入流结束的表现。不要把他和普通的结束符看成一样的。</li>
<li>cin.getline / cin.get都是遇到enter会终止，但不同的是，cin.getline会把缓冲区当中的enter删除掉，不影响下一次的输入。而cin.get不会删除。</li>
<li>getline（string）：Get line from stream into string (function )，不是遇到space tab就结束的，会记录下字符串当中的space。</li>
</ol>
<h3 id="零、’-’-作为输入分隔符"><a href="#零、’-’-作为输入分隔符" class="headerlink" title="零、’,’ 作为输入分隔符"></a><strong>零、’,’ 作为输入分隔符</strong></h3><p>例题：输入五个学生的名字，每个学生的名字不超过10个字符，输入时学生名字之间用逗号隔开，把这五个名字存储并换行输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> i;<span class="comment">// 每次遇到',' 就终止了 ，不保留在缓冲区。</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="built_in">cin</span>.getline(a[i],<span class="number">10</span>,<span class="string">','</span>);</span><br><span class="line"><span class="comment">// 最后一个是输入5'/n'没有','不符合上面的式子，需要重新把缓冲区中的读出来</span></span><br><span class="line">	<span class="built_in">cin</span>.getline(a[i],<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input:<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>（最后必须有enter保证跳出了输入流）</span><br><span class="line">out:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>这样我们就可以完成完成用任何符号作为分割符的输入了！此处getline换成get是不行的，因为cin.get不会删除缓冲区中的分隔符’，‘  后续输入不能继续进行</p>
<h3 id="一、以空格为间隔的数组"><a href="#一、以空格为间隔的数组" class="headerlink" title="一、以空格为间隔的数组"></a>一、以空格为间隔的数组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input: </span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<p>注意1 2 3 4 5之后有enter，enter是判断输入流结束的表现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、多组测试数据（while-cin-gt-gt-…-）"><a href="#二、多组测试数据（while-cin-gt-gt-…-）" class="headerlink" title="二、多组测试数据（while(cin&gt;&gt;…)）"></a>二、多组测试数据（while(cin&gt;&gt;…)）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">比如 输入的N组数据</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 2 3 4 5</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">123</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123; <span class="comment">//while cin这里</span></span><br><span class="line">    <span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、无空格-的字符串，cin-gt-gt-如果是char-memset"><a href="#三、无空格-的字符串，cin-gt-gt-如果是char-memset" class="headerlink" title="三、无空格 的字符串，cin&gt;&gt; , 如果是char[] memset"></a>三、无<strong>空格</strong> 的字符串，cin&gt;&gt; , 如果是char[] memset</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;//和string是两个东西！！</span></span></span><br><span class="line"><span class="keyword">char</span> out[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memset</span>(out,<span class="string">'0'</span>,<span class="number">8</span>);<span class="comment">//初始化注意</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">30</span>];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str; </span><br><span class="line"><span class="comment">//也可以用string，但是都不记录空格</span></span><br></pre></td></tr></table></figure>

<p>输出的时候也必须</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;<span class="comment">//必须是这种</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; out[i]; <span class="comment">//否则会出现 烫烫</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四-、有空格的字符数组：cin-getline-不记录’-n’-or-cin-get（记录’-n’）"><a href="#四-、有空格的字符数组：cin-getline-不记录’-n’-or-cin-get（记录’-n’）" class="headerlink" title="四 、有空格的字符数组：cin.getline(不记录’\n’) or cin.get（记录’\n’）"></a>四 、有空格的字符数组：cin.getline(不记录’\n’) or cin.get（记录’\n’）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">30</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(str,<span class="number">30</span>);<span class="comment">//读入整行数据，它使用回车键输入的换行符来确定输入结尾。</span></span><br><span class="line"><span class="comment">//cin.get(str,len);//这个还会保留换行符</span></span><br></pre></td></tr></table></figure>

<h3 id="五、输入字符串string"><a href="#五、输入字符串string" class="headerlink" title="五、输入字符串string"></a>五、输入字符串string</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br><span class="line"><span class="comment">//cin&gt;&gt;str;不能包含空格了</span></span><br></pre></td></tr></table></figure>

<p>输入：  1 2 3 4 5<br>        2 3 4 5 6</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m) &#123;</span><br><span class="line">    a.push_back(m);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cin</span>.get() == <span class="string">'\n'</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">    b.push_back(n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cin</span>.get() == <span class="string">'\n'</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、以空-‘-0’）作为输入的结束-第一个字符为’-0’-input-0-’-0’"><a href="#六、以空-‘-0’）作为输入的结束-第一个字符为’-0’-input-0-’-0’" class="headerlink" title="六、以空(‘/0’）作为输入的结束,第一个字符为’\0’ input[0]!=’\0’"></a>六、以空(‘/0’）作为输入的结束,第一个字符为’\0’ input[0]!=’\0’</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> input[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.get(input,<span class="number">100</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">while</span>(input[<span class="number">0</span>]!=<span class="string">'\0'</span>)</span><br></pre></td></tr></table></figure>



<h2 id="2-2-常见输出"><a href="#2-2-常见输出" class="headerlink" title="2.2 常见输出"></a>2.2 常见输出</h2><p>c++默认的流输出数值有效位是6，包括整数和小数，若数值超出6位，则第七位四舍五入到6位数</p>
<p> fixed ：浮点值显示为定点十进制。 默认是小数6位数，不包含整数，若小数位超出6位，则四舍五入到6位数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"># 小数点后保留两位小数，四舍五入</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; output &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>以下这个案例摘录自：<a href="http://c.biancheng.net/view/275.html" target="_blank" rel="noopener">http://c.biancheng.net/view/275.html</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">141</span>;</span><br><span class="line">    <span class="comment">//1) 分别以十六进制、十进制、八进制先后输出 n</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1)"</span> &lt;&lt; hex &lt;&lt; n &lt;&lt; <span class="string">" "</span> &lt;&lt; dec &lt;&lt; n &lt;&lt; <span class="string">" "</span> &lt;&lt; oct &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">1234567.89</span>, y = <span class="number">12.34567</span>;</span><br><span class="line">    <span class="comment">//2)保留5位有效数字</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2)"</span> &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//3)保留小数点后面5位</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3)"</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//4)科学计数法输出，且保留小数点后面5位</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4)"</span> &lt;&lt; scientific &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//5)非负数显示正号，输出宽度为12字符，宽度不足则用 * 填补</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5)"</span> &lt;&lt; showpos &lt;&lt; fixed &lt;&lt; setw(<span class="number">12</span>) &lt;&lt; setfill(<span class="string">'*'</span>) &lt;&lt; <span class="number">12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//6)非负数不显示正号，输出宽度为12字符，宽度不足则右边用填充字符填充</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"6)"</span> &lt;&lt; noshowpos &lt;&lt; setw(<span class="number">12</span>) &lt;&lt; left &lt;&lt; <span class="number">12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//7)输出宽度为 12 字符，宽度不足则左边用填充字符填充</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"7)"</span> &lt;&lt; setw(<span class="number">12</span>) &lt;&lt; right &lt;&lt; <span class="number">12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//8)宽度不足时，负号和数值分列左右，中间用填充字符填充</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"8)"</span> &lt;&lt; setw(<span class="number">12</span>) &lt;&lt; internal &lt;&lt; <span class="number">-12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"9)"</span> &lt;&lt; <span class="number">12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果是：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">8</span>d <span class="number">141</span> <span class="number">215</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span>.<span class="number">2346</span>e+<span class="number">06</span> <span class="number">12</span>.<span class="number">346</span></span><br><span class="line"><span class="number">3</span> <span class="number">1234567</span>.<span class="number">89000</span> <span class="number">12</span>.<span class="number">34567</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span>.<span class="number">23457</span>e+<span class="number">06</span> <span class="number">1</span>.<span class="number">23457</span>e+<span class="number">01</span></span><br><span class="line"><span class="number">5</span> ***+<span class="number">12</span>.<span class="number">10000</span></span><br><span class="line"><span class="number">6</span> <span class="number">12</span>.<span class="number">10000</span>****</span><br><span class="line"><span class="number">7</span> <span class="number">12</span>.<span class="number">10000</span></span><br><span class="line"><span class="number">8</span> -***<span class="number">12</span>.<span class="number">10000</span></span><br><span class="line"><span class="number">9</span> <span class="number">12</span>.<span class="number">10000</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯法</title>
    <url>/2020/08/17/%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<p>本文学习自<a href="https://labuladong.gitbook.io/algo/" target="_blank" rel="noopener">labuladong的算法小抄</a></p>
<a id="more"></a>

<p><strong>回溯问题，实际上就是一个决策树的遍历过程</strong>。需要思考 3 个问题：</p>
<ol>
<li><p>路径：也就是已经做出的选择。</p>
</li>
<li><p>选择列表：也就是你当前可以做的选择。</p>
</li>
<li><p>结束条件：也就是到达决策树底层，无法再做选择的条件。</p>
</li>
</ol>
<p>代码方面，回溯算法的框架：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong>，特别简单。</p>
<p>什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！</p>
<h2 id="24点游戏"><a href="#24点游戏" class="headerlink" title="24点游戏"></a>24点游戏</h2><p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。</p>
<p>示例 1:</p>
<p>输入: [4, 1, 8, 7]<br>输出: True<br>解释: (8-4) * (7-1) = 24<br>示例 2:</p>
<p>输入: [1, 2, 1, 2]<br>输出: False<br>注意:</p>
<p>除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。<br>每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。<br>你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/24-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/24-game</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>解法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> TARGET=<span class="number">24</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> EPISILON = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> ADD = <span class="number">0</span>,MULTIPLY = <span class="number">1</span>,SUBTRACT = <span class="number">2</span>,DIVIDE = <span class="number">3</span>; <span class="comment">//四则运算</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgePoint24</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)</span><br><span class="line">            l.emplace_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(num));</span><br><span class="line">        <span class="keyword">return</span> solve(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;l)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(l.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(l[<span class="number">0</span>]-TARGET)&lt;EPISILON;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = l.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="built_in">size</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; list2;</span><br><span class="line">                <span class="comment">//先把剩下的数字添加到队列中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">size</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k != i &amp;&amp; k != j) &#123;</span><br><span class="line">                        list2.emplace_back(l[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//添加新增的运算结果</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k&lt;<span class="number">2</span>&amp;&amp;i&gt;j)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">switch</span>(k)&#123;</span><br><span class="line">                    <span class="keyword">case</span> ADD: list2.emplace_back(l[i]+l[j]);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> MULTIPLY: list2.emplace_back(l[i]*l[j]);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> SUBTRACT: list2.emplace_back(l[i]-l[j]);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> DIVIDE: &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">abs</span>(l[j])&lt;EPISILON)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        list2.emplace_back(l[i]/l[j]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(solve(list2))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    list2.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>笔试</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>漫水填充法</title>
    <url>/2020/08/16/%E6%BC%AB%E6%B0%B4%E5%A1%AB%E5%85%85%E6%B3%95/</url>
    <content><![CDATA[<p>漫水填充法是一种用特定的颜色填充联通区域，通过设置可连通像素的上下限以及连通方式来达到不同的填充效果的方法。漫水填充经常被用来标记或分离图像的一部分以便对其进行进一步处理或分析，也可以用来从输入图像获取掩码区域，掩码会加速处理过程，或只处理掩码指定的像素点，操作的结果总是某个连续的区域。</p>
<a id="more"></a>

<h2 id="漫水填充算法"><a href="#漫水填充算法" class="headerlink" title="漫水填充算法"></a>漫水填充算法</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>漫水填充算法是用来标记一片区域的：设置一个种子点，然后种子点附近的相似点都被填充同一种颜色。该算法应用性很广，比如目标识别，photoshop 的魔术棒功能等等，是填充类算法中应用最为广泛的一个算法。</p>
<h3 id="OpenCV函数"><a href="#OpenCV函数" class="headerlink" title="OpenCV函数"></a>OpenCV函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvFloodFill</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IplImage * img,        　<span class="comment">// 输入图像</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CvPoint    seedPoint,    <span class="comment">// 种子点</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CvScalar newVal,    　　 <span class="comment">// 像素点被染色的值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CvScalar loDiff = cvScalarAll(<span class="number">0</span>),     <span class="comment">// 染色边界判定</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CvScalar upDiff = cvScalarAll(<span class="number">0</span>),     <span class="comment">// 染色边界判定</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CvConnectedComp * comp = <span class="literal">NULL</span>,        <span class="comment">// 填充区域统计属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> flags = <span class="number">4</span>,                        <span class="comment">// 连通性，相关性等参数设置。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CvArr * mask = <span class="literal">NULL</span>                   <span class="comment">// 掩码区域</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数特别说明：</strong></p>
<p>　　1. 掩码参数 mask 必须是一个单通道，8位，像素宽度高度均比原图像大两个像素。mask 图像的像素 (x+1, y+1) 与原图像 (x, y) 相对应。为 0 的位表示不进行处理。同时，掩码区也会返回填充结果。</p>
<p>　　2. flags 参数提供更为强大的填充配置信息，详见相关资料</p>
<h2 id="相应题目"><a href="#相应题目" class="headerlink" title="相应题目"></a>相应题目</h2><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p>
<p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p>
<p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p>
<p>最后返回经过上色渲染后的图像。</p>
<h3 id="方法一：广度优先搜索"><a href="#方法一：广度优先搜索" class="headerlink" title="方法一：广度优先搜索"></a>方法一：广度优先搜索</h3><p>思路及算法</p>
<p>我们从给定的起点开始，进行广度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格加入队列，并将该方格的颜色更新，以防止重复入队。</p>
<p>注意：因为初始位置的颜色会被修改，所以我们需要保存初始位置的颜色，以便于之后的更新操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  dx = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  dy = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">floodFill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="built_in">image</span>, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = <span class="built_in">image</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(rows==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = <span class="built_in">image</span>[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flag</span><span class="params">(rows,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols,<span class="number">1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">image</span>[sr][sc];</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(make_pair(sr,sc));</span><br><span class="line">        flag[sr][sc]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(sz--)&#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; loc = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> x = loc.first,y = loc.second;</span><br><span class="line">                <span class="built_in">image</span>[x][y] = newColor;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x+dx[i],ny = y+dy[i];</span><br><span class="line">                    <span class="keyword">if</span>(nx&gt;=<span class="number">0</span> &amp;&amp; nx&lt;rows &amp;&amp; ny&gt;=<span class="number">0</span> &amp;&amp; ny&lt;cols &amp;&amp; flag[nx][ny]==<span class="number">1</span> &amp;&amp; <span class="built_in">image</span>[nx][ny]==val)&#123;</span><br><span class="line">                        q.push(make_pair(nx,ny));</span><br><span class="line">                        flag[nx][ny]=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;                </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：深度优先搜索"><a href="#方法二：深度优先搜索" class="headerlink" title="方法二：深度优先搜索"></a>方法二：深度优先搜索</h3><p>思路及算法</p>
<p>我们从给定的起点开始，进行深度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格的颜色更新，以防止重复搜索；如果不相同，则进行回溯。</p>
<p>注意：因为初始位置的颜色会被修改，所以我们需要保存初始位置的颜色，以便于之后的更新操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  dx = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  dy = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> rows,cols,currColor;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">floodFill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="built_in">image</span>, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">        currColor = <span class="built_in">image</span>[sr][sc];</span><br><span class="line">        <span class="keyword">if</span>(newColor==currColor) <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">        rows = <span class="built_in">image</span>.<span class="built_in">size</span>(),cols = <span class="built_in">image</span>[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flag</span><span class="params">(rows,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols,<span class="number">1</span>))</span></span>;</span><br><span class="line">        dfs(<span class="built_in">image</span>,flag,sr,sc,newColor);                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="built_in">image</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flag,<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> newColor)</span></span>&#123;</span><br><span class="line">        <span class="built_in">image</span>[row][col] = newColor;</span><br><span class="line">        flag[row][col] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx = row+dx[i],ny = col+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&gt;=<span class="number">0</span> &amp;&amp; nx&lt;rows &amp;&amp; ny&gt;=<span class="number">0</span> &amp;&amp; ny&lt;cols &amp;&amp; flag[nx][ny]==<span class="number">1</span> &amp;&amp; <span class="built_in">image</span>[nx][ny]==currColor)&#123;</span><br><span class="line">                dfs(<span class="built_in">image</span>,flag,nx,ny,newColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>FloodFill</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>相机标定原理</title>
    <url>/2020/08/10/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>相机标定原理</p>
<p>  在图像测量过程以及机器视觉应用中，为确定空间物体表面某点的三维几何位置与其在图像中对应点之间的相互关系，必须建立相机成像的几何模型，这些几何模型参数就是相机参数。   </p>
<p>本文转载自 <a href="https://blog.csdn.net/qq_37791134/article/details/80942171" target="_blank" rel="noopener">笔记总结-相机标定（Camera calibration）原理、步骤</a>。</p>
<p>张正友标定算法原理详解(<a href="https://blog.csdn.net/u010128736/article/details/52860364" target="_blank" rel="noopener">https://blog.csdn.net/u010128736/article/details/52860364</a>)</p>
<a id="more"></a>

<h2 id="一-为什么要相机标定？"><a href="#一-为什么要相机标定？" class="headerlink" title="一. 为什么要相机标定？"></a>一. 为什么要相机标定？</h2><blockquote>
<p>​    在图像测量过程以及机器视觉应用中，为确定空间物体表面某点的三维几何位置与其在图像中对应点之间的相互关系，必须建立相机成像的几何模型，这些几何模型参数就是相机参数。      </p>
<p>​    【1】进行摄像机标定的目的：求出相机的内、外参数，以及畸变参数。<br>​    【2】标定相机后通常是想做两件事：一个是由于每个镜头的畸变程度各不相同，通过相机标定可以校正这种镜头畸变矫正畸变，生成矫正后的图像；另一个是根据获得的图像重构三维场景。</p>
<p>   摄像机标定过程，简单的可以简单的描述为通过标定板，如下图，可以得到n个对应的世界坐标三维点Xi和对应的图像坐标二维点xi，这些三维点到二维点的转换都可以通过上面提到的相机内参K，相机外参R和t，以及畸变参数D，经过一系列的矩阵变换得到。</p>
</blockquote>
<h2 id="二-什么叫相机标定？"><a href="#二-什么叫相机标定？" class="headerlink" title="二. 什么叫相机标定？"></a>二. 什么叫相机标定？</h2><blockquote>
<p>​    在大多数条件下这些参数必须通过实验与计算才能得到，这个求解参数的过程就称之为相机标定（或摄像机标定）</p>
</blockquote>
<h2 id="三-为什么相机标定很重要？"><a href="#三-为什么相机标定很重要？" class="headerlink" title="三. 为什么相机标定很重要？"></a>三. 为什么相机标定很重要？</h2><blockquote>
<p>   无论是在图像测量或者机器视觉应用中，相机参数的标定都是非常关键的环节，其标定结果的精度及算法的稳定性直接影响相机工作产生结果的准确性。因此，做好相机标定是做好后续工作的前提，提高标定精度是科研工作的重点所在。</p>
</blockquote>
<h2 id="四-相机标定方法有哪些？"><a href="#四-相机标定方法有哪些？" class="headerlink" title="四. 相机标定方法有哪些？"></a>四. 相机标定方法有哪些？</h2><blockquote>
<p>​     相机标定方法有：传统相机标定法、主动视觉相机标定方法、相机自标定法。</p>
<p>传统相机标定法需要使用尺寸已知的标定物，通过建立标定物上坐标已知的点与其图像点之间的对应，利用一定的算法获得相机模型的内外参数。根据标定物的不同可分为三维标定物和平面型标定物。三维标定物可由单幅图像进行标定，标定精度较高，但高精密三维标定物的加工和维护较困难。平面型标定物比三维标定物制作简单，精度易保证，但标定时必须采用两幅或两幅以上的图像。传统相机标定法在标定过程中始终需要标定物，且标定物的制作精度会影响标定结果。同时有些场合不适合放置标定物也限制了传统相机标定法的应用。</p>
<p>​    目前出现的自标定算法中主要是利用相机运动的约束。相机的运动约束条件太强，因此使得其在实际中并不实用。利用场景约束主要是利用场景中的一些平行或者正交的信息。其中空间平行线在相机图像平面上的交点被称为消失点，它是射影几何中一个非常重要的特征，所以很多学者研究了基于消失点的相机自标定方法。自标定方法灵活性强，可对相机进行在线定标。但由于它是基于绝对二次曲线或曲面的方法，其算法鲁棒性差。</p>
<p>​    基于主动视觉的相机标定法是指已知相机的某些运动信息对相机进行标定。该方法不需要标定物，但需要控制相机做某些特殊运动，利用这种运动的特殊性可以计算出相机内部参数。基于主动视觉的相机标定法的优点是算法简单，往往能够获得线性解，故鲁棒性较高，缺点是系统的成本高、实验设备昂贵、实验条件要求高，而且不适合于运动参数未知或无法控制的场合。</p>
</blockquote>
<h2 id="5、常用术语"><a href="#5、常用术语" class="headerlink" title="5、常用术语"></a>5、常用术语</h2><blockquote>
<ul>
<li>内参矩阵: Intrinsic Matrix</li>
<li>焦距: Focal Length</li>
<li>主点: Principal Point</li>
<li>径向畸变: Radial Distortion</li>
<li>切向畸变: Tangential Distortion</li>
<li>旋转矩阵: Rotation Matrices</li>
<li>平移向量: Translation Vectors</li>
<li>平均重投影误差: Mean Reprojection Error</li>
<li>重投影误差: Reprojection Errors</li>
<li>重投影点: Reprojected Points</li>
</ul>
</blockquote>
<h2 id="六-相机成像原理"><a href="#六-相机成像原理" class="headerlink" title="六. 相机成像原理"></a>六. 相机成像原理</h2><blockquote>
<p><img src="https://img-blog.csdn.net/20180706191301242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzkxMTM0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
</blockquote>
<h3 id="6-1-世界坐标系"><a href="#6-1-世界坐标系" class="headerlink" title="6.1 世界坐标系"></a>6.1 世界坐标系</h3><blockquote>
<p>   世界坐标系（world coordinate），也称为测量坐标系，是一个三维直角坐标系，以其为基准可以描述相机和待测物体的空间位置。世界坐标系的位置可以根据实际情况自由确定。</p>
</blockquote>
<h3 id="6-2-相机坐标系"><a href="#6-2-相机坐标系" class="headerlink" title="6.2 相机坐标系"></a>6.2 相机坐标系</h3><blockquote>
<p>  相机坐标系（camera coordinate），也是一个三维直角坐标系，原点位于镜头光心处，x、y轴分别与相面的两边平行，z轴为镜头光轴，与像平面垂直。 </p>
</blockquote>
<h3 id="6-3-相机坐标系转换为世界坐标系"><a href="#6-3-相机坐标系转换为世界坐标系" class="headerlink" title="6.3 相机坐标系转换为世界坐标系"></a>6.3 相机坐标系转换为世界坐标系</h3><p>   转换方程为：</p>
<p><img src="https://img-blog.csdn.net/20180706160227975?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzkxMTM0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>其中为3<em>3的旋转矩阵，为3</em>1的平移矢量，为相机坐标系的齐次坐标，为世界坐标系的齐次坐标。</p>
<p>  具体步骤为下图所示：</p>
<p><img src="https://img-blog.csdn.net/20180706182724223?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzkxMTM0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>图6.3.1</p>
<p><img src="https://img-blog.csdn.net/20180706182801733?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzkxMTM0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>图6.3.2</p>
<p><img src="https://img-blog.csdn.net/20180706182853235?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzkxMTM0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>图6.3.3</p>
<h3 id="6-4-像素坐标系、图像坐标系"><a href="#6-4-像素坐标系、图像坐标系" class="headerlink" title="6.4 像素坐标系、图像坐标系"></a>6.4 像素坐标系、图像坐标系</h3><p>​                           <img src="https://img-blog.csdn.net/20180706183548305?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzkxMTM0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>​                                      图6.4.1                                    </p>
<p>像素坐标系（pixel coordinate）<br>图6.4.1 ，像素坐标系是一个二维直角坐标系，反映了相机CCD/CMOS芯片中像素的排列情况。原点位于图像的左上角，轴、轴分别于像面的两边平行。<code>像素坐标系中坐标轴的单位是像素（整数）</code>。</p>
<p>像素坐标系不利于坐标变换，因此需要建立图像坐标系，<code>其坐标轴的单位通常为毫米（mm）</code>，原点是相机光轴与相面的交点（称为主点），即图像的中心点，轴、轴分别与轴、轴平行。故两个坐标系实际是平移关系，即可以通过平移就可得到。</p>
<h3 id="6-5-像素坐标系转换为图像坐标系"><a href="#6-5-像素坐标系转换为图像坐标系" class="headerlink" title="6.5 像素坐标系转换为图像坐标系"></a>6.5 像素坐标系转换为图像坐标系</h3><p><img src="https://img-blog.csdn.net/20180706184156952?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzkxMTM0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>其中，、分别为像素在、轴方向上的物理尺寸，为主点（图像原点）坐标。（这里 =dx）</p>
<h3 id="6-6-像素坐标系转换为图像坐标系"><a href="#6-6-像素坐标系转换为图像坐标系" class="headerlink" title="6.6 像素坐标系转换为图像坐标系"></a>6.6 像素坐标系转换为图像坐标系</h3><p><img src="https://img-blog.csdn.net/2018070618495256?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzkxMTM0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="针孔成像原理"><a href="#针孔成像原理" class="headerlink" title="针孔成像原理"></a>针孔成像原理</h3><p>​    如图中，空间任意一点与其图像点之间的关系，p与相机光心 的连线为op，与像面的交点即为空间点在图像平面上的投影。 该过程为透视投影，由上图的矩阵表示。</p>
<p>  其中，Zc为比例因子（Zc不为0），为有效焦距（光心到图像平面的距离），是空间点在相机坐标系中的齐次坐标，是像点在图像坐标系中的齐次坐标。</p>
<h3 id="6-7-世界坐标系转换为像素坐标系"><a href="#6-7-世界坐标系转换为像素坐标系" class="headerlink" title="6.7 世界坐标系转换为像素坐标系"></a>6.7 世界坐标系转换为像素坐标系</h3><p><img src="https://img-blog.csdn.net/20180706185826171?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzkxMTM0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>上面的式子也等于：MXw ，其中M成为投影矩阵，是相机内参矩阵和相机外参矩阵的乘积。</p>
<p>其中 <em>f</em> 为摄像机的焦距，单位一般是<em>mm</em>;<em>dx</em>,<em>dy</em> 为像元尺寸;<em>u0</em>,<em>v0</em> 为图像中心。fx = f/dx, fy = f/dy,分别称为x轴和y轴上的归一化焦距.</p>
<p><strong>*\</strong>*为更好的理解，举个实例：**<em>**</em></p>
<p>现以NiKon D700相机为例进行求解其内参数矩阵：<br>就算大家身边没有这款相机也无所谓，可以在网上百度一下，很方便的就知道其一些参数——<br> 焦距 f = 35mm  最高分辨率：4256×2832   传感器尺寸：36.0×23.9 mm<br>根据以上定义可以有：<br><em>u0</em>= 4256/2 = 2128  <em>v0</em>= 2832/2 = 1416 dx = 36.0/4256  dy = 23.9/2832<br>fx = f/dx = 4137.8  fy = f/dy = 4147.3</p>
<p>   其中相机的内参和外参可以通过张正友标定获取。通过最终的转换关系来看，一个三维中的坐标点，的确可以在图像中找到一个对应的像素点（为什么？你自己想想矩阵的运算，你就可以知道了），但是反过来，通过图像中的一个点找到它在三维中对应的点就很成了一个问题，因为我们并不知道等式左边的Zc的值。</p>
<h2 id="七-标定原理"><a href="#七-标定原理" class="headerlink" title="七 标定原理"></a>七 标定原理</h2><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>  ”张正友标定”是指张正友教授1998年提出的单平面棋盘格的摄像机标定方法[1]。文中提出的方法介于传统标定法和自标定法之间，但克服了传统标定法需要的高精度标定物的缺点，而仅需使用一个打印出来的棋盘格就可以。同时也相对于自标定而言，提高了精度，便于操作。因此张氏标定法被广泛应用于计算机视觉方面。</p>
<h3 id="二、计算内参和外参的初值"><a href="#二、计算内参和外参的初值" class="headerlink" title="二、计算内参和外参的初值"></a>二、计算内参和外参的初值</h3><h4 id="1、计算单应性矩阵H"><a href="#1、计算单应性矩阵H" class="headerlink" title="1、计算单应性矩阵H"></a>1、计算单应性矩阵H</h4><p>  根据之前博客介绍的摄像机模型，设三维世界坐标的点为<em>X</em>=[<em>X</em>,<em>Y</em>,<em>Z</em>,1]<em>T</em>X=[X,Y,Z,1]T，二维相机平面像素坐标为<em>m</em>=[<em>u</em>,<em>v</em>,1]<em>T</em>m=[u,v,1]T，所以标定用的棋盘格平面到图像平面的单应性关系为：<br>$$<br>s_0m=K[R,T]X<br>$$<br>其中s为尺度因子，K为摄像机内参数，R为旋转矩阵，T为平移向量。令<br>$$<br>K=[α,γ,u0;0,β,v_0;0,0,1]<br>$$</p>
<p>注意，s对于齐次坐标来说，不会改变齐次坐标值。张氏标定法中，将世界坐标系狗仔在棋盘格平面上，令棋盘格平面为Z=0的平面。则可得<br>$$<br>s[uv1]=K[r1r2r3t][XY01]=K[r1r2t][XY1]<br>$$<br>我们把K[r1, r2, t]叫做单应性矩阵H，即<br>$$<br>s[uv1]=H[XY1]H=[h1 h2 h3]=λK[r1 r2 t]<br>$$</p>
<p>H是一个齐次矩阵，所以有8个未知数，至少需要8个方程，每对对应点能提供两个方程，所以至少需要四个对应点，就可以算出世界平面到图像平面的单应性矩阵H。</p>
<h4 id="2、计算内参数矩阵"><a href="#2、计算内参数矩阵" class="headerlink" title="2、计算内参数矩阵"></a>2、计算内参数矩阵</h4><p>由上式可得</p>
<p><em>λ</em>=1<em>s*</em>r<em>1=1</em>λ<strong>K<em>−1</em>h<em>1</em>r<em>2=1</em>λ</strong>K<em>−1</em>h*2λ=1sr1=1λK−1h1r2=1λK−1h2</p>
<p>  由于旋转矩阵是个酉矩阵，r1和r2正交，可得</p>
<p><em>r*</em>T<em>1</em>r<em>2=0||</em>r<em>1||=||</em>r*2||=1r1Tr2=0||r1||=||r2||=1</p>
<p>代入可得：</p>
<p><em>h*</em>T<em>1</em>K<em>−</em>T<strong>K<em>−1</em>h<em>2=0</em>h</strong>T<em>1</em>K<em>−</em>T<strong>K<em>−1</em>h<em>1=</em>h</strong>T<em>2</em>K<em>−</em>T*<em>K</em>−1<em>h</em>2h1TK−TK−1h2=0h1TK−TK−1h1=h2TK−TK−1h2</p>
<p>即每个单应性矩阵能提供两个方程，而内参数矩阵包含5个参数，要求解，至少需要3个单应性矩阵。为了得到三个不同的单应性矩阵，我们使用至少三幅棋盘格平面的图片进行标定。通过改变相机与标定板之间的相对位置来得到三个不同的图片。为了方便计算，定义如下：</p>
<p><em>B</em>=<em>K</em>−<em>T<strong>K<em>−1=⎡⎣⎢⎢</em>B<em>11</em>B<em>21</em>B<em>31</em>B<em>12</em>B<em>22</em>B<em>32</em>B<em>13</em>B<em>23</em>B<em>33⎤⎦⎥⎥=⎡⎣⎢⎢⎢⎢⎢1</em>α<em>2−</em>γ</strong>α<em>2</em>β<strong>v<em>0</em>γ<em>−</em>u<em>0</em>β</strong>α<em>2</em>β<em>−</em>γ<strong>α<em>2</em>β</strong>γ<em>2</em>α<em>2</em>β<em>2+1</em>β<em>2−</em>γ</em>(<em>v</em>0<em>γ</em>−<em>u</em>0<em>β</em>)<em>α</em>2<em>β</em>2−<em>v</em>0<em>β</em>2<em>v</em>0<em>γ</em>−<em>u</em>0<em>β*<em>α</em>2<em>β</em>−*γ</em>(<em>v</em>0<em>γ</em>−<em>u</em>0<em>β</em>)<em>α</em>2<em>β</em>2−<em>v</em>0<em>β</em>2(<em>v</em>0<em>γ</em>−<em>u</em>0<em>β</em>)2<em>α</em>2<em>β</em>2+<em>v</em>0<em>β</em>2+1⎤⎦⎥⎥⎥⎥⎥B=K−TK−1=[B11B12B13B21B22B23B31B32B33]=[1α2−γα2βv0γ−u0βα2β−γα2βγ2α2β2+1β2−γ(v0γ−u0β)α2β2−v0β2v0γ−u0βα2β−γ(v0γ−u0β)α2β2−v0β2(v0γ−u0β)2α2β2+v0β2+1]</p>
<p>可以看到，B是一个对称阵，所以B的有效元素为六个，让这六个元素写成向量b，即</p>
<p><em>b</em>=[<em>B</em>11<em>B</em>12<em>B</em>22<em>B</em>13<em>B</em>23<em>B</em>33]<em>T</em>b=[B11B12B22B13B23B33]T</p>
<p>可以推导得到</p>
<p><em>h<strong>T</strong>i<strong>B</strong>h**j</em>=<em>v<strong>T</strong>i<strong>j</strong>b<strong>v</strong>i**j</em>=[<em>h*</em>i<em>1</em>h<strong>j<em>1</em>h</strong>i<em>1</em>h<strong>j<em>2+</em>h</strong>i<em>2</em>h<strong>j<em>1</em>h</strong>i<em>2</em>h<strong>j<em>2</em>h</strong>i<em>3</em>h<strong>j<em>1+</em>h</strong>i<em>1</em>h<strong>j<em>3</em>h</strong>i<em>3</em>h<strong>j<em>2+</em>h</strong>i<em>2</em>h<strong>j<em>3</em>h</strong>i<em>3</em>h*<em>j</em>3]<em>T</em>hiTBhj=vijTbvij=[hi1hj1hi1hj2+hi2hj1hi2hj2hi3hj1+hi1hj3hi3hj2+hi2hj3hi3hj3]T</p>
<p>利用约束条件可以得到：</p>
<p>[<em>v*<em>T</em>12(<em>v</em>11−<em>v</em>22)<em>T</em>]*b</em>=0[v12T(v11−v22)T]b=0</p>
<p>  通过上式，我们至少需要三幅包含棋盘格的图像，可以计算得到B，然后通过cholesky分解，得到相机的内参数矩阵K。</p>
<h4 id="3、计算外参数矩阵"><a href="#3、计算外参数矩阵" class="headerlink" title="3、计算外参数矩阵"></a>3、计算外参数矩阵</h4><p>  由之前的推导，可得</p>
<p><em>λ</em>=1<em>s</em>=1‖<em>A</em>−1<em>h</em>1‖=1‖<em>A</em>−1<em>h</em>2‖<em>r</em>1=1<em>λ<strong>K<em>−1</em>h<em>1</em>r<em>2=1</em>λ</strong>K<em>−1</em>h<em>2</em>r<em>3=</em>r<em>1×</em>r<em>2</em>t</em>=<em>λ*</em>K<em>−1</em>h*3λ=1s=1‖A−1h1‖=1‖A−1h2‖r1=1λK−1h1r2=1λK−1h2r3=r1×r2t=λK−1h3</p>
<h3 id="三、最大似然估计"><a href="#三、最大似然估计" class="headerlink" title="三、最大似然估计"></a>三、最大似然估计</h3><p>  上述的推导结果是基于理想情况下的解，但由于可能存在高斯噪声，所以使用最大似然估计进行优化。设我们采集了n副包含棋盘格的图像进行定标，每个图像里有棋盘格角点m个。令第i副图像上的角点Mj在上述计算得到的摄像机矩阵下图像上的投影点为：</p>
<p><em>m</em>̂ (<em>K</em>,<em>R**i</em>,<em>t**i</em>,<em>M<strong>i</strong>j</em>)=<em>K</em>[<em>R</em>|<em>t</em>]<em>M*</em>i*<em>j</em>m^(K,Ri,ti,Mij)=K[R|t]Mij</p>
<p>其中Ri和ti是第i副图对应的旋转矩阵和平移向量，K是内参数矩阵。则角点mij的概率密度函数为：</p>
<p><em>f</em>(<em>m<strong>i</strong>j</em>)=12<em>π</em>‾‾‾√<em>e</em>−(<em>m</em>̂ (<em>K</em>,<em>R**i</em>,<em>t**i</em>,<em>M<strong>i</strong>j</em>)−<em>m<strong>i</strong>j</em>)2<em>σ</em>2f(mij)=12πe−(m^(K,Ri,ti,Mij)−mij)2σ2</p>
<p>构造似然函数：</p>
<p><em>L</em>(<em>A</em>,<em>R**i</em>,<em>t**i</em>,<em>M<strong>i</strong>j</em>)=∏<em>i</em>=1,<em>j</em>=1<em>n</em>,<em>m**f</em>(<em>m<strong>i</strong>j</em>)=12<em>π</em>‾‾‾√<em>e</em>−∑<em>n**i</em>=1∑<em>m**j</em>=1(<em>m</em>̂ (<em>K</em>,<em>R**i</em>,<em>t**i</em>,<em>M<strong>i</strong>j</em>)−<em>m<strong>i</strong>j</em>)2<em>σ</em>2L(A,Ri,ti,Mij)=∏i=1,j=1n,mf(mij)=12πe−∑i=1n∑j=1m(m^(K,Ri,ti,Mij)−mij)2σ2</p>
<p>让L取得最大值，即让下面式子最小。这里使用的是多参数非线性系统优化问题的Levenberg-Marquardt算法[2]进行迭代求最优解。</p>
<p>∑<em>i</em>=1<em>n</em>∑<em>j</em>=1<em>m</em>‖<em>m</em>̂ (<em>K</em>,<em>R**i</em>,<em>t**i</em>,<em>M<strong>i</strong>j</em>)−<em>m*</em>i*<em>j</em>‖2∑i=1n∑j=1m‖m^(K,Ri,ti,Mij)−mij‖2</p>
<h3 id="四、径向畸变估计"><a href="#四、径向畸变估计" class="headerlink" title="四、径向畸变估计"></a>四、径向畸变估计</h3><p>  张氏标定法只关注了影响最大的径向畸变。则数学表达式为：</p>
<p><em>u</em>̂ =<em>u</em>+(<em>u</em>−<em>u</em>0)[<em>k</em>1(<em>x</em>2+<em>y</em>2)+<em>k</em>2(<em>x</em>2+<em>y</em>2)2]<em>v</em>̂ =<em>v</em>+(<em>v</em>−<em>v</em>0)[<em>k</em>1(<em>x</em>2+<em>y</em>2)+<em>k</em>2(<em>x</em>2+<em>y</em>2)2]u^=u+(u−u0)[k1(x2+y2)+k2(x2+y2)2]v^=v+(v−v0)[k1(x2+y2)+k2(x2+y2)2]</p>
<p>其中，(u,v)是理想无畸变的像素坐标，(<em>u</em>̂ ,<em>v</em>̂ )(u^,v^)是实际畸变后的像素坐标。(u0,v0)代表主点，(x,y)是理想无畸变的连续图像坐标，(<em>x</em>̂ ,<em>y</em>̂ )(x^,y^)是实际畸变后的连续图像坐标。k1和k2为前两阶的畸变参数。</p>
<p><em>u</em>̂ =<em>u</em>0+<em>α*</em>x<em>̂ +</em>γ<strong>y<em>̂ *v</em>̂ =<em>v</em>0+*β</strong>y*̂ u^=u0+αx^+γy^v^=v0+βy^</p>
<p>化作矩阵形式：</p>
<p>[(<em>u</em>−<em>u</em>0)(<em>x</em>2+<em>y</em>2)(<em>v</em>−<em>v</em>0)(<em>x</em>2+<em>y</em>2)(<em>u</em>−<em>u</em>0)(<em>x</em>2+<em>y</em>2)2(<em>v</em>−<em>v</em>0)(<em>x</em>2+<em>y</em>2)2][<em>k</em>1<em>k</em>2]=[<em>u</em>̂ −<em>u*</em>v<em>̂ −</em>v*][(u−u0)(x2+y2)(u−u0)(x2+y2)2(v−v0)(x2+y2)(v−v0)(x2+y2)2][k1k2]=[u^−uv^−v]</p>
<p>记做：</p>
<p><em>D**k</em>=<em>d</em>Dk=d</p>
<p>则可得：</p>
<p><em>k</em>=[<em>k</em>1 <em>k</em>2]<em>T</em>=(<em>D<strong>T</strong>D</em>)−1<em>D*</em>T*<em>d</em>k=[k1 k2]T=(DTD)−1DTd</p>
<p>计算得到畸变系数k。</p>
<p>  使用最大似然的思想优化得到的结果，即像上一步一样，LM法计算下列函数值最小的参数值：</p>
<p>∑<em>i</em>=1<em>n</em>∑<em>j</em>=1<em>m</em>‖<em>m</em>̂ (<em>K</em>,<em>k</em>1,<em>k</em>2,<em>R**i</em>,<em>t**i</em>,<em>M<strong>i</strong>j</em>)−<em>m*</em>i*<em>j</em>‖2∑i=1n∑j=1m‖m^(K,k1,k2,Ri,ti,Mij)−mij‖2</p>
<p>到此，张氏标定法介绍完毕。我们也得到了相机内参、外参和畸变系数。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p>1、Zhang, Zhengyou - 《IEEE Transactions on Pattern Analysis &amp; Machine Intelligence》 - 2000<br>2、J.More.Thelevenberg-marquardtalgorithm,implementationandtheory.InG.A.Watson, editor,NumericalAnalysis,LectureNotesinMathematics630.Springer-Verlag,1977.</p>
</blockquote>
<h2 id="八-标定过程"><a href="#八-标定过程" class="headerlink" title="八 标定过程"></a>八 标定过程</h2><p><strong>相机标定步骤：</strong></p>
<blockquote>
<p>1、打印一张棋盘格，把它贴在一个平面上，作为标定物。<br>2、通过调整标定物或摄像机的方向，为标定物拍摄一些不同方向的照片。<br>3、从照片中提取棋盘格角点。<br>4、估算理想无畸变的情况下，五个内参和六个外参。<br>5、应用最小二乘法估算实际存在径向畸变下的畸变系数。<br>6、极大似然法，优化估计，提升估计精度。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>相机标定</tag>
        <tag>SLAM</tag>
        <tag>Kalirbr</tag>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM 面试题汇总</title>
    <url>/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>本文总结面试SLAM中可能遇到的各种问题。</p>
<a id="more"></a>

<h1 id="零-数学基础"><a href="#零-数学基础" class="headerlink" title="零  数学基础"></a>零  数学基础</h1><h2 id="一-李群和李代数"><a href="#一-李群和李代数" class="headerlink" title="一 李群和李代数"></a>一 李群和李代数</h2><h4 id="李群和李代数的关系"><a href="#李群和李代数的关系" class="headerlink" title="李群和李代数的关系"></a>李群和李代数的关系</h4><h4 id="雅克比求导"><a href="#雅克比求导" class="headerlink" title="雅克比求导"></a>雅克比求导</h4><h4 id="双线性差值如何去做，写公式"><a href="#双线性差值如何去做，写公式" class="headerlink" title="双线性差值如何去做，写公式"></a>双线性差值如何去做，写公式</h4><h4 id="为什么要引入李群李代数"><a href="#为什么要引入李群李代数" class="headerlink" title="为什么要引入李群李代数"></a>为什么要引入李群李代数</h4><p>旋转矩阵自身是带有约束的，正交且行列式为1，他们作为优化变量时，会引入额外的约束，导致优化变的困难，通过李群李代数的转换关系，把位姿估计变成无约束的优化问题。优化过程求极值，由求导数的定义式，可以知道矩阵对于加法不封闭，对于乘法封闭；我们可以看错把李群就是变换矩阵的集合，但是用李代数的形式去表示变换矩阵，与李群的变换对应关系恰好是与指数相乘的关系，用求导的定义式子就可以求解优化问题了。</p>
<h2 id="二-刚体运动的表示"><a href="#二-刚体运动的表示" class="headerlink" title="二 刚体运动的表示"></a>二 刚体运动的表示</h2><h3 id="1-说一下3D空间的位姿如何去表达"><a href="#1-说一下3D空间的位姿如何去表达" class="headerlink" title="1. 说一下3D空间的位姿如何去表达?"></a>1. 说一下3D空间的位姿如何去表达?</h3><blockquote>
<p>描述3D空间位姿态需要描述旋转和平移；</p>
<p>旋转可用：旋转向量（即李代数）、欧拉角、四元数、RPY表示；</p>
<p>平移可以：向量描述</p>
<p>结合起来可以李代数矩阵描述。</p>
</blockquote>
<h3 id="2-机器人学中表示旋转的方式有哪些？区别是什么？"><a href="#2-机器人学中表示旋转的方式有哪些？区别是什么？" class="headerlink" title="2. 机器人学中表示旋转的方式有哪些？区别是什么？"></a>2. 机器人学中表示旋转的方式有哪些？区别是什么？</h3><blockquote>
<p>表示旋转的方式有4种：旋转矩阵、旋转向量、欧拉角、四元数；</p>
<p><strong>区别</strong></p>
<p><strong>旋转矩阵</strong>：用9个变量描述3个自由度，具有冗余，不够紧凑；<br><strong>旋转向量</strong>：3维，使用向量描述旋转，向量的方向与旋转轴一致、向量长度等于旋转角，即李代数。<br><strong>欧拉角</strong>：3维，比较直观，将一个旋转拆分成了绕3个坐标轴的旋转，如RPY指横滚、俯仰、偏航角度，指绕固定轴XYZ、绕旋转之后的轴：ZYX。<br><strong>四元数</strong>：4维，旋转向量与欧拉角虽然紧凑但具有奇异性，四元数紧凑、没有奇异性；使用1个实部、3个虚部表示。</p>
</blockquote>
<h2 id="三-坐标系变换"><a href="#三-坐标系变换" class="headerlink" title="三 坐标系变换"></a>三 坐标系变换</h2><blockquote>
<p>世界坐标系（world） 相机坐标（camera） 像素坐标（pixel）</p>
</blockquote>
<blockquote>
<ul>
<li>world —— camera：$P_C=T_{cw}∗P_w$</li>
<li>camera —— world： $P_w=T_{cw}^{−1}P_c$</li>
<li>pixel —— camera：$u=f_x * X_c / Z_c+C_x ; \quad v=f_y * Y_c / Z_c+C_y$</li>
<li>camera —— pixel：$X_{c}=(u-C_x) * Z_c / f_x ; \quad Y c=(v-C y) * Z_c / f_y$</li>
</ul>
</blockquote>
<h1 id="一-相机模型"><a href="#一-相机模型" class="headerlink" title="一 相机模型"></a>一 相机模型</h1><h2 id="零-图像"><a href="#零-图像" class="headerlink" title="零 图像"></a>零 图像</h2><h3 id="1-RGB图像的遍历"><a href="#1-RGB图像的遍历" class="headerlink" title="1. RGB图像的遍历"></a>1. RGB图像的遍历</h3><h4 id="1-一个H高W宽的图像或者matrix，如何去访问每一个元素，先访问行还是列？"><a href="#1-一个H高W宽的图像或者matrix，如何去访问每一个元素，先访问行还是列？" class="headerlink" title="1. 一个H高W宽的图像或者matrix，如何去访问每一个元素，先访问行还是列？"></a>1. 一个H高W宽的图像或者matrix，如何去访问每一个元素，先访问行还是列？</h4><p>提示：跟缓存还有关系~</p>
<p>矩阵在存储中需要区别是行优先还是列优先，Eigen中默认为列优先，因此需要按列访问。这样访问连续的存储能够加快矩阵的访问速度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>&gt; A;               <span class="comment">// Fixed rows and cols. Same as Matrix3d.</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, Dynamic&gt; B;         <span class="comment">// Fixed rows, dynamic cols.</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>, RowMajor&gt; E;     <span class="comment">// Row major; default is column-major.</span></span><br></pre></td></tr></table></figure>

<p>图像在<code>opencv</code>中一般是按行存储；一般来说图像行与行之间往往存储是不连续的，但是有些图像可以是连续的，Mat提供了一个检测图像是否连续的函数<code>isContinuous()</code>。当图像连通时，我们就可以把图像完全展开，看成是一行。</p>
<h3 id="2-图像处理"><a href="#2-图像处理" class="headerlink" title="2. 图像处理"></a>2. 图像处理</h3><h4 id="1、直方图均衡化"><a href="#1、直方图均衡化" class="headerlink" title="1、直方图均衡化"></a>1、直方图均衡化</h4><blockquote>
<p><strong>直方图均衡化</strong>（Histogram equalization）就是一种常用的灰度变换方法。</p>
<p>目的：通过拉伸像素强度分布范围来增强图像的对比度</p>
<p>操作：直接以图像的像素操作为基础，主要分为<strong>灰度变换</strong>和<strong>空域滤波</strong>两大类，</p>
<p>原理</p>
<ul>
<li>直方图是图像中像素强度分布的图形表达方式.</li>
<li>它统计了每一个强度值所具有的像素个数.</li>
</ul>
<p>应用：VINS中，如果图片太亮或者太暗，就要进行直方图的均衡化处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果EQUALIZE=1，表示太亮或太暗，进行直方图均衡化处理</span></span><br><span class="line"><span class="keyword">if</span> (EQUALIZE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自适应直方图均衡</span></span><br><span class="line">    <span class="comment">//createCLAHE(double clipLimit, Size tileGridSize)</span></span><br><span class="line">    cv::Ptr&lt;cv::CLAHE&gt; clahe = cv::createCLAHE(<span class="number">3.0</span>, cv::Size(<span class="number">8</span>, <span class="number">8</span>));</span><br><span class="line">    TicToc t_c;</span><br><span class="line">    clahe-&gt;apply(_img, img);</span><br><span class="line">    ROS_DEBUG(<span class="string">"CLAHE costs: %fms"</span>, t_c.toc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2、图像滤波方法"><a href="#2、图像滤波方法" class="headerlink" title="2、图像滤波方法"></a>2、图像滤波方法</h4><p>线性滤波方法：方框滤波(box filter) 、均值滤波(median filter)、 高斯滤波（Gaussian 滤波）</p>
<p>非线性滤波：中值滤波、双边滤波</p>
<h3 id="3-图像变换"><a href="#3-图像变换" class="headerlink" title="3. 图像变换"></a>3. 图像变换</h3><h2 id="一-相机"><a href="#一-相机" class="headerlink" title="一 相机"></a>一 相机</h2><h3 id="1-单目相机"><a href="#1-单目相机" class="headerlink" title="1 单目相机"></a>1 <strong>单目相机</strong></h3><table>
<thead>
<tr>
<th>常用型号：有非常多的种类可以选择</th>
<th>单目相机</th>
</tr>
</thead>
<tbody><tr>
<td>1、应用最广，成本可以做到非常低。<br>2、体积小，标定简单，硬件搭建也简单。<br>3、可以用于室内和室外（有适当光照条件下）。</td>
<td>优点</td>
</tr>
<tr>
<td>1、具有纯视觉传感器的通病：在光照变化较大，纹理特征缺失、快速运动导致模糊的情况下无法使用（睁眼瞎）。<br>2、SLAM过程使用单目相机有尺度不确定性，需要专门初始化。<br>3、必须通过运动才能估计深度（帧间匹配三角化）</td>
<td>缺点</td>
</tr>
</tbody></table>
<h3 id="2-双目相机"><a href="#2-双目相机" class="headerlink" title="2 双目相机"></a>2 双目相机</h3><table>
<thead>
<tr>
<th>双目相机</th>
<th>常用型号：Indemind，小觅，ZED等</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>1、相比于单目，在静止时就能够根据左右相机视差图计算深度。<br>2、可测量距离可以根据基线调节。基线距离越大，测量距离越远。<br>3、可以用于室内和室外（有适当光照条件下）。</td>
</tr>
<tr>
<td>缺点</td>
<td>1、双目相机标定相对复杂<br>2、用视差计算深度比较消耗资源<br>3、具有纯视觉传感器的通病：在光照变化较大，纹理特征缺失、快速运动导致模糊的情况下无法使用（睁眼瞎）。</td>
</tr>
</tbody></table>
<h3 id="3-RGB-D相机"><a href="#3-RGB-D相机" class="headerlink" title="3 RGB-D相机"></a>3 RGB-D相机</h3><table>
<thead>
<tr>
<th>RGBD相机</th>
<th>常用型号：Kinect系列、Realsense系列、Orbbec、Pico等</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>1、使用物理测距方法测量深度，所以避免了纯视觉传感器的通病，<br>在没有光照的情况下、快速运动的情况下都可以测距。这是非常大的优势。<br>2、相对双目，输出帧率较高，更适合运动场景。<br>3、输出深度值比较准，结合RGB信息，容易实现手势识别、人体姿态估计等应用。</td>
</tr>
<tr>
<td>缺点</td>
<td>1、测量范围窄，易受日光干扰，通常只能用于室内场景<br>2、在遇到透射材料、反光表面、黑色物体情况下表现不好，造成深度图缺失<br>3、通常分辨率无法做到很高，目前主流分辨率VGA（640x480）<br>4、标定比较复杂。</td>
</tr>
</tbody></table>
<h4 id="A-RGB-D相机我们知道可以直接输出-RGB-depth两张图比如我们常见的Kinect-是结构光原理，包括一个彩色相机，一个红外发射器，一个红外接收器。另外，Intel的Realsense系列RGB-D相机也非常常用，比如下面Realsense-D415，官网说是Active-IR-stereo，也就是双目深度相机，这个双目和我们平时说的双目有何不同？为什么有如下四个孔？"><a href="#A-RGB-D相机我们知道可以直接输出-RGB-depth两张图比如我们常见的Kinect-是结构光原理，包括一个彩色相机，一个红外发射器，一个红外接收器。另外，Intel的Realsense系列RGB-D相机也非常常用，比如下面Realsense-D415，官网说是Active-IR-stereo，也就是双目深度相机，这个双目和我们平时说的双目有何不同？为什么有如下四个孔？" class="headerlink" title="A. RGB-D相机我们知道可以直接输出 RGB + depth两张图比如我们常见的Kinect 是结构光原理，包括一个彩色相机，一个红外发射器，一个红外接收器。另外，Intel的Realsense系列RGB-D相机也非常常用，比如下面Realsense D415，官网说是Active IR stereo，也就是双目深度相机，这个双目和我们平时说的双目有何不同？为什么有如下四个孔？"></a>A. RGB-D相机我们知道可以直接输出 RGB + depth两张图比如我们常见的Kinect 是结构光原理，包括一个彩色相机，一个红外发射器，一个红外接收器。另外，Intel的Realsense系列RGB-D相机也非常常用，比如下面Realsense D415，官网说是Active IR stereo，也就是双目深度相机，这个双目和我们平时说的双目有何不同？为什么有如下四个孔？</h4><h3 id="4-相机对比"><a href="#4-相机对比" class="headerlink" title="4. 相机对比"></a>4. 相机对比</h3><table>
<thead>
<tr>
<th align="left">相机</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单目</td>
<td>成本低，搭建简单，单目相机有尺度不确定性，需要专门初始化。</td>
</tr>
<tr>
<td align="left">双目</td>
<td>不需要专门初始化，能够计算深度，基线距离越大，测量距离越远，可以用于室内和室外，标定较为复杂，视差计算比较消耗资源。</td>
</tr>
<tr>
<td align="left">深度</td>
<td>测量范围窄，噪声大，易受日光干扰，无法测量透射材料，主要用于室内。</td>
</tr>
</tbody></table>
<h4 id="1-全局快门相机与卷帘快门相机的异同"><a href="#1-全局快门相机与卷帘快门相机的异同" class="headerlink" title="1 全局快门相机与卷帘快门相机的异同"></a>1 全局快门相机与卷帘快门相机的异同</h4><table>
<thead>
<tr>
<th align="center">快门</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义</td>
<td>快门是照相机用来控制感光片有效曝光时间的机构，是照相机的一个重要组成部分，它的结构、形式及功能是衡量照相机档次的一个重要因素。一般而言快门的时间范围越大越好。秒数低适合拍运动中的物体，某款相机就强调快门最快能到1/16000秒，可轻松抓住急速移动的目标。不过当你要拍的是夜晚的车水马龙，快门时间就要拉长，常见照片中丝绢般的水流效果也要用慢速快门才能拍出来</td>
</tr>
<tr>
<td align="center">速度</td>
<td>快门速度单位是”秒”。常见的快门速度有:1 1/2 1/4 1/8 1/15 1/30 1/60 1/125 1/250 1/500 1/1000 1/2000等。相邻两级的快门速度的曝光量相差一倍。如1/60秒比1/125秒的曝光量多一倍，即1/60秒比1/125秒速度慢一级或称低一级。</td>
</tr>
<tr>
<td align="center">全局快门（global shutter）</td>
<td>全局快门是通过整幅图片在同一时间曝光实现的。传感器的所有像素点同时收集光线，同时曝光。当预设的曝光时间到了，传感器停止收集光线，并将曝光图像转成电子图像。在这个过程中，并没有实际意义上的快门存在。在曝光开始的时候，传感器开始收集光线，在曝光结束的时候，光线收集电路被切断，传感器读出值即为一幅图片。</td>
</tr>
<tr>
<td align="center">卷帘快门（rolling shutter）</td>
<td>卷帘快门通过控制芯片逐行曝光。卷帘快门也没有实际意义上的快门，而是通过断电控制传感器，使其不同部分在不同时间下对光的敏感度不同，逐行进行曝光，直至所有像素点都被曝光。所有的动作在很短的时间内完成。一般情况为1/48至1/60秒。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>卷帘快门 rolling shutter</th>
<th>全局快门 global shutter</th>
</tr>
</thead>
<tbody><tr>
<td>rolling shutter是逐行顺序曝光，所以不适合运动物体的拍摄，假如物体或摄像头在拍摄期间处于快速运动状态，拍摄结果就可能出现“倾斜”、“摇摆不定”或“部分曝光”等任意一种情况。</td>
<td>global shutter所有像素在同一时刻曝光，类似于将运动物体冻结了，所以适合拍摄快速运动的物体。但是global shutter可能出现像糊现象。像糊现象出现与否取决于曝光时间的长短，假如曝光时间过长，且物体运动快则会出现像糊；假如曝光时间很短，类似于运动物体在瞬间被冻结了，则少有像糊。</td>
</tr>
</tbody></table>
<h2 id="二-相机投影模型"><a href="#二-相机投影模型" class="headerlink" title="二 相机投影模型"></a>二 相机投影模型</h2><h3 id="1-单目相机-1"><a href="#1-单目相机-1" class="headerlink" title="1  单目相机"></a>1  单目相机</h3><h4 id="1-单目相机的投影模型。"><a href="#1-单目相机的投影模型。" class="headerlink" title="1. 单目相机的投影模型。"></a>1. 单目相机的投影模型。</h4><p>$$<br>\begin{aligned}<br>\left[<br>\begin{array}{ccc}<br>u\v\1<br>\end{array}<br>\right]<br>=<br>\frac{1}{Z}<br>\left[<br>\begin{array}{ccc}<br>\frac{1}{f_x}&amp;0&amp;cx\<br>0 &amp; \frac{1}{f_y}&amp; cy\<br>0 &amp; 0 &amp; 1<br>\end{array}<br>\right]<br>=<br>\left[<br>\begin{array}{ccc}<br>X\Y\Z<br>\end{array}<br>\right]<br>=KP<br>\end{aligned}<br>$$</p>
<h4 id="2-相机内参的物理意义"><a href="#2-相机内参的物理意义" class="headerlink" title="2 相机内参的物理意义"></a>2 相机内参的物理意义</h4><p>答：相机内参包括焦距<code>fx</code>，<code>fy</code>，<code>cx</code>，<code>cy</code>，径向畸变系数<code>k1</code>,<code>k2</code>,<code>k3</code>，切向畸变系数<code>p1</code>,<code>p2</code>。其中内参一般来说是不会改变，但是当使用可变焦距镜头时每次改变焦距需要重新标定内参。</p>
<table>
<thead>
<tr>
<th>内参参数</th>
<th>符号</th>
<th>意义</th>
<th>单位</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><code>fx</code>，<code>fy</code></td>
<td><code>fx = a f</code>；<code>fy=beta f</code></td>
<td>像素</td>
</tr>
<tr>
<td>焦距(Focal Length)</td>
<td><code>f</code></td>
<td>投影中心（光心）到物理成像平面的距离</td>
<td>米</td>
</tr>
<tr>
<td>主点(Principal Point )</td>
<td><code>cx</code>，<code>cy</code></td>
<td>主光轴在物理成像平面上的角点</td>
<td>像素</td>
</tr>
<tr>
<td>径向畸变( Radial Distortion )</td>
<td><code>k1</code>,<code>k2</code></td>
<td>由镜片形状不规则引起的畸变</td>
<td></td>
</tr>
<tr>
<td>切向畸变(Tangential Distortion )</td>
<td><code>q1</code>,<code>q2</code></td>
<td>由镜片不完全与成像平面平行引起的畸变</td>
<td></td>
</tr>
<tr>
<td>分辨率(Resolution)</td>
<td><code>rows</code>,<code>cols</code></td>
<td>像素平面图像的精密度</td>
<td>像素</td>
</tr>
</tbody></table>
<p>相机外参分为旋转矩阵<code>R</code>和平移矩阵<code>t</code>，旋转矩阵和平移矩阵共同描述了如何把点从世界坐标系转换到摄像机坐标系。</p>
<h4 id="3-单目相机，F和H矩阵有何不同，E和F矩阵有何不同，只旋转不平移能不能求F，只旋转不平移能不能求H"><a href="#3-单目相机，F和H矩阵有何不同，E和F矩阵有何不同，只旋转不平移能不能求F，只旋转不平移能不能求H" class="headerlink" title="3 单目相机，F和H矩阵有何不同，E和F矩阵有何不同，只旋转不平移能不能求F，只旋转不平移能不能求H"></a>3 单目相机，F和H矩阵有何不同，E和F矩阵有何不同，只旋转不平移能不能求F，只旋转不平移能不能求H</h4><h4 id="仿射变换、透视变换、欧式变换有什么区别"><a href="#仿射变换、透视变换、欧式变换有什么区别" class="headerlink" title="仿射变换、透视变换、欧式变换有什么区别"></a>仿射变换、透视变换、欧式变换有什么区别</h4><p>a) 仿射变换：形状会改变，但直线的平行关系不变，如矩形变成平行四边形。是透视变换的特殊形式。<br>b) 透视变换（或称射影变换）：是仿射变换更一般的形式，是共面点投影的变换关系，如单应性矩阵。平行的直线变换前后可能不会保持平行。<br>c) 欧式变换（或称等距变换）：旋转、平移；</p>
<h3 id="2-双目相机-1"><a href="#2-双目相机-1" class="headerlink" title="2 双目相机"></a>2 双目相机</h3><h4 id="1-我们知道双目相机两个相机光心的间距我们-称之为-baseline。如果双目相机baseline比较大，我们称之为wide-baseline-现在某代码中使用一个单目相机进行SLAM过程，在特征匹配时资料中提到了wide-baseline，请问这个wide-baseline怎么理解？"><a href="#1-我们知道双目相机两个相机光心的间距我们-称之为-baseline。如果双目相机baseline比较大，我们称之为wide-baseline-现在某代码中使用一个单目相机进行SLAM过程，在特征匹配时资料中提到了wide-baseline，请问这个wide-baseline怎么理解？" class="headerlink" title="1. 我们知道双目相机两个相机光心的间距我们 称之为 baseline。如果双目相机baseline比较大，我们称之为wide baseline.现在某代码中使用一个单目相机进行SLAM过程，在特征匹配时资料中提到了wide baseline，请问这个wide baseline怎么理解？"></a>1. 我们知道双目相机两个相机光心的间距我们 称之为 baseline。如果双目相机baseline比较大，我们称之为wide baseline.现在某代码中使用一个单目相机进行SLAM过程，在特征匹配时资料中提到了wide baseline，请问这个wide baseline怎么理解？</h4><h3 id="3-RGBD相机"><a href="#3-RGBD相机" class="headerlink" title="3 RGBD相机"></a>3 RGBD相机</h3><h4 id="1-RGB-D的SLAM和RGB的SLAM有什么区别？"><a href="#1-RGB-D的SLAM和RGB的SLAM有什么区别？" class="headerlink" title="1. RGB-D的SLAM和RGB的SLAM有什么区别？"></a>1. RGB-D的SLAM和RGB的SLAM有什么区别？</h4><p>a) RGBD-SLAM与RGB-SLAM使用的相机不同，前者可读出深度图像和彩色图像、后者只能读出彩色图像（单目或双目）；</p>
<p>b) 传感器数据不同，主要造成前端视觉里程计很多不同，如RGBD-SLAM不用初始化、计算3D点云方式不同、可以使用ICP直接计算相机位姿，</p>
<p> <a href="https://blog.csdn.net/qq_27550989/article/details/78341904" target="_blank" rel="noopener">参考</a></p>
<h2 id="三-相机畸变模型"><a href="#三-相机畸变模型" class="headerlink" title="三 相机畸变模型"></a>三 相机畸变模型</h2><p><strong>径向畸变</strong>是由透镜形状引起的畸变（Distortion，也叫失真）。<strong>切向畸变</strong>在相机的组装过程中由于不能使透镜和成像面严格平行引入的畸变。</p>
<p>通常使用多项式关系描述畸变，即：<br>$$<br>x_{distorted} = x(1+k_1r^2+k_2r^4+k_3r^6)\<br>y_{distorted} = y(1+k_1r^2+k_2r^4+k_3r^6)<br>$$<br>对于切向畸变，可以使用<code>p_1</code>,<code>p_2</code>进行纠正：<br>$$<br>x_{distorted} = x+2p_1xy+p_2(r^2+2x^2)\<br>y_{distorted} = y+p_1(r^2+2y^2)+2p_2xy<br>$$</p>
<h3 id="1-如何找到点在像素平面上的正确位置"><a href="#1-如何找到点在像素平面上的正确位置" class="headerlink" title="1. 如何找到点在像素平面上的正确位置"></a>1. 如何找到点在像素平面上的正确位置</h3><ol>
<li><p>将三维空间点投影到归一化图像平面。设它的归一化坐标为 [x, y]T。</p>
</li>
<li><p>对归一化平面上的点计算径向畸变和切向畸变。<br>$$<br>x_{distorted} = x(1+k_1r^2+k_2r^4+k_3r^6)+2p_1xy+p_2(r^2+2x^2)\<br>y_{distorted} = y(1+k_1r^2+k_2r^4+k_3r^6)+p_1(r^2+2y^2)+2p_2xy<br>$$</p>
</li>
<li><p>将畸变后的点通过内参数矩阵投影到像素平面，得到该点在图像上的正确位置。<br>$$<br>u = f_xx_{distorted}+c_x\<br>v = f_yy_{distorted}+c_y<br>$$</p>
</li>
</ol>
<h3 id="2-如果把一张图像去畸变，写公式，流程。（如何进行去畸变处理）"><a href="#2-如果把一张图像去畸变，写公式，流程。（如何进行去畸变处理）" class="headerlink" title="2. 如果把一张图像去畸变，写公式，流程。（如何进行去畸变处理）"></a>2. 如果把一张图像去畸变，写公式，流程。（如何进行去畸变处理）</h3><p><strong>去畸变过程</strong>主要包括以下步骤：</p>
<ol>
<li><p>将图像的像素坐标系通过内参矩阵转换到相机归一化坐标系<br>$$<br>x = (u-c_x)/f_x\<br>y = (v-c_y)/f_y<br>$$</p>
</li>
<li><p>在相机坐标系下进行去畸变操作<br>$$<br>r = \sqrt{x^2+y^2}\<br>x’ = x<em>(1+k_1<em>r^2+k_2</em>r^4)+2<em>p_1</em>x*y+p_2</em>(r^2+2<em>x^2)\<br>y’ = y</em>(1+k_1<em>r^2+k_2<em>r^4)+2</em>p_2<em>x</em>y+p_1</em>(r^2+2*y^2)\<br>$$</p>
</li>
<li><p>去畸变操作结束后，将相机坐标系重新转换到图像像素坐标系<br>$$<br>u’=x’<em>f_x+c_x\<br>v’=y’</em>f_y+c_y<br>$$</p>
</li>
<li><p>用源图像的像素值对新图像的像素点进行插值</p>
</li>
</ol>
<h3 id="4-如果一部相机的分辨率变为原来的两倍而其他地方不变，那么他的内参会如何变化？"><a href="#4-如果一部相机的分辨率变为原来的两倍而其他地方不变，那么他的内参会如何变化？" class="headerlink" title="4. 如果一部相机的分辨率变为原来的两倍而其他地方不变，那么他的内参会如何变化？"></a>4. 如果一部相机的分辨率变为原来的两倍而其他地方不变，那么他的内参会如何变化？</h3><p>相机内参<code>fx</code>，<code>fy</code>不会变化，<code>cx</code>，<code>cy</code>变为原来的两倍。</p>
<h3 id="5-我们知道相机的内参有-fx-fy-cx-cy-畸变参数-只考虑k1-k2-，相对世界坐标原点外参T。如果我们现在对相机拍摄的图片进行2倍的下采样，那么这些参数会如何变化？"><a href="#5-我们知道相机的内参有-fx-fy-cx-cy-畸变参数-只考虑k1-k2-，相对世界坐标原点外参T。如果我们现在对相机拍摄的图片进行2倍的下采样，那么这些参数会如何变化？" class="headerlink" title="5. 我们知道相机的内参有 fx, fy, cx, cy, 畸变参数(只考虑k1, k2)，相对世界坐标原点外参T。如果我们现在对相机拍摄的图片进行2倍的下采样，那么这些参数会如何变化？"></a>5. 我们知道相机的内参有 fx, fy, cx, cy, 畸变参数(只考虑k1, k2)，相对世界坐标原点外参T。如果我们现在对相机拍摄的图片进行2倍的下采样，那么这些参数会如何变化？</h3><h4 id><a href="#" class="headerlink" title></a></h4><h2 id="四-相机标定"><a href="#四-相机标定" class="headerlink" title="四 相机标定"></a>四 相机标定</h2><h3 id="一-相机如何标定"><a href="#一-相机如何标定" class="headerlink" title="一 相机如何标定"></a>一 相机如何标定</h3><p>答：相机标定一般是通过棋盘格进行标定</p>
<ul>
<li>检测每张图片中的棋盘图案的角点；</li>
<li>通过使用线性最小二乘法估算相机投影矩阵P；</li>
<li>根据P矩阵就解内参矩阵K和外参矩阵R，t;</li>
<li>通过非线性优化，提高K，R，t矩阵的精度。</li>
</ul>
<h3 id="二-RGB-D相机是如何标定的？需要标定哪些参数"><a href="#二-RGB-D相机是如何标定的？需要标定哪些参数" class="headerlink" title="二 RGB-D相机是如何标定的？需要标定哪些参数"></a>二 RGB-D相机是如何标定的？需要标定哪些参数</h3><p>参考链接：<a href="https://www.cnblogs.com/cv-pr/p/5769617.html" target="_blank" rel="noopener">https://www.cnblogs.com/cv-pr/p/5769617.html</a></p>
<p>机器视觉中，3D相机产生的深度图像（depth image）通常需要配准（registration），以生成配准深度图像（registed depth image）。实际上配准的目的就是想让深度图和彩色图重合在一起，即是将深度图像的图像坐标系转换到彩色图像的图像坐标系下。</p>
<p>已知彩色图像的像素表示为$=(uR,vR,zR)⊤$，$uR,vR,zR$分别表示彩色图像的横坐标，纵坐标和相机坐标系下的深度值（z方向上的值，非两点的距离）；同样地，深度图像的像素为$(uL,vL,zL)⊤$，$uL,vL,zL$分别表示深度图像的横坐标，纵坐标和相机坐标系下的深度值（z方向上的值，非两点的距离）。注意为了方便表示，本文中下标的R,L分别表示Right,Left的意思。那么深度图配准到彩色图的过程就是找到如下公式中的变换矩阵W′：<br>$$<br>\begin{bmatrix} u_{R}\  v_{R}\  1 \end{bmatrix} =W^{‘} \begin{bmatrix} u_{L}\  v_{L}\  1 \end{bmatrix}<br>$$</p>
<h1 id="二-视觉前端"><a href="#二-视觉前端" class="headerlink" title="二 视觉前端"></a>二 视觉前端</h1><h2 id="零-特征点"><a href="#零-特征点" class="headerlink" title="零 特征点"></a>零 特征点</h2><p>我们在阅读文献或者代码中误差相关时，经常可以看到一个概念，叫逆深度（inverse depth）。也就是深度的倒数，那么同学们有没有想过，为什么使用逆深度误差而不是深度误差？</p>
<h3 id="1-FAST-特征点"><a href="#1-FAST-特征点" class="headerlink" title="1 FAST 特征点"></a>1 FAST 特征点</h3><p>FAST特征点则直接利用了关键点与周围像素点灰度值的关系,提取时间非常短,能够实现实时计算,但是FAST关键点不具备尺度和方向不变性,无法应用与SLAM系统</p>
<h4 id="检测过程"><a href="#检测过程" class="headerlink" title="检测过程"></a>检测过程</h4><blockquote>
<ol>
<li>在图像中提取像素p，假设它的亮度为Ip；</li>
<li>设置一个阈值T，比如$I_p$的20%；</li>
<li>以像素p为中心，选取半径为3的圆上的16个像素点。</li>
<li>假如选取的圆上,有连续的 N 个点的亮度大于 Ip + T 或小于 Ip − T ,那么像素 p 可以被认为是特征点 (N 通常取 12,即为 FAST-12。其它常用的 N 取值为 9 和 11, 他们分别被称为 FAST-9,FAST-11)。</li>
<li>循环以上四步,对每一个像素执行相同的操作。</li>
</ol>
</blockquote>
<p>可以使用非极大值抑制在一定区域内保留响应极大值的角点，避免角点集中的问题</p>
<p>优点：速度快</p>
<p>缺点：重复性不强，分布不均匀</p>
<h3 id="SIFT-特征点"><a href="#SIFT-特征点" class="headerlink" title="SIFT 特征点"></a>SIFT 特征点</h3><p>SIFT特征点具备良好的尺度和方向不变性,而且对光照,抖动等噪声具有较强的鲁棒性.但由于SIFT的计算量比较大,根据orbslam2作者发表的论文<strong>“ORB-SLAM a Versatile and Accurate Monocular SLAM System”</strong>中可以知道,一张照片提取1000个SIFT特征点的平均时间为300ms,无法实现实时的SLAM系统,虽然后面有学者提出了在GPU加速下能够实现实时,但是毕竟实际的应用场景中,SLAM主要是为上层应用提高感知信息,理应不能占用过多的计算资源.而基于SIFT描述子改进的SURF描述子尽管提高了一个数量级的提取效率，但仍然无法满足SLAM系统的要求.</p>
<h3 id="3-ORB-特征点"><a href="#3-ORB-特征点" class="headerlink" title="3 ORB 特征点"></a>3 ORB 特征点</h3><p>ORB特征点的提取是<strong>基于图像金字塔</strong>的,在不同尺度的图像上面提取Oriented FAST 关键点<strong>(增加了方向的FAST关键点)</strong>和 BRIEF 描述子,以此来实现尺度和方向的不变性.</p>
<p>而ORB特征点则结合了一种改进的FAST关键点和BRIEF,具备有良好的尺度和方向不变性.提取一张照片的ORB特征点大约需要15ms,既实现了实时性,同时还保证了所提取特征点的可靠性.</p>
<h4 id="提取方法"><a href="#提取方法" class="headerlink" title="提取方法"></a>提取方法</h4><p>ORB取名已经反映出其是一个结合了改良后的FAST角点提取和BRIEF描述子的算法，提取ORB特征分为两步：</p>
<ol>
<li>FAST关键点提取：找出图像中的FAST角点，相较于原版的FAST，ORB中计算了特征点的主方向，为后续的BRIEF描述子增加了旋转不变性；</li>
<li>BRIEF描述子：对上一步提取出关键点的周围图像区域进行描述。</li>
</ol>
<h5 id="提取过程"><a href="#提取过程" class="headerlink" title="提取过程"></a>提取过程</h5><ol>
<li>计算图像块的矩</li>
<li>找到图像块的质心</li>
<li>连接几何中心与质心，得到方向向量，来描述ORB特征点</li>
</ol>
<h5 id="特征点描述"><a href="#特征点描述" class="headerlink" title="特征点描述"></a>特征点描述</h5><p>描述子BRIEF：由图像块中两个随机像素的亮度比较得到</p>
<h3 id="人工设计的特征需要考虑什么性质"><a href="#人工设计的特征需要考虑什么性质" class="headerlink" title="人工设计的特征需要考虑什么性质?"></a>人工设计的特征需要考虑什么性质?</h3><blockquote>
<p>可重复性；可取别想；高效率；本地性</p>
</blockquote>
<h2 id="一-特征提取"><a href="#一-特征提取" class="headerlink" title="一 特征提取"></a>一 特征提取</h2><p>给两组已经匹配好的3D点，计算相对位姿变换。已知匹配的ICP问题，写代码。</p>
<p>什么是Essential，Fundamental矩阵？</p>
<p>计算H矩阵和F矩阵的时候有什么技巧呢？实际上在问归一化的操作。</p>
<h3 id="1-什么是ORB特征，ORB特征的旋转不变性是如何做的，BRIEF算子是怎么提取的。"><a href="#1-什么是ORB特征，ORB特征的旋转不变性是如何做的，BRIEF算子是怎么提取的。" class="headerlink" title="1. 什么是ORB特征，ORB特征的旋转不变性是如何做的，BRIEF算子是怎么提取的。"></a>1. 什么是ORB特征，ORB特征的旋转不变性是如何做的，BRIEF算子是怎么提取的。</h3><p>ORB特征是对FAST特征点检测方法与BRIEF特征描述子进行结合和改进的特征点检测方法；FAST特征点不具备方向，ORB使用矩表示特征点的主方向，有了主方向就可以解决了BRIEF描述子不具备旋转不变性的问题了。方式：关键在于其建立坐标系的方式，ORB在计算BRIEF描述子时是以关键点为圆心、以关键点和取点区域的形心的连线为X轴建立2维坐标，这种方式保证了在不同的旋转角度下，当以同一个取点模式取出的点是相同的，这就解决了旋转不变性的问题？？？<br>ORB并未解决尺度不变性，OpenCV上的实现使用了高斯金字塔来保证其尺度不变性。</p>
<p>参考：<a href="https://blog.csdn.net/u014709760/article/details/87978271" target="_blank" rel="noopener">图像特征点—ORB特征点</a></p>
<ol>
<li>ORB特征即Oriented FAST and Rotated BRIEF，由FAST关键点和BRIEF描述子两部分组成，先使用FAST提取角点作为特征点，再使用BRIEF对特征点周围区域进行描述，计算描述子；</li>
<li>通过改进FAST特征点获得尺度不变性和旋转不变性：普通FAST角点不具备方向性和尺度不变性，ORB对其进行改进，增加了尺度不变性和特征点的方向信息，所以称为Oriented FAST关键点；尺度不变性通过构建图像金字塔、并在金字塔每一层检测角点实现；特征的方向（旋转）信息由灰度质心法计算图像块的质心、再连接图像块几何中心O与质心C，即可得到特征点的方向向量OC，特征点的方向即定义为theta =arctan(m01/m10)。至此FAST角点具有了尺度与旋转的描述。FAST特征点有了方向信息，在后续计算BRIEF描述子时，即可保证特征点的旋转不变性。</li>
<li>FAST角点提取：半径为3的圆上16个像素点，如果连续的N个点的亮度大于Ip+T或小于Ip-T（T为设定的阈值，如0.2*Ip），则认为该点是特征点，N常去12，即FAST-12。</li>
<li>BRIEF算子是二进制描述子，其描述向量由许多0和1组成，通过在关键点附近随机取两个像素（如p和q），比较p和q像素值的大小关系，如果p大于q，则取1，反之取0，取128组这样的p、q，即可得到特征点的128维描述子。</li>
<li>ORB速度快的原因：相比其他特征点检测算法，FAST只是比较像素亮度大小；BRIEF通过随机选点、编码0和1的方式计算描述子，因此速度快。</li>
</ol>
<h3 id="2-ORB-SLAM中的特征是如何提取的？如何均匀化的？"><a href="#2-ORB-SLAM中的特征是如何提取的？如何均匀化的？" class="headerlink" title="2. ORB-SLAM中的特征是如何提取的？如何均匀化的？"></a>2. ORB-SLAM中的特征是如何提取的？如何均匀化的？</h3><p><strong>特征提取</strong></p>
<p>ORB-SLAM2跟踪运行在主线程，是整个SLAM系统的基础。主程序在初始化SLAM系统后，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Examples&#x2F;Monocular&#x2F;mono_kitti.cc line:53&#96;&#96;</span><br><span class="line">&#x2F;&#x2F; Create SLAM system. It initializes all system threads and gets ready to process frames.&#96;&#96;</span><br><span class="line">ORB_SLAM2::System SLAM(argv[1],argv[2],ORB_SLAM2::System::MONOCULAR,&#96;&#96;true&#96;&#96;);</span><br></pre></td></tr></table></figure>

<p>就可以将每一帧图像送往跟踪函数，如下是单目SLAM主函数调用跟踪函数的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Examples&#x2F;Monocular&#x2F;mono_kitti.cc line:84&#96;&#96;</span><br><span class="line">&#x2F;&#x2F; Pass the image to the SLAM system&#96;&#96;</span><br><span class="line">SLAM.TrackMonocular(im,tframe);</span><br></pre></td></tr></table></figure>

<p><code>TrackMonocular()</code>函数调用<code>GrabImageMonocular()</code>函数实现跟踪功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; System.cc line:260&#96;&#96;</span><br><span class="line">cv::Mat Tcw &#x3D; mpTracker-&gt;GrabImageMonocular(im,timestamp);</span><br></pre></td></tr></table></figure>

<p> ORB-SLAM提取ORB特征时采用了8层金字塔，尺寸因子为1.2。对于像素为512<em>384到752</em>480的图片，提取1000个FAST角点，对于更高的分辨率，提取2000个FAST角点就可以了。</p>
<p>至此，得到当前帧ORB特征点<code>mvKeys</code>和描述子<code>mDescriptors</code>，均是<code>Frame</code>类对象<code>mCurrentFrame</code>的成员变量。提取出特征点后，需要对其去失真<code>UndistortKeyPoints();</code>。同时需要将图片分割为64*48大小的栅格，并将关键点按照位置分配到相应栅格中，从而降低匹配时的复杂度，实现函数为<code>AssignFeaturesToGrid();</code> 。</p>
<p><strong>特征均匀化</strong></p>
<h2 id="二-特征匹配"><a href="#二-特征匹配" class="headerlink" title="二 特征匹配"></a>二 特征匹配</h2><h3 id="1-快速最近邻算法（FLANN）"><a href="#1-快速最近邻算法（FLANN）" class="headerlink" title="1 快速最近邻算法（FLANN）"></a>1 快速最近邻算法（FLANN）</h3><h3 id="2-外点去除"><a href="#2-外点去除" class="headerlink" title="2 外点去除"></a>2 外点去除</h3><h4 id="A-RANSAC算法"><a href="#A-RANSAC算法" class="headerlink" title="A. RANSAC算法"></a>A. RANSAC算法</h4><p>RANSAC算法的<strong>基本假设</strong>是样本中包含正确数据(inliers，可以被模型描述的数据)，也包含异常数据(outliers，偏离正常范围很远、无法适应数学模型的数据)，即数据集中含有噪声。这些异常数据可能是由于错误的测量、错误的假设、错误的计算等产生的。同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。</p>
<p><strong>优缺点</strong></p>
<p>​    RANSAC算法的优点是能鲁棒的估计模型参数。例如，他能从包含大量局外点的数据集中估计出高精度的参数。缺点是它计算参数的迭代次数没有上限，如果设置迭代次数的上限，得到的结果可能不是最优的结果，甚至可能得到错误的结果。RANSAC只有一定的概率得到的可信的模型，概率与迭代次数成正比。另一个缺点是它要求设置跟问题相关的阈值，RANSAC只能从特定的数据集中估计出一个模型，如果存在两个（或多个）模型，RANSAC不能找到别的模型。</p>
<p><strong>算法流程</strong></p>
<blockquote>
<p>RANSAC是一个迭代算法。在基础版本中，每次迭代包括一下五个步骤：</p>
<ol>
<li>在原始数据中随机选取一个最小子集作为假设的内点（如果根据数据随机选择一条二维直线，则选择两个点）；</li>
<li>根据假设的内点拟合一个模型（比如根据两个点拟合直线）；</li>
<li>判断生育点的原始数据是否符合拟合的模型，并将其分为内点和外点。如果内点太少，则该次迭代被标记为无效并中止；</li>
<li>根据假设的内点和上一步中划分出的内点重新拟合模型</li>
<li>计算所有内点的残差，根据残差的和重新评估模型。</li>
</ol>
<p>迭代上述步骤，把具有残差和最小的模型作为最佳模型。</p>
</blockquote>
<p><strong>迭代次数的上限</strong></p>
<p>例如，k次才可以保证有概率p可以选到仅有内点组成的子集，假设每个测量为内点的概率均为$w$。<br>$$<br>1-p=(1-w^n)^k<br>$$<br>其中，n是拟合模型所需要的最少数据个数，k为总的迭代次数。k为<br>$$<br>k = \frac{\ln(1-p)}{\ln(1-w^n)}<br>$$</p>
<h4 id="B-M估计"><a href="#B-M估计" class="headerlink" title="B. M估计"></a>B. M估计</h4><h4 id="C-有哪几种鲁棒核函数？"><a href="#C-有哪几种鲁棒核函数？" class="headerlink" title="C. 有哪几种鲁棒核函数？"></a>C. 有哪几种鲁棒核函数？</h4><blockquote>
<p>RANAC和鲁棒核函数都是为了解决出现outlier的问题：RANAC是从数据中选择正确的匹配进行估计，鲁棒核函数则是直接作用在残差上，对残差进行饱和函数运算，限制单个数据点对于误差函数的影响力。等于对最小二乘问题做了包装，通过降低错误匹配的权重，使得观测数据中的outlier影响不到最终的估计结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20190930092003431.png#pic_center" alt="在这里插入图片描述"></p>
<p>常用核函数：Huber、Cauchy、Turkey;</p>
<p><img src="https://img-blog.csdnimg.cn/20190930092025127.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190930092033897.png#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="3-问题"><a href="#3-问题" class="headerlink" title="3 问题"></a>3 问题</h3><h4 id="1-如何对匹配好的点做进一步的处理，更好保证匹配效果"><a href="#1-如何对匹配好的点做进一步的处理，更好保证匹配效果" class="headerlink" title="1 如何对匹配好的点做进一步的处理，更好保证匹配效果"></a>1 如何对匹配好的点做进一步的处理，更好保证匹配效果</h4><blockquote>
<p>（1）确定匹配最大距离，汉明距离小于最小距离的两倍<br>（2）使用KNN-matching算法，令K=2。则每个match得到两个最接近的descriptor，然后计算最接近距离和次接近距离之间的比值，当比值大于既定值时，才作为最终match。<br>（3）RANSAC（使用RANSAC找到最佳单应性矩阵。由于这个函数使用的特征点同时包含正确和错误匹配点，因此计算的单应性矩阵依赖于二次投影的准确性）<br>（4）交叉匹配。针对暴力匹配，可以使用交叉匹配的方法来过滤错误的匹配。交叉过滤的思想很简单，再进行一次匹配，反过来使用被匹配到的点进行匹配，如果匹配到的仍然是第一次匹配的点的话，就认为这是一个正确的匹配。举例来说就是，假如第一次特征点A使用暴力匹配的方法，匹配到的特征点是特征点B；反过来，使用特征点B进行匹配，如果匹配到的仍然是特征点A，则就认为这是一个正确的匹配，否则就是一个错误的匹配。OpenCV中BFMatcher已经封装了该方法，创建BFMatcher的实例时，第二个参数传入true即可，BFMatcher bfMatcher(NORM_HAMMING,true)。</p>
</blockquote>
<h4 id="2-如果对于一个3D点，我们在连续帧之间形成了2D特征点之间的匹配，但是这个匹配中可能存在错误的匹配。请问你如何去构建3D点？除了RANSAC之外，还有什么鲁棒估计的方法？"><a href="#2-如果对于一个3D点，我们在连续帧之间形成了2D特征点之间的匹配，但是这个匹配中可能存在错误的匹配。请问你如何去构建3D点？除了RANSAC之外，还有什么鲁棒估计的方法？" class="headerlink" title="2 如果对于一个3D点，我们在连续帧之间形成了2D特征点之间的匹配，但是这个匹配中可能存在错误的匹配。请问你如何去构建3D点？除了RANSAC之外，还有什么鲁棒估计的方法？"></a>2 如果对于一个3D点，我们在连续帧之间形成了2D特征点之间的匹配，但是这个匹配中可能存在错误的匹配。请问你如何去构建3D点？除了RANSAC之外，还有什么鲁棒估计的方法？</h4><blockquote>
<p>可以使用RANSAC算法去除错误的匹配，M估计、鲁棒核函数。</p>
</blockquote>
<h4 id="3-如何优化重投影误差？采用什么方法求解？如果误匹配的点重投影之后误差很大，如何解决它对整个优化问题的影响？"><a href="#3-如何优化重投影误差？采用什么方法求解？如果误匹配的点重投影之后误差很大，如何解决它对整个优化问题的影响？" class="headerlink" title="3 如何优化重投影误差？采用什么方法求解？如果误匹配的点重投影之后误差很大，如何解决它对整个优化问题的影响？"></a>3 如何优化重投影误差？采用什么方法求解？如果误匹配的点重投影之后误差很大，如何解决它对整个优化问题的影响？</h4><blockquote>
<p>图优化模型将路标点和相机位姿作为两个节点，观测模型作为边，同时优化两个变量，SLAM中常用L-M求解。</p>
<p>如果误匹配误差很大可以考虑用核函数（Huber），核函数可以减小误匹配对整个方法的影响。</p>
</blockquote>
<h4 id="4-RANSAC在选择最佳模型的时候用的metric是什么？"><a href="#4-RANSAC在选择最佳模型的时候用的metric是什么？" class="headerlink" title="4  RANSAC在选择最佳模型的时候用的metric是什么？"></a>4  RANSAC在选择最佳模型的时候用的metric是什么？</h4><h3 id="3-常用边缘检测算子和优缺点"><a href="#3-常用边缘检测算子和优缺点" class="headerlink" title="3. 常用边缘检测算子和优缺点"></a>3. 常用边缘检测算子和优缺点</h3><p>边缘检测一般分为三步，分别是滤波、增强、检测。</p>
<p>基本原理都是用高斯滤波器进行去噪，之后在用卷积内核寻找像素梯度。常用的三种算法：<code>canny</code>算子，<code>sobel</code>算子，<code>laplacian</code>算子。</p>
<table>
<thead>
<tr>
<th>算子</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>scanny 算子</td>
<td>一种完善的边缘检测算法，抗噪能力强，用高斯滤波平滑图像，用一阶偏导的有限差分计算梯度的幅值和方向，<br>对梯度幅值进行非极大值抑制，采用双阈值检测和连接边缘。</td>
</tr>
<tr>
<td>sobel 算子</td>
<td>一阶导数算子，引入局部平均运算，对噪声具有平滑作用，抗噪声能力强，计算量较大，<br>但定位精度不高，得到的边缘比较粗，适用于精度要求不高的场合。</td>
</tr>
<tr>
<td>laplacian 算子</td>
<td>二阶微分算子，具有旋转不变性，容易受噪声影响，不能检测边缘的方向，<br>一般不直接用于检测边缘，而是判断明暗变化。</td>
</tr>
</tbody></table>
<h2 id="三-相机运动求解"><a href="#三-相机运动求解" class="headerlink" title="三 相机运动求解"></a>三 相机运动求解</h2><h3 id="1-极线约束（2D-2D）"><a href="#1-极线约束（2D-2D）" class="headerlink" title="1 极线约束（2D-2D）"></a>1 极线约束（2D-2D）</h3><p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200812162637025.png" alt="image-20200812162637025"><br>$$<br>x^T_2t^{\wedge}R x_1 = 0<br>$$</p>
<h4 id="1-按照你的理解讲解一下什么是极线约束？这个约束能带来什么好处？"><a href="#1-按照你的理解讲解一下什么是极线约束？这个约束能带来什么好处？" class="headerlink" title="1. 按照你的理解讲解一下什么是极线约束？这个约束能带来什么好处？"></a>1. 按照你的理解讲解一下什么是极线约束？这个约束能带来什么好处？</h4><blockquote>
<p>所谓极线约束就是说同一个点在两幅图像上的映射，已知左图映射点<code>p1</code>，那么右图映射点<code>p2</code>一定在相对于p1的极线上，这样可以减少待匹配的点数量。（画图解释）</p>
<p>极线约束的好处：从上面的描述我们可以看到，我们在做特征点匹配时，左图成像点p1的待匹配点p2一定在相对于p1的极线上，那么我们在做搜索时就可以在极线附近（考虑实际可能 会有一点误差）进行搜索，相对暴力匹配极大减少待匹配的点的数量。</p>
<p>可以画图解释，注意成像平面、特征点、极点、极线、极平面、相机光心等概念。</p>
</blockquote>
<h4 id="2-本质矩阵E、基本矩阵F、单应性矩阵H区别？"><a href="#2-本质矩阵E、基本矩阵F、单应性矩阵H区别？" class="headerlink" title="2 本质矩阵E、基本矩阵F、单应性矩阵H区别？"></a>2 本质矩阵E、基本矩阵F、单应性矩阵H区别？</h4><blockquote>
<p><strong>基本矩阵</strong>：描述的是不同帧之间同一空间点像素坐标的几何约束关系，将图像归一化坐标替换为像素点坐标，得到基本矩阵约束，基本矩阵描述的约束又称为极线约束。基本矩阵和相机内参，外参都有关系。</p>
<p><strong>本质矩阵</strong>：描述空间点在不同帧之间的归一化坐标的约束关系，是相机坐标系层面。本质矩阵和相机外参有关系，和内参无关。本质矩阵则是基本矩阵的一种特殊情况，是在归一化图像坐标下的基本矩阵，可以理解为本质矩阵对应的坐标位于相机坐标系，基础矩阵对应的坐标位于图像平面坐标系。</p>
<p><strong>单应性矩阵</strong>：在相机只有旋转而没有平移的情况，此时t为0，E也将为0，导致无法求解R，这时可以使用单应矩阵H求旋转，但仅有旋转，无法三角化求深度。</p>
</blockquote>
<h4 id="3-根据基础矩阵E如何求解相机运动R，t"><a href="#3-根据基础矩阵E如何求解相机运动R，t" class="headerlink" title="3 根据基础矩阵E如何求解相机运动R，t?"></a>3 根据基础矩阵E如何求解相机运动R，t?</h4><p>答：SVD分解</p>
<p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200815164626728.png" alt="image-20200815164626728"></p>
<p>其中的R矩阵怎么定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SVD分解</span></span><br><span class="line"><span class="function">Eigen::JacobiSVD&lt;Eigen::Matrix3d&gt; <span class="title">svd</span><span class="params">(E,ComputeThinU|ComputeThinV)</span></span>;</span><br><span class="line">Matrix3d V=svd.matrixV(),U=svd.matrixU();</span><br><span class="line">Matrix3d un_S=U.inverse()* E*V.transpose().inverse(); <span class="comment">//类型不要搞混</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算后的Sigma矩阵</span></span><br><span class="line"><span class="comment">//调整奇异值矩阵 调成E的解析格式，否则可能补满足E内在形式</span></span><br><span class="line"><span class="keyword">double</span> delta_1=un_S(<span class="number">0</span>,<span class="number">0</span>),delta_2=un_S(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">Matrix3d S = Matrix3d::Zero();</span><br><span class="line">S(<span class="number">0</span>,<span class="number">0</span>)=(delta_1+delta_2)/<span class="number">2</span>;</span><br><span class="line">S(<span class="number">1</span>,<span class="number">1</span>)=(delta_1+delta_2)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set t1, t2, R1, R2 </span></span><br><span class="line">Matrix3d t_wedge1, t_wedge2;</span><br><span class="line">Matrix3d R1, R2;</span><br><span class="line"><span class="comment">// 中间旋转矩阵的定义</span></span><br><span class="line"><span class="function">AngleAxisd <span class="title">V1</span><span class="params">(M_PI / <span class="number">2</span>, Vector3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function">AngleAxisd <span class="title">V2</span><span class="params">(- M_PI / <span class="number">2</span>, Vector3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">Matrix3d Rz_pos = V1.toRotationMatrix();</span><br><span class="line">Matrix3d Rz_neg = V2.toRotationMatrix();</span><br><span class="line">t_wedge1 = U*Rz_pos*S*U.transpose();</span><br><span class="line">t_wedge2 = U*Rz_neg*S*U.transpose();</span><br><span class="line">R1 = U*Rz_pos*V.transpose();</span><br><span class="line">R2 = U*Rz_neg*V.transpose();</span><br></pre></td></tr></table></figure>



<h3 id="2-ICP（3D-3D）"><a href="#2-ICP（3D-3D）" class="headerlink" title="2 ICP（3D-3D）"></a>2 ICP（3D-3D）</h3><p>迭代最近邻估计</p>
<h3 id="3-PnP（2D-3D"><a href="#3-PnP（2D-3D" class="headerlink" title="3 PnP（2D-3D)"></a>3 PnP（2D-3D)</h3><h4 id="1-什么是PnP算法？请用你的语言描述一下原理，它一般用在什么场景，解决什么问题？"><a href="#1-什么是PnP算法？请用你的语言描述一下原理，它一般用在什么场景，解决什么问题？" class="headerlink" title="1. 什么是PnP算法？请用你的语言描述一下原理，它一般用在什么场景，解决什么问题？"></a>1. 什么是PnP算法？请用你的语言描述一下原理，它一般用在什么场景，解决什么问题？</h4><p>Perspective-n-Points, PnP(P3P)提供了一种解决方案，它是一种由3D-2D的位姿求解方式，即需要已知匹配的3D点和图像2D点。目前遇到的场景主要就是SLAM算法中估计相机位姿时通常需要PnP给出相机初始位姿,第一帧图像中的3D点以及对应到第二帧图像中的2D点，通过相机成像模型，将3D点投影到二维平面，通过构建误差目标函数通过优化调整位姿的方法使得误差目标函数达到最小，所以它求得的是当前帧相对于上一帧的位姿变换，都是基于已知3D点和对应的图像2D点求解相机运动的过程。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="四-利用三角化求特征点位置"><a href="#四-利用三角化求特征点位置" class="headerlink" title="四 利用三角化求特征点位置"></a>四 利用三角化求特征点位置</h2><h2 id="六-2D-光流"><a href="#六-2D-光流" class="headerlink" title="六 2D 光流"></a>六 2D 光流</h2><h2 id="七-直接法"><a href="#七-直接法" class="headerlink" title="七 直接法"></a>七 直接法</h2><p>直接法估计相机位姿时，并不需要 提取特征点，而是通过优化匹配点的像素值误差（也称光度误差）估计位姿，但也会面临快速运动，光照变化等的挑战，如果让你改善该问题，你会采用哪些方法来提高跟踪质量(精度，速度，鲁棒性等)？</p>
<h2 id="八-方法对比"><a href="#八-方法对比" class="headerlink" title="八 方法对比"></a>八 方法对比</h2><h3 id="零-特征点法"><a href="#零-特征点法" class="headerlink" title="零 特征点法"></a><strong>零 特征点法</strong></h3><p>特征点法通过特征匹配得出2D-2D匹配点，使用对极几何即可计算相机位姿R、t，进一步通过最小化重投影误差优化R、t，得出最优的相机位姿。<strong>不同与直接法的地方</strong>在于，特征点法使用对极几何(或PnP、ICP)计算出的R、t作为位姿初值，最小化重投影误差进行优化，而直接法则使用经验值设定的R、t作为初值，使用最小化灰度误差进行优化。</p>
<h3 id="一-特征点法与直接法"><a href="#一-特征点法与直接法" class="headerlink" title="一 特征点法与直接法"></a>一 特征点法与直接法</h3><p><strong>特征点法</strong></p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>（1）精确，直接法属于强假设</td>
<td>（1）关键点提取、描述子、匹配耗时长</td>
</tr>
<tr>
<td>（2）运动过大时，只要匹配点在像素内，则不太会引起误匹配，鲁棒性好</td>
<td>（2）特征点丢失场景无法使用</td>
</tr>
<tr>
<td></td>
<td>（3）只能构建稀疏地图</td>
</tr>
</tbody></table>
<p><strong>直接法</strong></p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>（1）省去计算特征点、描述子时间</td>
<td>（1）易受光照和模糊影响</td>
</tr>
<tr>
<td>（2）可以用在特征缺失的场合（比如白墙）</td>
<td>（2）运动必须微小，要求相机运动较慢或采样频率较高（可以用图像金字塔改善）</td>
</tr>
<tr>
<td>（3）可以构建半稠密乃至稠密地图</td>
<td>（3）非凸性；单个像素没有区分度</td>
</tr>
</tbody></table>
<h4 id="简述一下特征点法和直接法的概念，以及对应的优缺点。"><a href="#简述一下特征点法和直接法的概念，以及对应的优缺点。" class="headerlink" title="简述一下特征点法和直接法的概念，以及对应的优缺点。"></a>简述一下特征点法和直接法的概念，以及对应的优缺点。</h4><p>特征点法，根据提取、匹配 特征点来估计相机运动，优化的是重投影误差，对光照变化不敏感 ，是比较成熟的方案。</p>
<table>
<thead>
<tr>
<th>特征点法</th>
<th>比如ORB-SLAM</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>（1）特征点本身对光照、运动、旋转比较不敏感，所以比较稳定<br>（2）相机运动较快（相对直接法来说）也能跟踪成功，鲁棒性好一些<br>（3）研究时间较久，方案比较成熟</td>
</tr>
<tr>
<td>缺点</td>
<td>（1）关键点提取、描述子、匹配耗时长<br>（2）特征点丢失场景无法使用<br>（3）只能构建稀疏地图</td>
</tr>
</tbody></table>
<p><strong>直接法</strong>，根据相机的亮度信息估计相机的运动，可以不需要计算关键点和描述子，优化的是光度误差，根据使用像素数量可分为稀疏、半稠密、稠密三种。</p>
<table>
<thead>
<tr>
<th>直接法</th>
<th>SVO，LSD-SLAM</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>（1）速度快，可以省去计算特征点、描述子时间<br>（2）可以用在特征缺失的场合（比如白墙），特征点法在该情况下会急速变差<br>（3）可以构建半稠密乃至稠密地图</td>
</tr>
<tr>
<td>缺点</td>
<td>（1）因为假设了灰度不变，所以易受光照变化影响<br><br>（2）要求相机运动较慢或采样频率较高（可以用图像金字塔改善）<br><br>（3）单个像素或像素块区分度不强，采用的是数量代替质量的策略</td>
</tr>
</tbody></table>
<h4 id="特征点法和直接法的BA有何不同"><a href="#特征点法和直接法的BA有何不同" class="headerlink" title="特征点法和直接法的BA有何不同"></a>特征点法和直接法的BA有何不同</h4><p> （1） 误差函数不同。<strong>特征点法是重投影误差，直接法是光度误差</strong> </p>
<p>（2） 雅克比矩阵不同</p>
<h3 id="二-光流法与直接法"><a href="#二-光流法与直接法" class="headerlink" title="二 光流法与直接法"></a>二 光流法与直接法</h3><h4 id="光流法"><a href="#光流法" class="headerlink" title="光流法"></a>光流法</h4><p>光流法通过光流跟踪图像像素点，得出两帧间角点的匹配关系，当存在一系列匹配点之后，即可使用三角测量、PnP、ICP等方法估计相机位姿。</p>
<h4 id="光流法与直接法的区别"><a href="#光流法与直接法的区别" class="headerlink" title="光流法与直接法的区别"></a>光流法与直接法的区别</h4><p><strong>光流法</strong></p>
<p>是基于像素的光度不变性假设，跟踪图像像素点的方法，描述了像素在图像中的运动。当使用光流法跟踪图像特征点得出匹配点对之后，即可以用匹配的特征点，使用ICP、PnP或对极几何估计相机运动。<strong>光流法本质上还应该划分到特征点法中</strong>，只不过把提取特征点、计算描述子、特征匹配替换成了光流跟踪而已，之后求解R和t的过程是一样的。</p>
<p><strong>直接法</strong></p>
<ol>
<li>是<strong>由光流法演变而来</strong>的，也是基于灰度不变性假设，通过<strong>最小化光度误差</strong>(或称为<strong>测量误差</strong>)来优化R和t。直接法将获取匹配点对(数据关联关系)与计算相机位姿放到同一个非线性最小二乘问题中，而特征点法是先得出匹配点，再进行非线性优化得出相机位姿，是分步进行的。</li>
<li><strong>区别</strong>：光流仅估计了像素间平移，但没有用到相机本身的几何结构、没有考虑到相机的旋转和图像的缩放、对于边界上的点，光流不好追踪，但直接法则考虑了这些信息；</li>
<li><strong>直接法流程</strong>：假设有两个帧，运动未知，但有初始估计R,t(通过经验值设定)；第一帧上看到了点P,投影为P1；按照初始估计，将P1转到第二帧，得出P在第二帧上投影P2；通过最小化P1与P2点的灰度误差来优化初始估计R、t。以上是定位过程，建图过程如下：当确定最优的R、t后，即可重投影得出3D点坐标。</li>
</ol>
<h4 id="光流和直接法有何不同："><a href="#光流和直接法有何不同：" class="headerlink" title="光流和直接法有何不同："></a>光流和直接法有何不同：</h4><blockquote>
<p><strong>答案1</strong>：匹配方法不同。<br>直接法是通过最小光度误差来匹配特征点，而光流法是通过计算<br>光流仅估计了像素间的平移，但像素梯度以及灰度关于时间的导数来预测像素在下一时刻的位置。</p>
<p><strong>答案2</strong>：光流仅估计了像素间的平移，但</p>
<p>（1）没有用相机结构<br>（2）没有考虑相机的旋转和图像缩放<br>（3）边界点追踪效果差</p>
</blockquote>
<h4 id="特征匹配（稀疏）和稠密匹配区别"><a href="#特征匹配（稀疏）和稠密匹配区别" class="headerlink" title="特征匹配（稀疏）和稠密匹配区别"></a><strong>特征匹配（稀疏）和稠密匹配区别</strong></h4><p>特征匹配： （1）速度快，效率高，可以到亚像素级别，精度高 （2）匹配元素为物体的几何特征，对照明变化不敏感 </p>
<p>稠密匹配 （1）速度慢，效率低 （2）对无纹理区域匹配效果不理想，对光强条件敏感</p>
<h1 id="三-卡尔曼滤波"><a href="#三-卡尔曼滤波" class="headerlink" title="三 卡尔曼滤波"></a>三 卡尔曼滤波</h1><h2 id="一-卡尔曼滤波"><a href="#一-卡尔曼滤波" class="headerlink" title="一 卡尔曼滤波"></a>一 卡尔曼滤波</h2><p>预测：如何从上一时刻的状态，根据输入信息推断当前时刻的状态分布（先验）计算协方差</p>
<p>更新：计算增益Kg，然后计算后验</p>
<h4 id="描述（扩展）卡尔曼滤波与粒子滤波，你自己在用卡尔曼滤波时遇到什么问题没有？"><a href="#描述（扩展）卡尔曼滤波与粒子滤波，你自己在用卡尔曼滤波时遇到什么问题没有？" class="headerlink" title="描述（扩展）卡尔曼滤波与粒子滤波，你自己在用卡尔曼滤波时遇到什么问题没有？"></a>描述（扩展）卡尔曼滤波与粒子滤波，你自己在用卡尔曼滤波时遇到什么问题没有？</h4><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>SLAM后端一般有两种方法：滤波方法和非线性优化方法，这两种方法有什么优缺点？</p>
<h3 id="常见滤波方法的对比（KF、EKF、IEKF、UKF、PF）"><a href="#常见滤波方法的对比（KF、EKF、IEKF、UKF、PF）" class="headerlink" title="常见滤波方法的对比（KF、EKF、IEKF、UKF、PF）"></a>常见滤波方法的对比（KF、EKF、IEKF、UKF、PF）</h3><h3 id="简述EKF和BA的区别"><a href="#简述EKF和BA的区别" class="headerlink" title="简述EKF和BA的区别"></a>简述EKF和BA的区别</h3><p>（1） EKF假设了马尔科夫性，认为k时刻的状态只与k-1时刻有关。非线性优化使用所有的历史数据，做全体的SLAM<br>（2） EKF做了线性化处理，在工作点处用一阶泰勒展开式近似整个函数，但在工作点较远处不一定成立。非线性优化每迭代一次，状态估计发生改变，我们会重新对新的估计点做 泰勒展开</p>
<p>可以把EKF看做只有一次迭代的BA</p>
<h1 id="四-非线性优化"><a href="#四-非线性优化" class="headerlink" title="四 非线性优化"></a>四 非线性优化</h1><p>最小化重投影误差问题（Minimization of Reprojection error）是个非线性，非凸的优化问题，这意味着我们不一定能求解它，也不一定能找到全局最优的解。在实际操作中，我们实际上是在调整每个$X_j$，使得它们更符合每一次观测$z_j$，也就是使每个误差项都尽量的小。由于这个原因，它也叫做捆集调整（Bundle Adjustment）。</p>
<h4 id="重投影误差的表达式，误差关于位姿的偏导数怎么算？误差关于空间点的偏导数怎么计算？"><a href="#重投影误差的表达式，误差关于位姿的偏导数怎么算？误差关于空间点的偏导数怎么计算？" class="headerlink" title="重投影误差的表达式，误差关于位姿的偏导数怎么算？误差关于空间点的偏导数怎么计算？"></a>重投影误差的表达式，误差关于位姿的偏导数怎么算？误差关于空间点的偏导数怎么计算？</h4><h2 id="一-最优化方法"><a href="#一-最优化方法" class="headerlink" title="一 最优化方法"></a>一 最优化方法</h2><h3 id="1-最小二乘法"><a href="#1-最小二乘法" class="headerlink" title="1 最小二乘法"></a>1 最小二乘法</h3><p>对于一个最小二乘问题：<br>$$<br>\min_{x}F(x) = \frac{1}{2} ||f(x)||2_2<br>$$<br>最小二乘法即使用迭代的方式，从一个初始值出发，不断更新优化变量，使得目标函数下降。</p>
<p>具体步骤如下：</p>
<ol>
<li>给定某个初值$x_0$；</li>
<li>对于第k次迭代，寻找一个增量$\Delta x_k$ ,使得$||f(x_k+\Delta x_k)||^2_x$达到极小值；</li>
<li>若$\Delta x_k$ 足够小,则停止‘；</li>
<li>否则，令$x_{k+1} = x_k + \Delta x_k$,返回第二步。</li>
</ol>
<h3 id="2-最速下降法、一阶二阶梯度法"><a href="#2-最速下降法、一阶二阶梯度法" class="headerlink" title="2 最速下降法、一阶二阶梯度法"></a>2 最速下降法、一阶二阶梯度法</h3><p><strong>梯度下降法</strong>：在寻找目标函数极小值时，是沿着反梯度方向进行寻找的。梯度的定义就是指向标量场增长最快的方向，在寻找极小值时，先随便定初始点（x0，y0）然后进行迭代不断寻找直到梯度的模达到预设的要求。但是梯度下降法的<strong>缺点</strong>之处在于：在远离极小值的地方下降很快，而在靠近极小值的地方下降很慢，靠近的时候可能成zig-zag下降。</p>
<h3 id="3-GN、LM算法"><a href="#3-GN、LM算法" class="headerlink" title="3 GN、LM算法"></a>3 GN、LM算法</h3><h4 id="1-Gauss-Netwon法-和-LM算法以及两者的区别。"><a href="#1-Gauss-Netwon法-和-LM算法以及两者的区别。" class="headerlink" title="1 Gauss-Netwon法 和 LM算法以及两者的区别。"></a>1 <code>Gauss</code>-<code>Netwon</code>法 和 <code>LM</code>算法以及两者的区别。</h4><p><strong>为什么用这两种算法</strong>：在SLAM中求解相机位姿时，常构建待优化位姿的误差函数（光度误差或重投影误差），通过使得这个误差函数取最小值，得出最优的相机位姿。如果这个误差函数是线性的，则可以直接求导数等于0处的极值即可，但该误差函数通常是关于待优化位姿的非线性多元函数，这实际上是一个非线性无约束最优化问题，常用的解法是G-N、LM算法。<br>两者均是非线性最小二乘求解方法， 都是通过泰勒展开进行线性化，并利用导数确定最优迭代方向，进行逐步迭代求出最优解的优化算法。</p>
<p><strong>高斯牛顿法</strong>：其利用了目标函数的泰勒展开式把<strong>非线性函数的最小二乘化问题化为每次迭代的线性函数的最小二乘化问题</strong>。高斯牛顿法的<strong>缺点</strong>在于：若初始点距离极小值点过远，迭代步长过大会导致迭代下一代的函数值不一定小于上一代的函数值。<br><strong>LM算法</strong>：在高斯牛顿法中加入了因子μ，当<strong>μ大时相当于梯度下降法</strong>，<strong>μ小时相当于高斯牛顿法</strong>。在使用Levenberg-Marquart时，先设置一个比较小的μ值，当发现目标函数反而增大时，将μ增大使用梯度下降法快速寻找，然后再将μ减小使用牛顿法进行寻找。<br>LM算法在高斯牛顿法中加入了因子μ，当μ大时相当于梯度下降法，μ小时相当于高斯牛顿法。在使用Levenberg-Marquart时，先设置一个比较小的μ值，当发现目标函数反而增大时，将μ增大使用梯度下降法快速寻找，然后再将μ减小使用牛顿法进行寻找。</p>
<h5 id="最速下降法"><a href="#最速下降法" class="headerlink" title="最速下降法"></a>最速下降法</h5><h5 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h5><h5 id="高斯牛顿法"><a href="#高斯牛顿法" class="headerlink" title="高斯牛顿法"></a>高斯牛顿法</h5><h5 id="LM算法"><a href="#LM算法" class="headerlink" title="LM算法"></a>LM算法</h5><p>最速下降法比较直观，但过于贪心，容易走出锯齿路线，反而增加迭代次数，导致局部收敛速度下降。<br>牛顿法在最速下降的基础上引入二阶导数，这样就处理了最速下降法一阶导数为0的情况，但是需要计算目标函数的海塞矩阵，二阶求导运算量不小，在问题规模较大时非常困难。<br>高斯牛顿法则对牛顿法进行了简化，避免了二阶求导，但实际中该近似只有半正定性，容易产生病态方程。<br>列文伯格—马夸尔特算法在高斯牛顿法引入阻尼项，一定程度上避免系数矩阵的非奇异和病态问题，但收敛速度较慢。</p>
<h4 id="2-为什么SLAM中常用LM算法而不是高斯牛顿求解优化问题？"><a href="#2-为什么SLAM中常用LM算法而不是高斯牛顿求解优化问题？" class="headerlink" title="2 为什么SLAM中常用LM算法而不是高斯牛顿求解优化问题？"></a>2 为什么SLAM中常用LM算法而不是高斯牛顿求解优化问题？</h4><ol>
<li>GN：线搜索 将f（x）进行一节泰勒展开，最后求解线性方程H△x=b；用JT*J近似H矩阵，H的计算过程根据特定问题特殊分析；该方法特点是：稳定性差，可能不收敛；</li>
<li>LM：信赖区域； 求解线性方程(H+λI)△x=b；通过调整拉格朗日乘子，可以判断是H占据主导地位(二阶近似较好)，还是λI占据主导地位(一阶近似较好)，</li>
<li>避免非奇异和病态问题，提供更稳定，更准确的增量。</li>
</ol>
<h4 id="4-LM算法里面那个λ是如何变化的呢？"><a href="#4-LM算法里面那个λ是如何变化的呢？" class="headerlink" title="4. LM算法里面那个λ是如何变化的呢？"></a>4. LM算法里面那个λ是如何变化的呢？</h4><p>答：LM算法中$\lambda$ 表示阻尼因子，阻尼因子的变化是根据比例因子来确定的。比例因子根据以下公式确定：<br>$$<br>\rho = \frac{F(x)-F(x+\Delta x_{lm})}{L(0)-L(\Delta x_{lm})}<br>$$</p>
<p><strong>阻尼因子的作用</strong></p>
<ul>
<li>$\lambda&gt;0$ 保证 $J^TJ+\lambda I$的正定性。</li>
<li>$\lambda$非常大的情况下。则$\Delta x_{lm} = -\frac{1}{\mu}J^Tf = -\frac{1}{\lambda}F’(x)^T$，接近最速下降法。</li>
<li>$\lambda$比较小的情况下，则认为$\Delta x_{lm} \approx \Delta x_{gn}$，最进阶高斯牛顿法。</li>
</ul>
<p><strong>基本思想</strong></p>
<p>首先比例因子分母始终大于 0,如果:</p>
<ul>
<li>ρ &lt; 0, 则 F (x) ↑ ,应该 μ ↑→ ∆x ↓, 增大阻尼减小步长。</li>
<li>如果 ρ &gt; 0 且比较大,减小 μ, 让 LM 接近 Gauss-Newton 使得系统更快收敛。</li>
<li>反之,如果是比较小的正数,则增大阻尼 μ,缩小迭代步长。</li>
</ul>
<p><strong>具体的阻尼策略(Marquardt)</strong></p>
<ul>
<li>当$\rho&gt;\frac{3}{4}$,则设置$\lambda = 2\lambda$；</li>
<li>当$\rho &lt; \frac{1}{4}$ ，则设置$\lambda = 0.5 \lambda$</li>
</ul>
<h4 id="5-为什么SLAM中常用L-M？"><a href="#5-为什么SLAM中常用L-M？" class="headerlink" title="5. 为什么SLAM中常用L-M？"></a>5. 为什么SLAM中常用L-M？</h4><p>G-N中的H矩阵可能为奇异矩阵或者病态矩阵，导致算法不收敛。而且当步长较大时，也无法保证收敛性，所以采用L-M求解增量方程，但是它的收敛速度可能较慢。</p>
<h4 id="6-一阶梯度下降，G-N和L-M三种方法的关系"><a href="#6-一阶梯度下降，G-N和L-M三种方法的关系" class="headerlink" title="6. 一阶梯度下降，G-N和L-M三种方法的关系"></a>6. <strong>一阶梯度下降，G-N和L-M三种方法的关系</strong></h4><p>(H+λI)△x=b</p>
<ul>
<li>当λ= 0时，L-M等于G-N；</li>
<li>当λ= ∞时，L-M等于一阶梯度下降。</li>
</ul>
<p>L-M的好处就在于：如果下降的太快，使用较小的λ，如果下降的太慢，使用较大的λ</p>
<h3 id="4-Dog-Leg算法"><a href="#4-Dog-Leg算法" class="headerlink" title="4 Dog-Leg算法"></a>4 Dog-Leg算法</h3><h4 id="22-做图优化时，对比采用四元数法和李代数法在数学直观性、计算量上的差异性"><a href="#22-做图优化时，对比采用四元数法和李代数法在数学直观性、计算量上的差异性" class="headerlink" title="22. 做图优化时，对比采用四元数法和李代数法在数学直观性、计算量上的差异性"></a>22. 做图优化时，对比采用四元数法和李代数法在数学直观性、计算量上的差异性</h4><h4 id="23-优化求解过程中，g2o或者ceres的内部实现过程，有哪些加速计算的处理"><a href="#23-优化求解过程中，g2o或者ceres的内部实现过程，有哪些加速计算的处理" class="headerlink" title="23.优化求解过程中，g2o或者ceres的内部实现过程，有哪些加速计算的处理"></a>23.优化求解过程中，g2o或者ceres的内部实现过程，有哪些加速计算的处理</h4><h4 id="24-画后端优化因子图"><a href="#24-画后端优化因子图" class="headerlink" title="24. 画后端优化因子图"></a>24. 画后端优化因子图</h4><h4 id="25-边缘化的过程全面分析，示意图，公式推导，优缺点，哪些矩阵块有改变"><a href="#25-边缘化的过程全面分析，示意图，公式推导，优缺点，哪些矩阵块有改变" class="headerlink" title="25.边缘化的过程全面分析，示意图，公式推导，优缺点，哪些矩阵块有改变"></a>25.边缘化的过程全面分析，示意图，公式推导，优缺点，哪些矩阵块有改变</h4><h4 id="26-10个相机同时看到100个路标点，问BA优化的雅克比矩阵和信息多少维？"><a href="#26-10个相机同时看到100个路标点，问BA优化的雅克比矩阵和信息多少维？" class="headerlink" title="26. 10个相机同时看到100个路标点，问BA优化的雅克比矩阵和信息多少维？"></a>26. 10个相机同时看到100个路标点，问BA优化的雅克比矩阵和信息多少维？</h4><p>答：雅克比矩阵维度：误差项数*误差变量数 （2000 360）</p>
<p>信息矩阵维度：误差变量数*误差变量数（360*360）</p>
<h2 id="二-编程问题"><a href="#二-编程问题" class="headerlink" title="二 编程问题"></a>二 编程问题</h2><h4 id="1-熟悉Ceres优化库吗？说一下。"><a href="#1-熟悉Ceres优化库吗？说一下。" class="headerlink" title="1 熟悉Ceres优化库吗？说一下。"></a>1 熟悉Ceres优化库吗？说一下。</h4><p>Ceres是一个广泛使用的最小二成求解库。用户只需要按照一定步骤定义待解的优化问题。Ceres求解的最小二成问题一般如下形式：<br>$$<br>\min_x\  \frac{1}{2}\sum_{i}p_i(||f_i(x_{i_1},…,x_{i_n})||^2)\<br>s.t\quad l_j\leq x_j \leq u_j<br>$$<br>一般求解过程：</p>
<ol>
<li><p>定义参数块</p>
</li>
<li><p>定义残差块的计算方式</p>
</li>
<li><p>定义残差快计算雅克比矩阵的方式；</p>
<p>三种方式可以使用：（1）自动求导（需要指定误差项和优化变量的维度）（AutoDiff）（2）使用数值求导(Numeric Diff)；（3）自行推到解析函数的形式。</p>
</li>
<li><p>在option里配置优化选项，比如使用Line search还是trust Regin；迭代次数、步长等</p>
</li>
<li><p>传入problem对象，调用solve函数求解。</p>
</li>
</ol>
<h4 id="2-介绍一下g2o库以及使用的基本方法"><a href="#2-介绍一下g2o库以及使用的基本方法" class="headerlink" title="2 介绍一下g2o库以及使用的基本方法"></a>2 介绍一下g2o库以及使用的基本方法</h4><p>g2o库是一个SLAM领域广为使用的优化库。它主要基于图优化。图优化就是把优化问题表现成图的一种优化方法。图有多个顶点以及链接这些顶点的边组成。用顶点表示优化变量，用边表示误差项。</p>
<p>g2o的基本使用步骤：</p>
<ol>
<li>定义顶点和边的类型；</li>
<li>构建图；</li>
<li>选择优化算法；</li>
<li>调用g2o进行优化，返回结果；</li>
</ol>
<h4 id="3-g2o-与-ceres的区别与联系"><a href="#3-g2o-与-ceres的区别与联系" class="headerlink" title="3 g2o 与 ceres的区别与联系"></a>3 g2o 与 ceres的区别与联系</h4><p>使用中：g2o提供了大量现成的边和顶点，非常便于相机的位姿态估计问题；ceres则需要手动实现每一个cost function。</p>
<h4 id="4-DogLeg-是什么？它与GN-和LM-有何异同？"><a href="#4-DogLeg-是什么？它与GN-和LM-有何异同？" class="headerlink" title="4. DogLeg 是什么？它与GN 和LM 有何异同？"></a>4. DogLeg 是什么？它与GN 和LM 有何异同？</h4><p><a href="http://www.numerical.rl.ac.uk/people/nimg/course/lectures/raphael/lectures/lec7slides.pdf" target="_blank" rel="noopener">DogLeg介绍</a><br>Dogleg属于Trust Region优化方法，即用置信域的方法在最速下降法和高斯牛顿法之间进行切换（将二者的搜索步长及方向转化为向量，两个向量进行叠加得到新的方向和置信域内的步长），相当于是一种加权求解。<br><a href="https://blog.csdn.net/lucylove3943/article/details/41588491" target="_blank" rel="noopener">相关材料</a></p>
<h5 id="我们知道（不知道的话，去查一下十四讲）用g2o和ceres库都能用来进行BA优化，这两者在使用过程中有什么不同？"><a href="#我们知道（不知道的话，去查一下十四讲）用g2o和ceres库都能用来进行BA优化，这两者在使用过程中有什么不同？" class="headerlink" title="我们知道（不知道的话，去查一下十四讲）用g2o和ceres库都能用来进行BA优化，这两者在使用过程中有什么不同？"></a>我们知道（不知道的话，去查一下十四讲）用g2o和ceres库都能用来进行BA优化，这两者在使用过程中有什么不同？</h5><h4 id="5-还有别的什么优化库吗"><a href="#5-还有别的什么优化库吗" class="headerlink" title="5. 还有别的什么优化库吗"></a>5. 还有别的什么优化库吗</h4><p>除了Ceres库和g2o库，还有NLopt库、liblbfgs、slam++库等等。 </p>
<h4 id="6-什么是边缘化？First-Estimate-Jacobian？一致性？可观性？"><a href="#6-什么是边缘化？First-Estimate-Jacobian？一致性？可观性？" class="headerlink" title="6. 什么是边缘化？First Estimate Jacobian？一致性？可观性？"></a>6. 什么是边缘化？First Estimate Jacobian？一致性？可观性？</h4><p> 对于VIO系统，边缘化的目的是把旧的状态量从状态估计窗口中移除，保证运行效率；同时，需要把移除的状态量的信息保留下来，作为当下窗口的先验，尽可能避免信息丢失。</p>
<h4 id="7-相比VSLAM，加入IMU后，哪些状态可观？"><a href="#7-相比VSLAM，加入IMU后，哪些状态可观？" class="headerlink" title="7. 相比VSLAM，加入IMU后，哪些状态可观？"></a>7. 相比VSLAM，加入IMU后，哪些状态可观？</h4><p>a. 单目SLAM7个自由度不可观：6个自由度+尺度；<br>b. 单目+IMU4个自由度不可观：偏航角（yaw）+3自由度不可观；翻滚角（roll）、俯仰角（pitch）由于重力存在而可观，尺度因子由于加速度计的存在而可观；</p>
<h4 id="8-给你m相机n个点的bundle-adjustment。当我们在仿真的时候，在迭代的时候，相机的位姿会很快的接近真值。而地图点却不能很快的收敛这是为什么呢？"><a href="#8-给你m相机n个点的bundle-adjustment。当我们在仿真的时候，在迭代的时候，相机的位姿会很快的接近真值。而地图点却不能很快的收敛这是为什么呢？" class="headerlink" title="8. 给你m相机n个点的bundle adjustment。当我们在仿真的时候，在迭代的时候，相机的位姿会很快的接近真值。而地图点却不能很快的收敛这是为什么呢？"></a>8. 给你m相机n个点的bundle adjustment。当我们在仿真的时候，在迭代的时候，相机的位姿会很快的接近真值。而地图点却不能很快的收敛这是为什么呢？</h4><h1 id="五-闭环检测与重定位"><a href="#五-闭环检测与重定位" class="headerlink" title="五 闭环检测与重定位"></a>五 闭环检测与重定位</h1><h2 id="一-闭环检测"><a href="#一-闭环检测" class="headerlink" title="一 闭环检测"></a>一 闭环检测</h2><h3 id="1-什么是闭环检测？"><a href="#1-什么是闭环检测？" class="headerlink" title="1 什么是闭环检测？"></a>1 什么是闭环检测？</h3><p>在视觉SLAM问题中，位姿的估计往往是由上一帧位姿解算当前帧位姿，这么递增求解，因此相邻两帧之间的误差就会产生累计。如我们在求解第五帧位姿的时候，一般是根据第四帧计算的，但是如果我们发现第5帧还可以由第2帧计算出来，就减少了误差的累计。<strong>这种与之前的某一帧（非相邻帧）建立位姿约束关系就叫做回环</strong>。找到可以建立这种位姿约束的历史帧，就是<strong>回环检测</strong>。</p>
<h4 id="a-什么要进行回环检测？"><a href="#a-什么要进行回环检测？" class="headerlink" title="a 什么要进行回环检测？"></a>a 什么要进行回环检测？</h4><p>回环通过减少约束数，起到了减小累计误差的作用。</p>
<h3 id="2-闭环检测有哪些方法-最常用的方法有哪些？"><a href="#2-闭环检测有哪些方法-最常用的方法有哪些？" class="headerlink" title="2 闭环检测有哪些方法? 最常用的方法有哪些？"></a>2 闭环检测有哪些方法? 最常用的方法有哪些？</h3><h5 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a><strong>朴素方法</strong></h5><ol>
<li>对任意两张图像都做一遍特征匹配，根据正确匹配的数量确定哪两个图像存在关联。（这是 O(N2) 的复杂度，随着轨迹变长增长太快，在实时系统中不实用）</li>
<li>随机抽取历史数据并进行回环检测，比如说在n 帧当中随机抽 5 帧与当前帧比较。（盲目试探方法在帧数 N 增长时，抽到回环的几率又大幅下降，使得检测效率不高）</li>
</ol>
<h5 id="基于里程计的几何关系"><a href="#基于里程计的几何关系" class="headerlink" title="基于里程计的几何关系"></a>基于里程计的几何关系</h5><p>当我们发现当前相机运动到了之前的某个位置附近时，检测它们有没有回环关系</p>
<p><strong>基于外观的检测方法</strong></p>
<p>它和前端后端的估计都无关，仅根据两张图像的相似性确定回环检测关系。核心问题是如何计算图像间的相似性。</p>
<p>方法：特征匹配，提取当前帧与过去所有帧的特征，并进行匹配，这种方式假设了过去所有帧都有可能出现回环，匹配十分耗时、计算量大。基于词袋模型，词袋模型就是把特征看成是一个个单词，通过比较两张图片中单词的一致性，来判断两张图片是否属于同一场景。词袋模型需要训练字典(K-means聚类)，但通常字典内单词数量巨大，在确定某个特征时需要与字典内每个单词进行匹配，效率低下。为提高匹配效率，字典在训练的过程中构建了一个有k个分支，深度为d的树(K叉树)，类似于层次聚类，可容纳$k^d$个单词，保证了对数级别的查找效率。</p>
<h3 id="3-闭环检测的评价方法"><a href="#3-闭环检测的评价方法" class="headerlink" title="3 闭环检测的评价方法"></a>3 闭环检测的评价方法</h3><p>表 12-1 回环检测的结果分类</p>
<table>
<thead>
<tr>
<th>算法 \ 事实</th>
<th>是回环</th>
<th>不是回环</th>
</tr>
</thead>
<tbody><tr>
<td>是回环</td>
<td>真阳性(<strong>T</strong>rue <strong>P</strong>ositive)</td>
<td>假阳性(<strong>F</strong>alse <strong>P</strong>ositive)</td>
</tr>
<tr>
<td>不是回环</td>
<td>假阴性(<strong>F</strong>alse <strong>N</strong>egative)</td>
<td>真阴性(<strong>T</strong>rue <strong>N</strong>egative)</td>
</tr>
</tbody></table>
<h4 id="准确率-False-Positive"><a href="#准确率-False-Positive" class="headerlink" title="准确率 (False Positive)"></a>准确率 (False Positive)</h4><p>准确率描述的是,算法提取的所有回环中,确实是真实回环的概率。<br>$$<br>Precision = T P /(T P + F P ),<br>$$</p>
<h4 id="召回率-Precision-amp-Recall"><a href="#召回率-Precision-amp-Recall" class="headerlink" title="召回率 (Precision &amp; Recall)"></a>召回率 (Precision &amp; Recall)</h4><p>召回率则是说,在所有真实回环中,被正确检测出来的概率<br>$$<br>Recall = T P /(T P + F N ).<br>$$<br>在 SLAM 中,我们对准确率要求更高,而对召回率则相对宽容一些。</p>
<h4 id="PR曲线"><a href="#PR曲线" class="headerlink" title="PR曲线"></a>PR曲线</h4><p>测试回环检测在各种配置下的 P 和 R 值,然后做出一条Precision-Recall 曲线。当用召回率为横轴,用准确率为纵轴时,我们会关心整条曲线偏向右上方的程度、100% 准确率下的召回率,或者 50% 召回率时候的准确率,作为评价算法的指标。</p>
<h3 id="4-词袋模型"><a href="#4-词袋模型" class="headerlink" title="4 词袋模型"></a>4 词袋模型</h3><p>词袋,也就是 Bag-of-Words(BoW) ,目的是用“图像上有哪几种特征”来描述一个图像。</p>
<p>词袋模型的简明流程：</p>
<ol>
<li>提取单词，组成字典；</li>
<li>用单词描述图片，即构成一个向量(对图片的描述)</li>
<li>比较向量的相似程度</li>
</ol>
<h4 id="a-字典构建"><a href="#a-字典构建" class="headerlink" title="a 字典构建"></a>a 字典构建</h4><p>字典生成问题类似于一个聚类(Clustering)问题。</p>
<h4 id="b-K-means聚类"><a href="#b-K-means聚类" class="headerlink" title="b K-means聚类"></a>b K-means聚类</h4><ol>
<li>随机选取 k 个中心点:c1 , . . . , ck ;</li>
<li>对每一个样本,计算与每个中心点之间的距离,取最小的作为它的归类;</li>
<li>重新计算每个类的中心点。</li>
<li>如果每个中心点都变化很小,则算法收敛,退出;否则返回 1。</li>
</ol>
<h4 id="c-字典的表示"><a href="#c-字典的表示" class="headerlink" title="c 字典的表示"></a>c 字典的表示</h4><p>使用一种 k 叉树来表达字典。它的思路很简单,类似于层次聚类,是 k-means 的直接扩展。假定我们有 N 个特征点,希望构建一个深度为 d,每次分叉为 k 的<br>树,那么做法如下(见图 12.3.1 ):</p>
<ol>
<li>在根节点,用 k-means 把所有样本聚成 k 类(实际中为保证聚类均匀性会使用k-means++)  。这样得到了第一层。</li>
<li>对第一层的每个节点,把属于该节点的样本再聚成 k 类,得到下一层。</li>
<li>依此类推,最后得到叶子层。叶子层即为所谓的 Words。</li>
</ol>
<h4 id="d-相似度的计算"><a href="#d-相似度的计算" class="headerlink" title="d 相似度的计算"></a>d 相似度的计算</h4><p>TF-IDF(Term Frequency–Inverse Document Frequency)[100, 101],或译频率-逆文档频率­。TF 部分的思想是,某单词在一个图像中经常出现,它的区分度就高。另一方面,IDF 的思想是,某单词在字典中出现的频率越低,则分类图像时区分度越高。</p>
<p>在词袋模型中,在建立字典时可以考虑 IDF 部分。我们统计某个叶子节点 wi 中的特征数量相对于所有特征数量的比例,作为 IDF 部分。另一方面,TF 部分则是指某个特征在单个图像中出现的频率。<br>$$<br>IDF_i = \log \frac{n}{n_i}\<br>TF_i = \frac{n_i}{n}\<br>\eta_i = TF_i \times IDF_i<br>$$<br>考虑权重以后,对于某个图像 A,它的特征点可对应到许多个单词,组成它的 <strong>Bag-of-Words</strong>:<br>$$<br>A = {(w1 , η1 ), (w2 , η2), . . . , (wN , ηN )} = ∆ v_A<br>$$<br>给定 vA 和 vB ,如何计算它们的差异呢?这个问题和范数定义的方式一样,存在若干种解决方式,比如 [102] 中提到的 <strong>L1 范数</strong>形式:<br>$$<br>s (v_A − v_B ) =2∑^N_{o=1} |v_{A_i} | + |v_{B_i} | − |v_{A_i} − v_{B_i}|.<br>$$</p>
<h4 id="e-相似性评分的处理"><a href="#e-相似性评分的处理" class="headerlink" title="e 相似性评分的处理"></a>e 相似性评分的处理</h4><p>考虑到这种情况,我们会取一个先验相似度 s (vt , vt−∆t ),它表示某时刻关键帧图像与上一时刻的关键帧的相似性。然后,其他的分值都参照这个值进行归一化:<br>$$<br>s（v_t, v_{t_j})’ = s(v_t , v_{t_j}) /s (v_t , v_{(t−∆t)}) .<br>$$<br>:如果当前帧与之前某关键帧的相似度,超过当前帧与上一<br>个关键帧相似度的 3 倍,就认为可能存在回环。</p>
<p>好处：这个步骤避免了引入绝对的相似性阈值,使得算法能够适应更多的环境。</p>
<h4 id="f-关键帧的处理"><a href="#f-关键帧的处理" class="headerlink" title="f 关键帧的处理"></a>f 关键帧的处理</h4><p>检测回环关键帧的选取。如果关键帧选得太近,那么导致两个关键帧之间的相似性过高, 相比之下不容易检测出历史数据中的回环。比如检测结果经常是第 n 帧和第 n − 2 帧、n − 3 帧最为相似,这种结果似乎太平凡了,意义不大。所以从实践上说,用于回环检测的帧最好是稀疏一些,彼此之间不太相同,又能涵盖整个环境。</p>
<h4 id="e-为什么检测到回环之后还要验证-如何验证？"><a href="#e-为什么检测到回环之后还要验证-如何验证？" class="headerlink" title="e 为什么检测到回环之后还要验证 如何验证？"></a>e 为什么检测到回环之后还要验证 如何验证？</h4><p>词袋的回环检测算法完全依赖于外观而没有利用任何的几何信息,这导致外观相似的图像容易被当成回环。并且,由于词袋不在乎单词顺序,只在意单词有无的表达方式,更容易引发感知偏差。所以,在回环检测之后,我们通常还会有一个验证步骤 [80, 103]。</p>
<p><strong>验证的方法</strong></p>
<ol>
<li><strong>时间上的一致性检测</strong>。设立回环的缓存机制,认为单次检测到的回环并不足以构成良好的约束,而在一段时间中一直检测到的回环,才认为是正确的回环。</li>
<li><strong>空间上的一致性检测</strong>。即是对回环检测到的两个帧进行特征匹配,估计相机的运动。然后,再把运动放到之前的 Pose Graph 中,检查与之前的估计是否有很大的出入。总之,验证部分通常是必须的,但如何实现却是见仁见智的问题。</li>
</ol>
<h3 id="6-你用的哪种方法？有没有创新？"><a href="#6-你用的哪种方法？有没有创新？" class="headerlink" title="6. 你用的哪种方法？有没有创新？"></a>6. 你用的哪种方法？有没有创新？</h3><h3 id="7-闭环检测成功之后有什么操作？"><a href="#7-闭环检测成功之后有什么操作？" class="headerlink" title="7. 闭环检测成功之后有什么操作？"></a>7. 闭环检测成功之后有什么操作？</h3><ol>
<li><p>根据PnP等算法计算运动关系</p>
</li>
<li><p>根据重投影关系验证回环是否成立</p>
</li>
<li><p>利用全局BA或Pose Graph进行优化</p>
</li>
</ol>
<h2 id="二-重定位"><a href="#二-重定位" class="headerlink" title="二 重定位"></a>二 重定位</h2><p>绑架问题就是重定位，是指机器人在缺少之前位置信息的情况下，或跟踪丢失的情况下，如何进行重新定位、确定当前位姿。例如当机器人被安置在一个已经构建好地图的环境中，但是并不知道它在地图中的相对位置，或者在移动过程中，由于传感器的暂时性功能故障或相机的快速移动，都导致机器人先前的位置信息的丢失，在这种情况下如何重新确定自己的位置。</p>
<h4 id="我们在看SLAM相关论文的时候，会遇到一个词“kidnap”，-直译过来就是“绑架”，不了解的同学可能感觉怪怪的。你知道这个“绑架”是什么意思吗？可以用哪些方法解决这样的问题？"><a href="#我们在看SLAM相关论文的时候，会遇到一个词“kidnap”，-直译过来就是“绑架”，不了解的同学可能感觉怪怪的。你知道这个“绑架”是什么意思吗？可以用哪些方法解决这样的问题？" class="headerlink" title="我们在看SLAM相关论文的时候，会遇到一个词“kidnap”， 直译过来就是“绑架”，不了解的同学可能感觉怪怪的。你知道这个“绑架”是什么意思吗？可以用哪些方法解决这样的问题？"></a>我们在看SLAM相关论文的时候，会遇到一个词“kidnap”， 直译过来就是“绑架”，不了解的同学可能感觉怪怪的。你知道这个“绑架”是什么意思吗？可以用哪些方法解决这样的问题？</h4><h2 id="三-对比"><a href="#三-对比" class="headerlink" title="三 对比"></a>三 对比</h2><h3 id="1-重定位与闭环检测的区别"><a href="#1-重定位与闭环检测的区别" class="headerlink" title="1 重定位与闭环检测的区别"></a>1 重定位与闭环检测的区别</h3><p><strong>重定位</strong> 指的是当跟丢之后重新找回当前的姿态，通过当前帧与关键帧的特征匹配，定位当前帧的相机位姿。顾名思义，这是“ 重新”定位，当前图像因为和最近的图像或者局部地图之间缺乏足够的匹配，导致机器人无法确定自己的位姿，此时处于当前状态的机器人不再知道其在地图中的位置，也叫做机器人被“绑架”，就说的是人质被蒙上双眼带到未知地方，蒙罩去掉后完全不知道自己在哪里，这时候就需要充分利用之前建好的地图或者存好的数据库。此时机器人需要观察周围环境，并且从已有地图中寻找可靠的匹配关系（一般是关键帧信息），这样就可以根据已有信息“ 重新 ”估计机器人的姿态。</p>
<p><strong>回环检测</strong> 是为了解决解决位置估计随时间漂移的问题。主要是通过识别曾经到过的场景，将其与当前帧对应，优化整个地图信息，包括3D路标点、及相机位姿、相对尺度信息.<br>回环的主要目的是降低机器人随时间增加，轨迹中累积的漂移，一般发生在建图过程中。这是因为基于运动传感器或者视觉信息的里程计容易出错，使估计的轨迹偏离其实际真实的情况。通过回环，优化整个地图信息，包括3D路标点、及相机位姿、相对尺度信息。回环检测提供了回环帧与所有历史帧的关系，可以极大减小误差。</p>
<p><strong>联系</strong>：回环主要是纠正机器人/相机轨迹，而重新定位在从未知状态找回姿态。两者都需要当前图像预先访问过之前的位置附近，本质上都是一个图像识别问题。</p>
<p><strong>区别</strong>：二者目的不同，重定位主要为了恢复姿态估计，而回环为了解决飘移，提高全局精度。之所以容易混淆，可能是因为重定位通常也需要找到与之前帧的对应关系来解出姿态，而这可以通过回环检测来完成。也就是说，二者在匹配帧上可以共享一些算法。然后是第一个问题。专门研究重定位的论文很多，实际在单目VSLAM算法用的比较多的还是基于BoW的匹配方案（ORB-SLAM，VINS等），也有基于机器学习匹配patch的方法（PTAM）。同时也有一些简单粗暴的解决方案，比如单独开线程暴力匹配之前所有关键帧（LSD），或者只扰动初始值不断与上一个关键帧进行匹配（DSO）。</p>
<h3 id="2-词袋模型可以用于回环检测，也可以用于重定位，有什么区别"><a href="#2-词袋模型可以用于回环检测，也可以用于重定位，有什么区别" class="headerlink" title="2 词袋模型可以用于回环检测，也可以用于重定位，有什么区别"></a>2 词袋模型可以用于回环检测，也可以用于重定位，有什么区别</h3><p>词袋模型在SLAM中的应用：当前帧与关键帧的特征匹配、重定位的特征匹配、回环检测的特征匹配；（第一个是后两个的基本原理，后两个是应用场景）。连续帧间特征匹配采用的并不是词袋模型。</p>
<p>a) 重定位：主要是通过当前帧与关键帧的特征匹配，定位当前帧的相机位姿。<br>b) 回环检测：优化整个地图信息，包括3D路标点、及相机位姿、相对尺度信息。回环检测提供了当前帧与所有历史帧的关系，</p>
<h1 id="六-建图"><a href="#六-建图" class="headerlink" title="六 建图"></a>六 建图</h1><h2 id="地图点"><a href="#地图点" class="headerlink" title="地图点"></a>地图点</h2><h3 id="3D地图点是怎么存储的？表达方式？"><a href="#3D地图点是怎么存储的？表达方式？" class="headerlink" title="3D地图点是怎么存储的？表达方式？"></a>3D地图点是怎么存储的？表达方式？</h3><p>a) 地图点构建：单目：可以通过关键帧匹配构造、也可以通过普通帧构造（临时被Tracking用来追踪的）；双目：立体匹配、块匹配；RGBD：彩色深度图对齐得到深度d，再根据彩色(u，v)坐标根据相机投影公式计算3D点坐标。<br>b) 3D地图点存储方式：Vector3f<br>c) 地图主要包含关键帧、3D地图点、BoW向量、共视图、生长树等：关键帧(包括特征点、描述符、当前帧的相机位姿，BoW向量无法保存，可在加载关键帧后重新计算)、3D地图点、共视图、<br>d) <a href="https://www.cnblogs.com/mafuqiang/p/6972342.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><h4 id="不同的需求需要什么样的地图"><a href="#不同的需求需要什么样的地图" class="headerlink" title="不同的需求需要什么样的地图"></a>不同的需求需要什么样的地图</h4><ul>
<li>定位仅需匹配特征点</li>
<li>导航和避障需要稠密障碍物信息</li>
<li>交互需要稠密的物体表面信息</li>
<li>高层任务需要语义信息</li>
</ul>
<h2 id="建图方法"><a href="#建图方法" class="headerlink" title="建图方法"></a>建图方法</h2><h3 id="RGBD稠密建图"><a href="#RGBD稠密建图" class="headerlink" title="RGBD稠密建图"></a>RGBD稠密建图</h3><ul>
<li>点云</li>
<li>网格/面片</li>
<li>TSDF</li>
<li>八叉树</li>
</ul>
<h4 id="给一组点云，从中提取平面。"><a href="#给一组点云，从中提取平面。" class="headerlink" title="给一组点云，从中提取平面。"></a>给一组点云，从中提取平面。</h4><h1 id="七-SLAM方案"><a href="#七-SLAM方案" class="headerlink" title="七 SLAM方案"></a>七 SLAM方案</h1><ol>
<li>你认为室内SLAM与自动驾驶SLAM有什么区别？</li>
<li>读Maplab，设计室内服务机器人地图更新的方法、流程。</li>
</ol>
<h2 id="一-时间戳"><a href="#一-时间戳" class="headerlink" title="一 时间戳"></a>一 时间戳</h2><p>工程目录下有<code>GPS</code>保存的坐标文件<code>gps.txt</code>和激光雷达保存的坐标文件<code>laser.txt</code>两个文件，两个文件的第一列为记录当前数据的时间戳，后两列为坐标。由于GPS每隔500时间单位保存一次数据，激光雷达每隔300时间单位保存一次数据，因此，一段时间内激光雷达保存的数据比<code>GPS</code>保存的数据要多。现在想取出两个文件中时间戳最接近的数据，并分别存放在<code>gps2.txt</code>和<code>laser2.txt</code>中，编写程序实现。（不知道哪位大神能讲下这道题。。。）</p>
<p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200812100331825.png" alt="image-20200812100331825"></p>
<h2 id="二-关键帧"><a href="#二-关键帧" class="headerlink" title="二 关键帧"></a>二 关键帧</h2><h3 id="关键帧的概念"><a href="#关键帧的概念" class="headerlink" title="关键帧的概念"></a>关键帧的概念</h3><blockquote>
<p><strong>关键帧</strong>目前是一种非常常用的方法，可以减少待优化的帧数，并且可以代表其附近的帧。可以理解为一个学校里有100个班级，每个班的班长就是一个关键帧，他可以代表他班里的人，那么如何选取关键帧呢？</p>
<p><strong>关键帧作用</strong>：图像插入频率过高会导致信息冗余度快速增加，而这些冗余的信息对系统的精度提升却十分有限，甚至没有提高，反而消耗了更多的计算资源。关键帧的目的在于，适当地降低信息冗余度，减少计算机资源的损耗，保证系统的平稳运行。</p>
</blockquote>
<h3 id="0-为什么要选择关键帧"><a href="#0-为什么要选择关键帧" class="headerlink" title="0 为什么要选择关键帧"></a>0 为什么要选择关键帧</h3><p>答：1  后端通常实时性较差,不适合处理所有帧；2  如果相机停止,可能给后端留下无用的优化,甚至导致后端问题退化</p>
<h4 id="1-关键帧选择指标（如何选择关键帧）"><a href="#1-关键帧选择指标（如何选择关键帧）" class="headerlink" title="1 关键帧选择指标（如何选择关键帧）"></a>1 关键帧选择指标（如何选择关键帧）</h4><blockquote>
<ol>
<li><strong>跟踪质量</strong>：比如当前帧跟踪到的特征点数大于一定阈值，如大于50个点，或关键帧跟踪到的点比参考关键帧少90%。</li>
<li><strong>距离最近关键帧的距离是否足够远（空间）</strong>：即当前帧空间位置是否有足够的变换，如在静止不动或移动幅度较小的情况下，当移动角度大于一定程度才认为是关键帧。</li>
<li><strong>距离上一关键帧的帧数是否足够多（时间）</strong>：如过了20帧仍没有插入关键帧；</li>
<li><strong>局部地图空闲</strong></li>
</ol>
</blockquote>
<h4 id="2-ORB-SLAM中关键帧之间的连接，共视图（Covisibility-Graph）数据结构"><a href="#2-ORB-SLAM中关键帧之间的连接，共视图（Covisibility-Graph）数据结构" class="headerlink" title="2 ORB-SLAM中关键帧之间的连接，共视图（Covisibility Graph）数据结构"></a>2 ORB-SLAM中关键帧之间的连接，共视图（Covisibility Graph）数据结构</h4><blockquote>
<ol>
<li>ORB-SLAM2中关键帧之间的连接是通过共视图（Covisibility Graph）和生成树（Spanning Tree）表达的。</li>
<li>共视图：是一个有权重的无向图，图的结点为一个关键帧，如果两个关键帧能共同观测到一定数量的地图点，那么这两个关键帧之间建立一条边，边的权重为共同观测到的地图数量。</li>
<li>生成树： 生成树是共视图的包含最少边的子图，每次向生成树添加一个关键帧时，将该关键帧与树中共视地图点数量最多的关键帧连接。从生成树中删除一个关键帧时，也要更新受到影响的所有关键帧的连接关系。</li>
<li><a href="https://sqn175.cn/2017/05/24/ORB-SLAM2局部映射.html" target="_blank" rel="noopener">参考</a><br><img src="https://img-blog.csdnimg.cn/20190930092325386.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
</blockquote>
<h4 id="3-关键帧在SLAM里应用非常多，很多知名的开源算法都使用了关键帧。请你用自己的语言描述一下关键帧是什么？有什么用？如何选择关键帧？"><a href="#3-关键帧在SLAM里应用非常多，很多知名的开源算法都使用了关键帧。请你用自己的语言描述一下关键帧是什么？有什么用？如何选择关键帧？" class="headerlink" title="3. 关键帧在SLAM里应用非常多，很多知名的开源算法都使用了关键帧。请你用自己的语言描述一下关键帧是什么？有什么用？如何选择关键帧？"></a>3. 关键帧在SLAM里应用非常多，很多知名的开源算法都使用了关键帧。请你用自己的语言描述一下关键帧是什么？有什么用？如何选择关键帧？</h4><blockquote>
<p>关键帧目前是一种非常常用的方法，可以减少待优化的帧数，并且可以代表其附近的帧。可以理解为一个学校里有100个班级，每个班的班长就是一个关键帧，他可以代表他班里的人，那么如何选取关键帧呢？</p>
<p>选取的指标主要有：</p>
<p>（1）距离上一关键帧的帧数是否足够多（时间）。比如我每隔固定帧数选择一个关键帧，这样编程简单但效果不好。比如运动很慢的时候，就会选择大量相似的关键帧，冗余，运动快的时候又丢失了很多重要的帧。</p>
<p>（2）距离最近关键帧的距离是否足够远（空间）/运动</p>
<p>比如相邻帧我根据pose计算运动的相对大小，可以是位移也可以是旋转或者两个都考虑，运动足够大（超过一定阈值）就新建一个关键帧，这种方法比第一种好。但问题是如果对着同一个物体来回扫就会出现大量相似关键帧。</p>
<p>（3）跟踪质量（主要根据跟踪过程中搜索到的点数和搜索的点数比例）/共视特征点</p>
<p>这种方法就是记录当前视角下的特征点数，或者视角，当相机离开当前场景时才会新建关键帧，避免了第2种方法的问题。缺点是比较复杂</p>
<p>打个比方，关键帧相当于slam的骨架，是在局部一系列普通帧中选出一帧作为局部帧的代表，记录局部信息。举例来说，摄像头放在原处不动，普通帧还是要记录的，但关键帧因为总看到原场景，所以不会增加。</p>
<p>三角化需要一定程度的共视区域，所以普通帧每2帧之间会存在大量的信息冗余，如果所有帧全部参与计算，不仅浪费了算力，对内存也是极大的考验，这一点在前端vo递归处理方式中表现不明显，但在后端优化里是一个大问题，所以关键帧主要作用是面向后端优化的算力与精度的折中。此外，关键帧选择时还会对图片质量、特征点质量等进行考察，一定程度上也发挥了滤波的作用，防止无用的或错误的信息进入优化过程而破坏定位建图的准确性。</p>
<p>选择关键帧主要从关键帧自身和关键帧与其他关键帧的关系2方面来考虑。一方面，关键帧自身质量要好，例如不能是非常模糊的图像、特征点数量要充足、特征点分布要尽量均匀等等；另一方面，关键帧与其他关键帧之间的关系，需要和局部地图中的其他关键帧有少量的共视关系，但大部分特征点是新特征点，以达到既存在约束，又尽量少的信息冗余的效果，例如局部地图点投影到此帧的点数低于一个阈值或前一个关键帧的特征点在此帧里已经有90%观测不到等等。</p>
<p>在关键帧的运用上，我认为orbslam做的非常好，尤其是在回环检测中使用了以关键帧为代表的帧“簇”的概念，回环筛选中有一步将关键帧前后10帧为一组，计算组内总分，以最高分的组的0.75为阈值，滤除一些组，再在剩下的组内各自找最高分的一帧作为备选帧，这个方法非常好地诠释了“关键帧代表局部”的这个理念。</p>
</blockquote>
<h2 id="三-初始化"><a href="#三-初始化" class="headerlink" title="三 初始化"></a>三 初始化</h2><p>初始化的意义是求取两个图像间的<strong>运动</strong>和特征点<strong>距离</strong>，初始化之后的运动都以初始化时的平移作为单位1，这称为单目的不确定性问题（Scale Ambiguity）。且在初始化时，要保证两帧图片之间的运动必须包括平移（不能只旋转），否则将导致求得的本质矩阵E为0，也就无法分解得到相机位姿。</p>
<h3 id="1-ORB-SLAM初始化的时候为什么要同时计算H矩阵和F矩阵？"><a href="#1-ORB-SLAM初始化的时候为什么要同时计算H矩阵和F矩阵？" class="headerlink" title="1. ORB-SLAM初始化的时候为什么要同时计算H矩阵和F矩阵？"></a>1. ORB-SLAM初始化的时候为什么要同时计算H矩阵和F矩阵？</h3><p>当特征点共面或相机间发生了纯旋转时，基础矩阵自由度下降，即发生了所谓的退化，此时如果仍采用八点法估算F矩阵，基础矩阵多出来的自由度将会由噪声决定，对结果造成极大误差。为避免退化现象造成的影响，通常会同时估计基础矩阵F和单应矩阵H，选择重投影误差较小的那个作为最终的运动估计矩阵。</p>
<h2 id="四-重定位"><a href="#四-重定位" class="headerlink" title="四 重定位"></a>四 重定位</h2><p>绑架问题就是<strong>重定位</strong>，是指机器人在缺少之前位置信息的情况下，如何去确定当前位姿。例如当机器人被安置在一个已经构建好地图的环境中，但是并不知道它在地图中的相对位置，或者在移动过程中，由<strong>于传感器的暂时性功能故障或相机的快速移动</strong>，都导致机器人先前的位置信息的丢失，在这种情况下如何重新确定自己的位置。</p>
<h2 id="五-ORB-SLAM2"><a href="#五-ORB-SLAM2" class="headerlink" title="五 ORB-SLAM2"></a>五 ORB-SLAM2</h2><h3 id="1-ORB-SLAM中的特征是如何提取的？如何均匀化的？"><a href="#1-ORB-SLAM中的特征是如何提取的？如何均匀化的？" class="headerlink" title="1. ORB-SLAM中的特征是如何提取的？如何均匀化的？"></a>1. ORB-SLAM中的特征是如何提取的？如何均匀化的？</h3><h3 id="2-ORB-SLAM在估计相机位姿时，为什么同时计算基础矩阵F和单应性矩阵H？"><a href="#2-ORB-SLAM在估计相机位姿时，为什么同时计算基础矩阵F和单应性矩阵H？" class="headerlink" title="2. ORB-SLAM在估计相机位姿时，为什么同时计算基础矩阵F和单应性矩阵H？"></a>2. ORB-SLAM在估计相机位姿时，为什么同时计算基础矩阵F和单应性矩阵H？</h3><p>当特征点共面或相机间发生了纯旋转时，基础矩阵自由度下降，即发生了所谓的退化，此时如果仍采用八点法估算F矩阵，基础矩阵多出来的自由度将会由噪声决定，对结果造成极大误差。为避免退化现象造成的影响，通常会同时估计基础矩阵F和单应矩阵H，选择重投影误差较小的那个作为最终的运动估计矩阵。</p>
<h2 id="六-视觉SLAM的问题"><a href="#六-视觉SLAM的问题" class="headerlink" title="六 视觉SLAM的问题"></a>六 视觉SLAM的问题</h2><h3 id="1-视觉SLAM存在的问题"><a href="#1-视觉SLAM存在的问题" class="headerlink" title="1. 视觉SLAM存在的问题"></a>1. 视觉SLAM存在的问题</h3><p>虽然双目和RGBD不存在初始化化和尺度漂移问题，但是视觉SLAM仍然存在很多共性问题。相机运动太快会导致图像模糊、相机视野不够会导致匹配特征点少、计算量太大（特征提取和匹配）、遮挡、特征缺失、动态物体或光源干扰等。</p>
<h3 id="2-尺度漂移问题"><a href="#2-尺度漂移问题" class="headerlink" title="2 尺度漂移问题"></a>2 尺度漂移问题</h3><p><strong>根本原因</strong>：单目slam产生尺度漂移的根本原因是单目相机无法根据一张图片得出图中物体的大小，这是尺度漂移的根源；在使用单目估计相机位姿和3D点坐标时，需要通过对极几何、三角化进行估计，在这个过程中会产生误差（特征点精度误差、计算误差），这些误差经过多帧累积后会变得特别大，进而导致尺度的不一致性，造成尺度漂移。<br><strong>解决办法</strong>：1、视觉与IMU融合，借助IMU测得的高帧率的角速度、加速度对视觉进行修正、补充；后端优化时，把尺度作为一个优化变量进行优化，可以减小尺度漂移问题。<br><strong>补充</strong>：由于初始化时存在尺度不确定性，因此单目相机估计的目标物体距离与真实世界里的距离存在比例上的差异，这个比例被称作尺度。而且，受到噪声的影响，导致这个尺度会逐渐漂移、改变，这被称为单目SLAM的尺度漂移问题。从理论上来说，只靠单目相机（不借助其他传感器）是无法确定这个尺度具体是多少的，比较好的解决方法是使用回环检测，但是要求相机的整个运动过程存在回环。</p>
<h4 id="单目视觉slam中尺寸漂移是怎么产生的"><a href="#单目视觉slam中尺寸漂移是怎么产生的" class="headerlink" title="单目视觉slam中尺寸漂移是怎么产生的"></a>单目视觉slam中尺寸漂移是怎么产生的</h4><p>单目相机根据一张图片<strong>无法得出一张图片中物体的实际大小</strong>，同理也就<strong>无法得出运动的尺度大小</strong>，这是产生尺度漂移的根源。而在优化过程中，单目相机使用对极几何中的三角测量原理求解深度信息，而三角测量中，<strong>极小的角度误差在累积之后深度不确定都会变得很大</strong>，从而无法保证尺度一致性。</p>
<h2 id="七-视觉惯性SLAM"><a href="#七-视觉惯性SLAM" class="headerlink" title="七 视觉惯性SLAM"></a>七 视觉惯性SLAM</h2><h3 id="什么是紧耦合、松耦合？优缺点。"><a href="#什么是紧耦合、松耦合？优缺点。" class="headerlink" title="什么是紧耦合、松耦合？优缺点。"></a>什么是紧耦合、松耦合？优缺点。</h3><ol>
<li>VIO是融合相机和IMU数据实现SLAM的算法，根据融合框架的区别又分为紧耦合和松耦合，松耦合中视觉运动估计和惯导运动估计系统是两个独立的模块，将每个模块的输出结果进行融合，而紧耦合则是使用两个传感器的原始数据共同估计一组变量，传感器噪声也是相互影响的，紧耦合算法上比较复杂，但充分利用了传感器数据，可以实现更好的效果，是目前研究的重点。</li>
<li>按照是否把图像的Feature加入到状态向量区分，也就是松耦合是在视觉和IMU各自求出的位姿的基础上做的耦合，紧耦合是使用图像和IMU耦合后的数据计算相机位姿。</li>
</ol>
<h1 id="八-其它传感器"><a href="#八-其它传感器" class="headerlink" title="八 其它传感器"></a>八 其它传感器</h1><h2 id="一-IMU"><a href="#一-IMU" class="headerlink" title="一 IMU"></a>一 IMU</h2><h3 id="1-IMU的优点"><a href="#1-IMU的优点" class="headerlink" title="1. IMU的优点"></a>1. IMU的优点</h3><blockquote>
<p>IMU能帮助单目确定尺度；<br>IMU能测量快速的运动；<br>IMU在相机被遮挡时亦能提供短时间的位姿估计；<br>视觉SLAM相邻两帧之间没有约束关系，优化误差函数是重投影误差；IMU增加了相邻帧之间的约束关系。</p>
</blockquote>
<h3 id="2-如何标定IMU与相机之间的外参数？"><a href="#2-如何标定IMU与相机之间的外参数？" class="headerlink" title="2. 如何标定IMU与相机之间的外参数？"></a>2. 如何标定IMU与相机之间的外参数？</h3><h2 id="二-GPS"><a href="#二-GPS" class="headerlink" title="二 GPS"></a>二 GPS</h2><h3 id="1、给你xx误差的GPS，给你xx误差的惯导你怎么得到一个cm级别的地图。"><a href="#1、给你xx误差的GPS，给你xx误差的惯导你怎么得到一个cm级别的地图。" class="headerlink" title="1、给你xx误差的GPS，给你xx误差的惯导你怎么得到一个cm级别的地图。"></a>1、给你xx误差的GPS，给你xx误差的惯导你怎么得到一个cm级别的地图。</h3><p>在给定一些有噪声的GPS信号的时候如何去精准的定位？</p>
<h2 id="三-其它"><a href="#三-其它" class="headerlink" title="三 其它"></a>三 其它</h2><p>一 除了视觉传感，还用过其他传感吗？比如GPS，激光雷达。</p>
<h1 id="九-通用库"><a href="#九-通用库" class="headerlink" title="九 通用库"></a>九 通用库</h1><h2 id="一-Eigen"><a href="#一-Eigen" class="headerlink" title="一 Eigen"></a>一 Eigen</h2><h3 id="矩阵赋值"><a href="#矩阵赋值" class="headerlink" title="矩阵赋值"></a>矩阵赋值</h3><p>按块赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">4</span>&gt; P;</span><br><span class="line">P.block(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>) = camera_pose[<span class="number">0</span>].Rwc;</span><br><span class="line"><span class="comment">// 前面两个数值是起点，后面两个数值是块的大小，此处是将3*3的Rwc赋值给P的前三列</span></span><br></pre></td></tr></table></figure>



<h3 id="动态矩阵"><a href="#动态矩阵" class="headerlink" title="动态矩阵"></a>动态矩阵</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">MatrixXd <span class="title">M</span><span class="params">(rows,cols)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="二-OpenCV"><a href="#二-OpenCV" class="headerlink" title="二 OpenCV"></a>二 OpenCV</h2><table>
<thead>
<tr>
<th>图像操作</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>直方图均衡化</td>
<td><code>equalizeHist( src, dst )</code></td>
</tr>
</tbody></table>
<h2 id="三-G2O"><a href="#三-G2O" class="headerlink" title="三 G2O"></a>三 G2O</h2><p>概念：<code>g2o</code>全称是什么？<code>g2o</code>是一个通用的图优化框架。<code>g2o</code>的核里带有各种各样的求解器，而它的顶点、边的类型则多种多样。通过自定义顶点和边，事实上，只要一个优化问题能够表达成图，那么就可以用<code>g2o</code>去求解它。常见的，比如bundle adjustment，<code>ICP</code>，数据拟合，都可以用<code>g2o</code>来做。</p>
<p>参考链接：<a href="https://www.cnblogs.com/gaoxiang12/p/5304272.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaoxiang12/p/5304272.html</a></p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>apps</strong></td>
<td>一些应用程序。好用的g2o_viewer就在这里。其他还有一些不常用的命令行工具等。</td>
</tr>
<tr>
<td><strong>core</strong></td>
<td>核心组件，很重要！基本的顶点、边、图结构的定义，算法的定义，求解器接口的定义在这里。</td>
</tr>
<tr>
<td>examples</td>
<td>一些例程，可以参照着这里的东西来写。不过注释不太多。</td>
</tr>
<tr>
<td>solvers</td>
<td>求解器的实现。主要来自choldmod, csparse。在使用g2o时要先选择其中一种。</td>
</tr>
<tr>
<td><strong>types</strong></td>
<td>各种顶点和边，很重要！我们用户在构建图优化问题时，先要想好自己的顶点和边是否已经提供了定义。如果没有，要自己实现。如果有，就用g2o提供的即可。</td>
</tr>
</tbody></table>
<h3 id="1-G2O的类结构"><a href="#1-G2O的类结构" class="headerlink" title="1 G2O的类结构"></a>1 G2O的类结构</h3><p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200815142336116.png" alt="image-20200815142336116"></p>
<p>​        先看上半部分。SparseOptimizer 是我们最终要维护的东东。它是一个Optimizable Graph，从而也是一个Hyper Graph（超图）。一个 SparseOptimizer 含有很多个顶点 （都继承自 Base Vertex）和很多个边（继承自 BaseUnaryEdge, BaseBinaryEdge或BaseMultiEdge）。这些 Base Vertex 和 Base Edge 都是抽象的基类，而实际用的顶点和边，都是它们的派生类。我们用 SparseOptimizer.addVertex 和 SparseOptimizer.addEdge 向一个图中添加顶点和边，最后调用 SparseOptimizer.optimize 完成优化。</p>
<p>　　在优化之前，需要指定我们用的求解器和迭代算法。从图中下半部分可以看到，一个 SparseOptimizer 拥有一个 Optimization Algorithm，继承自Gauss-Newton, Levernberg-Marquardt, Powell’s dogleg 三者之一（我们常用的是GN或LM）。同时，这个 Optimization Algorithm 拥有一个Solver，它含有两个部分。一个是 SparseBlockMatrix ，用于计算稀疏的雅可比和海塞； 一个是用于计算迭代过程中最关键的一步<br>$$<br>HΔx=−b<br>$$<br>这就需要一个线性方程的求解器。而这个求解器，可以从 PCG, CSparse, Choldmod 三者选一。</p>
<h3 id="2-G2O-优化方法的选择步骤："><a href="#2-G2O-优化方法的选择步骤：" class="headerlink" title="2 G2O 优化方法的选择步骤："></a>2 G2O 优化方法的选择步骤：</h3><ol>
<li>选择一个线性方程求解器，从 PCG, CSparse, Choldmod中选，实际则来自 g2o/solvers 文件夹中定义的东东。</li>
<li>选择一个 BlockSolver 。</li>
<li>选择一个迭代策略，从GN, LM, Dogleg中选。</li>
</ol>
<h3 id="3-G2O工程化的注意事项"><a href="#3-G2O工程化的注意事项" class="headerlink" title="3 G2O工程化的注意事项"></a>3 G2O工程化的注意事项</h3><h4 id="图优化流程："><a href="#图优化流程：" class="headerlink" title="图优化流程："></a>图优化流程：</h4><ol>
<li>选择节点和边，确定参数化形式</li>
<li>加入节点和边</li>
<li>选择初值，开始迭代</li>
<li>计算J和H</li>
<li>解H△x = -b</li>
<li>GN/LM</li>
<li>g2o需要实现其中的③-⑥</li>
</ol>
<h4 id="g2o"><a href="#g2o" class="headerlink" title="g2o"></a>g2o</h4><p>实现过程 ：选择节点和边<br>节点：g2o :: VertexSE3Expmap（相机位姿）g2o :: VertexSBApointXYZ（路标）<br>边：g2o :: EdgeProjectXYZ2UV（重投影误差）</p>
<h3 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BA Example</span></span><br><span class="line"><span class="comment"> * Author: Xiang Gao</span></span><br><span class="line"><span class="comment"> * Date: 2016.3</span></span><br><span class="line"><span class="comment"> * Email: gaoxiang12@mails.tsinghua.edu.cn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在这个程序中，我们读取两张图像，进行特征匹配。然后根据匹配得到的特征，计算相机运动以及特征点的位置。这是一个典型的Bundle Adjustment，我们用g2o进行优化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for std</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// for opencv</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/concept_check.hpp&gt;</span></span></span><br><span class="line"><span class="comment">// for g2o</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/sparse_optimizer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/robust_kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/robust_kernel_impl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/cholmod/linear_solver_cholmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/types/slam3d/se3quat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/types/sba/types_six_dof_expmap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找两个图像中的对应点，像素坐标系</span></span><br><span class="line"><span class="comment">// 输入：img1, img2 两张图像</span></span><br><span class="line"><span class="comment">// 输出：points1, points2, 两组对应的2D点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>     <span class="title">findCorrespondingPoints</span><span class="params">( <span class="keyword">const</span> cv::Mat&amp; img1, <span class="keyword">const</span> cv::Mat&amp; img2, <span class="built_in">vector</span>&lt;cv::Point2f&gt;&amp; points1, <span class="built_in">vector</span>&lt;cv::Point2f&gt;&amp; points2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机内参</span></span><br><span class="line"><span class="keyword">double</span> cx = <span class="number">325.5</span>;</span><br><span class="line"><span class="keyword">double</span> cy = <span class="number">253.5</span>;</span><br><span class="line"><span class="keyword">double</span> fx = <span class="number">518.0</span>;</span><br><span class="line"><span class="keyword">double</span> fy = <span class="number">519.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用格式：命令 [第一个图] [第二个图]</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Usage: ba_example img1, img2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取图像</span></span><br><span class="line">    cv::Mat img1 = cv::imread( argv[<span class="number">1</span>] );</span><br><span class="line">    cv::Mat img2 = cv::imread( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到对应点</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Point2f&gt; pts1, pts2;</span><br><span class="line">    <span class="keyword">if</span> ( findCorrespondingPoints( img1, img2, pts1, pts2 ) == <span class="literal">false</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"匹配点不够！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"找到了"</span>&lt;&lt;pts1.<span class="built_in">size</span>()&lt;&lt;<span class="string">"组对应特征点。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 构造g2o中的图</span></span><br><span class="line">    <span class="comment">// 先构造求解器</span></span><br><span class="line">    g2o::SparseOptimizer    optimizer;</span><br><span class="line">    <span class="comment">// 使用Cholmod中的线性方程求解器</span></span><br><span class="line">    g2o::BlockSolver_6_3::LinearSolverType* linearSolver = <span class="keyword">new</span>  g2o::LinearSolverCholmod&lt;g2o::BlockSolver_6_3::PoseMatrixType&gt; ();</span><br><span class="line">    <span class="comment">// 6*3 的参数</span></span><br><span class="line">    g2o::BlockSolver_6_3* block_solver = <span class="keyword">new</span> g2o::BlockSolver_6_3( linearSolver );</span><br><span class="line">    <span class="comment">// L-M 下降</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg* algorithm = <span class="keyword">new</span> g2o::OptimizationAlgorithmLevenberg( block_solver );</span><br><span class="line"></span><br><span class="line">    optimizer.setAlgorithm( algorithm );</span><br><span class="line">    optimizer.setVerbose( <span class="literal">false</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加节点</span></span><br><span class="line">    <span class="comment">// 两个位姿节点</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::VertexSE3Expmap* v = <span class="keyword">new</span> g2o::VertexSE3Expmap();</span><br><span class="line">        v-&gt;setId(i);</span><br><span class="line">        <span class="keyword">if</span> ( i == <span class="number">0</span>)</span><br><span class="line">            v-&gt;setFixed( <span class="literal">true</span> ); <span class="comment">// 第一个点固定为零</span></span><br><span class="line">        <span class="comment">// 预设值为单位Pose，因为我们不知道任何信息</span></span><br><span class="line">        v-&gt;setEstimate( g2o::SE3Quat() );</span><br><span class="line">        optimizer.addVertex( v );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 很多个特征点的节点</span></span><br><span class="line">    <span class="comment">// 以第一帧为准</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;pts1.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::VertexSBAPointXYZ* v = <span class="keyword">new</span> g2o::VertexSBAPointXYZ();</span><br><span class="line">        v-&gt;setId( <span class="number">2</span> + i );</span><br><span class="line">        <span class="comment">// 由于深度不知道，只能把深度设置为1了</span></span><br><span class="line">        <span class="keyword">double</span> z = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> x = ( pts1[i].x - cx ) * z / fx;</span><br><span class="line">        <span class="keyword">double</span> y = ( pts1[i].y - cy ) * z / fy;</span><br><span class="line">        v-&gt;setMarginalized(<span class="literal">true</span>);</span><br><span class="line">        v-&gt;setEstimate( Eigen::Vector3d(x,y,z) );</span><br><span class="line">        optimizer.addVertex( v );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备相机参数</span></span><br><span class="line">    g2o::CameraParameters* camera = <span class="keyword">new</span> g2o::CameraParameters( fx, Eigen::Vector2d(cx, cy), <span class="number">0</span> );</span><br><span class="line">    camera-&gt;setId(<span class="number">0</span>);</span><br><span class="line">    optimizer.<span class="built_in">addParameter</span>( camera );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备边</span></span><br><span class="line">    <span class="comment">// 第一帧</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;g2o::EdgeProjectXYZ2UV*&gt; edges;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;pts1.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::EdgeProjectXYZ2UV*  edge = <span class="keyword">new</span> g2o::EdgeProjectXYZ2UV();</span><br><span class="line">        edge-&gt;setVertex( <span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSBAPointXYZ*&gt;   (optimizer.vertex(i+<span class="number">2</span>)) );</span><br><span class="line">        edge-&gt;setVertex( <span class="number">1</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSE3Expmap*&gt;     (optimizer.vertex(<span class="number">0</span>)) );</span><br><span class="line">        edge-&gt;setMeasurement( Eigen::Vector2d(pts1[i].x, pts1[i].y ) );</span><br><span class="line">        edge-&gt;setInformation( Eigen::Matrix2d::Identity() );</span><br><span class="line">        edge-&gt;setParameterId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 核函数</span></span><br><span class="line">        edge-&gt;setRobustKernel( <span class="keyword">new</span> g2o::RobustKernelHuber() );</span><br><span class="line">        optimizer.addEdge( edge );</span><br><span class="line">        edges.push_back(edge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二帧</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;pts2.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::EdgeProjectXYZ2UV*  edge = <span class="keyword">new</span> g2o::EdgeProjectXYZ2UV();</span><br><span class="line">        edge-&gt;setVertex( <span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSBAPointXYZ*&gt;   (optimizer.vertex(i+<span class="number">2</span>)) );</span><br><span class="line">        edge-&gt;setVertex( <span class="number">1</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSE3Expmap*&gt;     (optimizer.vertex(<span class="number">1</span>)) );</span><br><span class="line">        edge-&gt;setMeasurement( Eigen::Vector2d(pts2[i].x, pts2[i].y ) );</span><br><span class="line">        edge-&gt;setInformation( Eigen::Matrix2d::Identity() );</span><br><span class="line">        edge-&gt;setParameterId(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 核函数</span></span><br><span class="line">        edge-&gt;setRobustKernel( <span class="keyword">new</span> g2o::RobustKernelHuber() );</span><br><span class="line">        optimizer.addEdge( edge );</span><br><span class="line">        edges.push_back(edge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"开始优化"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    optimizer.setVerbose(<span class="literal">true</span>);</span><br><span class="line">    optimizer.initializeOptimization();</span><br><span class="line">    optimizer.optimize(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"优化完毕"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们比较关心两帧之间的变换矩阵</span></span><br><span class="line">    g2o::VertexSE3Expmap* v = <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSE3Expmap*&gt;( optimizer.vertex(<span class="number">1</span>) );</span><br><span class="line">    Eigen::Isometry3d pose = v-&gt;estimate();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Pose="</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;pose.matrix()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以及所有特征点的位置</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;pts1.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::VertexSBAPointXYZ* v = <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSBAPointXYZ*&gt; (optimizer.vertex(i+<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"vertex id "</span>&lt;&lt;i+<span class="number">2</span>&lt;&lt;<span class="string">", pos = "</span>;</span><br><span class="line">        Eigen::Vector3d pos = v-&gt;estimate();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;pos(<span class="number">0</span>)&lt;&lt;<span class="string">","</span>&lt;&lt;pos(<span class="number">1</span>)&lt;&lt;<span class="string">","</span>&lt;&lt;pos(<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 估计inlier的个数</span></span><br><span class="line">    <span class="keyword">int</span> inliers = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> e:edges )</span><br><span class="line">    &#123;</span><br><span class="line">        e-&gt;computeError();</span><br><span class="line">        <span class="comment">// chi2 就是 error*\Omega*error, 如果这个数很大，说明此边的值与其他边很不相符</span></span><br><span class="line">        <span class="keyword">if</span> ( e-&gt;chi2() &gt; <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"error = "</span>&lt;&lt;e-&gt;chi2()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            inliers++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"inliers in total points: "</span>&lt;&lt;inliers&lt;&lt;<span class="string">"/"</span>&lt;&lt;pts1.<span class="built_in">size</span>()+pts2.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    optimizer.save(<span class="string">"ba.g2o"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>     <span class="title">findCorrespondingPoints</span><span class="params">( <span class="keyword">const</span> cv::Mat&amp; img1, <span class="keyword">const</span> cv::Mat&amp; img2, <span class="built_in">vector</span>&lt;cv::Point2f&gt;&amp; points1, <span class="built_in">vector</span>&lt;cv::Point2f&gt;&amp; points2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::ORB orb;</span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::KeyPoint&gt; kp1, kp2;</span><br><span class="line">    cv::Mat desp1, desp2;</span><br><span class="line">    orb( img1, cv::Mat(), kp1, desp1 );</span><br><span class="line">    orb( img2, cv::Mat(), kp2, desp2 );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"分别找到了"</span>&lt;&lt;kp1.<span class="built_in">size</span>()&lt;&lt;<span class="string">"和"</span>&lt;&lt;kp2.<span class="built_in">size</span>()&lt;&lt;<span class="string">"个特征点"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    cv::Ptr&lt;cv::DescriptorMatcher&gt;  matcher = cv::DescriptorMatcher::create( <span class="string">"BruteForce-Hamming"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> knn_match_ratio=<span class="number">0.8</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;cv::DMatch&gt; &gt; matches_knn;</span><br><span class="line">    matcher-&gt;knnMatch( desp1, desp2, matches_knn, <span class="number">2</span> );</span><br><span class="line">    <span class="built_in">vector</span>&lt; cv::DMatch &gt; matches;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;matches_knn.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matches_knn[i][<span class="number">0</span>].distance &lt; knn_match_ratio * matches_knn[i][<span class="number">1</span>].distance )</span><br><span class="line">            matches.push_back( matches_knn[i][<span class="number">0</span>] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matches.<span class="built_in">size</span>() &lt;= <span class="number">20</span>) <span class="comment">//匹配点太少</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> m:matches )</span><br><span class="line">    &#123;</span><br><span class="line">        points1.push_back( kp1[m.queryIdx].pt );</span><br><span class="line">        points2.push_back( kp2[m.trainIdx].pt );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四-Ceres"><a href="#四-Ceres" class="headerlink" title="四 Ceres"></a>四 Ceres</h2><h2 id="五-ROS"><a href="#五-ROS" class="headerlink" title="五 ROS"></a>五 ROS</h2><h2 id="六-DBOW"><a href="#六-DBOW" class="headerlink" title="六 DBOW"></a>六 DBOW</h2><h3 id="训练字典"><a href="#训练字典" class="headerlink" title="训练字典"></a>训练字典</h3><p>实际 BoW 使用时,字典往往是从更大的数据集中生成的,而且最好是来自目标应该环境类似的地方。我们通常使用较大规模的字典——越大代表字典单词量越丰富,容易找到与当前图像对应的单词,但也不能大到超过我们计算能力和内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read the image</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"reading images... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt; images;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">string</span> path = <span class="string">"./data/"</span>+to_string(i+<span class="number">1</span>)+<span class="string">".png"</span>;</span><br><span class="line">    images.push_back( imread(path) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// detect ORB features</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"detecting ORB features ... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Ptr&lt; Feature2D &gt; detector = ORB::create();</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt; descriptors;</span><br><span class="line">    <span class="keyword">for</span> ( Mat&amp; <span class="built_in">image</span>:images )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints;</span><br><span class="line">    Mat descriptor;</span><br><span class="line">    detector-&gt;detectAndCompute( <span class="built_in">image</span>, Mat(), keypoints, descriptor );</span><br><span class="line">    descriptors.push_back( descriptor );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create vocabulary</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"creating vocabulary ... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    DBoW3::Vocabulary vocab;</span><br><span class="line">    vocab.create( descriptors );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"vocabulary info: "</span>&lt;&lt;vocab&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    vocab.save( <span class="string">"vocabulary.yml.gz"</span> );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"done"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DBoW3 的使用方式非常容易。我们对十张目标图像提取 ORB 特征并存放至 vector容器中,然后调用 DBoW3 的字典生成接口即可。在 DBoW3::Vocabulary 对象的构造函数中,我们能够指定树的分叉数量以及深度,不过这里使用了默认构造函数,也就是 k =10, d = 5。这是一个小规模的字典,最大能容纳 10000 个单词。对于图像特征,我们亦使用默认参数,即每张图像 500 个特征点。最后我们把字典存储为一个压缩文件。</p>
<h1 id="十-开放问题"><a href="#十-开放问题" class="headerlink" title="十 开放问题"></a>十 开放问题</h1><h2 id="一-自己的项目"><a href="#一-自己的项目" class="headerlink" title="一 自己的项目"></a>一 自己的项目</h2><h3 id="1-你做的工作在本质上有什么不同，贡献，创新本质上在哪里？"><a href="#1-你做的工作在本质上有什么不同，贡献，创新本质上在哪里？" class="headerlink" title="1. 你做的工作在本质上有什么不同，贡献，创新本质上在哪里？"></a>1. 你做的工作在本质上有什么不同，贡献，创新本质上在哪里？</h3><ol>
<li>给定几个连续帧的带有位姿的帧，如何去测量车道线相对于世界坐标系的坐标。</li>
<li>给一张图片，知道相机与地面之间的相对关系，计算出图的俯视图。</li>
</ol>
<h3 id="2-说一个自己熟悉的SLAM算法，Lidar-Visual-slam，说优缺点。"><a href="#2-说一个自己熟悉的SLAM算法，Lidar-Visual-slam，说优缺点。" class="headerlink" title="2. 说一个自己熟悉的SLAM算法，Lidar/Visual slam，说优缺点。"></a>2. 说一个自己熟悉的SLAM算法，Lidar/Visual slam，说优缺点。</h3><h3 id="3-说一下VINS-Mono的优缺点"><a href="#3-说一下VINS-Mono的优缺点" class="headerlink" title="3. 说一下VINS-Mono的优缺点"></a>3. 说一下VINS-Mono的优缺点</h3><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h3><h2 id="二-设计系统"><a href="#二-设计系统" class="headerlink" title="二 设计系统"></a>二 设计系统</h2><p>机器人从超市门口出发，前往3公里外的小区送货。请你设计一个定位系统，包括传感器的配置、算法的流程，用伪代码写出来。</p>
<h2 id="三-其他问题"><a href="#三-其他问题" class="headerlink" title="三 其他问题"></a>三 其他问题</h2><h3 id="你还有什么问题？"><a href="#你还有什么问题？" class="headerlink" title="你还有什么问题？"></a>你还有什么问题？</h3><p>可以从以下方面进行提问：(1) 部门(2) 业务范围(3) 培养方式(4) 工作模式(5) 后续通知时间</p>
<h4 id="你的缺点"><a href="#你的缺点" class="headerlink" title="你的缺点"></a>你的缺点</h4><ol>
<li>喜欢熬夜</li>
</ol>
<h2 id="四-SLAM行业相关问题"><a href="#四-SLAM行业相关问题" class="headerlink" title="四 SLAM行业相关问题"></a>四 SLAM行业相关问题</h2><h4 id="1-大家都是SLAM方向的研究者，不管是学生还是已经工作，以后都面临找（换）工作的问题，那么你知道哪些做SLAM技术的公司？"><a href="#1-大家都是SLAM方向的研究者，不管是学生还是已经工作，以后都面临找（换）工作的问题，那么你知道哪些做SLAM技术的公司？" class="headerlink" title="1. 大家都是SLAM方向的研究者，不管是学生还是已经工作，以后都面临找（换）工作的问题，那么你知道哪些做SLAM技术的公司？"></a>1. 大家都是SLAM方向的研究者，不管是学生还是已经工作，以后都面临找（换）工作的问题，那么你知道哪些做SLAM技术的公司？</h4><h4 id="2-讨论一下SLAM应用场景及落地的问题。大家觉得SLAM技术最适合的应用场景是什么？在哪个场景能够最快技术落地呢？"><a href="#2-讨论一下SLAM应用场景及落地的问题。大家觉得SLAM技术最适合的应用场景是什么？在哪个场景能够最快技术落地呢？" class="headerlink" title="2. 讨论一下SLAM应用场景及落地的问题。大家觉得SLAM技术最适合的应用场景是什么？在哪个场景能够最快技术落地呢？"></a>2. 讨论一下SLAM应用场景及落地的问题。大家觉得SLAM技术最适合的应用场景是什么？在哪个场景能够最快技术落地呢？</h4><h1 id="十一-大疆笔试题"><a href="#十一-大疆笔试题" class="headerlink" title="十一 大疆笔试题"></a>十一 大疆笔试题</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><ol>
<li><p>以下哪一种情况，可以认为双目视觉系统内参和双目间的相对旋转标定正确</p>
<p>A. 计算标定时采集的pattern重投影误差，数值相对较小</p>
<p>B. 使用双目拍摄远处的雪山，无论怎么移动相机，在recify图像上，雪山在左右成像位置相同，但亮度差异较大</p>
<p>C. 使用双目拍摄远处的车辆，无论怎么移动相机，在recify图像上，车辆在左右成像尽在x方向有disparity；</p>
<p>D. 使用双目拍摄远处的彩虹，无论怎么移动相机，在recify图像上，彩虹在左右成像的亮度没有差异</p>
</li>
</ol>
<p>   答：C</p>
<ol start="2">
<li><p>以下哪些相机模型不适用与FOV约180度鱼眼相机投影关系（r为像高，f为焦距，$\theta$为光线到光心的理想入射角）</p>
<p>A.  针孔相机模型 像高表示为$r=f\tan(\theta)$</p>
<p>B.  等距投影模型 像高表示为$r=f\theta$</p>
<p>C.  等立体角投影 像高表示为$r=2 f\sin(\theta)$</p>
<p>D.  正交投影模型 像高表示为$r=f\sin(\theta)$</p>
</li>
</ol>
<ol start="3">
<li><p>以下哪些做法有助于神经网络过拟合</p>
<p>A. 使用更深的网络以提升泛华性</p>
<p>B. 进行数据增强以增加数据的多样性</p>
<p>C. 加入dropout模块以增加训练过程的随机性</p>
<p>D. 使用leaky relu 取代relu避免特征损失过多</p>
<p>答：BCD </p>
</li>
</ol>
<ol start="4">
<li><p>以下哪些手段可以提升重复纹理环境的定位感知能力</p>
<p>A.  调整SGBM的参数，增大平滑项的权重</p>
<p>B.  VIO后端增加robust norm 降低feature误匹配带来的误差</p>
<p>C. 对原图进行高斯滤波，降低重复纹理的梯度</p>
<p>D. 对depth增加时域的滤波，降低depth误匹配的影响</p>
<p>答：获取更多的训练数据;    减小网络容量; 添加权重正则化;  添加dropout.</p>
</li>
</ol>
<h2 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h2><ol>
<li><p>SIFT是图像的全局特征，具有尺度不变和旋转不变性（错）</p>
</li>
<li><p>训练卷积神经网络时，可以对输入进行旋转、平移、缩放、翻转等预处理提高模型泛化能力（对）</p>
</li>
<li><p>Hough变换可以用来在图像中进行形状提取（）</p>
</li>
<li><p>牛顿迭代法的基本思想是使用泰勒技术展开式去近似地代替非线性回归函数，然后通过多次迭代，多次修正回归系数，使回归系数不断逼近非线性回归模型的最佳系数，最后使原模型的残差平方和达到最小（）</p>
</li>
</ol>
<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><p>一：</p>
<p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200818000618164.png" alt="image-20200818000618164"></p>
<p>二： 卡尔曼滤波</p>
<p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200818000645583.png" alt="image-20200818000645583"></p>
<p>三 </p>
<p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200818000939557.png" alt="image-20200818000939557"></p>
<h1 id="面试经历"><a href="#面试经历" class="headerlink" title="面试经历"></a>面试经历</h1><h2 id="一-美团"><a href="#一-美团" class="headerlink" title="一 美团"></a>一 美团</h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>VIO</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM-三维空间刚体运动</title>
    <url>/2020/08/06/SLAM-%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>刚体运动</tag>
        <tag>李群</tag>
        <tag>四元数</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM概述</title>
    <url>/2020/08/06/SLAM%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>SLAM首先要解决自主运动的两大基本问题</p>
<ol>
<li>我在什么地方？——定位</li>
<li>周围环境是什么子？——建图</li>
</ol>
<p>SLAM与定位与建图又有着联系：内外兼修 ；定位侧重对自身的了解，建图侧重对外在的了解；它与两者又相互关联；准确的定位需要精确的地图；精确的地图来自准确的定位。</p>
<a id="more"></a>

<h2 id="视觉SLAM框架"><a href="#视觉SLAM框架" class="headerlink" title="视觉SLAM框架"></a>视觉SLAM框架</h2><p>经典的视觉SLAM主要包含以下部分</p>
<ol>
<li>前端：Visual Odometry</li>
<li>后端：Optimization</li>
<li>回环：Loop Closing</li>
<li>建图：Mapping</li>
</ol>
<p>其中，<strong>视觉里程计</strong>用来估计邻近时刻的相机运动。最简化的形式就是：估计两个图像的相对运动。采用的方法有特征点法和直接法两部分；<strong>后端</strong>则用来从带有噪声的数据中估计最优轨迹与地图，涉及到的最大后验概率估计部分可以分为滤波器和图优化两类。<strong>回环检测</strong>是用来检测相机是否到达过之前位置，主要通过计算图像间相似性来判断与之前位置的差异，需要用到词袋模型。<strong>建图</strong>涉及到导航、规划、通讯、交互、可视化等内容，最后需要构建度量地图、拓扑地图、稀疏地图、稠密地图等。度量地图强调精确地表示地图中物体的位置关系，通常用稀疏（Sparse）与稠密（Dense）对其分类。稀疏地图进行了一定程度的抽象，并不需要表达所有的物体。相对地，稠密地图着重于建模所有看到的东西。相比于度量地图的精确性，拓扑地图则更强调地图元素之间的关系。拓扑地图是一个图（Graph），由节点和边组成，只考虑节点间的连通性。</p>
<h4 id="数学描述"><a href="#数学描述" class="headerlink" title="数学描述"></a>数学描述</h4><p>视觉SLAM可以通过以下两个方程进行数学描述：<br>运动方程：$x_{k+1}= f(x_k, u_k,w_k)$<br>观测方程：$z_{k,j} = h(x_k, y_j,w_{k,j})$</p>
<p>为了解决这个问题，需要解决一下三个问题：</p>
<ol>
<li>位置是三维的，如何表述？一一第2、3次课</li>
<li>观测模型如何表述？一一第4次课</li>
<li>已知u,z时，如何推断x,y？一第5次课以后</li>
</ol>
<p>SLAM用到的<strong>传感器</strong>是机器人感知外界环境的手段。大致可以分为内质和外质两类。其中，内质传感器是用来感受机器人本体信息，比如：加速度计、陀螺仪、编码器等；外质传感器是用来感受测量外界的信息。比如：相机、激光、导轨、磁条等；环境限制了一些传感器的形式。比如 GPS：需要能接收到卫星信号的环境；Marker、导轨：需要环境允许安装 相比之下，激光、相机等携带式传感器更加自由。</p>
<h4 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h4><p>概念：以一定速率采集图像、形成视频（24hz/30hz）<br>分类：相机的主要分类有：1. 单目相机 Monocular；2. 双目相机（立体相机） Stereo；3. 深度相机RGB-D ；4.其他全景相机、 Event Camera。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>相机以二维投影形式记录了三维世界的信息。该过程丢掉了一个维度：距离。<br>各类相机的区别</p>
<ol>
<li>单目：无深度深度需要其他手段估计</li>
<li>双目：通过视差计算深度</li>
<li>RGB-D：通过物理方法测量深度</li>
</ol>
<p>当相机运动时，可通过视差确定深度，深度即第三维信息，对SLAM来说至关重要。</p>
<h2 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h2><h3 id="一-熟悉Linux"><a href="#一-熟悉Linux" class="headerlink" title="一 熟悉Linux"></a>一 熟悉Linux</h3><h4 id="1-如何在Ubuntu-中安装软件（命令行界面）？它们通常被安装在什么地方？"><a href="#1-如何在Ubuntu-中安装软件（命令行界面）？它们通常被安装在什么地方？" class="headerlink" title="1. 如何在Ubuntu 中安装软件（命令行界面）？它们通常被安装在什么地方？"></a>1. 如何在Ubuntu 中安装软件（命令行界面）？它们通常被安装在什么地方？</h4><p>Ubuntu 可通过如下命令安装库</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo apt-get install package</span><br></pre></td></tr></table></figure>

<p>通过apt方式安装的库一般被安装在目录<code>usr/lib</code>或者<code>usr/include</code>中。</p>
<p><em>补充：</em></p>
<p>下载的软件存放位置: <code>/var/cache/apt/archives</code><br>安装后软件默认位置: <code>/usr/share</code><br>可执行文件位置: <code>/usr/bin</code><br>配置文件位置: <code>/etc</code><br>lib文件位置: <code>/usr/lib</code></p>
<h4 id="2-linux-的环境变量是什么？我如何定义新的环境变量？"><a href="#2-linux-的环境变量是什么？我如何定义新的环境变量？" class="headerlink" title="2. linux 的环境变量是什么？我如何定义新的环境变量？"></a>2. linux 的环境变量是什么？我如何定义新的环境变量？</h4><p>环境变量用来定义每个用户的操作环境。linux环境变量和Windows的环境变量一样，分系统环境变量和用户环境变量，系统环境变量对所有用户有效，而用户环境变量只对当前用户有效。</p>
<p>以路径<code>$PATH:/opt/au1200_rm/build_tools/bin</code>为例，定义环境变量的方法如下：</p>
<p>方法一：<strong>用export命令，</strong></p>
<ol>
<li>输入<code>“export PATH=&quot;$PATH:/opt/au1200_rm/build_tools/bin”</code>。</li>
</ol>
<p>方法二：<strong>修改profile文件</strong>，</p>
<ol>
<li>输入<code>sudo gedit /etc/profile</code>，回车;</li>
<li>再输入<code>“export PATH=&quot;$PATH:/opt/au1200_rm/build_tools/bin”</code>。</li>
</ol>
<p>方法三：<strong>修改.bashrc文件</strong>，</p>
<ol>
<li>输入<code>sudo gedit /root/.bashrc</code>，回车。</li>
<li>再输入<code>“export PATH=&quot;$PATH:/opt/au1200_rm/build_tools/bin”</code>。</li>
</ol>
<p>​                </p>
<h4 id="3-linux-根目录下面的目录结构是什么样的？至少说出3-个目录的用途"><a href="#3-linux-根目录下面的目录结构是什么样的？至少说出3-个目录的用途" class="headerlink" title="3. linux 根目录下面的目录结构是什么样的？至少说出3 个目录的用途"></a>3. linux 根目录下面的目录结构是什么样的？至少说出3 个目录的用途</h4><p>Linux根目录结构及用途</p>
<ol>
<li><strong>bin 目录</strong>：此目录存放所有二进制命令（用户）</li>
<li><strong>boot目录</strong>：Linux内核及引导系统程序所需的目录</li>
<li><strong>dev目录</strong>：所有设备文件的目录（如声卡、磁盘、光驱）</li>
<li><strong>etc目录</strong>：二进制安装包（yum，rpm）配置文件默认路径，服务启动命令存放目录</li>
<li><strong>lib目录</strong>：库文件存放目录</li>
<li><strong>home目录</strong>：普通用户的家目录默认数据存放目录</li>
<li><strong>opt目录</strong>：自定义软件安装存放目录，用户自行安装的软件包存放目录。</li>
<li><strong>lost+found目录</strong>：在EXT3系统中，当系统意外崩溃或意外关机时，会产生一些碎片文件在这个目录下面，系统启动fcsk工具会检查这个目录，并修复已损坏的文件系统。</li>
<li><strong>mnt目录</strong>：用于临时挂载存储设备，通常情况下可以挂载LINUX ISO光盘进行无网条件下的安装其他软件包</li>
<li><strong>proc目录</strong>：进程及内核信息存放目录</li>
<li><strong>root目录</strong>：管理的家目录 </li>
<li><strong>sbin目录</strong>：系统管理员命令存放的目录（超级管理员使用的命令） </li>
<li><strong>tmp目录</strong>：临时文件目录，程序运行时产生的临时文件存放目录</li>
<li><strong>usr目录</strong>：系统存放程序的目录（命令和帮助文件）</li>
</ol>
<h4 id="4-假设我要给a-sh-加上可执行权限，该输入什么命令？"><a href="#4-假设我要给a-sh-加上可执行权限，该输入什么命令？" class="headerlink" title="4. 假设我要给a.sh 加上可执行权限，该输入什么命令？"></a>4. 假设我要给a.sh 加上可执行权限，该输入什么命令？</h4><p>为一个文件添加可执行权限</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">chmod +x a.sh</span><br></pre></td></tr></table></figure>

<p>*：为一个文件夹下的所有文件添加可执行权限</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">chmod +x *</span><br></pre></td></tr></table></figure>



<h4 id="5-假设我要将a-sh文件的所有者改成xiang-xiang，该输入什么命令？"><a href="#5-假设我要将a-sh文件的所有者改成xiang-xiang，该输入什么命令？" class="headerlink" title="5. 假设我要将a.sh文件的所有者改成xiang:xiang，该输入什么命令？"></a>5. 假设我要将a.sh文件的所有者改成xiang:xiang，该输入什么命令？</h4><p>可利用如下命令：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo chown -R  username:groupname  filename</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p>sudo：管理员权限</p>
<p>chown ：修改文件所有者和组别</p>
<p>-R ：递归文件夹内部的所有文件及文件夹</p>
<p>username：目标所有者名称</p>
<p>groupname：组名</p>
<p>filename：文件或文件夹名称</p>
<p><strong>答案：</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo chown -R xiang:xiang a.sh</span><br></pre></td></tr></table></figure>



<h3 id="二-SLAM综述文献阅读"><a href="#二-SLAM综述文献阅读" class="headerlink" title="二 SLAM综述文献阅读"></a>二 SLAM综述文献阅读</h3><h4 id="1-SLAM-会在哪些场合中用到？至少列举三个方向"><a href="#1-SLAM-会在哪些场合中用到？至少列举三个方向" class="headerlink" title="1. SLAM 会在哪些场合中用到？至少列举三个方向"></a>1. SLAM 会在哪些场合中用到？至少列举三个方向</h4><p>答：SLAM在以下方向可能会有非常大的用处</p>
<ol>
<li><strong>增强现实应用</strong>: AR通过电脑技术，将虚拟的信息应用到真实世界，真实的环境和虚拟的物体实时地叠加到了同一个画面或空间同时存在。这一画面的实现，离不开SLAM技术的实时定位。虽然在AR行业有很多可代替技术，但SLAM技术是最理想的定位导航技术。相较于SLAM在机器人、无人驾驶等领域的应用，在AR行业的应用则有很多不同点。<ul>
<li>精度：AR一般更关注于局部精度，要求恢复的相机运动避免出现漂移、抖动，这样叠加的虚拟物体才能看起来与现实场景真实地融合在一起。但在机器人和无人驾驶领域则一般更关注全局精度，需要恢复的整条运动轨迹误差累积不能太大，循环回路要能闭合，而在某个局部的漂移、 抖动等问题往往对机器人应用来说影响不大。</li>
<li>效率：AR需要在有限的计算资源下实时求解，人眼的刷新率为24帧，所以AR的计算效率通常需要到达30帧以上; 机器人本身运动就很慢，可以把帧率降低，所以对算法效率的要求相对较低。</li>
<li>配置：AR对硬件的体积、功率、成本等问题比机器人更敏感，比如机器人上可以配置鱼眼、双目或深度摄像头、高性能CPU等硬件来降低SLAM的难度，而AR应用更倾向于采用更为高效、鲁棒的算法达到需求。</li>
</ul>
</li>
<li><strong>无人机</strong>: 无人机在飞行的过程中需要知道哪里有障碍物，该怎么规避，怎么重新规划路线。显然，这是SLAM技术的应用。但无人机飞行的范围较大，所以对精度的要求不高，市面上其他的一些光流、超声波传感器可以作为辅助。</li>
<li><strong>自动驾驶</strong>: 随着城市物联网和智能系统的完善，无人驾驶必是大势所趋。无人驾驶利用激光雷达传感器（Velodyne、IBEO等）作为工具，获取地图数据，并构建地图，规避路程中遇到的障碍物，实现路径规划。跟SLAM技术在机器人领域的应用类似，只是相比较于SLAM在机器人中的应用，无人驾驶的雷达要求和成本要明显高于机器人。</li>
<li><strong>机器人:</strong> 激光+SLAM是目前机器人自主定位导航所使用的主流技术。激光测距相比较于图像和超声波测距，具有良好的指向性和高度聚焦性，是目前最可靠、稳定的定位技术。激光雷达传感器获取地图信息，构建地图，实现路径规划与导航。机器人可以应用的地方很多，比如配送机器人，探索机器人等。</li>
<li>*<em>智能家居: *</em>近年来，智能家居的发展使得我们的居家生活变得更加充满乐趣与效率。对于智能清扫机器人这类室内移动型机器人而言，机器人自主定位和对周边环境的识别是其高效工作的根本。利用激光或相机进行SLAM在只能家居机器人上有很大的应用空间。</li>
</ol>
<h4 id="2-SLAM-中定位与建图是什么关系？为什么在定位的同时需要建图？"><a href="#2-SLAM-中定位与建图是什么关系？为什么在定位的同时需要建图？" class="headerlink" title="2. SLAM 中定位与建图是什么关系？为什么在定位的同时需要建图？"></a>2. SLAM 中定位与建图是什么关系？为什么在定位的同时需要建图？</h4><p>答：SLAM全称是simultaneous localization and mapping（即时定位与建图）。假设了机器人从未知环境中的未知地点出发，在运动过程中通过重复观测到的地图特征（比如，墙角，柱子等）定位自身位置和姿态，再根据自身位置增量式的构建地图，从而达到同时定位和地图构建的目的。</p>
<p><strong>定位与建图的关系</strong></p>
<p>整个SLAM过程中，移动机器人一方面要明白自身的状态（即定位），另一方面又需要了解外在的环境（即建图）。两者紧密相关。建图的准确性依赖于定位精度，而定位的实现又离不开精确的建图。</p>
<p><strong>为什么定位的同时需要建图</strong></p>
<p>答：SLAM强调在未知环境下进行整个过程，如果在未知环境下进行定位，首先需要能够识别并理解周围的环境。再利用环境中的外部信息作为定位的基准，所以需要对所处的环境进行建图。</p>
<h4 id="3-SLAM-发展历史如何？我们可以将它划分成哪几个阶段？"><a href="#3-SLAM-发展历史如何？我们可以将它划分成哪几个阶段？" class="headerlink" title="3. SLAM 发展历史如何？我们可以将它划分成哪几个阶段？"></a>3. SLAM 发展历史如何？我们可以将它划分成哪几个阶段？</h4><p>答：<strong>SLAM发展历史</strong></p>
<p>SLAM最早由Smith、Self和Cheeseman于1988年提出。 由于其重要的理论与应用价值，被很多学者认为是实现真正全自主移动机器人的关键。在文献2（Past, Present, and Future of Simultaneous Localization And Mapping: Towards the Robust-Perception Age）中，根据Durrant-Whyte和Bailey在两篇综述中对SLAM的前20年历史进行的详尽回顾。SLAM的发展可以大致分为三个阶段：</p>
<ol>
<li><p><strong>朴素时期：classical age</strong>（1986-2004）。classical age出现了SLAM最基本的概率公式，包括基于扩展卡尔曼滤波器(EKF)，Rao-Blackwellised粒子滤波器和最大似然估计的方法。此外，它还剔除了与效率以及鲁棒数据等相关的基本问题，这也是日后的发展方向。</p>
</li>
<li><p><strong>算法分析时期：algorithmic-analysis age</strong>（2004-2015），这一时期研究了SLAM的基本特性，包括可观察性，收敛性，一致性以及稀疏性对SLAM高效求解的关键作用，主要的开源SLAM库在这个时期得到了开发。</p>
</li>
<li><p><strong>鲁棒性-预测性时代: ** **robust-perception</strong>（2015-至今）：这一时期主要探索SLAM在位置环境中对鲁棒性、高级别的场景理解，计算资源优化，任务驱动的环境感知等。</p>
<p>视觉SLAM是在传统SLAM的基础上发展起来的，早期的视觉SLAM多采用扩展卡尔曼滤波等手段来优化相机位姿的估计和地图构建的准确性，后期随着计算能力的提升及算法的改进，BA优化、位姿优化等手段逐渐成为主流。随着人工智能技术的普及，基于深度学习的SLAM越来越受到研究者的关注。</p>
</li>
</ol>
<h4 id="4-列举三篇在SLAM-领域的经典文献。"><a href="#4-列举三篇在SLAM-领域的经典文献。" class="headerlink" title="4. 列举三篇在SLAM 领域的经典文献。"></a>4. 列举三篇在SLAM 领域的经典文献。</h4><ol start="0">
<li><p>On the Representation and Estimation of Spatial Uncertainty[0]: 公认的SLAM开山之作</p>
</li>
<li><p>MonoSLAM[1]: real-time single camera SLAM[1]：第一个实时的单目视觉SLAM系统</p>
</li>
<li><p>ORB-SLAM2[2]: 当前应用最多基于优化的视觉SLAM方法，系统框架非常完善</p>
</li>
<li><p>MSCKF[3]: 基于滤波的视觉SLAM方法，由于优秀的计算量和精度得到了实际应用（AR Kit）</p>
</li>
</ol>
<p>[0] Randall, C, Smith,等. On the Representation and Estimation of Spatial Uncertainty[J]. The International Journal of Robotics Research, 1986.</p>
<p>[1] Davison A J , Reid I D , Molton N D , et al. MonoSLAM: real-time single camera SLAM[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2007, 29(6):1052-1067.</p>
<p>[2] Mur-Artal R , Tardos J D . ORB-SLAM2: an Open-Source SLAM System for Monocular, Stereo and RGB-D Cameras[J]. IEEE Transactions on Robotics, 2016, 33(5):1255-1262.</p>
<p>[3]Mourikis, Anastasios /I, Roumeliotis, Stergios /I. A Multi-State Constraint Kalman Filter for Vision-aided Inertial Navigation[C]// IEEE International Conference on Robotics &amp; Automation. IEEE, 2007.</p>
<h3 id="三-CMake-练习"><a href="#三-CMake-练习" class="headerlink" title="三. CMake 练习"></a>三. CMake 练习</h3><p>书写⼀个由 <code>cmake</code> 组织的 C++ ⼯程，要求如下：</p>
<ol>
<li>include/hello.h 和 src/hello.c 构成了 libhello.so 库。hello.c 中提供⼀个函数 sayHello()，调⽤此函数时往屏幕输出⼀⾏“Hello SLAM”。我们已经为你准备了 hello.h 和 hello.c 这两个⽂件，见“code/” ⽬录下。</li>
<li>⽂件 useHello.c 中含有⼀个 main 函数，它可以编译成⼀个可执⾏⽂件，名为“sayhello”。</li>
<li>默认⽤ Release 模式编译这个⼯程。</li>
<li>如果⽤户使⽤ sudo make install，那么将 hello.h 放⾄/usr/local/include/下，将 libhello.so 放⾄/usr/local/lib/下。请按照上述要求组织源代码⽂件，并书写CMakeLists.txt。</li>
</ol>
<p>答：CMakeList内容如下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>.<span class="number">0</span> )</span><br><span class="line"><span class="keyword">PROJECT</span>(HELLO )</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_BUILD_TYPE <span class="string">"Release"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"-std=c++11"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(src)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(usehello useHello.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(usehello HELLO)</span><br></pre></td></tr></table></figure>





<h3 id="五-理解ORB-SLAM2-框架"><a href="#五-理解ORB-SLAM2-框架" class="headerlink" title="五. 理解ORB-SLAM2 框架"></a>五. 理解ORB-SLAM2 框架</h3><h4 id="1-从github-com-下载ORB-SLAM2-的代码。"><a href="#1-从github-com-下载ORB-SLAM2-的代码。" class="headerlink" title="1. 从github.com 下载ORB-SLAM2 的代码。"></a>1. 从github.com 下载ORB-SLAM2 的代码。</h4><p>地址在：<a href="https://github.com/raulmur/ORB_SLAM2" target="_blank" rel="noopener">https://github.com/raulmur/ORB_SLAM2</a>.<br>提示：在安装git 之后，可以⽤git clone <a href="https://github.com/raulmur/ORB_SLAM2" target="_blank" rel="noopener">https://github.com/raulmur/ORB_SLAM2</a> 命令下载<br>ORB-SLAM2。下载完成后，请给出终端截图。</p>
<p>![image-20200522170310934](D:\我的坚果云\视觉SLAM\第一节 概述与预备知识\image\下载ORBSLAM.png)</p>
<h4 id="2-阅读ORB-SLAM2-代码目录下的CMakeLists-txt，回答问题："><a href="#2-阅读ORB-SLAM2-代码目录下的CMakeLists-txt，回答问题：" class="headerlink" title="2. 阅读ORB-SLAM2 代码目录下的CMakeLists.txt，回答问题："></a>2. 阅读ORB-SLAM2 代码目录下的CMakeLists.txt，回答问题：</h4><h5 id="a-ORB-SLAM2-将编译出什么结果？有几个库文件和可执行文件？"><a href="#a-ORB-SLAM2-将编译出什么结果？有几个库文件和可执行文件？" class="headerlink" title="(a) ORB-SLAM2 将编译出什么结果？有几个库文件和可执行文件？"></a>(a) ORB-SLAM2 将编译出什么结果？有几个库文件和可执行文件？</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(ORB_SLAM2)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> SHARED</span><br><span class="line">src/System.cc</span><br><span class="line">src/Tracking.cc</span><br><span class="line">src/LocalMapping.cc</span><br><span class="line">src/LoopClosing.cc</span><br><span class="line">src/ORBextractor.cc</span><br><span class="line">src/ORBmatcher.cc</span><br><span class="line">src/FrameDrawer.cc</span><br><span class="line">src/Converter.cc</span><br><span class="line">src/MapPoint.cc</span><br><span class="line">src/KeyFrame.cc</span><br><span class="line">src/Map.cc</span><br><span class="line">src/MapDrawer.cc</span><br><span class="line">src/Optimizer.cc</span><br><span class="line">src/PnPsolver.cc</span><br><span class="line">src/Frame.cc</span><br><span class="line">src/KeyFrameDatabase.cc</span><br><span class="line">src/Sim3Solver.cc</span><br><span class="line">src/Initializer.cc</span><br><span class="line">src/Viewer.cc</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>根据以上CMakeLists.txt的描述，ORBSLAM2编译将生成<code>libORB_SLAM2.so</code><strong>动态链接库</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Build examples</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/Examples/RGB-D)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(rgbd_tum</span><br><span class="line">Examples/RGB-D/rgbd_tum.cc)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(rgbd_tum <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/Examples/Stereo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(stereo_kitti</span><br><span class="line">Examples/Stereo/stereo_kitti.cc)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(stereo_kitti <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(stereo_euroc</span><br><span class="line">Examples/Stereo/stereo_euroc.cc)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(stereo_euroc <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/Examples/Monocular)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(mono_tum</span><br><span class="line">Examples/Monocular/mono_tum.cc)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(mono_tum <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(mono_kitti</span><br><span class="line">Examples/Monocular/mono_kitti.cc)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(mono_kitti <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(mono_euroc</span><br><span class="line">Examples/Monocular/mono_euroc.cc)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(mono_euroc <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>根据以上部分CMakeLists.txt的描述，ORBSLAM2还将生成<code>rgbd_tum</code>, <code>stereo_kitti</code>, <code>stereo_euroc</code>,  <code>mono_tum</code>, <code>mono_kitti</code>,<code>mono_euroc</code>共6个可执行的<strong>demo程序</strong>。</p>
<p><strong>库文件</strong>有1个：指的是lib*.so文件</p>
<p><strong>可执行文件</strong>有如下6个：</p>
<ol>
<li><code>rgbd_tum</code></li>
<li><code>stereo_kitti</code></li>
<li><code>stereo_euroc</code></li>
<li><code>mono_tum</code></li>
<li><code>mono_kitti</code></li>
<li><code>mono_euroc</code></li>
</ol>
<h5 id="b-ORB-SLAM2-中的include-src-Examples-三个文件夹中都含有什么内容？"><a href="#b-ORB-SLAM2-中的include-src-Examples-三个文件夹中都含有什么内容？" class="headerlink" title="(b) ORB-SLAM2 中的include, src, Examples 三个文件夹中都含有什么内容？"></a>(b) ORB-SLAM2 中的include, src, Examples 三个文件夹中都含有什么内容？</h5><ul>
<li><strong>include</strong>：存放头文件</li>
<li><strong>src</strong>：用来存放<code>.cc</code>等库文件</li>
<li><strong>Example</strong>：存放运行例子的可执行文件，包含了针对不同数据集的运行文件，：<ul>
<li>基于TUM数据集的深度相机运行文件</li>
<li>基于TUM数据集的单目相机运行例程</li>
<li>基于EuRoc数据集的单目相机运行例程</li>
<li>基于EuRoc数据集的双目相机运行例程</li>
<li>基于KITTI数据集的单目相机运行例程</li>
<li>基于KITTI数据集的双目相机运行例程</li>
</ul>
</li>
</ul>
<h5 id="c-ORB-SLAM2-中的可执行文件链接到了哪些库？它们的名字是什么？"><a href="#c-ORB-SLAM2-中的可执行文件链接到了哪些库？它们的名字是什么？" class="headerlink" title="(c) ORB-SLAM2 中的可执行文件链接到了哪些库？它们的名字是什么？"></a>(c) ORB-SLAM2 中的可执行文件链接到了哪些库？它们的名字是什么？</h5><p>ORBSLAM2中的可执行文件链接了五个第三方库：<code>OpenCV</code>、<code>EIGEN3</code>、<code>Pangolin</code>、<code>DBoW2</code>、<code>g2o</code>和一个生成库<code>libORB_SLAM2.so</code>。</p>
<h3 id="六-使用摄像头或视频运行ORB-SLAM2"><a href="#六-使用摄像头或视频运行ORB-SLAM2" class="headerlink" title="六 使用摄像头或视频运行ORB-SLAM2"></a>六 使用摄像头或视频运行ORB-SLAM2</h3><h4 id="1-编译ORBSLAM2"><a href="#1-编译ORBSLAM2" class="headerlink" title="1. 编译ORBSLAM2"></a>1. 编译ORBSLAM2</h4><h4 id="2-修改工程"><a href="#2-修改工程" class="headerlink" title="2. 修改工程"></a>2. 修改工程</h4><p>注意到，ORB-SLAM2 提供了若⼲数据集中的运⾏⽰例，这可以作为我们运行自己摄像头程序的参考，因为它们很相似。对于数据集上的⽰例，ORB-SLAM2 会⾸先读取数据集中的图像，再放到SLAM 中处理。那么对于我们⾃⼰的摄像头，同样可以这样处理。所以最方便的方案是直接将我们的程序作为⼀个新的可执⾏程序，加入到ORB-SLAM2 ⼯程中。那么请问，如何将myslam.cpp或myvideo.cpp 加⼊到ORB-SLAM2 工程中？请给出你的CMakeLists.txt 修改⽅案。</p>
<p>答：修改方案：修改ORBSLAM2的目录下CMakeLists</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/Examples/myvideo)</span><br><span class="line"><span class="keyword">add_executable</span>(myvideo</span><br><span class="line">Examples/myvideo/myvideo.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(myvideo <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-运行ORBSLAM"><a href="#3-运行ORBSLAM" class="headerlink" title="3. 运行ORBSLAM"></a>3. 运行ORBSLAM</h4><p>现在你的程序应该可以编译出结果了。但是我们现在还没有谈相机标定，所以你还没办法标定你的摄像头。我们可以用⼀个不那么好的标定参数，先来试一试效果（所幸 ORB-SLAM2对标定参数不太敏感）。我为你提供了⼀个<code>myslam.yaml（myvideo.yaml）</code>，这个文件是我们假想的标定参数。现在，用这个文件让 ORB-SLAM2 运行起来，看看 ORB-SLAM2 的实际效果吧。请给出运行截图，并谈谈你在运⾏过程中的体会。</p>
<p><img src="/2020/08/06/SLAM%E6%A6%82%E8%BF%B0/ORBSLAM%E8%BF%90%E8%A1%8C%E6%88%AA%E5%9B%BE.png" alt="ORBSLAM运行截图"></p>
<p><img src="/2020/08/06/SLAM%E6%A6%82%E8%BF%B0/%E8%BF%90%E8%A1%8Cmyvideo.png" alt="运行myvideo"></p>
<p><strong>体会</strong></p>
<p>实验过程中，我使用的是虚拟机，运行内存为3G，ORBSLAM2在运行myvideo的过程中，能够保持24~40的关键帧，同时追踪200个特征点，可见其能在计算量有限的情况下仍能追踪到特征点，非常强大。</p>
<p>对于一个不那么准确的标定文件，依然能展现出一定的结果，表明ORBSLAM具有对于标定过程具有一定的鲁棒性。我猜想这可能是因为单目相机的单一性，不需要考虑多个传感器之间的协同。在我测试VINS的过程中则发现运行效果对标定的依赖性非常大。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>处理H自由度的不同方法</title>
    <url>/2020/08/06/%E5%A4%84%E7%90%86H%E8%87%AA%E7%94%B1%E5%BA%A6%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>视觉-惯性状态估计过程中有四个自由度需要进行额外处理，它们是一个平移变量（3个自由度）和绕重力轴方向的旋转（1个自由度）。</p>
<p>视觉惯性状态估计最多可以达到四自由度的转换（围绕重力的旋转和平移），因此必须正确处理额外的自由度 。尽管在实践中使用了不同方法处理多余自由度，但没有任何研究来系统地分析它们的差异。本文介绍了在基于优化的视觉惯性状态估计中处理量测自由度的不同方法的对比分析。通过实验比较了三种常用方法：</p>
<ol>
<li>将不可观察的状态固定为给定值，</li>
<li>在这些状态上设置先验</li>
<li>在优化过程中让状态自由地优化。</li>
</ol>
<p>实验表明：</p>
<ol>
<li>三种方法的准确性和计算时间相似，自由量测方法稍快一些； </li>
<li>自由优化法的协方差估计似乎有很大的不同，但实际上与其他方法紧密相关。</li>
</ol>
<a id="more"></a>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在机器人视觉研究领域。 惯性传感器与相机融合是互补的[1]，两者的结合可提供可靠而准确的状态估计。 尽管关于VI融合的大多数研究都集中在基于滤波器的方法上[2]，[3]，[4]，但非线性优化在最近几年中变得越来越流行。 与基于滤波器的方法相比，基于非线性优化的方法受线性累积误差的影响较小。 它们的主要缺点即高计算成本，已通过硬件和理论的发展得到缓解[5]，[6]。 最近的工作[5]，[7]，[8]，[9]在使用非线性优化的挑战性环境中显示了令人印象深刻的实时VI状态估计结果。</p>
<p>尽管这些工作具有相同的基本原理，即将状态估计作为非线性最小二乘优化问题求解，但它们使用不同的方法来处理VI系统中不可观察的自由度。众所周知，VI系统无法观察到全局位置和偏航[3]，[10]，在本文中，我们根据BA领域的惯例将其称为测量自由度[11]。给定这种测量自由度，获得唯一解决方案的自然方法是在优化中固定相应的状态（即参数）[12]。另一种可能性是将先验设置为不可观察状态，并且先验本质上在优化中充当虚拟度量[5]，[8]，[13]，[7]。最后，可以改为允许优化算法在迭代过程中自由更改不可观察的状态。尽管这三种方法在现有文献中都可以证明是可行的，但对VI状态估计的差异却没有进行比较研究：它们通常作为实现细节呈现，因此没有得到很好的研究和理解。此外，尽管已经研究了类似的仅视觉束调节问题（例如，在单目情况下具有7个不可观察的DoF的[11]，[14]），但据我们所知，此类研究尚未完成用于VI系统（具有4个不可观察的DoF）。</p>
<p>本文所对比的三种方法包括：<strong>规范自由度固定法</strong>，<strong>规范自由度先验法</strong>和<strong>自由规范自由度</strong>法。在准确性，计算成本和估计的协方差（该指标是SLAM感兴趣的[16]）。虽然所有这些方法在估计误差方面具有相似的性能，但由于收敛所需的迭代次数较少，因此自由规范方法略快。我们还发现，正如[7]所述，在自由规范自由度方法中，由优化产生的协方差与任何特定的参考系都没有关联（与规范自由度固定方法相反），这使得解释不确定性的含义变得困难。然而，在这项工作中，我们进一步表明，通过应用协方差变换，自由规范自由度方法得到的协方差实际上与其他方法所得的密切相关（见图1）。</p>
<table>
<thead>
<tr>
<th align="center">章节</th>
<th align="center">内容安排</th>
</tr>
</thead>
<tbody><tr>
<td align="center">二</td>
<td align="center">介绍了基于优化的VI状态估计问题及其非唯一解</td>
</tr>
<tr>
<td align="center">三</td>
<td align="center">介绍了处理规范自由度的不同方法</td>
</tr>
<tr>
<td align="center">四</td>
<td align="center">描述了我们用于对比研究的仿真环境设置</td>
</tr>
<tr>
<td align="center">五</td>
<td align="center">精度/时间和协方差方面的详细比较</td>
</tr>
<tr>
<td align="center">六</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">七</td>
<td align="center">展示了真实世界数据集的实验结果。</td>
</tr>
</tbody></table>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>视觉惯性状态估计的问题包括推断<strong>相机-IMU组合传感器</strong>的运动以及传感器在场景中移动时摄像机看到的3D路标点的位置。 通过收集视觉测量（图像点）和惯性测量（加速度计和陀螺仪）的方程，可以将问题写为非线性最小二乘（NLLS）优化问题，其目的是最小化目标函数（ 例如，假设高斯误差）。<br>$$<br>J(\theta) = ||r^V(\theta)||^2_{\sum_V}+||r^I(\theta)||^2_{\sum_I}<br>$$<br>其中，$||r||^2_\Sigma = r^T\Sigma^{-1}r$ 是是残差向量<code>r</code>的平方<code>Mahalanobis</code>范数，$||r^I(\theta)||^2_{\Sigma_I}$是协方差矩阵，协方差矩阵用来加权。损失函数（1）可用在完全平滑[5]或固定滞后平滑[7]方法中。</p>
<p>方程（1）中的<strong>视觉项</strong>，包括测量图像点$x_{ij}$与米制重建得到的预测点$\hat x_{ij}$间的重投影误差。假设有针孔摄像机模型，则x̂ij（θ）∝ Ki（R&gt; i | − Ri&gt; pi）（Xj&gt;，1）&gt;，其中（Ri，pi）是第i个摄像机的外部参数（i = 0 ，…，N-1）和Xj是第j个界标点（j = 0，…，K-1）的3D欧几里得坐标。 我们假设固有校准Ki是无噪声的。 （1）中的惯性项由惯性测量值和IMU轨迹模型所预测的值之间的误差组成。 例如，[17]考虑了原始加速度和角速度测量中的误差，而[5]考虑了等效的较低速率测量中的误差（以视觉数据的速率表示的惯性预积分项）。 在这项工作中，我们将考虑后一种配方，尽管大多数结果并不取决于配方的选择。</p>
<p>假设有针孔摄像机模型，则$\hat{x̂}_{ij}（θ）∝ K——i（R&gt; i | − R_i&gt; p_i）（X_j^T，1）^T$，其中$（R_i，p_i）$是第i个摄像机的外部参数$（i = 0 ，…，N-1）$和$X_j$是第$j$个界标点$（j = 0，…，K-1）$的3D欧几里得坐标。 我们假设固有校准Ki是无噪声的。 （1）中的惯性项由惯性测量值和IMU轨迹模型所预测的值之间的误差组成。 例如，[17]考虑了原始加速度和角速度测量中的误差，而[5]考虑了等效的较低速率测量中的误差（以视觉数据的速率表示的惯性预积分项）。 在这项工作中，我们将考虑后一种描述，尽管大多数结果并不取决于描述方法的选择。</p>
<p>问题的参数（也称为状态）如下：<br>$$<br>θ \dot{=} {p_i , R_i , v_i , X_j }<br>$$<br>包括相机参数（外参和线速度）和3D路标点。加速度计和陀螺仪的偏置通常表示在<code>IMU</code>框架中，不受坐标系的影响。 因此，我们从状态中排除了bias，并假设IMU测量值已被校正。 惯性和视觉测量模型的完整阐述不在本文的讨论范围内，有关详细信息，请读者参考[5]。</p>
<p>由于VI状态估计问题的不确定性和不可观性，导致没有足够的方程来求解唯一解。</p>
<p>A. 解歧义和几何等价</p>
<p>当解决VI状态估计问题的时候，有必要确定目标函数来确定内参的变换，例如：<br>$$<br>J(\theta)=J(g(\theta))<br>$$<br>特别的，g 有本征矩阵的形式定义如下：</p>
<p><img src="/2020/08/06/%E5%A4%84%E7%90%86H%E8%87%AA%E7%94%B1%E5%BA%A6%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E6%B3%95/image-20200807193315625.png" alt="image-20200807193315625"></p>
<p>是一个4自由度变换，由任意平移t∈R3和围绕重力轴ez =（0，0，1的任意角度（yaw）α∈（-π，π）旋转Rz = Exp（αez）组成 ）&gt;。 Exp（θ</p>
<p>不变性（3）的主要结果是（1）没有唯一的最小值，因为有很多的组合可以得到相同的最小误差：轨道上的所有重构（6）的代价最小（见图2） ），仅区别于4自由度转换（4）。 因此，VI估计问题具有一些不确定性或不可观察的状态：没有足够的方程式来完全指定唯一的解。</p>
<p><img src="/2020/08/06/%E5%A4%84%E7%90%86H%E8%87%AA%E7%94%B1%E5%BA%A6%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E6%B3%95/image-20200807193541351.png" alt="image-20200807193541351"></p>
<p>图2：不同规范处理方法所采用的优化路径示意图。 量规固定方法始终在量规C上移动，因此满足了量规约束。 自由量规方法使用伪逆来选择给定成本降低的最小尺寸的参数步长，因此垂直于成本等值线（1）移动。 量规先验方法遵循量规固定和自由量规方法之间的路径。 它最大程度地减少了（11）所增加的成本，因此它可能无法完全落在最小视觉惯性成本（1）的轨道上。</p>
<p>三种不同解决方法的对比</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">参数量</th>
<th align="center">Hessian矩阵</th>
</tr>
</thead>
<tbody><tr>
<td align="center">固定规范</td>
<td align="center">n-4</td>
<td align="center">逆,(n-4)*(n-4)</td>
</tr>
<tr>
<td align="center">规范先验</td>
<td align="center">n</td>
<td align="center">逆，n*n</td>
</tr>
<tr>
<td align="center">自由规范</td>
<td align="center">n</td>
<td align="center">伪逆，,n×n</td>
</tr>
</tbody></table>
<h2 id="三种处理方法"><a href="#三种处理方法" class="headerlink" title="三种处理方法"></a>三种处理方法</h2><p>一般在状态估计过程中，采用以下三种方法来处理这几个不可观状态：（1）将它们设置成固定值（固定值法）；（2）为它们设置一个先验值，然后在估计过程中进行优化；（3）不进行特殊处理，直接进行优化（自由优化法）。</p>
<p>1.固定值法：在优化过程中，保持第一个相机位姿的平移变量（涉及三个维度）和旋转变量（李代数表示法）中的z分量不变。具体做法是：在优化过程中，设置<br>$$<br>p_0=p^0_0\Δϕ_{0_z}≐e_z^T Δϕ=0<br>$$<br>其中是第一个相机的初始位置。这样的设置也意味着Jacobi矩阵中，对上述变量的(导数）取值为0。</p>
<p>2.先验值法：在优化的时候，给目标函数增加一个惩罚项：<br>$$<br>||r^P_0||^2_{\sum^P_0} \ where, r^P_0(\theta) \dot{=}[p_0-o_0]^0，\Delta\phi_0z]^T<br>$$<br>于是惩罚项。当时，效果接近于自由优化法，当时，效果基本上接近于固定值法。</p>
<p>3.自由优化法：在优化的过程中，让变量随着优化的过程自行演化。为了避免<code>hessian</code>矩阵的奇异化，可以求矩阵的广义逆或者使用阻尼因子来保证优化过程有一个良好的迭代更新过程。 </p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>结果表明</p>
<ul>
<li>三种方法的数值精确度基本相同 先验值法需要选择合适的先验值权重以避免增加计算量</li>
<li>在选择了合适的先验值的情况下，先验值法和固定值法的表现（精确度和计算成本）基本相同</li>
<li>自由优化法比其他两种方法略微快一些，因为它用了更少的迭代来达到收敛</li>
<li>自由优化法的另一个优点是它更通用一些，不需要对旋转进行特殊处理</li>
</ul>
<p>虽然可能可以修复不可观察的自由度（量身定制的参数化方法（9）来修复偏航自由度），但自由规范方法具有通用的额外优势，即不是VI特有的，因此 不需要对旋转参数化进行任何特殊处理。</p>
]]></content>
  </entry>
  <entry>
    <title>OpenCV_Function</title>
    <url>/2020/08/04/OpenCV-Function/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="图像操作"><a href="#图像操作" class="headerlink" title="图像操作"></a>图像操作</h2><h3 id="遍历图像的四种方式"><a href="#遍历图像的四种方式" class="headerlink" title="遍历图像的四种方式"></a>遍历图像的四种方式</h3><ol>
<li><code>at&lt;typename&gt;(i,j)</code></li>
</ol>
<p>Mat类提供了一个at的方法用于取得图像上的点，它是一个模板函数，可以取到任何类型的图像上的点。下面我们通过一个图像处理中的实际来说明它的用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">colorReduce</span><span class="params">(Mat&amp; <span class="built_in">image</span>,<span class="keyword">int</span> div)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">image</span>.rows;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">image</span>.cols;j++)&#123;</span><br><span class="line">           <span class="built_in">image</span>.at&lt;Vec3b&gt;(i,j)[<span class="number">0</span>]=<span class="built_in">image</span>.at&lt;Vec3b&gt;(i,j)[<span class="number">0</span>]/div*div+div/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">image</span>.at&lt;Vec3b&gt;(i,j)[<span class="number">1</span>]=<span class="built_in">image</span>.at&lt;Vec3b&gt;(i,j)[<span class="number">1</span>]/div*div+div/<span class="number">2</span>;</span><br><span class="line">           <span class="built_in">image</span>.at&lt;Vec3b&gt;(i,j)[<span class="number">2</span>]=<span class="built_in">image</span>.at&lt;Vec3b&gt;(i,j)[<span class="number">2</span>]/div*div+div/<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用指针来遍历图像</li>
</ol>
<p>我们实际喜欢把原图传进函数内，但是在函数内我们对原图像进行了修改，而将原图作为一个结果输出，很多时候我们需要保留原图，这样我们需要一个原图的副本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">colorReduce</span><span class="params">(<span class="keyword">const</span> Mat&amp; <span class="built_in">image</span>,Mat&amp; outImage,<span class="keyword">int</span> div)</span></span></span><br><span class="line"><span class="function"> 2 </span>&#123;</span><br><span class="line"> <span class="number">3</span>     <span class="comment">// 创建与原图像等尺寸的图像</span></span><br><span class="line"> <span class="number">4</span>     outImage.create(<span class="built_in">image</span>.<span class="built_in">size</span>(),<span class="built_in">image</span>.type());</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">int</span> nr=<span class="built_in">image</span>.rows;</span><br><span class="line"> <span class="number">6</span>     <span class="comment">// 将3通道转换为1通道</span></span><br><span class="line"> <span class="number">7</span>     <span class="keyword">int</span> nl=<span class="built_in">image</span>.cols*<span class="built_in">image</span>.channels();</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;nr;k++)&#123;</span><br><span class="line"><span class="number">10</span>         <span class="comment">// 每一行图像的指针</span></span><br><span class="line"><span class="number">11</span>         <span class="keyword">const</span> uchar* inData=<span class="built_in">image</span>.ptr&lt;uchar&gt;(k);</span><br><span class="line"><span class="number">12</span>         uchar* outData=outImage.ptr&lt;uchar&gt;(k);</span><br><span class="line"><span class="number">13</span>         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nl;i++)&#123;</span><br><span class="line"><span class="number">15</span>             outData[i]=inData[i]/div*div+div/<span class="number">2</span>;</span><br><span class="line"><span class="number">16</span>         &#125;</span><br><span class="line"><span class="number">17</span>     &#125;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用迭代器来遍历图像</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">colorReduce</span><span class="params">(<span class="keyword">const</span> Mat&amp; <span class="built_in">image</span>,Mat&amp; outImage,<span class="keyword">int</span> div)</span></span></span><br><span class="line"><span class="function"> 2 </span>&#123;</span><br><span class="line"> <span class="number">3</span>     outImage.create(<span class="built_in">image</span>.<span class="built_in">size</span>(),<span class="built_in">image</span>.type());</span><br><span class="line"> <span class="number">4</span>     MatConstIterator_&lt;Vec3b&gt; it_in=<span class="built_in">image</span>.<span class="built_in">begin</span>&lt;Vec3b&gt;();</span><br><span class="line"> <span class="number">5</span>     MatConstIterator_&lt;Vec3b&gt; itend_in=<span class="built_in">image</span>.<span class="built_in">end</span>&lt;Vec3b&gt;();</span><br><span class="line"> <span class="number">6</span>     MatIterator_&lt;Vec3b&gt; it_out=outImage.<span class="built_in">begin</span>&lt;Vec3b&gt;();</span><br><span class="line"> <span class="number">7</span>     MatIterator_&lt;Vec3b&gt; itend_out=outImage.<span class="built_in">end</span>&lt;Vec3b&gt;();</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">while</span>(it_in!=itend_in)</span><br><span class="line"> <span class="number">9</span>     &#123;</span><br><span class="line"><span class="number">10</span>         (*it_out)[<span class="number">0</span>]=(*it_in)[<span class="number">0</span>]/div*div+div/<span class="number">2</span>;</span><br><span class="line"><span class="number">11</span>         (*it_out)[<span class="number">1</span>]=(*it_in)[<span class="number">1</span>]/div*div+div/<span class="number">2</span>;</span><br><span class="line"><span class="number">12</span>         (*it_out)[<span class="number">2</span>]=(*it_in)[<span class="number">2</span>]/div*div+div/<span class="number">2</span>;</span><br><span class="line"><span class="number">13</span>         it_in++;</span><br><span class="line"><span class="number">14</span>         it_out++;</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>最高效的方法</li>
</ol>
<p>当不对行进行填补的时候，图像可被视为一个长为W x H的一维数组。用isContinuous来判断是否对行进行的填补。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n1 = <span class="built_in">image</span>.rows;</span><br><span class="line"><span class="keyword">int</span> nc = <span class="built_in">image</span>.cols * <span class="built_in">image</span>.channels（）;</span><br><span class="line"><span class="keyword">if</span>（<span class="built_in">image</span>.isContinuous（））<span class="comment">//判断是否对行有额外的填补像素，返回值为真，则没有填补。</span></span><br><span class="line">&#123;</span><br><span class="line">    nc = nc * n1;</span><br><span class="line">    n1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>（<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n1; i ++）<span class="comment">//若图像是连续的，则只循环一次</span></span><br><span class="line">&#123;</span><br><span class="line">    uchar * data = <span class="built_in">image</span>.ptr &lt;uchar&gt;（i）;</span><br><span class="line">    <span class="keyword">for</span>（<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;nc; j ++）</span><br><span class="line">    &#123;</span><br><span class="line">        data [j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>图像</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 二叉树</title>
    <url>/2020/08/02/C++%E6%A0%91/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="一-树的概念"><a href="#一-树的概念" class="headerlink" title="一 树的概念"></a>一 树的概念</h2><h2 id="二-二叉树"><a href="#二-二叉树" class="headerlink" title="二 二叉树"></a>二 二叉树</h2><p>满二叉树：</p>
<p>定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。</span><br><span class="line"></span><br><span class="line">国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</span><br></pre></td></tr></table></figure>

<p>最后一层的节点个数等于其他层数节点个数之和+1，假设第k层，最后一层的节点个数即2*（k-1）</p>
<p>完全二叉树：</p>
<p>定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边。</span><br><span class="line"></span><br><span class="line">完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h4><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; his;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        TreeNode *t = root, *dummy = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        his.push(dummy);</span><br><span class="line">        <span class="keyword">while</span>(!his.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(t)&#123;</span><br><span class="line">                res.push_back(t-&gt;val);</span><br><span class="line">                his.push(t);</span><br><span class="line">                t = t-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            t = his.top()-&gt;right;</span><br><span class="line">            his.pop();  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>容易理解的写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* ptr = st.top();</span><br><span class="line">            res.push_back(ptr-&gt;val);</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(ptr-&gt;right)</span><br><span class="line">                st.push(ptr-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(ptr-&gt;left)</span><br><span class="line">                st.push(ptr-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="built_in">stack</span> = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">stack</span> <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="built_in">stack</span>.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            top = <span class="built_in">stack</span>.pop() #此时左子树遍历完成</span><br><span class="line">            res.append(top.val)  #将父节点加入列表</span><br><span class="line">            cur = top.right #遍历右子树</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="built_in">stack</span> = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">stack</span> <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                <span class="built_in">stack</span>.append(cur)</span><br><span class="line">                cur = cur.right  #先将右节点压栈</span><br><span class="line">            top = <span class="built_in">stack</span>.pop()  #此时该节点的右子树已经全部遍历完</span><br><span class="line">            cur = top.left  #对左子树遍历</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]  #结果翻转</span><br></pre></td></tr></table></figure>



<h3 id="统一形式"><a href="#统一形式" class="headerlink" title="统一形式"></a>统一形式</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;  <span class="comment">//保存结果</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;  <span class="comment">//调用栈</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>) st.push(root);  <span class="comment">//首先介入root节点</span></span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            TreeNode *t = st.top();</span><br><span class="line">            st.pop();  <span class="comment">//访问过的节点弹出</span></span><br><span class="line">            <span class="keyword">if</span>(t!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) st.push(t-&gt;right);  <span class="comment">//右节点先压栈，最后处理</span></span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) st.push(t-&gt;left);</span><br><span class="line">                st.push(t);  <span class="comment">//当前节点重新压栈（留着以后处理），因为先序遍历所以最后压栈</span></span><br><span class="line">                st.push(<span class="literal">nullptr</span>);  <span class="comment">//在当前节点之前加入一个空节点表示已经访问过了</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//空节点表示之前已经访问过了，现在需要处理除了递归之外的内容</span></span><br><span class="line">                res.push_back(st.top()-&gt;val);  <span class="comment">//st.top()是nullptr之前压栈的一个节点，也就是上面st.push(t)中的那个t</span></span><br><span class="line">                st.pop();  <span class="comment">//处理完了，第二次弹出节点（彻底从栈中移除）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>二叉树</category>
        <category>数据结构</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake指令手册</title>
    <url>/2020/07/30/Cmake-%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p> Cmake 是 kitware 公司以及一些开源开发者在开发几个工具套件(VTK)的过程中衍生品，最终形成体系，成为一个独立的开放源代码项目。</p>
<p>本文主要记录书写Cmake的大致流程</p>
<a id="more"></a>

<h2 id="常见CMakeLists-txt中指令剖析"><a href="#常见CMakeLists-txt中指令剖析" class="headerlink" title="常见CMakeLists.txt中指令剖析"></a>常见<code>CMakeLists.txt</code>中指令剖析</h2><p>注意:Cmake的指令是大小写无关的,参数和变量是大小写相关的。</p>
<h3 id="cmake-minimum-required-VERSION-2-6-命令"><a href="#cmake-minimum-required-VERSION-2-6-命令" class="headerlink" title="cmake_minimum_required(VERSION 2.6)命令"></a><strong>cmake_minimum_required(VERSION 2.6)命令</strong></h3><p>规定cmake软件的最低版本。这行命令是可选的，可以不写这句话，但在有些情况下，如果CMakeLists.txt文件中使用了一些高版本cmake特有的一些命令时，就需要加上这一行，提醒用户升级到该版本之后再执行cmake。</p>
<h3 id="project-lt-projectname-gt-命令"><a href="#project-lt-projectname-gt-命令" class="headerlink" title="project(&lt;projectname&gt;)命令"></a><strong><code>project(&lt;projectname&gt;)</code>命令</strong></h3><p><strong>语法：</strong><code>project(projectname [cxx] [c] [java])</code><br>可以指定工程采用的语言，选项分别表示：C++, C, java， 如不指定默认支持所有语言。<br>指定项目的名称，在生成VS项目下即指明了生成的<code>.sln</code>项目的文件名。项目最终编译生成的<strong>可执行文件</strong>不一定是这个项目名称，而是由另一条命令(<code>add_executable</code>)指定的。</p>
<p>通过<code>project</code>命令，为整个代码项目定义了一个管理架构，这点可以通过在VS下建立项目的结构层次来帮助理解。VS下所有的项目都是在解决方案（.sln文件）下进行管理的，一个解决方案可以包含多个项目。cmake中project命令正是定义了解决方案的名称，<code>add_executable</code>和<code>add_library</code>命令都会生成一个项目，cmake会自动为每个项目（包括生成可执行文件的项目和生成链接库的项目）创建对应的文件夹，存储编译中间文件。</p>
<p>但是这个项目名称还是很必要的，在cmake中有两个预定义的变量：<code>&lt;projectname&gt;_BINARY_DIR</code> 和<code>&lt;projectname&gt;_SOURCE_DIR</code> ，即一旦使用了project指明了一个项目名称，则同时隐式定义了这两个预定义的变量。在内部编译情况下，这两个变量的含义相同，而在外部编译下，两者指代的内容会有所不同。要理解这两个变量的含义，我们首先需要了解什么是<strong>外部构建（out of source build）</strong>，下面会介绍什么叫外部构建。</p>
<p>同时cmake还预定义了<code>PROJECT_BINARY_DIR</code>和<code>PROJECT_SOURCE_DIR</code>变量，其中<code>PROJECT_BINARY_DIR</code>就等同于<code>&lt;projectname&gt;_BINARY_DIR,PROJECT_SOURCE_DIR</code>等同于<code>&lt;projectname&gt;_SOURCE_DIR</code>。因此在实际应用中，强烈推荐使用<code>PROJECT_BINARY_DIR</code>和<code>PROJECT_SOURCE_DIR</code>变量，这样即使项目名称发生变化也不会影响CMakeLists.txt文件。</p>
<p><strong>外部构建的含义：</strong><br>外部构建和内部构建最大的不同在于执行cmake的工作路径不同，在我们使用cmake构建项目时，首先要求指定<strong>“Where is the source code”</strong>，然后要求指定<strong>“Where to build the binaries”</strong>。此时如果这两个路径相同的话，cmake生成的所有中间文件和可执行文件都会存放在项目目录（即所谓的根目录）中；而如果我们在项目目录下先新建一个build文件夹，然后将<strong>“Where to build the binaries”</strong>指定为该build文件夹的路径，此时中间文件和可执行文件都会存放在<code>build</code>目录下。第二种方法的优点显而易见，它最大限度的保持了代码目录的整洁，同时由于第二种方法的生成、编译和安装时发生在不同于项目目录的其他目录中，所以第二种方法就叫做<strong>“外部构建”</strong>。<br>回到project命令下的问题，在外部构建的情况下，<code>PROJECT_SOURCE_DIR</code>指向 的目录同内部构建一样，仍然是项目目录，而<code>PROJECT_BINARY_DIR</code>则有所不同，指向的是&lt;项目目录&gt;/build目录。cmake强烈推荐使用外部构建的方法。</p>
<h3 id="ADD-SUBDIRECTORY命令"><a href="#ADD-SUBDIRECTORY命令" class="headerlink" title="ADD_SUBDIRECTORY命令"></a><strong>ADD_SUBDIRECTORY命令</strong></h3><p><strong>语法：</strong> <code>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</code><br>该命令告诉CMake去<strong>子目录</strong>中查看可用的CMakeLists.txt文件<br>指令用于向当前工程添加存放源文件的子目录,并可以指定中间二进制和目标二进制存放的位置。 <code>EXCLUDE_FROM_ALL</code> 参数的含义是将这个目录从编译过程中排除。比如,工程的 example,可能就需要工程构建完成后,再进入 example 目录单独进行构建。<br>在我们的项目中，我们添加了src目录到项目中，而把对应于src目录生成的中间文件和目标文件存放到bin目录下，在上一节举例中“外部构建”的情况下，中间文件和目标文件将存放在build/srcobj目录下</p>
<h3 id="ADD-EXECUTABLE命令"><a href="#ADD-EXECUTABLE命令" class="headerlink" title="ADD_EXECUTABLE命令"></a><strong>ADD_EXECUTABLE命令</strong></h3><p>告诉工程生成一个<strong>可执行文件</strong>。该命令定义了工程最终生成的可执行文件的文件名以及参与编译的头文件和cpp文件。<br>如果想指定生成的可执行文件的存放路径，可以设置cmake中预定义变量EXECUTABLE_OUTPUT_PATH 的值。例如，将生成的可执行文件放置在cmake编译路径的bin文件夹下可用：<code>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)</code></p>
<h3 id="ADD-LIBRARY命令"><a href="#ADD-LIBRARY命令" class="headerlink" title="ADD_LIBRARY命令"></a><strong>ADD_LIBRARY命令</strong></h3><p><strong>语法：</strong><code>ADD_LIBRARY(libname [SHARED|STATIC]</code><br>告诉工程生成一个库文件</p>
<h3 id="FIND-LIBRARY命令"><a href="#FIND-LIBRARY命令" class="headerlink" title="FIND_LIBRARY命令"></a><strong>FIND_LIBRARY命令</strong></h3><p>查找库所在目录，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find_library (</span><br><span class="line">          &lt;VAR&gt;</span><br><span class="line">          name | NAMES name1 [name2 ...] [NAMES_PER_DIR]</span><br><span class="line">          [HINTS path1 [path2 ... ENV var]]</span><br><span class="line">          [PATHS path1 [path2 ... ENV var]]</span><br><span class="line">          [PATH_SUFFIXES suffix1 [suffix2 ...]]</span><br><span class="line">          [DOC &quot;cache documentation string&quot;]</span><br><span class="line">          [NO_DEFAULT_PATH]</span><br><span class="line">          [NO_CMAKE_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_CMAKE_PATH]</span><br><span class="line">          [NO_SYSTEM_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_CMAKE_SYSTEM_PATH]</span><br><span class="line">          [CMAKE_FIND_ROOT_PATH_BOTH |</span><br><span class="line">           ONLY_CMAKE_FIND_ROOT_PATH |</span><br><span class="line">           NO_CMAKE_FIND_ROOT_PATH]</span><br><span class="line">         )</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FIND_LIBRARY(RUNTIME_LIB rt &#x2F;usr&#x2F;lib  &#x2F;usr&#x2F;local&#x2F;lib NO_DEFAULT_PATH)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>cmake会在目录中查找，如果所有目录中都没有，值<code>RUNTIME_LIB</code>就会被赋为<code>NO_DEFAULT_PATH</code></p>
<h3 id="SET命令——用于设置变量，相当于为变量取别名"><a href="#SET命令——用于设置变量，相当于为变量取别名" class="headerlink" title="SET命令——用于设置变量，相当于为变量取别名"></a><strong>SET命令——用于设置变量，相当于为变量取别名</strong></h3><p><strong>SET(CMAKE_BUILE_TYPE DEBUG)</strong> 设置编译类型debug 或者release。 debug 版会生成相关调试信息，可以使用GDB 进行调试；release不会生成调试信息。当无法进行调试时查看此处是否设置为debug.<br>SET(CMAKE_C_FLAGS_DEBUG “-g -Wall”) 设置编译器的类型<br>CMAKE_C_FLAGS_DEBUG —- C 编译器<br>CMAKE_CXX_FLAGS_DEBUG —- C++ 编译器</p>
<h3 id="CMAKE-MODULE-PATH变量——定义cmake模块所在路径"><a href="#CMAKE-MODULE-PATH变量——定义cmake模块所在路径" class="headerlink" title="CMAKE_MODULE_PATH变量——定义cmake模块所在路径"></a><strong>CMAKE_MODULE_PATH变量——定义cmake模块所在路径</strong></h3><p>如果你的工程比较复杂,有可能会自己编写一些 <strong>cmake 模块</strong>（所谓cmake模块指的是在该文件内部定义了一些变量，这些变量指明了一些头文件路径和库文件路径等有用信息）。这些 cmake 模块是随你的工程发布的,为了让 cmake 在处理CMakeLists.txt 时找到这些模块,你需要通过 SET 指令,将自己的 cmake 模块路径设置一下。<br>比如<br><code>SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)</code><br>这时候你就可以通过 INCLUDE 指令来调用自己的模块了</p>
<h3 id="EXECUTABLE-OUTPUT-PATH和LIBRARY-OUTPUT-PATH变量"><a href="#EXECUTABLE-OUTPUT-PATH和LIBRARY-OUTPUT-PATH变量" class="headerlink" title="EXECUTABLE_OUTPUT_PATH和LIBRARY_OUTPUT_PATH变量"></a><strong>EXECUTABLE_OUTPUT_PATH和LIBRARY_OUTPUT_PATH变量</strong></h3><p>我们可以通过 <code>SET</code> 指令重新定义 <code>EXECUTABLE_OUTPUT_PATH</code> 和 <code>LIBRARY_OUTPUT_PATH</code> 变量来指定最终的目标二进制的位置(指最终生成的CRNode可执行文件或者最终的共享库，而不包含编译生成的中间文件)。<br>命令如下：<br><code>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)</code><br><code>SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</code><br>需要注意的是，在哪里 <code>ADD_EXECUTABLE</code> 或 <code>ADD_LIBRARY</code>,如果需要改变目标存放路径,就在哪里加入上述的定义。</p>
<h2 id="CMake-基础模板"><a href="#CMake-基础模板" class="headerlink" title="CMake 基础模板"></a>CMake 基础模板</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">## This is a standard CMakeLists.txt template, including</span></span><br><span class="line"><span class="comment">## how to enable C++11 compiler option and how to set 'Release'</span></span><br><span class="line"><span class="comment">## target compile option</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(cmake_template)</span><br><span class="line"></span><br><span class="line"><span class="comment">############# Use message function to print information ############</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"CMake version: $&#123;CMAKE_VERSION&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">############ enable C++11 compiler###############</span></span><br><span class="line"><span class="comment">## Method 1</span></span><br><span class="line"><span class="keyword">include</span>(CheckCXXCompilerFlag)</span><br><span class="line">CHECK_CXX_COMPILER_FLAG(<span class="string">"-std=c++11"</span> COMPILER_SUPPORTS_CXX11)</span><br><span class="line">CHECK_CXX_COMPILER_FLAG(<span class="string">"-std=c++0x"</span> COMPILER_SUPPORTS_CXX0X)</span><br><span class="line"><span class="keyword">if</span>(COMPILER_SUPPORTS_CXX11)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11"</span>)</span><br><span class="line"><span class="keyword">elseif</span>(COMPILER_SUPPORTS_CXX0X)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"$&#123;CMAKE_CXX_FLAGS&#125; -std=c++0x"</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(WARNING <span class="string">"The compiler $&#123;CMAKE_CXX_COMPILER&#125; has no C++11 support."</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">"Please use a different C++ compiler."</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment">## Method 2</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############ #enable warnings##################</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"$&#123;CMAKE_CXX_FLAGS&#125; -fPIC -Wall"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#############Set cmake compiler options##############</span></span><br><span class="line"><span class="comment">## Method 1</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">"Release"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Method 2</span></span><br><span class="line"><span class="keyword">IF</span>(<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">  <span class="keyword">SET</span>(CMAKE_BUILD_TYPE RelWithDebInfo CACHE <span class="keyword">STRING</span></span><br><span class="line">      <span class="string">"Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel."</span></span><br><span class="line">      FORCE)</span><br><span class="line"><span class="keyword">ENDIF</span>(<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line"></span><br><span class="line"><span class="comment">################## Some useful arguments ##########################</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_INCLUDE_CURRENT_DIR <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##########</span></span><br><span class="line"><span class="comment">##Build###</span></span><br><span class="line"><span class="comment">##########</span></span><br><span class="line"><span class="keyword">add_library</span>(lib hello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main <span class="variable">$&#123;LINK_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="常用变量列表"><a href="#常用变量列表" class="headerlink" title="常用变量列表"></a><strong>常用变量列表</strong></h2><table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PROJECT_NAME</strong></td>
<td><code>project</code>命令中写的项目名</td>
</tr>
<tr>
<td><strong>CMAKE_VERSION</strong></td>
<td>当前使用CMake的版本</td>
</tr>
<tr>
<td><strong>CMAKE_SOURCE_DIR</strong></td>
<td>工程顶层目录，即入口CMakeLists文件所在路径</td>
</tr>
<tr>
<td><strong>PROJECT_SOURCE_DIR</strong></td>
<td>同<strong>CMAKE_SOURCE_DIR</strong></td>
</tr>
<tr>
<td><strong>CMAKE_BINARY_DIR</strong></td>
<td>工程编译发生的目录，即执行cmake命令进行项目配置的目录，一般为build</td>
</tr>
<tr>
<td><strong>PROJECT_BINARY_DIR</strong></td>
<td>同<strong>CMAKE_BINARY_DIR</strong></td>
</tr>
<tr>
<td><strong>CMAKE_CURRENT_SOURCE_DIR</strong></td>
<td>当前处理的CMakeLists.txt所在的路径</td>
</tr>
<tr>
<td><strong>CMAKE_CURRRENT_BINARY_DIR</strong></td>
<td>当前处理的CMakeLists.txt中生成目标文件所在编译目录</td>
</tr>
<tr>
<td><strong>CMAKE_CURRENT_LIST_FILE</strong></td>
<td>输出调用这个变量的CMakeLists.txt文件的完整路径</td>
</tr>
<tr>
<td><strong>CMAKE_CURRENT_LIST_DIR</strong></td>
<td>当前处理的CMakeLists.txt文件所在目录的路径</td>
</tr>
<tr>
<td><strong>CMAKE_INSTALL_PREFIX</strong></td>
<td>指定<code>make install</code>命令执行时包安装路径</td>
</tr>
<tr>
<td><strong>CMAKE_MODULE_PATH</strong></td>
<td><code>find_package</code>命令搜索包路径<strong>之一</strong>，默认为空</td>
</tr>
</tbody></table>
<p><strong>编译配置相关变量：</strong></p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CMAKE_BUILD_TYPE</strong></td>
<td>编译选项，Release或者Debug，如<code>set(CMAKE_BUILD_TYPE &quot;Release&quot;)</code></td>
</tr>
<tr>
<td><strong>CMAKE_CXX_FLAGS</strong></td>
<td>编译标志，设置C++11编译，<code>set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++11&quot;)</code></td>
</tr>
<tr>
<td><strong>CMAKE_CXX_STANDARD</strong></td>
<td>也可以设置C++11编译，<code>set(CMAKE_CXX_STANDARD 11)</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每周打卡05~25-31</title>
    <url>/2020/05/27/2020-05-27-LeetCodeCheckDaily/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/" target="_blank" rel="noopener">974. 和可被 K 整除的子数组</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></td>
<td>困难</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></td>
<td>简单</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>运用你所掌握的数据结构，设计和实现一个 <a href="https://baike.baidu.com/item/LRU" target="_blank" rel="noopener">LRU (最近最少使用) 缓存机制</a>。它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p>
<p>获取数据 <code>get(key)</code> - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a><strong>进阶:</strong></h4><p>你是否可以在 <strong>O(1)</strong> 时间复杂度内完成这两种操作？</p>
<p> <strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回  1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得关键字 2 作废</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得关键字 1 作废</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; 返回  3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; 返回  4</span><br></pre></td></tr></table></figure>

<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cache;</span><br><span class="line">    <span class="comment">// 哈希表：key 映射到 (key, value) 在 cache 中的位置</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cap = capacity; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">map</span>.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="comment">// 访问的 key 不存在</span></span><br><span class="line">        <span class="keyword">if</span> (it == <span class="built_in">map</span>.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// key 存在，把 (k, v) 换到队头</span></span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; kv = *<span class="built_in">map</span>[key];</span><br><span class="line">        cache.erase(<span class="built_in">map</span>[key]);</span><br><span class="line">        cache.push_front(kv);</span><br><span class="line">        <span class="comment">// 更新 (key, value) 在 cache 中的位置</span></span><br><span class="line">        <span class="built_in">map</span>[key] = cache.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> kv.second; <span class="comment">// value</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 要先判断 key 是否已经存在 */</span> </span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">map</span>.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="built_in">map</span>.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">/* key 不存在，判断 cache 是否已满 */</span> </span><br><span class="line">            <span class="keyword">if</span> (cache.<span class="built_in">size</span>() == cap) &#123;</span><br><span class="line">                <span class="comment">// cache 已满，删除尾部的键值对腾位置</span></span><br><span class="line">                <span class="comment">// cache 和 map 中的数据都要删除</span></span><br><span class="line">                <span class="keyword">auto</span> lastPair = cache.back();</span><br><span class="line">                <span class="keyword">int</span> lastKey = lastPair.first;</span><br><span class="line">                <span class="built_in">map</span>.erase(lastKey);</span><br><span class="line">                cache.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cache 没满，可以直接添加</span></span><br><span class="line">            cache.push_front(make_pair(key, value));</span><br><span class="line">            <span class="built_in">map</span>[key] = cache.<span class="built_in">begin</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* key 存在，更改 value 并换到队头 */</span></span><br><span class="line">            cache.erase(<span class="built_in">map</span>[key]);</span><br><span class="line">            cache.push_front(make_pair(key, value));</span><br><span class="line">            <span class="built_in">map</span>[key] = cache.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含 <em>n</em> + 1 个整数的数组 <em>nums*，其数字都在 1 到 *n</em> 之间（包括 1 和 <em>n</em>），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a><strong>说明：</strong></h4><ol>
<li><strong>不能</strong>更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 <em>O</em>(1) 的空间。</li>
<li>时间复杂度小于 <em>O</em>(<em>n</em>2) 。</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ol>
<h3 id="官方解法：二进制"><a href="#官方解法：二进制" class="headerlink" title="官方解法：二进制"></a>官方解法：二进制</h3><p>这个方法我们来将所有数二进制展开按位考虑如何找出重复的数，如果我们能确定重复数每一位是 1还是 0 就可以按位还原出重复的数是什么。考虑到第 i 位，我们记 $\textit{nums}[]$ 数组中二进制展开后第 i 位为 1 的数有 x 个，数字 $[1,n]$这 n 个数二进制展开后第 i 位为 1 的数有 y 个，那么重复的数第 i 位为 1 当且仅当 $x&gt;y$。</p>
<p>仍然以示例 1 为例，如下的表格列出了每个数字二进制下每一位是 1 还是 0 以及对应位的 x 和 y 是多少：</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>3</th>
<th>4</th>
<th>2</th>
<th>2</th>
<th>x</th>
<th>y</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>那么按之前说的我们发现只有第 1 位 $x&gt;y$ ，所以按位还原后 $\textit{target}=(010)<em>2=(2)</em>{10}$ ，符合答案。</p>
<p>正确性的证明其实和方法一类似，我们可以按方法一的方法，考虑不同示例数组中第 ii 位 11 的个数 xx 的变化：</p>
<p>如果测试用例的数组中 $\textit{target}$ 出现了两次，其余的数各出现了一次，且 $\textit{target}$ 的第 i 位为 1，那么 $\textit{nums}[]$ 数组中第 i 位 1 的个数 x 恰好比 y 大一。如果$\textit{target}$ 的第 i 位为 0，那么两者相等。<br>如果测试用例的数组中 $\textit{target}$ 出现了三次及以上，那么必然有一些数不在 $\textit{nums}[]$ 数组中了，这个时候相当于我们用 $\textit{target}$ 去替换了这些数，我们考虑替换的时候对 xx 的影响：</p>
<ul>
<li>如果被替换的数第 i 位为 1，且 $\textit{target}$ 第 i 位为 1：x 不变，满足 $x&gt;y$。</li>
<li>如果被替换的数第 i 位为 0，且 $\textit{target}$ 第 i 位为 1：x 加一，满足 $x&gt;y$。</li>
<li>如果被替换的数第 i 位为 1，且 $\textit{target}$ 第 i 位为 0：x 减一，满足 $x\le y$。</li>
<li>如果被替换的数第 i 位为 0，且 $\textit{target}$ 第 i 位为 0：x 不变，满足 $x\le y$。</li>
</ul>
<p>也就是说如果 $\textit{target}$ 第 i 位为 1，那么每次替换后只会使 x 不变或增大，如果为 0，只会使 x 不变或减小，始终满足 x&gt;y 时 $\textit{target}$ 第 i 位为 1，否则为 0，因此我们只要按位还原这个重复的数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 确定二进制下最高位是多少</span></span><br><span class="line">        <span class="keyword">int</span> bit_max = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">while</span> (!((n - <span class="number">1</span>) &gt;&gt; bit_max)) &#123;</span><br><span class="line">            bit_max -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">bit</span> = <span class="number">0</span>; <span class="built_in">bit</span> &lt;= bit_max; ++<span class="built_in">bit</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &amp; (<span class="number">1</span> &lt;&lt; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">                    x += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; (i &amp; (<span class="number">1</span> &lt;&lt; <span class="built_in">bit</span>))) &#123;</span><br><span class="line">                    y += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; <span class="built_in">bit</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="官方解法：快慢指针"><a href="#官方解法：快慢指针" class="headerlink" title="官方解法：快慢指针"></a>官方解法：快慢指针</h3><p>本方法需要读者对 「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解，它是一个检测链表是否有环的算法。</p>
<p>我们对$\textit{nums}[]$数组建图，每个位置 $i$ 连一条 $i→nums[i]$ 的边。由于存在的重复的数字 $\textit{target}$，因此$\textit{target}$这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的 $\textit{target}$ 就是这个环的入口，那么整个问题就等价于 142. 环形链表 II。</p>
<p>我们先设置慢指针 $\textit{slow}$ 和快指针 $\textit{fast}$ ，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将 $\textit{slow}$ 放置起点 0，两个指针每次同时移动一步，相遇的点就是答案。</p>
<p>这里简单解释为什么后面将 $\textit{slow}$ 放置起点后移动相遇的点就一定是答案了。假设环长为 L，从起点到环的入口的步数是 a，从环的入口继续走 b 步到达相遇位置，从相遇位置继续走 c 步回到环的入口，则有 $b+c=L$，其中 L、a、b、c 都是正整数。根据上述定义，慢指针走了 $a+b$ 步，快指针走了 $2(a+b)$ 步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成 $a+b+kL$，其中 k 表示快指针在环上走的圈数。联立等式，可以得到<br>$$<br>2(a+b)=a+b+kL<br>$$<br>解得 $a=kL-b$，整理可得<br>$$<br>a=(k-1)L+(L-b)=(k-1)L+c<br>$$<br>从上述等式可知，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了 $a$ 步之后到达环的入口，快指针在环里走了 $k-1$ 圈之后又走了 $c$ 步，由于从相遇位置继续走 $c$ 步即可回到环的入口，因此快指针也到达环的入口。两个指针在环的入口相遇，相遇点就是答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;;</span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/" target="_blank" rel="noopener">974. 和可被 K 整除的子数组</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 <code>A</code>，返回其中元素之和可被 <code>K</code> 整除的（连续、非空）子数组的数目。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [4,5,0,-2,-3,1], K &#x3D; 5</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">有 7 个子数组满足其元素之和可被 K &#x3D; 5 整除：</span><br><span class="line">[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>2 &lt;= K &lt;= 10000</code></li>
</ol>
<h3 id="我的解法：前缀和"><a href="#我的解法：前缀和" class="headerlink" title="我的解法：前缀和"></a>我的解法：前缀和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysDivByK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            A[i] = i==<span class="number">0</span>?A[<span class="number">0</span>]:A[i<span class="number">-1</span>]+A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((A[j]-A[i])%K==<span class="number">0</span>)</span><br><span class="line">                    count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(A[i]%K==<span class="number">0</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <em>encoded_string</em> 正好重复 <em>k</em> 次。注意 <em>k</em> 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <em>k</em> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</span><br><span class="line">s &#x3D; &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</span><br><span class="line">s &#x3D; &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="官方解法：栈操作"><a href="#官方解法：栈操作" class="headerlink" title="官方解法：栈操作"></a>官方解法：栈操作</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题中可能出现括号嵌套的情况，比如 <code>2[a2[bc]]</code>，这种情况下我们可以先转化成 <code>2[abcbc]</code>，在转化成 <code>abcbcabcbc</code>。我们可以把字母、数字和括号看成是独立的 TOKEN，并用栈来维护这些 TOKEN。具体的做法是，遍历这个栈：</p>
<ul>
<li><p>如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈</p>
</li>
<li><p>如果当前的字符为字母或者左括号，直接进栈</p>
</li>
<li><p>如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字（<strong>此时栈顶一定是数字，想想为什么？</strong>），就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈</p>
<p>重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来，就得到了答案。注意：<strong>这里可以用不定长数组来模拟栈操作，方便从栈底向栈顶遍历。</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getDigits</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">size_t</span> &amp;ptr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[ptr])) &#123;</span><br><span class="line">            ret.push_back(s[ptr++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s: v) &#123;</span><br><span class="line">            ret += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line">        <span class="keyword">size_t</span> ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s[ptr];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(cur)) &#123;</span><br><span class="line">                <span class="comment">// 获取一个数字并进栈</span></span><br><span class="line">                <span class="built_in">string</span> digits = getDigits(s, ptr);</span><br><span class="line">                stk.push_back(digits);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(cur) || cur == <span class="string">'['</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取一个字母并进栈</span></span><br><span class="line">                stk.push_back(<span class="built_in">string</span>(<span class="number">1</span>, s[ptr++])); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                <span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; sub;</span><br><span class="line">                <span class="keyword">while</span> (stk.back() != <span class="string">"["</span>) &#123;</span><br><span class="line">                    sub.push_back(stk.back());</span><br><span class="line">                    stk.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                reverse(sub.<span class="built_in">begin</span>(), sub.<span class="built_in">end</span>());</span><br><span class="line">                <span class="comment">// 左括号出栈</span></span><br><span class="line">                stk.pop_back();</span><br><span class="line">                <span class="comment">// 此时栈顶为当前 sub 对应的字符串应该出现的次数</span></span><br><span class="line">                <span class="keyword">int</span> repTime = stoi(stk.back()); </span><br><span class="line">                stk.pop_back();</span><br><span class="line">                <span class="built_in">string</span> t, o = getString(sub);</span><br><span class="line">                <span class="comment">// 构造字符串</span></span><br><span class="line">                <span class="keyword">while</span> (repTime--) t += o; </span><br><span class="line">                <span class="comment">// 将构造好的字符串入栈</span></span><br><span class="line">                stk.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getString(stk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法：动态规划"><a href="#我的解法：动态规划" class="headerlink" title="我的解法：动态规划"></a>我的解法：动态规划</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">money</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                money[i] = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">                money[i] = <span class="built_in">max</span>(money[i<span class="number">-1</span>],nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                money[i] = <span class="built_in">max</span>(money[i<span class="number">-1</span>],money[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="198-打家劫舍-1"><a href="#198-打家劫舍-1" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<h4 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法：动态规划-1"><a href="#我的解法：动态规划-1" class="headerlink" title="我的解法：动态规划"></a>我的解法：动态规划</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">money</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                money[i] = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">                money[i] = <span class="built_in">max</span>(money[i<span class="number">-1</span>],nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                money[i] = <span class="built_in">max</span>(money[i<span class="number">-1</span>],money[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt="img"></p>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="img"></p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我们需要在柱状图中找出最大的矩形，因此我们可以考虑枚举矩形的宽和高，其中「宽」表示矩形贴着柱状图底边的宽度，「高」表示矩形在柱状图上的高度。</p>
<ul>
<li><p>如果我们枚举「宽」，我们可以使用两重循环枚举矩形的左右边界以固定宽度 <code>w</code>，此时矩形的高度 <code>h</code>，就是所有包含在内的柱子的「最小高度」，对应的面积为 <code>w * h</code>。下面给出了这种方法的 <code>C++</code> 代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; n; ++left) &#123;</span><br><span class="line">            <span class="keyword">int</span> minHeight = INT_MAX;</span><br><span class="line">            <span class="comment">// 枚举右边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> right = left; right &lt; n; ++right) &#123;</span><br><span class="line">                <span class="comment">// 确定高度</span></span><br><span class="line">                minHeight = <span class="built_in">min</span>(minHeight, heights[right]);</span><br><span class="line">                <span class="comment">// 计算面积</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (right - left + <span class="number">1</span>) * minHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们枚举「高」，我们可以使用一重循环枚举某一根柱子，将其固定为矩形的高度 <code>h</code>。随后我们从这跟柱子开始向两侧延伸，直到遇到高度小于 <code>h</code> 的柱子，就确定了矩形的左右边界。如果左右边界之间的宽度为 <code>w</code>，那么对应的面积为 <code>w * h</code>。下面给出了这种方法的 <code>C++</code> 代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">0</span>; mid &lt; n; ++mid) &#123;</span><br><span class="line">            <span class="comment">// 枚举高</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">height</span> = heights[mid];</span><br><span class="line">            <span class="keyword">int</span> left = mid, right = mid;</span><br><span class="line">            <span class="comment">// 确定左右边界</span></span><br><span class="line">            <span class="keyword">while</span> (left - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; heights[left - <span class="number">1</span>] &gt;= <span class="built_in">height</span>) &#123;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right + <span class="number">1</span> &lt; n &amp;&amp; heights[right + <span class="number">1</span>] &gt;= <span class="built_in">height</span>) &#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算面积</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right - left + <span class="number">1</span>) * <span class="built_in">height</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可以发现，这两种暴力方法的时间复杂度均为 <code>O(N^2)</code>，会超出时间限制，我们必须要进行优化。考虑到枚举「宽」的方法使用了两重循环，本身就已经需要 O(N^2)<em>O</em>(<em>N</em>2) 的时间复杂度，不容易优化，因此我们可以考虑优化只使用了一重循环的枚举「高」的方法。</p>
<h4 id="方法一：单调栈"><a href="#方法一：单调栈" class="headerlink" title="方法一：单调栈"></a>方法一：单调栈</h4><p><strong>思路</strong></p>
<p>我们归纳一下枚举「高」的方法：</p>
<ul>
<li>首先我们枚举某一根柱子 i 作为高 $h = \textit{heights}[i]$；</li>
<li>随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 h。换句话说，我们需要找到<strong>左右两侧最近的高度小于 h 的柱子</strong>，这样这两根柱子之间（不包括其本身）的所有柱子高度均不小于 h，并且就是 i 能够扩展到的最远范围。</li>
</ul>
<p>那么我们先来看看如何求出<strong>一根柱子的左侧且最近的小于其高度的柱子</strong>。除了根据「前言」部分暴力地进行枚举之外，我们可以通过如下的一个结论来深入地进行思考：</p>
<blockquote>
<p>对于两根柱子 $j_0$以及 $j_1$，如果 $j_0 &lt; j_1$并且 $\textit{heights}[j_0] \geq \textit{heights}[j_1]$，那么<strong>对于任意的在它们之后出现的柱子 i（$j_1 &lt; i$），$j_0$ 一定不会是 $i$ 左侧且最近的小于其高度的柱子</strong>。</p>
</blockquote>
<p>换句话说，如果有两根柱子 $j_0$ 和 $j_1$，其中 $j_0$ 在 $j_1$ 的左侧，并且 $j_0$ 的高度大于等于 $j_1$，那么在后面的柱子 $i$ 向左找小于其高度的柱子时，$j_1$ 会「挡住」$j_0$，$j_0$ 就不会作为答案了。</p>
<p>这样以来，我们可以对数组从左向右进行遍历，同时维护一个「可能作为答案」的数据结构，其中按照从小到大的顺序存放了一些 j 值。根据上面的结论，如果我们存放了 $j_0, j_1, \cdots, j_s$，那么一定有 $\textit{height}[j_0] &lt; \textit{height}[j_1] &lt; \cdots &lt; \textit{height}[j_s]$，因为如果有两个相邻的 j值对应的高度不满足 &lt; 关系，那么后者会「挡住」前者，前者就不可能作为答案了。</p>
<p>当我们枚举到第 i<em>i</em> 根柱子时，我们的数据结构中存放了 j_0, j_1, \cdots, j_s<em>j</em>0,<em>j</em>1,⋯,<em>j*<em>s</em>，如果第 i*i</em> 根柱子左侧且最近的小于其高度的柱子为 j_i<em>j*</em>i<em>，那么必然有<br>$$<br>\textit{height}[j_0] &lt; \textit{height}[j_1] &lt; \cdots &lt; \textit{height}[j_i] &lt; \textit{height}[i] \leq \textit{height}[j_{i+1}] &lt; \cdots &lt; \textit{height}[j_s]<br>$$<br>这样我们就可以使用二分查找的方法找到 $i$对应的 $j_i$，*</em>但真的需要吗<strong>？当我们枚举到 $i+1$ 时，原来的 $i$ 也变成了 $j$ 值，因此 $i$ 会被放入数据结构。由于所有在数据结构中的 $j$ 值均小于 $i$，那么所有高度大于等于 $\textit{height}[i]$ 的 j 都不会作为答案，需要从数据结构中移除。而我们发现，这些被移除的 $j$ 值恰好就是<br>$$<br>j_{i+1}, \cdots, j_s<br>$$<br>这样我们在枚举到第 i 根柱子的时候，就可以先把所有高度大于等于 $\textit{height}[i]$ 的 $j$ 值全部移除，剩下的 $j$ 值中高度最高的即为答案。在这之后，我们将 i 放入数据结构中，开始接下来的枚举。此时，我们需要使用的数据结构也就呼之欲出了，它就是</strong>栈**。</p>
<ul>
<li>栈中存放了 j 值。从栈底到栈顶，j 的值严格单调递增，同时对应的高度值也严格单调递增；</li>
<li>当我们枚举到第 i 根柱子时，我们从栈顶不断地移除 $\textit{height}[j] \geq \textit{height}[i]$ 的 j 值。在移除完毕后，栈顶的 j 值就一定满足 $\textit{height}[j] &lt; \textit{height}[i]$，此时 j 就是 i 左侧且最近的小于其高度的柱子。<ul>
<li>这里会有一种特殊情况。如果我们移除了栈中所有的 j 值，那就说明 i 左侧所有柱子的高度都大于 $\textit{height}[i]$，那么我们可以认为 i左侧且最近的小于其高度的柱子在位置 $j=-1$，它是一根「虚拟」的、高度无限低的柱子。这样的定义不会对我们的答案产生任何的影响，我们也称这根「虚拟」的柱子为「哨兵」。</li>
</ul>
</li>
<li>我们再将 i放入栈顶。</li>
</ul>
<p>栈中存放的元素具有单调性，这就是经典的数据结构「单调栈」了。</p>
<p><strong>例子</strong></p>
<p>我们用一个具体的例子 <code>[6, 7, 5, 2, 4, 5, 9, 3]</code>来帮助读者理解单调栈。我们需要求出每一根柱子的左侧且最近的小于其高度的柱子。初始时的栈为空。</p>
<ul>
<li>我们枚举 6，因为栈为空，所以 6 左侧的柱子是「哨兵」，位置为 -1。随后我们将 6 入栈。<ul>
<li>栈：<code>[6(0)]</code>。（这里括号内的数字表示柱子在原数组中的位置）</li>
</ul>
</li>
<li>我们枚举 7，由于 6&lt;7，因此不会移除栈顶元素，所以 7 左侧的柱子是 6，位置为 0。随后我们将 7 入栈。<ul>
<li>栈：<code>[6(0), 7(1)]</code></li>
</ul>
</li>
<li>我们枚举 5，由于 $7\geq 5$，因此移除栈顶元素 7。同样地，$6 \geq 5$,再移除栈顶元素 6。此时栈为空，所以 5 左侧的柱子是「哨兵」，位置为 -1。随后我们将 5 入栈。<ul>
<li>栈：<code>[5(2)]</code></li>
</ul>
</li>
<li>接下来的枚举过程也大同小异。我们枚举 2，移除栈顶元素 5，得到 2 左侧的柱子是「哨兵」，位置为 -1。将 2 入栈。<ul>
<li>栈：<code>[2(3)]</code></li>
</ul>
</li>
<li>我们枚举 4，5 和 9，都不会移除任何栈顶元素，得到它们左侧的柱子分别是 2，4 和 5，位置分别为 3，4 和 5。将它们入栈。<ul>
<li>栈：<code>[2(3), 4(4), 5(5), 9(6)]</code></li>
</ul>
</li>
<li>我们枚举 3，依次移除栈顶元素 9，5 和 4，得到 3 左侧的柱子是 2，位置为 3。将 3 入栈。<ul>
<li>栈：<code>[2(3), 3(7)]</code></li>
</ul>
</li>
</ul>
<p>这样以来，我们得到它们左侧的柱子编号分别为 [-1, 0, -1, -1, 3, 4, 5, 3]。用相同的方法，我们从右向左进行遍历，也可以得到它们右侧的柱子编号分别为 [2, 2, 3, 8, 7, 7, 7, 8]，这里我们将位置 8 看作「哨兵」。</p>
<p>在得到了左右两侧的柱子之后，我们就可以计算出每根柱子对应的左右边界，并求出答案了。</p>
<p><strong>分析</strong></p>
<p>单调栈的时间复杂度是多少？直接计算十分困难，但是我们可以发现：</p>
<blockquote>
<p>每一个位置只会入栈一次（在枚举到它时），并且最多出栈一次。</p>
</blockquote>
<p>因此当我们从左向右/总右向左遍历数组时，对栈的操作的次数就为 O(N)。所以单调栈的总时间复杂度为 O(N)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;int&gt; left(n), right(n);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mono_stack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.empty() &amp;&amp; heights[mono_stack.top()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.empty() ? <span class="number">-1</span> : mono_stack.top());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mono_stack = <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.empty() &amp;&amp; heights[mono_stack.top()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = (mono_stack.empty() ? n : mono_stack.top());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，检查它是否是镜像对称的。 </p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>



<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root-&gt;left);</span><br><span class="line">        que.push(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* l=que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            TreeNode* r=que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (l&amp;&amp;r&amp;&amp;l-&gt;val==r-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(l-&gt;left);</span><br><span class="line">                que.push(r-&gt;right);</span><br><span class="line">                que.push(l-&gt;right);</span><br><span class="line">                que.push(r-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l==r&amp;&amp;l==<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡 5-18~24</title>
    <url>/2020/05/18/2020-05-18-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>本周打卡题目如下：</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">680. 验证回文字符串 Ⅱ</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">1371. 每个元音包含偶数次的最长子字符串</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></td>
<td>困难</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></td>
<td>困难</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">product</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res,nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                product[i] =nums[i]; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(product[i<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">                    product[i] = nums[i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    product[i] = product[i<span class="number">-1</span>]*nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res,product[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> zero = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j;k&lt;=i;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[k]==<span class="number">0</span>) </span><br><span class="line">                    &#123;</span><br><span class="line">                        zero = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(zero) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span>(product[j])</span><br><span class="line">                    res = <span class="built_in">max</span>(res,product[i]/product[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>暴力超时了</p>
<h3 id="暴力法2"><a href="#暴力法2" class="headerlink" title="暴力法2"></a>暴力法2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res,nums[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;= i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j ; k &lt; i;k++)</span><br><span class="line">                    tmp *= nums[k];</span><br><span class="line">                res = <span class="built_in">max</span>(res,tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-动态规划"><a href="#官方解法-动态规划" class="headerlink" title="官方解法: 动态规划"></a>官方解法: 动态规划</h3><p><strong>思路和算法</strong></p>
<p>如果我们用 $f_{\max}(i)$ 开表示以第 i<em>i</em> 个元素结尾的乘积最大子数组的乘积，a<em>a</em> 表示输入参数 <code>nums</code>，那么根据「53. 最大子序和」的经验，我们很容易推导出这样的状态转移方程：</p>
<p>$f_{\max}(i) = \max_{i = 1}^{n} { f(i - 1) \times a_i, a_i }$</p>
<p>它表示以第 $i$ 个元素结尾的乘积最大子数组的乘积可以考虑 $a_i$ 加入前面的 $f_{\max}(i - 1)$ 对应的一段，或者单独成为一段，这里两种情况下取最大值。求出所有的 $f_{\max}(i) $之后选取最大的一个作为答案。</p>
<p><strong>可是在这里，这样做是错误的。为什么呢？</strong></p>
<p>因为这里的定义并不满足「最优子结构」。具体地讲，如果 $a = { 5, 6, -3, 4, -3 }$，那么此时 $f_{\max}$对应的序列是 ${ 5, 30, -3, 4, -3 }$，按照前面的算法我们可以得到答案为 $30$，即前两个数的乘积，而实际上答案应该是全体数字的乘积。我们来想一想问题出在哪里呢？问题出在最后一个 -3−3 所对应的 $f_{\max}$ 的值既不是 $-3$，也不是 $4 \times -3$，而是 $5 \times 30 \times (-3) \times 4 \times (-3)$。所以我们得到了一个结论：当前位置的最优解未必是由前一个位置的最优解转移得到的。</p>
<p><strong>我们可以根据正负性进行分类讨论。</strong></p>
<p>考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。于是这里我们可以再维护一个 $f_{\min}(i)$，它表示以第 i<em>i</em> 个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：<br>$$<br>\begin{aligned} f_{\max}(i) &amp;= \max_{i = 1}^{n} { f_{\max}(i - 1) \times a_i, f_{\min}(i - 1) \times a_i, a_i } \ f_{\min}(i) &amp;= \min_{i = 1}^{n} { f_{\max}(i - 1) \times a_i, f_{\min}(i - 1) \times a_i, a_i } \end{aligned}<br>$$<br>它代表第 $i$ 个元素结尾的乘积最大子数组的乘积 $f_{\max}(i)$，可以考虑把 $a_i$ 加入第 $i - 1$ 个元素结尾的乘积最大或最小的子数组的乘积中，二者加上 $a_i$，三者取大，就是第 i<em>i</em> 个元素结尾的乘积最大子数组的乘积。第 i 个元素结尾的乘积最小子数组的乘积 $f_{\min}(i)$ 同理。</p>
<p>不难给出这样的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; maxF(nums), minF(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            maxF[i] = <span class="built_in">max</span>(maxF[i - <span class="number">1</span>] * nums[i], <span class="built_in">max</span>(nums[i], minF[i - <span class="number">1</span>] * nums[i]));</span><br><span class="line">            minF[i] = <span class="built_in">min</span>(minF[i - <span class="number">1</span>] * nums[i], <span class="built_in">min</span>(nums[i], maxF[i - <span class="number">1</span>] * nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(maxF.<span class="built_in">begin</span>(), maxF.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优化空间"><a href="#优化空间" class="headerlink" title="优化空间"></a>优化空间</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxF = nums[<span class="number">0</span>], minF = nums[<span class="number">0</span>], ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> mx = maxF, mn = minF;</span><br><span class="line">            maxF = <span class="built_in">max</span>(mx * nums[i], <span class="built_in">max</span>(nums[i], mn * nums[i]));</span><br><span class="line">            minF = <span class="built_in">min</span>(mn * nums[i], <span class="built_in">min</span>(nums[i], mx * nums[i]));</span><br><span class="line">            ans = <span class="built_in">max</span>(maxF, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">680. 验证回文字符串 Ⅱ</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abca&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 你可以删除c字符。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=len/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[len<span class="number">-1</span>-i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;i&lt;&lt;' '&lt;&lt;len-1-i&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">return</span> check(s,i,len<span class="number">-2</span>-i)||check(s,i+<span class="number">1</span>,len<span class="number">-1</span>-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;= (right-left)/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left+i]!=s[right-i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1371-每个元音包含偶数次的最长子字符串"><a href="#1371-每个元音包含偶数次的最长子字符串" class="headerlink" title="1371. 每个元音包含偶数次的最长子字符串"></a><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">1371. 每个元音包含偶数次的最长子字符串</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 <code>&#39;a&#39;，&#39;e&#39;，&#39;i&#39;，&#39;o&#39;，&#39;u&#39;</code>，在子字符串中都恰好出现了偶数次。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;eleetminicoworoep&quot;</span><br><span class="line">输出：13</span><br><span class="line">解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcodeisgreat&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;bcbcbc&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。</span><br></pre></td></tr></table></figure>

<h3 id="官方解法："><a href="#官方解法：" class="headerlink" title="官方解法："></a>官方解法：</h3><p>前缀和+状态压缩</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, status = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pos</span><span class="params">(<span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        pos[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'a'</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'e'</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'i'</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'o'</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'u'</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果pos[status]==0 即全为偶数的话</span></span><br><span class="line">            <span class="keyword">if</span> (~pos[status]) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i + <span class="number">1</span> - pos[status]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pos[status] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法1：动态规划"><a href="#官方解法1：动态规划" class="headerlink" title="官方解法1：动态规划"></a>官方解法1：动态规划</h3><p>方法一：动态规划<br>思路与算法</p>
<p>对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 $\textrm{<code>ababa&#39;&#39;}$，如果我们已经知道 $\textrm{</code>bab’’}$ 是回文串，那么 $\textrm{<code>ababa&#39;&#39;}$ 一定是回文串，这是因为它的首尾两个字母都是 $\textrm{</code>a’’}$。</p>
<p>根据这样的思路，我们就可以用动态规划的方法解决本题。我们用 $P(i,j))$ 表示字符串 s 的第 i 到 j个字母组成的串（下文表示成 $s[i:j]$）是否为回文串：<br>$$<br>P(i,j) = \begin{cases} \text{true,} &amp;\quad\text{如果子串<del>} S_i \dots S_j \text{</del>是回文串}\ \text{false,} &amp;\quad\text{其它情况} \end{cases}<br>$$<br>如果子串 $S_i…S_j$  是回文串。</p>
<p>其它情况</p>
<p>这里的「其它情况」包含两种可能性：$s[i, j]$ 本身不是一个回文串；$i &gt; j$，此时 $s[i, j]$] 本身不合法。</p>
<p>那么我们就可以写出动态规划的状态转移方程：<br>$$<br>P(i, j) = P(i+1, j-1) \wedge (S_i == S_j)<br>$$<br>也就是说，只有$ s[i+1:j-1]s[i+1:j−1] $是回文串，并且 s 的第 i 和 j 个字母相同时，$s[i:j]$ 才会是回文串。</p>
<p>上文的所有讨论是建立在子串长度大于 22 的前提之上的，我们还需要考虑动态规划中的边界条件，即子串的长度为 11 或 22。对于长度为 11 的子串，它显然是个回文串；对于长度为 22 的子串，只要它的两个字母相同，它就是一个回文串。因此我们就可以写出动态规划的边界条件：<br>$$<br>\begin{cases} P(i, i) = \text{true} \ P(i, i+1) = ( S_i == S_{i+1} ) \end{cases}<br>$$</p>
<p>根据这个思路，我们就可以完成动态规划了，最终的答案即为所有 $P(i, j) = \text{true} $中 $j-i+1$（即子串长度）的最大值。注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + l &lt; n; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + l;</span><br><span class="line">                <span class="keyword">if</span> (l == <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = (s[i] == s[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; l + <span class="number">1</span> &gt; ans.<span class="built_in">size</span>()) </span><br><span class="line">                &#123;</span><br><span class="line">                    ans = s.substr(i, l + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法2：中心扩展算法"><a href="#官方解法2：中心扩展算法" class="headerlink" title="官方解法2：中心扩展算法"></a>官方解法2：中心扩展算法</h3><p>我们仔细观察一下方法一中的状态转移方程：<br>$$<br>\begin{cases} P(i, i) &amp;=\quad \text{true} \ P(i, i+1) &amp;=\quad ( S_i == S_{i+1} ) \ P(i, j) &amp;=\quad P(i+1, j-1) \wedge (S_i == S_j) \end{cases}<br>$$</p>
<p>找出其中的状态转移链：</p>
<p>$P(i, j) \leftarrow P(i+1, j-1) \leftarrow P(i+2, j-2) \leftarrow \cdots \leftarrow \text{某一边界情况}$</p>
<p>可以发现，所有的状态在转移的时候的可能性都是唯一的。也就是说，我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案。</p>
<p>边界情况即为子串长度为 11 或 22 的情况。我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母相同，我们就可以继续扩展，例如从 P(i+1,j-1)P(i+1,j−1) 扩展到 P(i,j)P(i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。</p>
<p>聪明的读者此时应该可以发现，「边界情况」对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。方法二的本质即为：我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;int, int&gt; expandAroundCenter(const string&amp; s, int left, int right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [left1, right1] = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="keyword">auto</span> [left2, right2] = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (right1 - left1 &gt; <span class="built_in">end</span> - start) &#123;</span><br><span class="line">                start = left1;</span><br><span class="line">                <span class="built_in">end</span> = right1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right2 - left2 &gt; <span class="built_in">end</span> - start) &#123;</span><br><span class="line">                start = left2;</span><br><span class="line">                <span class="built_in">end</span> = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, <span class="built_in">end</span> - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法三：Manacher-算法"><a href="#官方解法三：Manacher-算法" class="headerlink" title="官方解法三：Manacher 算法"></a>官方解法三：Manacher 算法</h3><p>还有一个复杂度为 $O(n)$的 Manacher 算法。然而本算法十分复杂，一般不作为面试内容。这里给出，仅供有兴趣的同学挑战自己。</p>
<p>为了表述方便，我们定义一个新概念臂长，表示中心扩展算法向外扩展的长度。如果一个位置的最大回文字符串长度为 2 * length + 1 ，其臂长为 length。</p>
<p>下面的讨论只涉及长度为奇数的回文字符串。长度为偶数的回文字符串我们将会在最后与长度为奇数的情况统一起来。</p>
<p>思路与算法</p>
<p>在中心扩展算法的过程中，我们能够得出每个位置的臂长。那么当我们要得出以下一个位置 i 的臂长时，能不能利用之前得到的信息呢？</p>
<p>答案是肯定的。具体来说，如果位置 j 的臂长为 length，并且有 j + length &gt; i，如下图所示：</p>
<p>当在位置 i 开始进行中心拓展时，我们可以先找到 i 关于 j 的对称点 2 * j - i。那么如果点 2 * j - i 的臂长等于 n，我们就可以知道，点 i 的臂长至少为 min(j + length - i, n)。那么我们就可以直接跳过 i 到 i + min(j + length - i, n) 这部分，从 i + min(j + length - i, n) + 1 开始拓展。</p>
<p>我们只需要在中心扩展法的过程中记录右臂在最右边的回文字符串，将其中心作为 j，在计算过程中就能最大限度地避免重复计算。</p>
<p>那么现在还有一个问题：如何处理长度为偶数的回文字符串呢？</p>
<p>我们可以通过一个特别的操作将奇偶数的情况统一起来：我们向字符串的头尾以及每两个字符中间添加一个特殊字符 #，比如字符串 aaba 处理后会变成 #a#a#b#a#。那么原先长度为偶数的回文字符串 aa 会变成长度为奇数的回文字符串 #a#a#，而长度为奇数的回文字符串 aba 会变成长度仍然为奇数的回文字符串 #a#b#a#，我们就不需要再考虑长度为偶数的回文字符串了。</p>
<p>注意这里的特殊字符不需要是没有出现过的字母，我们可以使用任何一个字符来作为这个特殊字符。这是因为，当我们只考虑长度为奇数的回文字符串时，每次我们比较的两个字符奇偶性一定是相同的，所以原来字符串中的字符不会与插入的特殊字符互相比较，不会因此产生问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (right - left - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s) &#123;</span><br><span class="line">            t += c;</span><br><span class="line">            t += <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t += <span class="string">'#'</span>;</span><br><span class="line">        s = t;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arm_len;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">-1</span>, j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur_arm_len;</span><br><span class="line">            <span class="keyword">if</span> (right &gt;= i) &#123;</span><br><span class="line">                <span class="keyword">int</span> i_sym = j * <span class="number">2</span> - i;</span><br><span class="line">                <span class="keyword">int</span> min_arm_len = <span class="built_in">min</span>(arm_len[i_sym], right - i);</span><br><span class="line">                cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur_arm_len = expand(s, i, i);</span><br><span class="line">            &#125;</span><br><span class="line">            arm_len.push_back(cur_arm_len);</span><br><span class="line">            <span class="keyword">if</span> (i + cur_arm_len &gt; right) &#123;</span><br><span class="line">                j = i;</span><br><span class="line">                right = i + cur_arm_len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur_arm_len * <span class="number">2</span> + <span class="number">1</span> &gt; <span class="built_in">end</span> - start) &#123;</span><br><span class="line">                start = i - cur_arm_len;</span><br><span class="line">                <span class="built_in">end</span> = i + cur_arm_len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">'#'</span>) &#123;</span><br><span class="line">                ans += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n)$，其中 n 是字符串的长度。由于对于每个位置，扩展要么从当前的最右侧臂长 right 开始，要么只会进行一步，而 right 最多向前走 $O(n)$ 步，因此算法的复杂度为 $O(n)$。</p>
<p>空间复杂度：$O(n)$，我们需要 $O(n)$ 的空间记录每个位置的臂长。</p>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<h3 id="我的解法：递归"><a href="#我的解法：递归" class="headerlink" title="我的解法：递归"></a>我的解法：递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        TreeNode* root = helper(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>,inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> preleft,<span class="keyword">int</span> preright,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> inleft,<span class="keyword">int</span> inright)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"pre: "&lt;&lt;preleft&lt;&lt;','&lt;&lt;preright&lt;&lt;" inleft:"&lt;&lt;inleft&lt;&lt;','&lt;&lt;inright&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(preleft&gt;preright)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> val = preorder[preleft];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inleft;i&lt;=inright;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==val)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lenleft = mid - inleft;</span><br><span class="line">        <span class="keyword">int</span> lenright = inright - mid;</span><br><span class="line">        <span class="keyword">if</span>(lenleft&gt;<span class="number">0</span>||lenright&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = helper (preorder,preleft+<span class="number">1</span>,preleft+lenleft, inorder,inleft,mid<span class="number">-1</span>);</span><br><span class="line">            root-&gt;right = helper(preorder,preleft+<span class="number">1</span>+lenleft,  preright,inorder,mid+<span class="number">1</span>,inright);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法二：迭代"><a href="#官方解法二：迭代" class="headerlink" title="官方解法二：迭代"></a>官方解法二：迭代</h3><p><strong>思路</strong></p>
<p>迭代法是一种非常巧妙的实现方法。</p>
<p>对于前序遍历中的任意两个连续节点 u和 v，根据前序遍历的流程，我们可以知道 u 和 v 只有两种可能的关系：</p>
<p>v 是 u 的左儿子。这是因为在遍历到 u 之后，下一个遍历的节点就是 u 的左儿子，即 v；</p>
<p>u没有左儿子，并且 v 是 u 的某个祖先节点（或者 u 本身）的右儿子。如果 u 没有左儿子，那么下一个遍历的节点就是 u 的右儿子。如果 u 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 u 不在它的右儿子的子树中）的节点 $u_a$ ，那么 v 就是 $u_a$的右儿子。</p>
<p>第二种关系看上去有些复杂。我们举一个例子来说明其正确性，并在例子中给出我们的迭代算法。</p>
<p>例子：我们以树</p>
<pre><code>        3
       / \
      9  20
     /  /  \
    8  15   7
   / \
  5  10
 /
4</code></pre><p>为例，它的前序遍历和中序遍历分别为</p>
<p><code>preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]</code><br><code>inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]</code><br>我们用一个栈 stack 来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针 index 指向中序遍历的某个位置，初始值为 0。index 对应的节点是「当前节点不断往左走达到的最终节点」，这也是符合中序遍历的，它的作用在下面的过程中会有所体现。</p>
<p>首先我们将根节点 3 入栈，再初始化 index 所指向的节点为 4，随后对于前序遍历中的每个节点，我们依此判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p>
<p>我们遍历 9。9 一定是栈顶节点 3 的左儿子。我们使用反证法，假设 9 是 3 的右儿子，那么 3 没有左儿子，index 应该恰好指向 3，但实际上为 4，因此产生了矛盾。所以我们将 9 作为 3 的左儿子，并将 9 入栈。</p>
<p><code>stack = [3, 9]</code><br><code>index -&gt; inorder[0] = 4</code><br>我们遍历 8，5 和 4。同理可得它们都是上一个节点（栈顶节点）的左儿子，所以它们会依次入栈。</p>
<p><code>stack = [3, 9, 8, 5, 4]</code><br><code>index -&gt; inorder[0] = 4</code><br>我们遍历 10，这时情况就不一样了。我们发现 index 恰好指向当前的栈顶节点 4，也就是说 4 没有左儿子，那么 10 必须为栈中某个节点的右儿子。那么如何找到这个节点呢？栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的。</p>
<p>这是因为栈中的任意两个相邻的节点，前者都是后者的某个祖先。并且我们知道，栈中的任意一个节点的右儿子还没有被遍历过，说明后者一定是前者左儿子的子树中的节点，那么后者就先于前者出现在中序遍历中。</p>
<p>因此我们可以把 index 不断向右移动，并与栈顶节点进行比较。如果 index 对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了栈顶节点，所以将 index 增加 1 并弹出栈顶节点，直到 index 对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后一个节点 x 就是 10 的双亲节点，这是因为 10 出现在了 x 与 x 在栈中的下一个节点的中序遍历之间，因此 10 就是 x 的右儿子。</p>
<p>回到我们的例子，我们会依次从栈顶弹出 4，5 和 8，并且将 index 向右移动了三次。我们将 10 作为最后弹出的节点 8 的右儿子，并将 10 入栈。</p>
<p><code>stack = [3, 9, 10]</code><br><code>index -&gt; inorder[3] = 10</code><br>我们遍历 20。同理，index 恰好指向当前栈顶节点 10，那么我们会依次从栈顶弹出 10，9 和 3，并且将 index 向右移动了三次。我们将 20 作为最后弹出的节点 3 的右儿子，并将 20 入栈。</p>
<p><code>stack = [20]</code><br><code>index -&gt; inorder[6] = 15</code><br>我们遍历 15，将 15 作为栈顶节点 20 的左儿子，并将 15 入栈。</p>
<p><code>stack = [20, 15]</code><br><code>index -&gt; inorder[6] = 15</code><br>我们遍历 7。index 恰好指向当前栈顶节点 15，那么我们会从栈顶弹出 15，并且将 index 向右移动一次。我们将 7 作为最后弹出的节点 15 的右儿子，并将 7 入栈。</p>
<p><code>stack = [20, 7]</code><br><code>index -&gt; inorder[7] = 20</code><br>此时遍历结束，我们就构造出了正确的二叉树。</p>
<p><strong>算法</strong></p>
<p>我们归纳出上述例子中的算法流程：</p>
<ul>
<li><p>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p>
</li>
<li><p>我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</p>
</li>
</ul>
<p>无论是哪一种情况，我们最后都将当前的节点入栈。</p>
<p>最后得到的二叉树即为答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!preorder.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="keyword">int</span> inorderIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> preorderVal = preorder[i];</span><br><span class="line">            TreeNode* node = stk.top();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">                stk.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top()-&gt;val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    ++inorderIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">                stk.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n是树中的节点个数。</p>
<p>空间复杂度：O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(h)（其中 h 是树的高度）的空间存储栈。这里 h &lt; n，所以（在最坏情况下）总空间复杂度为 O(n)。</p>
<h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;</span><br><span class="line">输出: &quot;BANC&quot;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>如果 S 中不存这样的子串，则返回空字符串 <code>&quot;&quot;</code>。</li>
<li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<h3 id="我的解法：滑动窗口"><a href="#我的解法：滑动窗口" class="headerlink" title="我的解法：滑动窗口"></a>我的解法：滑动窗口</h3><p>思路：我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cntmap;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:t) <span class="built_in">map</span>[ch]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        cntmap[s[l]]++;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(check())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res==<span class="string">""</span> || r-l+<span class="number">1</span>&lt;res.length())</span><br><span class="line">                &#123;</span><br><span class="line">                    res = s.substr(l,r-l+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cntmap[s[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                r++;</span><br><span class="line">                <span class="keyword">if</span>(r&gt;=s.length()) <span class="keyword">return</span> res;</span><br><span class="line">                cntmap[s[r]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = <span class="built_in">map</span>.<span class="built_in">begin</span>();iter!=<span class="built_in">map</span>.<span class="built_in">end</span>();iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;second &gt; cntmap[iter-&gt;first])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。</p>
<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。 </p>
<h4 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>

<h3 id="我的解法：偷懒了"><a href="#我的解法：偷懒了" class="headerlink" title="我的解法：偷懒了"></a>我的解法：偷懒了</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums2)</span><br><span class="line">            nums1.push_back(n);</span><br><span class="line">        sort(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> len = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums1[len/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> (nums1[len/<span class="number">2</span>]+nums1[len/<span class="number">2</span><span class="number">-1</span>])/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlog(n));</p>
<h3 id="官方解法：二分查找"><a href="#官方解法：二分查找" class="headerlink" title="官方解法：二分查找"></a>官方解法：二分查找</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 "/" 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="keyword">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="keyword">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKthElement(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (getKthElement(nums1, nums2, totalLength / <span class="number">2</span>) + getKthElement(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>算法复杂度:O(log(m+n))</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多线程编程</title>
    <url>/2020/05/15/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>多线程是学习SLAM过程中不可缺少的一步，正确的使用多线程能使SLAM系统的运行速度提升很多，达到更高的精度和速度。本节就来学习SLAM中的多线程编程方法。</p>
<a id="more"></a>

<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>线程在Unix系统下，通常被称为轻量级的进程，线程虽然不是进程，但却可以看作是Unix进程的表亲，同一进程中的多条线程将<strong>共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等</strong>。但同一进程中的多个线程<strong>有各自的调用栈(call stack)，自己的寄存器环境（register context)，自己的线程本地存储(thread-local storage)</strong>。 一个进程可以有很多线程，每条线程并行执行不同的任务。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>线程可以提高应用程序在多核环境下处理诸如文件I/O或者socket I/O等会产生堵塞的情况的表现性能。在Unix系统中，一个进程包含很多东西，包括可执行程序以及一大堆的诸如文件描述符地址空间等资源。在很多情况下，完成相关任务的不同代码间需要交换数据。如果采用多进程的方式，那么通信就需要在用户空间和内核空间进行频繁的切换，开销很大。但是如果使用多线程的方式，因为可以使用共享的全局变量，所以线程间的通信（数据交换）变得非常高效。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h4 id="一个简单的Demo"><a href="#一个简单的Demo" class="headerlink" title="一个简单的Demo"></a>一个简单的Demo</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helloworld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world \n"</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//开启一个线程 </span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(helloworld)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world main thread\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程的终结</span></span><br><span class="line">    t.join(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多线程库"><a href="#多线程库" class="headerlink" title="多线程库"></a>多线程库</h4><p><code>C++11</code>中终于提供了多线程的标准库，提供了线程管理、保护共享数据、线程间同步操作、原子操作等类。</p>
<p>多线程库对应的头文件是<code>#include&lt;thread&gt;</code>，类名为<code>std::thread</code>。</p>
<p>一个简单的串行程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm function_1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    function_1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个典型的单线程的单进程程序，任何程序都是一个进程，<code>main()</code>函数就是其中的主线程，单个线程都是顺序执行。</p>
<p>将上面的程序改造成多线程程序其实很简单，让<code>function_1()</code>函数在另外的线程中执行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm function_1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line">    <span class="comment">// do other things</span></span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li>首先，构建一个<code>std::thread</code>对象<code>t1</code>，构造的时候传递了一个参数，这个参数是一个函数，这个函数就是这个线程的<strong>入口函数</strong>，函数执行完了，整个线程也就执行完了。</li>
<li>线程创建成功后，就会<strong>立即启动</strong>，并没有一个类似<code>start</code>的函数来显式的启动线程。</li>
<li>一旦线程开始运行， 就需要显式的决定是要等待它完成(join)，或者分离它让它自行运行(detach)。注意：只需要在<code>std::thread</code>对象<strong>被销毁之前</strong>做出这个决定。这个例子中，对象<code>t1</code>是栈上变量，在<code>main</code>函数执行结束后就会被销毁，所以需要在<code>main</code>函数结束之前做决定。</li>
<li>这个例子中选择了使用<code>t1.join()</code>，主线程会一直阻塞着，直到子线程完成，<code>join()</code>函数的另一个任务是回收该线程中使用的资源。</li>
</ol>
<p><strong>线程对象和对象内部管理的线程的生命周期并不一样</strong>，如果线程执行的快，可能内部的线程已经结束了，但是线程对象还活着，也有可能线程对象已经被析构了，内部的线程还在运行。</p>
<h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>下面的程序，我们可以用它来创建一个 POSIX 线程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">pthread_create (thread, attr, start_routine, arg)</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>pthread_create</strong> 创建一个新的线程，并让它可执行。下面是关于参数的说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">thread</td>
<td align="left">指向线程标识符指针。</td>
</tr>
<tr>
<td align="left">attr</td>
<td align="left">一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td>
</tr>
<tr>
<td align="left">start_routine</td>
<td align="left">线程运行函数起始地址，一旦线程被创建就会执行。</td>
</tr>
<tr>
<td align="left">arg</td>
<td align="left">运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td>
</tr>
</tbody></table>
<p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p>
<h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">pthread_exit (status)</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>pthread_exit</strong> 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。</p>
<p>如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多线程编程</title>
    <url>/2020/05/15/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>多线程是学习SLAM过程中不可缺少的一步，正确的使用多线程能使SLAM系统的运行速度提升很多，达到更高的精度和速度。本节就来学习SLAM中的多线程编程方法。</p>
<a id="more"></a>

<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>线程在Unix系统下，通常被称为轻量级的进程，线程虽然不是进程，但却可以看作是Unix进程的表亲，同一进程中的多条线程将<strong>共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等</strong>。但同一进程中的多个线程<strong>有各自的调用栈(call stack)，自己的寄存器环境（register context)，自己的线程本地存储(thread-local storage)</strong>。 一个进程可以有很多线程，每条线程并行执行不同的任务。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>线程可以提高应用程序在多核环境下处理诸如文件I/O或者socket I/O等会产生堵塞的情况的表现性能。在Unix系统中，一个进程包含很多东西，包括可执行程序以及一大堆的诸如文件描述符地址空间等资源。在很多情况下，完成相关任务的不同代码间需要交换数据。如果采用多进程的方式，那么通信就需要在用户空间和内核空间进行频繁的切换，开销很大。但是如果使用多线程的方式，因为可以使用共享的全局变量，所以线程间的通信（数据交换）变得非常高效。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h4 id="一个简单的Demo"><a href="#一个简单的Demo" class="headerlink" title="一个简单的Demo"></a>一个简单的Demo</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helloworld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world \n"</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//开启一个线程 </span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(helloworld)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world main thread\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程的终结</span></span><br><span class="line">    t.join(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多线程库"><a href="#多线程库" class="headerlink" title="多线程库"></a>多线程库</h4><p><code>C++11</code>中终于提供了多线程的标准库，提供了线程管理、保护共享数据、线程间同步操作、原子操作等类。</p>
<p>多线程库对应的头文件是<code>#include&lt;thread&gt;</code>，类名为<code>std::thread</code>。</p>
<p>一个简单的串行程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm function_1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    function_1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个典型的单线程的单进程程序，任何程序都是一个进程，<code>main()</code>函数就是其中的主线程，单个线程都是顺序执行。</p>
<p>将上面的程序改造成多线程程序其实很简单，让<code>function_1()</code>函数在另外的线程中执行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm function_1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line">    <span class="comment">// do other things</span></span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li>首先，构建一个<code>std::thread</code>对象<code>t1</code>，构造的时候传递了一个参数，这个参数是一个函数，这个函数就是这个线程的<strong>入口函数</strong>，函数执行完了，整个线程也就执行完了。</li>
<li>线程创建成功后，就会<strong>立即启动</strong>，并没有一个类似<code>start</code>的函数来显式的启动线程。</li>
<li>一旦线程开始运行， 就需要显式的决定是要等待它完成(join)，或者分离它让它自行运行(detach)。注意：只需要在<code>std::thread</code>对象<strong>被销毁之前</strong>做出这个决定。这个例子中，对象<code>t1</code>是栈上变量，在<code>main</code>函数执行结束后就会被销毁，所以需要在<code>main</code>函数结束之前做决定。</li>
<li>这个例子中选择了使用<code>t1.join()</code>，主线程会一直阻塞着，直到子线程完成，<code>join()</code>函数的另一个任务是回收该线程中使用的资源。</li>
</ol>
<p><strong>线程对象和对象内部管理的线程的生命周期并不一样</strong>，如果线程执行的快，可能内部的线程已经结束了，但是线程对象还活着，也有可能线程对象已经被析构了，内部的线程还在运行。</p>
<h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>下面的程序，我们可以用它来创建一个 POSIX 线程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">pthread_create (thread, attr, start_routine, arg)</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>pthread_create</strong> 创建一个新的线程，并让它可执行。下面是关于参数的说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">thread</td>
<td align="left">指向线程标识符指针。</td>
</tr>
<tr>
<td align="left">attr</td>
<td align="left">一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td>
</tr>
<tr>
<td align="left">start_routine</td>
<td align="left">线程运行函数起始地址，一旦线程被创建就会执行。</td>
</tr>
<tr>
<td align="left">arg</td>
<td align="left">运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td>
</tr>
</tbody></table>
<p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p>
<h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">pthread_exit (status)</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>pthread_exit</strong> 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。</p>
<p>如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。</p>
<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><h3 id="0-C-中信号量的使用"><a href="#0-C-中信号量的使用" class="headerlink" title="0 C++中信号量的使用"></a>0 C<a href="https://www.jianshu.com/p/4fdad407068b" target="_blank" rel="noopener">++中信号量的使用</a></h3><h4 id="1、sem-init函数"><a href="#1、sem-init函数" class="headerlink" title="1、sem_init函数"></a>1、sem_init函数</h4><p>sem_init函数是Posix信号量操作中的函数。sem_init() 初始化一个定位在 sem 的匿名信号量。value 参数指定信号量的初始值。 pshared 参数指明信号量是由进程内线程共享，还是由进程之间共享。如果 pshared 的值为 0，那么信号量将被进程内的线程共享，并且应该放置在这个进程的所有线程都可见的地址上(如全局变量，或者堆上动态分配的变量)。</p>
<p>如果 pshared 是非零值，那么信号量将在进程之间共享，并且应该定位共享内存区域(见 shm_open(3)、mmap(2) 和 shmget(2))。因为通过 fork(2) 创建的孩子继承其父亲的内存映射，因此它也可以见到这个信号量。所有可以访问共享内存区域的进程都可以用 sem_post(3)、sem_wait(3) 等等操作信号量。初始化一个已经初始的信号量其结果未定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem,<span class="keyword">int</span> pshared,<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回值 ：<br> sem_init() 成功时返回 0；错误时，返回 -1，并把 errno 设置为合适的值。</p>
<h4 id="2、semaphore相关函数"><a href="#2、semaphore相关函数" class="headerlink" title="2、semaphore相关函数"></a>2、semaphore相关函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>; </span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;  <span class="comment">// 资源减少1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;  <span class="comment">// 资源增加1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><h3 id="1114-按序打印"><a href="#1114-按序打印" class="headerlink" title="1114. 按序打印"></a><a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">1114. 按序打印</a></h3><p>我们提供了一个类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line">  public void first() &#123; print(&quot;first&quot;); &#125;</span><br><span class="line">  public void second() &#123; print(&quot;second&quot;); &#125;</span><br><span class="line">  public void third() &#123; print(&quot;third&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个不同的线程将会共用一个 <code>Foo</code> 实例。</p>
<ul>
<li>线程 A 将会调用 <code>first()</code> 方法</li>
<li>线程 B 将会调用 <code>second()</code> 方法</li>
<li>线程 C 将会调用 <code>third()</code> 方法</li>
</ul>
<p>请设计修改程序，以确保 <code>second()</code> 方法在 <code>first()</code> 方法之后被执行，<code>third()</code> 方法在 <code>second()</code> 方法之后被执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">sem_t</span> syn1 ;</span><br><span class="line">    <span class="keyword">sem_t</span> syn2 ;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123;</span><br><span class="line">        sem_init(&amp;syn1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        sem_init(&amp;syn2, <span class="number">0</span>, <span class="number">0</span>);       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;   </span><br><span class="line">        <span class="comment">// printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst();</span><br><span class="line">        sem_post(&amp;syn1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        sem_wait(&amp;syn1);</span><br><span class="line">        printSecond();</span><br><span class="line">        sem_post(&amp;syn2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;    </span><br><span class="line">        <span class="comment">// printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        sem_wait(&amp;syn2);</span><br><span class="line">        printThird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1115-交替打印FooBar"><a href="#1115-交替打印FooBar" class="headerlink" title="1115. 交替打印FooBar"></a><a href="https://leetcode-cn.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">1115. 交替打印FooBar</a></h4><p>难度中等73</p>
<p>我们提供一个类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class FooBar &#123;</span><br><span class="line">  public void foo() &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">      print(&quot;foo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void bar() &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">      print(&quot;bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个不同的线程将会共用一个 <code>FooBar</code> 实例。其中一个线程将会调用 <code>foo()</code> 方法，另一个线程将会调用 <code>bar()</code> 方法。</p>
<p>请设计修改程序，以确保 “foobar” 被输出 n 次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">sem_t</span> syn1;</span><br><span class="line">    <span class="keyword">sem_t</span> syn2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FooBar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        sem_init(&amp;syn1,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        sem_init(&amp;syn2,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFoo)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            </span><br><span class="line">        	<span class="comment">// printFoo() outputs "foo". Do not change or remove this line.</span></span><br><span class="line">            sem_wait(&amp;syn1);</span><br><span class="line">        	printFoo();</span><br><span class="line">            sem_post(&amp;syn2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printBar)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            </span><br><span class="line">        	<span class="comment">// printBar() outputs "bar". Do not change or remove this line.</span></span><br><span class="line">            sem_wait(&amp;syn2);</span><br><span class="line">        	printBar();</span><br><span class="line">            sem_post(&amp;syn1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1226-哲学家进餐"><a href="#1226-哲学家进餐" class="headerlink" title="1226. 哲学家进餐"></a><a href="https://leetcode-cn.com/problems/the-dining-philosophers/" target="_blank" rel="noopener">1226. 哲学家进餐</a></h2><p>5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）</p>
<p>所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。</p>
<p>假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p>
<p>设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> forks[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DiningPhilosophers() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) pthread_mutex_init(forks + i, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                    function&lt;<span class="keyword">void</span>()&gt; pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                    function&lt;<span class="keyword">void</span>()&gt; pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                    function&lt;<span class="keyword">void</span>()&gt; eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                    function&lt;<span class="keyword">void</span>()&gt; putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                    function&lt;<span class="keyword">void</span>()&gt; putRightFork)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left_hand = philosopher, right_hand = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;    <span class="comment">//左右手序号</span></span><br><span class="line">        <span class="keyword">int</span> ret1 = <span class="number">1</span>, ret2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(ret1 || ret2) &#123;                                               <span class="comment">//尝试同时锁两个直到成功</span></span><br><span class="line">            <span class="keyword">if</span>(ret1 == <span class="number">0</span>) pthread_mutex_unlock(forks + left_hand);          <span class="comment">//锁失败锁住的打开</span></span><br><span class="line">            <span class="keyword">if</span>(ret2 == <span class="number">0</span>) pthread_mutex_unlock(forks + right_hand);</span><br><span class="line">            ret1 = pthread_mutex_trylock(forks + left_hand);                <span class="comment">//继续尝试 </span></span><br><span class="line">            ret2 = pthread_mutex_trylock(forks + right_hand);               <span class="comment">//pthread_mutex_trylock 成功会返回0</span></span><br><span class="line">        &#125;</span><br><span class="line">        pickLeftFork();</span><br><span class="line">        pickRightFork();</span><br><span class="line">        eat();</span><br><span class="line">        putLeftFork();</span><br><span class="line">        putRightFork();</span><br><span class="line">        pthread_mutex_unlock(forks + left_hand);                            <span class="comment">//全部解锁</span></span><br><span class="line">        pthread_mutex_unlock(forks + right_hand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡 5-11~17</title>
    <url>/2020/05/13/2020-05-11-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>本周打卡题目如下：</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener">210. 课程表 II</a></td>
<td>中等</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>
<li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> d = x;</span><br><span class="line">            <span class="keyword">long</span> N = n;</span><br><span class="line">            <span class="keyword">if</span>(N&lt;<span class="number">0</span>)&#123; d = <span class="number">1</span>/d; N*= <span class="number">-1</span>;&#125;</span><br><span class="line">            <span class="keyword">while</span>(N&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mo = N%<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(mo==<span class="number">1</span>) res*=d;</span><br><span class="line">                N/=<span class="number">2</span>;</span><br><span class="line">                d*=d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li><code>push(x)</code> —— 将元素 x 推入栈中。</li>
<li><code>pop()</code> —— 删除栈顶的元素。</li>
<li><code>top()</code> —— 获取栈顶元素。</li>
<li><code>getMin()</code> —— 检索栈中的最小元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minst;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st.push(x);</span><br><span class="line">        <span class="keyword">if</span>(minst.empty())</span><br><span class="line">            minst.push(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            minst.push(<span class="built_in">min</span>(x,minst.top()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        st.pop();</span><br><span class="line">        minst.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minst.top();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。 </p>
<p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            ret.push_back(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.front(); q.pop();</span><br><span class="line">                ret.back().push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)</span><br><span class="line">            a^=n;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1 :"></a><strong>示例 1 :</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>

<p><strong>说明 :</strong></p>
<ol>
<li>数组的长度为 [1, 20,000]。</li>
<li>数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li>
</ol>
<h3 id="我的解法：暴力"><a href="#我的解法：暴力" class="headerlink" title="我的解法：暴力"></a>我的解法：暴力</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> h = i;h&lt;=j;h++)</span><br><span class="line">                    sum+=nums[h];</span><br><span class="line">                <span class="keyword">if</span>(sum == k)</span><br><span class="line">                    res++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法：哈希"><a href="#官方解法：哈希" class="headerlink" title="官方解法：哈希"></a>官方解法：哈希</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x:nums) &#123;</span><br><span class="line">            pre += x;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) </span><br><span class="line">                count += mp[pre - k];</span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度</strong>：O(n)，其中 n 为数组的长度。我们遍历数组的时间复杂度为 O(n)，中间利用哈希表查询删除的复杂度均为 O(1)，因此总时间复杂度为 O(n)。</p>
<p><strong>空间复杂度</strong>：O(n)，其中 n 为数组的长度。哈希表在最坏情况下可能有 n 个不同的键值，因此需要 O(n) 的空间复杂度。</p>
<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p><strong>示例：</strong></p>
<p>给你这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>当 <em>k</em> = 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>当 <em>k</em> = 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>说明：</strong></p>
<ul>
<li>你的算法只能使用常数的额外空间。</li>
<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li>
</ul>
<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* root = head;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* start = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(i==k)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *tmp_head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">                ListNode *tmp = start;</span><br><span class="line">                ListNode *tmp_p = start;</span><br><span class="line">                <span class="keyword">while</span>(tmp&amp;&amp;(i--&gt;<span class="number">0</span>)) <span class="comment">//把这一段翻转过来</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp_p = tmp;</span><br><span class="line">                    ListNode *val = tmp -&gt;next;</span><br><span class="line">                    tmp-&gt;next = tmp_head-&gt;next;</span><br><span class="line">                    tmp_head-&gt;next = tmp;</span><br><span class="line">                    tmp = val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(prev)</span><br><span class="line">                    prev-&gt;next = tmp_head-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    root = tmp_head-&gt;next;</span><br><span class="line">                prev = start;</span><br><span class="line">                start = p;</span><br><span class="line">                i=<span class="number">0</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i) prev-&gt;next = start;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-模拟"><a href="#官方解法-模拟" class="headerlink" title="官方解法 模拟"></a>官方解法 模拟</h3><p><strong>思路与算法</strong></p>
<p>本题的目标非常清晰易懂，不涉及复杂的算法，但是实现过程中需要考虑的细节比较多，容易写出冗长的代码。主要考察面试者设计的能力。</p>
<p>我们需要把链表结点按照 k 个一组分组，所以可以使用一个指针 head 依次指向每组的头结点。这个指针每次向前移动 k 步，直至链表结尾。对于每个分组，我们先判断它的长度是否大于等于 k。若是，我们就翻转这部分链表，否则不需要翻转。</p>
<p>接下来的问题就是如何翻转一个分组内的子链表。翻转一个链表并不难，过程可以参考 206. 反转链表。但是对于一个子链表，除了翻转其本身之外，还需要将子链表的头部与上一个子链表连接，以及子链表的尾部与下一个子链表连接。因此，在翻转子链表的时候，我们不仅需要子链表头结点 head，还需要有 head 的上一个结点 pre，以便翻转完后把子链表再接回 pre。</p>
<p>但是对于第一个子链表，它的头结点 head 前面是没有结点 pre 的。太麻烦了！难道只能特判了吗？答案是否定的。没有条件，我们就创造条件；没有结点，我们就创建一个结点。我们新建一个结点，把它接到链表的头部，让它作为 pre 的初始值，这样 head 前面就有了一个结点，我们就可以避开链表头部的边界条件。这么做还有一个好处，下面我们会看到。</p>
<p>反复移动指针 head 与 pre，对 head 所指向的子链表进行翻转，直到结尾，我们就得到了答案。下面我们该返回函数值了。</p>
<p>有的同学可能发现这又是一件麻烦事：链表翻转之后，链表的头结点发生了变化，那么应该返回哪个结点呢？照理来说，前 k 个结点翻转之后，链表的头结点应该是第 k 个结点。那么要在遍历过程中记录第 k 个结点吗？但是如果链表里面没有 k 个结点，答案又还是原来的头结点。我们又多了一大堆循环和判断要写，太崩溃了！</p>
<p>等等！还记得我们创建了节点 pre吗？这个结点一开始被连接到了头结点的前面，而无论之后链表有没有翻转，它的 next 指针都会指向正确的头结点。那么我们只要返回它的下一个结点就好了。至此，问题解决。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 翻转一个子链表，并且返回新的头与尾</span></span><br><span class="line">    pair&lt;ListNode*, ListNode*&gt; myReverse(ListNode* head, ListNode* tail) &#123;</span><br><span class="line">        ListNode* prev = tail-&gt;next;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (prev != tail) &#123;</span><br><span class="line">            ListNode* nex = p-&gt;next;</span><br><span class="line">            p-&gt;next = prev;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* hair = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        hair-&gt;next = head;</span><br><span class="line">        ListNode* pre = hair;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode* tail = pre;</span><br><span class="line">            <span class="comment">// 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!tail) &#123;</span><br><span class="line">                    <span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* nex = tail-&gt;next;</span><br><span class="line">            <span class="comment">// 这里是 C++17 的写法，也可以写成</span></span><br><span class="line">            <span class="comment">// pair&lt;ListNode*, ListNode*&gt; result = myReverse(head, tail);</span></span><br><span class="line">            <span class="comment">// head = result.first;</span></span><br><span class="line">            <span class="comment">// tail = result.second;</span></span><br><span class="line">            tie(head, tail) = myReverse(head, tail);</span><br><span class="line">            <span class="comment">// 把子链表重新接回原链表</span></span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">            tail-&gt;next = nex;</span><br><span class="line">            pre = tail;</span><br><span class="line">            head = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/k-ge-yi-zu-fan-zhuan-lian-biao-by-leetcode-solutio/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener">210. 课程表 II</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>现在你总共有 <em>n</em> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: [0,1]</span><br><span class="line">解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>输入的先决条件是由<strong>边缘列表</strong>表示的图形，而不是邻接矩阵。详情请参见<a href="http://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">图的表示法</a>。</li>
<li>你可以假定输入的先决条件中没有重复的边。</li>
</ol>
<p><strong>提示:</strong></p>
<ol>
<li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li>
<li><a href="https://www.coursera.org/specializations/algorithms" target="_blank" rel="noopener">通过 DFS 进行拓扑排序</a> - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li>
<li>拓扑排序也可以通过 <a href="https://baike.baidu.com/item/宽度优先搜索/5224802?fr=aladdin&fromid=2148012&fromtitle=广度优先搜索" target="_blank" rel="noopener">BFS</a> 完成。</li>
</ol>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="comment">// 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="comment">// 判断有向图中是否有环</span></span><br><span class="line">    <span class="keyword">bool</span> invalid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (invalid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                invalid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result.push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].push_back(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; !invalid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (invalid) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="comment">// 注意下标 0 为栈底，因此需要将数组反序输出</span></span><br><span class="line">        reverse(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>ORB_SLAM2 双目稀疏立体匹配算法</title>
    <url>/2020/05/13/ORB%20SLAM2%20%E5%8F%8C%E7%9B%AE%E7%A8%80%E7%96%8F%E7%AB%8B%E4%BD%93%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>本节主要学习ORB_SLAM2中的双目立体匹配算法的实现过程</p>
<a id="more"></a>

<p>主要在frame.cc文件中</p>
<p>主要过程：</p>
<ol>
<li>ID自增</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mnId=nNextId++;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>计算图像金字塔的参数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mnScaleLevels = mpORBextractorLeft-&gt;GetLevels();</span><br><span class="line">mfScaleFactor = mpORBextractorLeft-&gt;GetScaleFactor();    </span><br><span class="line">mfLogScaleFactor = <span class="built_in">log</span>(mfScaleFactor);</span><br><span class="line">mvScaleFactors = mpORBextractorLeft-&gt;GetScaleFactors();</span><br><span class="line">mvInvScaleFactors = mpORBextractorLeft-&gt;GetInverseScaleFactors();</span><br><span class="line">mvLevelSigma2 = mpORBextractorLeft-&gt;GetScaleSigmaSquares();</span><br><span class="line">mvInvLevelSigma2 = mpORBextractorLeft-&gt;GetInverseScaleSigmaSquares();</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>对左右图像提取ORB特征点, 使用双线程进行提取</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">thread <span class="title">threadLeft</span><span class="params">(&amp;Frame::ExtractORB,<span class="keyword">this</span>,<span class="number">0</span>,imLeft)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">threadRight</span><span class="params">(&amp;Frame::ExtractORB,<span class="keyword">this</span>,<span class="number">1</span>,imRight)</span></span>;</span><br><span class="line">threadLeft.join();</span><br><span class="line">threadRight.join();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>用opencv的矫正函数，内参对提取到的特征点进行矫正</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UndisortKeyPoints();</span><br></pre></td></tr></table></figure>



<ol start="5">
<li><strong>计算双目见特征点的匹配</strong>，只有匹配成功的特征点才会计算深度，深度存放在mvDepth中;</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ComPuteStereoMatches();</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>计算去畸变后边界</li>
</ol>
<h2 id="双目特征点匹配"><a href="#双目特征点匹配" class="headerlink" title="双目特征点匹配"></a>双目特征点匹配</h2><p><img src="/2020/05/13/ORB%20SLAM2%20%E5%8F%8C%E7%9B%AE%E7%A8%80%E7%96%8F%E7%AB%8B%E4%BD%93%E5%8C%B9%E9%85%8D/%E5%8F%8C%E7%9B%AE%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D.png" alt="image-20200515110530658"></p>
<p>主要对应函数<code>Frame::ComputeStereoMatches()</code>。<br><strong>输入</strong>：两帧立体矫正后的图像对应的ob特征点集<br><strong>过程</strong></p>
<ol>
<li>行特征点统计</li>
<li>粗匹配</li>
<li>精确匹配SAD.</li>
<li>亚像素精度优化</li>
<li>最有视差值/深度选择</li>
<li>删除离群点（ outliers)</li>
</ol>
<p><strong>输出</strong>：稀疏特征点视差图/深度图和匹配结果</p>
<p><strong>视差公式</strong></p>
<p>z:深度 d:视差（disparity）f:焦距 b：(baseline) 基线</p>
<p>$z=\frac{fb}{d},d=u_L-u_R$</p>
<p>亚像素插值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sub-pixel match (Parabola fitting)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> dist1 = vDists[L+bestincR<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> dist2 = vDists[L+bestincR];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> dist3 = vDists[L+bestincR+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> deltaR = (dist1-dist3)/(<span class="number">2.0f</span>*(dist1+dist3<span class="number">-2.0f</span>*dist2));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(deltaR&lt;<span class="number">-1</span> || deltaR&gt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>



<p>亚像素插值方法：</p>
<p><img src="/2020/05/13/ORB%20SLAM2%20%E5%8F%8C%E7%9B%AE%E7%A8%80%E7%96%8F%E7%AB%8B%E4%BD%93%E5%8C%B9%E9%85%8D/%E4%BA%9A%E5%83%8F%E7%B4%A0%E6%8F%92%E5%80%BC.png" alt="image-20200515113540723"></p>
<p>亚像素的误差在一个像素以内，所以修正量大一1时鉴定为误匹配。</p>
<ol start="5">
<li>最优视差值。深度选择</li>
<li>删除离群点（Outliers）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快匹配相似度阈值判断，快意话sad最小，不代表就是匹配的，比如光照变化，若纹理，无纹理都会造成误匹配</span></span><br><span class="line"><span class="comment">//误匹配判断条件 norm_sad &gt; 1.5*1.4*median</span></span><br><span class="line">sort(vDistIdx.<span class="built_in">begin</span>(),vDistIdx.<span class="built_in">end</span>()); <span class="comment">//对dist进行排序</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> median = vDistIdx[vDistIdx.<span class="built_in">size</span>()/<span class="number">2</span>].first; <span class="comment">//根据中值计算阈值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thDist = <span class="number">1.5f</span>*<span class="number">1.4f</span>*median;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=vDistIdx.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(vDistIdx[i].first&lt;thDist)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mvuRight[vDistIdx[i].second]=<span class="number">-1</span>;</span><br><span class="line">        mvDepth[vDistIdx[i].second]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>ORBSLAM</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>ORB_SLAM2 双目稀疏立体匹配算法</title>
    <url>/2020/05/13/ORB_SLAM2%20%E5%8F%8C%E7%9B%AE%E7%A8%80%E7%96%8F%E7%AB%8B%E4%BD%93%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>本节主要学习ORB_SLAM2中的双目立体匹配算法的实现过程</p>
<a id="more"></a>

<p>主要在frame.cc文件中</p>
<p>主要过程：</p>
<ol>
<li>ID自增</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mnId=nNextId++;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>计算图像金字塔的参数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mnScaleLevels = mpORBextractorLeft-&gt;GetLevels();</span><br><span class="line">mfScaleFactor = mpORBextractorLeft-&gt;GetScaleFactor();    </span><br><span class="line">mfLogScaleFactor = <span class="built_in">log</span>(mfScaleFactor);</span><br><span class="line">mvScaleFactors = mpORBextractorLeft-&gt;GetScaleFactors();</span><br><span class="line">mvInvScaleFactors = mpORBextractorLeft-&gt;GetInverseScaleFactors();</span><br><span class="line">mvLevelSigma2 = mpORBextractorLeft-&gt;GetScaleSigmaSquares();</span><br><span class="line">mvInvLevelSigma2 = mpORBextractorLeft-&gt;GetInverseScaleSigmaSquares();</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>对左右图像提取ORB特征点, 使用双线程进行提取</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">thread <span class="title">threadLeft</span><span class="params">(&amp;Frame::ExtractORB,<span class="keyword">this</span>,<span class="number">0</span>,imLeft)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">threadRight</span><span class="params">(&amp;Frame::ExtractORB,<span class="keyword">this</span>,<span class="number">1</span>,imRight)</span></span>;</span><br><span class="line">threadLeft.join();</span><br><span class="line">threadRight.join();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>用opencv的矫正函数，内参对提取到的特征点进行矫正</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UndisortKeyPoints();</span><br></pre></td></tr></table></figure>



<ol start="5">
<li><strong>计算双目见特征点的匹配</strong>，只有匹配成功的特征点才会计算深度，深度存放在mvDepth中;</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ComPuteStereoMatches();</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>计算去畸变后边界</li>
</ol>
<h2 id="双目特征点匹配"><a href="#双目特征点匹配" class="headerlink" title="双目特征点匹配"></a>双目特征点匹配</h2><p><img src="/2020/05/13/ORB_SLAM2%20%E5%8F%8C%E7%9B%AE%E7%A8%80%E7%96%8F%E7%AB%8B%E4%BD%93%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/%E5%8F%8C%E7%9B%AE%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D.png" alt="image-20200515110530658"></p>
<p>主要对应函数<code>Frame::ComputeStereoMatches()</code>。<br><strong>输入</strong>：两帧立体矫正后的图像对应的ob特征点集<br><strong>过程</strong></p>
<ol>
<li>行特征点统计</li>
<li>粗匹配</li>
<li>精确匹配SAD.</li>
<li>亚像素精度优化</li>
<li>最有视差值/深度选择</li>
<li>删除离群点（ outliers)</li>
</ol>
<p><strong>输出</strong>：稀疏特征点视差图/深度图和匹配结果</p>
<p><strong>视差公式</strong></p>
<p>z:深度 d:视差（disparity）f:焦距 b：(baseline) 基线</p>
<p>$z=\frac{fb}{d},d=u_L-u_R$</p>
<p>亚像素插值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sub-pixel match (Parabola fitting)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> dist1 = vDists[L+bestincR<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> dist2 = vDists[L+bestincR];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> dist3 = vDists[L+bestincR+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> deltaR = (dist1-dist3)/(<span class="number">2.0f</span>*(dist1+dist3<span class="number">-2.0f</span>*dist2));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(deltaR&lt;<span class="number">-1</span> || deltaR&gt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>



<p>亚像素插值方法：</p>
<p><img src="/2020/05/13/ORB_SLAM2%20%E5%8F%8C%E7%9B%AE%E7%A8%80%E7%96%8F%E7%AB%8B%E4%BD%93%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/%E4%BA%9A%E5%83%8F%E7%B4%A0%E6%8F%92%E5%80%BC.png" alt="image-20200515113540723"></p>
<p>亚像素的误差在一个像素以内，所以修正量大一1时鉴定为误匹配。</p>
<ol start="5">
<li>最优视差值。深度选择</li>
<li>删除离群点（Outliers）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快匹配相似度阈值判断，快意话sad最小，不代表就是匹配的，比如光照变化，若纹理，无纹理都会造成误匹配</span></span><br><span class="line"><span class="comment">//误匹配判断条件 norm_sad &gt; 1.5*1.4*median</span></span><br><span class="line">sort(vDistIdx.<span class="built_in">begin</span>(),vDistIdx.<span class="built_in">end</span>()); <span class="comment">//对dist进行排序</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> median = vDistIdx[vDistIdx.<span class="built_in">size</span>()/<span class="number">2</span>].first; <span class="comment">//根据中值计算阈值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thDist = <span class="number">1.5f</span>*<span class="number">1.4f</span>*median;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=vDistIdx.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(vDistIdx[i].first&lt;thDist)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mvuRight[vDistIdx[i].second]=<span class="number">-1</span>;</span><br><span class="line">        mvDepth[vDistIdx[i].second]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>ORBSLAM</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡 5-4~10</title>
    <url>/2020/05/04/2020-05-03-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>本周打卡题目如下：</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></td>
<td>困难</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">983. 最低票价</a></td>
<td>困难</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">572. 另一个树的子树</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></td>
<td>中等</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>假设你总是可以到达数组的最后一个位置。</p>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">steps</span><span class="params">(len,INT_MAX)</span></span>;</span><br><span class="line">        steps[len<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=nums[i]&amp;&amp;((i+j)&lt;len);j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(steps[i+j]!=INT_MAX)    </span><br><span class="line">                    steps[i] = <span class="built_in">min</span>(steps[i],steps[i+j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>会超时</p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：$O(n^2)$，其中 n 是数组长度。有两层嵌套循环，在最坏的情况下，例如数组中的所有元素都是 1，position 需要遍历数组中的每个位置，对于 position 的每个值都有一次循环。</p>
<p>空间复杂度：$O(1)$。</p>
<h3 id="方法二：正向查找可到达的最大位置"><a href="#方法二：正向查找可到达的最大位置" class="headerlink" title="方法二：正向查找可到达的最大位置"></a>方法二：正向查找可到达的最大位置</h3><p>方法一虽然直观，但是时间复杂度比较高，有没有办法降低时间复杂度呢？</p>
<p>如果我们「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。</p>
<p>例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。</p>
<p>从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。</p>
<p><img src="/2020/05/04/2020-05-03-LeetCode-CheckDaily/45_fig1.png" alt="x"></p>
<p>在具体的实现中，我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。</p>
<p>在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxPos = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), <span class="built_in">end</span> = <span class="number">0</span>, <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxPos &gt;= i) &#123;</span><br><span class="line">                maxPos = <span class="built_in">max</span>(maxPos, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="built_in">end</span>) &#123;</span><br><span class="line">                    <span class="built_in">end</span> = maxPos;</span><br><span class="line">                    ++<span class="built_in">step</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)，其中 n 是数组长度。</p>
<p>空间复杂度：O(1)。</p>
<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>思路：设置上界下界进行判断即可；需要注意的是，要对边界值的设置需要注意一点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> MINVAL_FLAG = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> MAXVAL_FLAG = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==INT_MIN &amp;&amp; MINVAL_FLAG) MINVAL_FLAG = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==INT_MAX &amp;&amp; MAXVAL_FLAG) MAXVAL_FLAG = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;left,INT_MIN,root-&gt;val)&amp;&amp; helper(root-&gt;right,root-&gt;val,INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root,<span class="keyword">int</span> minval,<span class="keyword">int</span> maxval)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">' '</span>&lt;&lt;minval&lt;&lt;<span class="string">' '</span>&lt;&lt;maxval&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(minval==root-&gt;val||maxval==root-&gt;val)</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val==INT_MIN &amp;&amp; MINVAL_FLAG&amp;&amp;root-&gt;val&lt;maxval)</span><br><span class="line">                    MINVAL_FLAG = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val==INT_MAX &amp;&amp; MAXVAL_FLAG &amp;&amp;root-&gt;val &gt; minval)</span><br><span class="line">                    MAXVAL_FLAG = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(minval&gt;root-&gt;val||maxval&lt;root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;left,minval,<span class="built_in">min</span>(root-&gt;val,maxval))&amp;&amp;helper(root-&gt;right,<span class="built_in">max</span>(minval,root-&gt;val),maxval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">long</span> <span class="keyword">long</span> lower, <span class="keyword">long</span> <span class="keyword">long</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：中序遍历"><a href="#方法二：中序遍历" class="headerlink" title="方法二：中序遍历"></a>方法二：中序遍历</h4><p><strong>思路和算法</strong></p>
<p>基于方法一中提及的性质，我们可以进一步知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。</p>
<p>可能由读者不知道中序遍历是什么，我们这里简单提及一下，中序遍历是二叉树的一种遍历方式，它先遍历左子树，再遍历根节点，最后遍历右子树。而我们二叉搜索树保证了左子树的节点的值均小于根节点的值，根节点的值均小于右子树的值，因此中序遍历以后得到的序列一定是升序序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> inorder = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() || root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root);</span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (root -&gt; val &lt;= inorder) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            inorder = root -&gt; val;</span><br><span class="line">            root = root -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="983-最低票价"><a href="#983-最低票价" class="headerlink" title="983. 最低票价"></a><a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">983. 最低票价</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 <code>days</code> 的数组给出。每一项是一个从 <code>1</code> 到 <code>365</code> 的整数。</p>
<p>火车票有三种不同的销售方式：</p>
<ul>
<li>一张为期一天的通行证售价为 <code>costs[0]</code> 美元；</li>
<li>一张为期七天的通行证售价为 <code>costs[1]</code> 美元；</li>
<li>一张为期三十天的通行证售价为 <code>costs[2]</code> 美元。</li>
</ul>
<p>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
<p>返回你想要完成在给定的列表 <code>days</code> 中列出的每一天的旅行所需要的最低消费。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：days &#x3D; [1,4,6,7,8,20], costs &#x3D; [2,7,15]</span><br><span class="line">输出：11</span><br><span class="line">解释： </span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 1 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 1 天生效。</span><br><span class="line">在第 3 天，你花了 costs[1] &#x3D; $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。</span><br><span class="line">在第 20 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 20 天生效。</span><br><span class="line">你总共花了 $11，并完成了你计划的每一天旅行。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：days &#x3D; [1,2,3,4,5,6,7,8,9,10,30,31], costs &#x3D; [2,7,15]</span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： </span><br><span class="line">在第 1 天，你花了 costs[2] &#x3D; $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。</span><br><span class="line">在第 31 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 </span><br><span class="line">你总共花了 $17，并完成了你计划的每一天旅行。</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ol>
<li><code>1 &lt;= days.length &lt;= 365</code></li>
<li><code>1 &lt;= days[i] &lt;= 365</code></li>
<li><code>days</code> 按顺序严格递增</li>
<li><code>costs.length == 3</code></li>
<li><code>1 &lt;= costs[i] &lt;= 1000</code></li>
</ol>
<h4 id="方法一：记忆化搜索（日期变量型）"><a href="#方法一：记忆化搜索（日期变量型）" class="headerlink" title="方法一：记忆化搜索（日期变量型）"></a>方法一：记忆化搜索（日期变量型）</h4><h5 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a><strong>思路和算法</strong></h5><p>我们用 $\textit{dp}(i)$ 来表示从第 i天开始到一年的结束，我们需要花的钱。考虑到一张通行证可以让我们在「接下来」的若干天进行旅行，所以我们「从后往前」倒着进行动态规划。</p>
<p>对于一年中的任意一天：</p>
<ul>
<li><p>如果这一天不是必须出行的日期，那我们可以贪心地选择不买。这是因为如果今天不用出行，那么也不必购买通行证，并且通行证越晚买越好。所以有 $\textit{dp}(i) = \textit{dp}(i + 1)$；</p>
</li>
<li><p>如果这一天是必须出行的日期，我们可以选择买 1，7 或 30天的通行证。若我们购买了 j天的通行证，那么接下来的 j - 1天，我们都不再需要购买通行证，只需要考虑第 i + j天及以后即可。因此，我们有</p>
<p>$\textit{dp}(i) = \min{\textit{cost}(j) + \textit{dp}(i + j)}, \quad j \in {1, 7, 30}$</p>
<p>其中 $\textit{cost}(j)$表示 j天通行证的价格。为什么我们只需要考虑第 i+j天及以后呢？这里和第一条的贪心思路是一样的，如果我们需要购买通行证，那么一定越晚买越好，在握着一张有效的通行证的时候购买其它的通行证显然是不划算的。</p>
</li>
</ul>
<p>由于我们是倒着进行动态规划的，因此我们可以使用记忆化搜索，减少代码的编写难度。我们使用一个长度为 366366 的数组（因为天数是 <code>[1, 365][1,365]</code>，而数组的下标是从 0开始的）存储所有的动态规划结果，这样所有的 $\textit{dp}(i)$ 只会被计算一次（和普通的动态规划相同），时间复杂度不会增大。</p>
<p>最终的答案记为 $\textit{dp}(1)$。</p>
<h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; dayset;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; costs;</span><br><span class="line">    <span class="keyword">int</span> memo[<span class="number">366</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;costs = costs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d: days) &#123;</span><br><span class="line">            dayset.insert(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(memo, <span class="number">-1</span>, <span class="keyword">sizeof</span>(memo));</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">365</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dayset.count(i)) &#123;</span><br><span class="line">            memo[i] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp(i + <span class="number">1</span>) + costs[<span class="number">0</span>], dp(i + <span class="number">7</span>) + costs[<span class="number">1</span>]), dp(i + <span class="number">30</span>) + costs[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            memo[i] = dp(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(W)，其中 W = 365是旅行计划中日期的最大值，我们需要计算 W个解，而每个解最多需要查询 3个其他的解，因此计算量为 $O(3 * W)=O(W)$。</li>
<li>空间复杂度：O(W），我们需要长度为 O(W)的数组来存储所有的解。</li>
</ul>
<h4 id="方法二：记忆化搜索（窗口变量型）"><a href="#方法二：记忆化搜索（窗口变量型）" class="headerlink" title="方法二：记忆化搜索（窗口变量型）"></a>方法二：记忆化搜索（窗口变量型）</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h5><p>方法一需要遍历一年中所有的天数，无论 $\textit{days}$的长度是多少。</p>
<p>但是观察方法一的递推式，我们可以看到，如果我们查询 $\textit{dp}(i)$，而第 i天我们又不需要出行的话，那么 $\textit{dp}$ 函数会一直向后计算$ \textit{dp}(i + 1) = \textit{dp}(i + 2) = \textit{dp}(i + 3)$ 一直到一年结束或者有一天我们需要出行为止。那么我们其实可以直接跳过这些不需要出行的日期，直接找到下一个需要出行的日期。</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h5><p>现在，我们令 $\textit{dp}(i)$ 表示能够完成从第 $\textit{days}[i]$ 天到最后的旅行计划的最小花费（注意，不再是第 i 天到最后的最小花费）。令 $j_1$ 是满足 $\textit{days}[j_1] &gt;= \textit{days}[i] + 1$ 的最小下标，$j_7$是满足 $\textit{days}[j_7] &gt;= \textit{days}[i] + 7$ 的最小下标， $j_{30}$ 是满足 $\textit{days}[j_{30}] &gt;= \textit{days}[i] + 30$ 的最小下标，那么就有：<br>$$<br>dp(i)=min(dp(j_1 )+costs[0],dp(j_7)+costs[1],dp(j_30)+costs[2])<br>$$</p>
<h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; days, costs;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line">    <span class="keyword">int</span> durations[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;days = days;</span><br><span class="line">        <span class="keyword">this</span>-&gt;costs = costs;</span><br><span class="line">        memo.assign(days.<span class="built_in">size</span>(), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= days.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; days.<span class="built_in">size</span>() &amp;&amp; days[j] &lt; days[i] + durations[k]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[i] = <span class="built_in">min</span>(memo[i], dp(j) + costs[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N是出行日期的数量，我们需要计算 N 个解，而计算每个解的过程中最多将指针挪动 30步，计算量为 O(30 * N)=O(N)。</li>
<li>空间复杂度：O(N)，我们需要长度为 O(N) 的数组来存储所有的解。</li>
</ul>
<h2 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">572. 另一个树的子树</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个非空二叉树 <strong>s</strong> 和 <strong>t</strong>，检验 <strong>s</strong> 中是否包含和 <strong>t</strong> 具有相同结构和节点值的子树。<strong>s</strong> 的一个子树包括 <strong>s</strong> 的一个节点和这个节点的所有子孙。<strong>s</strong> 也可以看做它自身的一棵子树。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><p>给定的树 s:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>给定的树 t：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>返回 <strong>true</strong>，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><p>给定的树 s：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br><span class="line">   &#x2F;</span><br><span class="line">  0</span><br></pre></td></tr></table></figure>

<p>给定的树 t：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>返回 <strong>false</strong>。</p>
<h3 id="我的解法：暴力匹配"><a href="#我的解法：暴力匹配" class="headerlink" title="我的解法：暴力匹配"></a>我的解法：暴力匹配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span>||t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(isSubtree(s-&gt;left,t))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(isSubtree(s-&gt;right,t))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;s-&gt;val&lt;&lt;' '&lt;&lt;t-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val==t-&gt;val)</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left||t-&gt;right)</span><br><span class="line">                <span class="keyword">return</span> issame(s-&gt;left,t-&gt;left)&amp;&amp;issame(s-&gt;right,t-&gt;right);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> !s-&gt;left&amp;&amp;!s-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">issame</span><span class="params">(TreeNode* s, TreeNode* t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span>&amp;&amp;t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span>||t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val==t-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> issame(s-&gt;left,t-&gt;left)&amp;&amp;issame(s-&gt;right,t-&gt;right);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：DFS-序列上做串匹配"><a href="#方法二：DFS-序列上做串匹配" class="headerlink" title="方法二：DFS 序列上做串匹配"></a>方法二：DFS 序列上做串匹配</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>这个方法需要我们先了解一个「小套路」：一棵子树上的点在 DFS 序列（即先序遍历）中是连续的。了解了这个「小套路」之后，我们可以确定解决这个问题的方向就是：把 s和 t 先转换成 DFS 序，然后看 t 的 DFS 序是否是 s 的 DFS 序的「子串」。</p>
<p>这样做正确吗？ 假设 s由两个点组成，1 是根，2 是 1 的左孩子；tt 也由两个点组成，1是根，2 是 1的右孩子。这样一来 s 和 t 的 DFS 序相同，可是 t 并不是 s 的某一棵子树。由此可见「s 的 DFS 序包含 t的 DFS 序」是「t 是 ss 子树」的 必要不充分条件，所以单纯这样做是不正确的。</p>
<p>为了解决这个问题，我们可以引入两个空值 lNull 和 rNull，当一个节点的左孩子或者右孩子为空的时候，就插入这两个空值，这样 DFS 序列就唯一对应一棵树。处理完之后，就可以通过判断 「s 的 DFS 序包含 tt的 DFS 序」来判断答案。</p>
<p>在判断「s 的 DFS 序包含 t 的 DFS 序」的时候，可以暴力匹配，也可以使用 KMP 或者 Rabin-Karp 算法，在使用 Rabin-Karp 算法的时候，要注意串中可能有负值。</p>
<p>这里给出用 KMP 判断的代码实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="keyword">int</span>(<span class="number">1E9</span>) + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> vis[MAX_N];</span><br><span class="line">    <span class="keyword">int</span> p[MAX_N], tot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span>; tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) p[++tot] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt; MAX_N; ++j) &#123;</span><br><span class="line">                vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> f, s; <span class="comment">// f 为哈希值 | s 为子树大小</span></span><br><span class="line">        Status(<span class="keyword">int</span> f_ = <span class="number">0</span>, <span class="keyword">int</span> s_ = <span class="number">0</span>) </span><br><span class="line">            : f(f_), s(s_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; hS, hT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *o, <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; &amp;h)</span> </span>&#123;</span><br><span class="line">        h[o] = Status(o-&gt;val, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!o-&gt;left &amp;&amp; !o-&gt;right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;left) &#123;</span><br><span class="line">            dfs(o-&gt;left, h);</span><br><span class="line">            h[o].s += h[o-&gt;left].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">31L</span>L * h[o-&gt;left].f * p[h[o-&gt;left].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;right) &#123;</span><br><span class="line">            dfs(o-&gt;right, h);</span><br><span class="line">            h[o].s += h[o-&gt;right].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">179L</span>L * h[o-&gt;right].f * p[h[o-&gt;right].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        getPrime();</span><br><span class="line">        dfs(s, hS);</span><br><span class="line">        dfs(t, hT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tHash = hT[t].f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[k, v]: hS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.f == tHash) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h3 id="方法三：哈希"><a href="#方法三：哈希" class="headerlink" title="方法三：哈希"></a>方法三：哈希</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="keyword">int</span>(<span class="number">1E9</span>) + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> vis[MAX_N];</span><br><span class="line">    <span class="keyword">int</span> p[MAX_N], tot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span>; tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) p[++tot] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt; MAX_N; ++j) &#123;</span><br><span class="line">                vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> f, s; <span class="comment">// f 为哈希值 | s 为子树大小</span></span><br><span class="line">        Status(<span class="keyword">int</span> f_ = <span class="number">0</span>, <span class="keyword">int</span> s_ = <span class="number">0</span>) </span><br><span class="line">            : f(f_), s(s_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; hS, hT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *o, <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; &amp;h)</span> </span>&#123;</span><br><span class="line">        h[o] = Status(o-&gt;val, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!o-&gt;left &amp;&amp; !o-&gt;right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;left) &#123;</span><br><span class="line">            dfs(o-&gt;left, h);</span><br><span class="line">            h[o].s += h[o-&gt;left].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">31L</span>L * h[o-&gt;left].f * p[h[o-&gt;left].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;right) &#123;</span><br><span class="line">            dfs(o-&gt;right, h);</span><br><span class="line">            h[o].s += h[o-&gt;right].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">179L</span>L * h[o-&gt;right].f * p[h[o-&gt;right].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        getPrime();</span><br><span class="line">        dfs(s, hS);</span><br><span class="line">        dfs(t, hT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tHash = hT[t].f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[k, v]: hS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.f == tHash) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h4 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h4><p><strong>思路：动态规划</strong></p>
<p>状态转移方程<br>$$<br>dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(rows==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(rows,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;rows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>]-<span class="string">'0'</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;cols;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i]-<span class="string">'0'</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;rows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;cols;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">'1'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]))+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;dp[i][j]&lt;&lt;' ';</span></span><br><span class="line">                    res = <span class="built_in">max</span>(res,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>(), columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 遇到一个 1 作为正方形的左上角</span></span><br><span class="line">                    maxSide = <span class="built_in">max</span>(maxSide, <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 计算可能的最大正方形边长</span></span><br><span class="line">                    <span class="keyword">int</span> currentMaxSide = <span class="built_in">min</span>(rows - i, columns - j);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; currentMaxSide; k++) &#123;</span><br><span class="line">                        <span class="comment">// 判断新增的一行一列是否均为 1</span></span><br><span class="line">                        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + k][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[i + k][j + m] == <span class="string">'0'</span> || matrix[i + m][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                            maxSide = <span class="built_in">max</span>(maxSide, k + <span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></h2><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<h5 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h5 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><p>二分查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = x;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(((<span class="keyword">long</span>)mid*mid&lt;=x)&amp;&amp;((<span class="keyword">long</span>)(mid+<span class="number">1</span>)*(mid+<span class="number">1</span>)&gt;x)) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">long</span>)mid*mid&gt;x)</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(\log x)$，即为二分查找需要的次数。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h3 id="其它解法1-袖珍计算器法"><a href="#其它解法1-袖珍计算器法" class="headerlink" title="其它解法1: 袖珍计算器法"></a>其它解法1: 袖珍计算器法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">exp</span>(<span class="number">0.5</span> * <span class="built_in">log</span>(x));</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)(ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法2-牛顿迭代"><a href="#其它解法2-牛顿迭代" class="headerlink" title="其它解法2: 牛顿迭代"></a>其它解法2: 牛顿迭代</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> C = x, x0 = x;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> xi = <span class="number">0.5</span> * (x0 + C / x0);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(x0 - xi) &lt; <span class="number">1e-7</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x0 = xi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(x0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="/2020/05/04/2020-05-03-LeetCode-CheckDaily/D:%5CProject%5Cblog%5Csource_posts%5C2020-05-03-LeetCode-CheckDaily%5Cbinarytree.png" alt="img"></p>
<h4 id="示例-1-3"><a href="#示例-1-3" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-3"><a href="#示例-2-3" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h3 id="我的解法-4"><a href="#我的解法-4" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==p-&gt;val||root-&gt;val==q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(hasptr(root-&gt;left,p)&amp;&amp;hasptr(root-&gt;left,q))</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">if</span>(hasptr(root-&gt;right,p)&amp;&amp;hasptr(root-&gt;right,q))</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">return</span> root;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasptr</span><span class="params">(TreeNode* root, TreeNode* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==p-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> hasptr(root-&gt;left,p)||hasptr(root-&gt;right,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> lson = dfs(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">bool</span> rson = dfs(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，因此时间复杂度为 O(N)。</li>
<li>空间复杂度：O(N) ，其中 N 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O(N)。</li>
</ul>
<h4 id="方法二：存储父节点"><a href="#方法二：存储父节点" class="headerlink" title="方法二：存储父节点"></a>方法二：存储父节点</h4><p><strong>思路</strong></p>
<p>我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 <code>p</code> 结点开始不断往上跳，并记录已经访问过的节点，再从 <code>q</code> 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。</p>
<p><strong>算法</strong></p>
<ol>
<li>从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。</li>
<li>从 <code>p</code> 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。</li>
<li>同样，我们再从 <code>q</code> 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 <code>p</code> 和 <code>q</code> 的深度最深的公共祖先，即 LCA 节点。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, TreeNode*&gt; fa;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fa[root-&gt;left-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fa[root-&gt;right-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        fa[root-&gt;val] = <span class="literal">nullptr</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vis[p-&gt;val] = <span class="literal">true</span>;</span><br><span class="line">            p = fa[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[q-&gt;val]) <span class="keyword">return</span> q;</span><br><span class="line">            q = fa[q-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N是二叉树的节点数。二叉树的所有节点有且只会被访问一次，从 <code>p</code> 和 <code>q</code> 节点往上跳经过的祖先节点个数不会超过 N，因此总的时间复杂度为 O(N)。</li>
<li>空间复杂度：O(N)，其中 N是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O(N)，哈希表存储每个节点的父节点也需要 O(N) 的空间复杂度，因此最后总的空间复杂度为 O(N)。</li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第187场周赛</title>
    <url>/2020/05/03/2020-05-03-LeetCode-Contest-187/</url>
    <content><![CDATA[<p>本周参加周赛，战况不行，两题选手，排名<code>1084 / 3108</code></p>
<table>
<thead>
<tr>
<th>题目</th>
<th align="center">分值</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/destination-city/" target="_blank" rel="noopener">5400. 旅行终点站</a></td>
<td align="center">3</td>
<td align="center">简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/" target="_blank" rel="noopener">5401. 是否所有 1 都至少相隔 k 个元素</a></td>
<td align="center">4</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">5402. 绝对差不超过限制的最长连续子数组</a></td>
<td align="center">5</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/" target="_blank" rel="noopener">5403. 有序矩阵中的第 k 个最小数组和</a></td>
<td align="center">7</td>
<td align="center">困难</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="5400-旅行终点站"><a href="#5400-旅行终点站" class="headerlink" title="5400. 旅行终点站"></a><a href="https://leetcode-cn.com/problems/destination-city/" target="_blank" rel="noopener">5400. 旅行终点站</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityAi, cityBi]</code> 表示该线路将会从 <code>cityAi</code> 直接前往 <code>cityBi</code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市<em>。</em></p>
<p>题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]]</span><br><span class="line">输出：&quot;Sao Paulo&quot; </span><br><span class="line">解释：从 &quot;London&quot; 出发，最后抵达终点站 &quot;Sao Paulo&quot; 。本次旅行的路线是 &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot; 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;,&quot;B&quot;],[&quot;C&quot;,&quot;A&quot;]]</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">解释：所有可能的线路是：</span><br><span class="line">&quot;D&quot; -&gt; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;A&quot;. </span><br><span class="line">显然，旅行终点站是 &quot;A&quot; 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;A&quot;,&quot;Z&quot;]]</span><br><span class="line">输出：&quot;Z&quot;</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= paths.length &lt;= 100</code></li>
<li><code>paths[i].length == 2</code></li>
<li><code>1 &lt;= cityAi.length, cityBi.length &lt;= 10</code></li>
<li><code>cityAi != cityBi</code></li>
<li>所有字符串均由大小写英文字母和空格字符组成。</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="思路：使用哈希表一直套娃，套完了就是终点"><a href="#思路：使用哈希表一直套娃，套完了就是终点" class="headerlink" title="思路：使用哈希表一直套娃，套完了就是终点"></a>思路：使用哈希表一直套娃，套完了就是终点</h4><h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">destCity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:paths)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[p[<span class="number">0</span>]] = p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.<span class="built_in">find</span>(p[<span class="number">0</span>])==<span class="built_in">set</span>.<span class="built_in">end</span>()) <span class="built_in">set</span>.insert(p[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.<span class="built_in">find</span>(p[<span class="number">1</span>])==<span class="built_in">set</span>.<span class="built_in">end</span>()) <span class="built_in">set</span>.insert(p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v=<span class="built_in">set</span>.<span class="built_in">begin</span>();v!=<span class="built_in">set</span>.<span class="built_in">end</span>();v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(*v)==<span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> *v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">destCity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; vis;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : paths)</span><br><span class="line">            vis.insert(p[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : paths)</span><br><span class="line">            <span class="keyword">if</span> (vis.<span class="built_in">find</span>(p[<span class="number">1</span>]) == vis.<span class="built_in">end</span>()) <span class="keyword">return</span> p[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"send me offer plz"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：Gary_coding</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/destination-city/solution/c-zhong-gui-zhong-ju-de-32msjie-fa-set-by-gary_cod/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h2 id="5401-是否所有-1-都至少相隔-k-个元素"><a href="#5401-是否所有-1-都至少相隔-k-个元素" class="headerlink" title="5401. 是否所有 1 都至少相隔 k 个元素"></a><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/" target="_blank" rel="noopener">5401. 是否所有 1 都至少相隔 k 个元素</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>nums</code> 以及整数 <code>k</code>。如果所有 <code>1</code> 都至少相隔 <code>k</code> 个元素，则返回 <code>True</code> ；否则，返回 <code>False</code> 。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><p><img src="/2020/05/03/2020-05-03-LeetCode-Contest-187/sample_1_1791.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,0,1,0,0,1], k &#x3D; 2</span><br><span class="line">输出：true</span><br><span class="line">解释：每个 1 都至少相隔 2 个元素。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><p><strong><img src="/2020/05/03/2020-05-03-LeetCode-Contest-187/2020-05-03-LeetCode-Contest-187%5Csample_2_1791.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,1,0,1], k &#x3D; 2</span><br><span class="line">输出：false</span><br><span class="line">解释：第二个 1 和第三个 1 之间只隔了 1 个元素。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1], k &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,1], k &#x3D; 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h4 id="提示：-1"><a href="#提示：-1" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>0 &lt;= k &lt;= nums.length</code></li>
<li><code>nums[i]</code> 的值为 <code>0</code> 或 <code>1</code></li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kLengthApart</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastone = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lastone&gt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-lastone&lt;=k)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                lastone = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5402-绝对差不超过限制的最长连续子数组"><a href="#5402-绝对差不超过限制的最长连续子数组" class="headerlink" title="5402. 绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">5402. 绝对差不超过限制的最长连续子数组</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code> <em>。</em></p>
<p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p>
<h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [8,2,4,7], limit &#x3D; 4</span><br><span class="line">输出：2 </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[8] 最大绝对差 |8-8| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[8,2] 最大绝对差 |8-2| &#x3D; 6 &gt; 4. </span><br><span class="line">[8,2,4] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[8,2,4,7] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[2] 最大绝对差 |2-2| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[2,4] 最大绝对差 |2-4| &#x3D; 2 &lt;&#x3D; 4.</span><br><span class="line">[2,4,7] 最大绝对差 |2-7| &#x3D; 5 &gt; 4.</span><br><span class="line">[4] 最大绝对差 |4-4| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[4,7] 最大绝对差 |4-7| &#x3D; 3 &lt;&#x3D; 4.</span><br><span class="line">[7] 最大绝对差 |7-7| &#x3D; 0 &lt;&#x3D; 4. </span><br><span class="line">因此，满足题意的最长子数组的长度为 2 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">输出：4 </span><br><span class="line">解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| &#x3D; 5 &lt;&#x3D; 5 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<h4 id="提示：-2"><a href="#提示：-2" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>0 &lt;= limit &lt;= 10^9</code></li>
</ul>
<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+res;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> a = getmax(nums,i,j);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(a)&lt;=limit)</span><br><span class="line">                    res = <span class="built_in">max</span>(res,j-i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getmax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l,<span class="keyword">int</span> r )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxn = nums[l];</span><br><span class="line">        <span class="keyword">int</span> minn = nums[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxn = <span class="built_in">max</span>(maxn,nums[i]);</span><br><span class="line">            minn = <span class="built_in">min</span>(minn,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn-minn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>暴力解法 会超时</p>
<h3 id="大佬优秀解法"><a href="#大佬优秀解法" class="headerlink" title="大佬优秀解法"></a>大佬优秀解法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>使用滑动窗口保持符合条件的子数组，记录最长长度</li>
<li>怎样确定子数组是否符合条件，需要知道两个关键数据<ol start="21">
<li>子数组中的最大值</li>
<li>子数组中的最小值</li>
</ol>
</li>
<li>需要对滑入窗口的数据记录，滑出的数据删除，并且使这些记录方便的算出最大值和最小值<br>\31. 使用 <code>map</code> / <code>multiset</code> 可以在滑入滑出的时候方便的增减对应数据<br>\32. 同时 <code>map</code> / <code>multiset</code> 本身是有序的，可以方便的找出最大值最小值</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int longestSubarray(vector&lt;int&gt;&amp; nums, int limit) &#123;</span><br><span class="line">    map&lt;int, int&gt; m;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; nums.size(); j++) &#123;</span><br><span class="line">        m[nums[j]]++;</span><br><span class="line">        while (m.rbegin()-&gt;first - m.begin()-&gt;first &gt; limit) &#123;</span><br><span class="line">            m[nums[i]]--;</span><br><span class="line">            if (m[nums[i]] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                m.erase(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans &#x3D; max(ans, j - i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            s.insert(nums[j]);</span><br><span class="line">            <span class="keyword">while</span> (*s.rbegin() - *s.<span class="built_in">begin</span>() &gt; limit) &#123;</span><br><span class="line">                s.erase(s.<span class="built_in">find</span>(nums[i]));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">作者：ikaruga</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution/longest-continuous-subarray-by-ikaruga/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="5403-有序矩阵中的第-k-个最小数组和"><a href="#5403-有序矩阵中的第-k-个最小数组和" class="headerlink" title="5403. 有序矩阵中的第 k 个最小数组和"></a><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/" target="_blank" rel="noopener">5403. 有序矩阵中的第 k 个最小数组和</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个 <code>m * n</code> 的矩阵 <code>mat</code>，以及一个整数 <code>k</code> ，矩阵中的每一行都以非递减的顺序排列。</p>
<p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 <strong>最小</strong> 数组和。</p>
<h4 id="示例-1：-3"><a href="#示例-1：-3" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,3,11],[2,4,6]], k &#x3D; 5</span><br><span class="line">输出：7</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-3"><a href="#示例-2：-3" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,3,11],[2,4,6]], k &#x3D; 9</span><br><span class="line">输出：17</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-3"><a href="#示例-3：-3" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,10,10],[1,4,5],[2,3,6]], k &#x3D; 7</span><br><span class="line">输出：9</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,1,10],[2,2,9]], k &#x3D; 7</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>

<h4 id="提示：-3"><a href="#提示：-3" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat.length[i]</code></li>
<li><code>1 &lt;= m, n &lt;= 40</code></li>
<li><code>1 &lt;= k &lt;= min(200, n ^ m)</code></li>
<li><code>1 &lt;= mat[i][j] &lt;= 5000</code></li>
<li><code>mat[i]</code> 是一个非递减数组</li>
</ul>
<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>解题思路</p>
<ul>
<li>将“求前<code>m</code>行的第<code>k</code>个最小数组和”按动态规划的思路划分成子问题：已知前<code>m-1</code>行的最小数组和的<strong>列表</strong>，求前<code>m</code>行的第<code>k</code>个最小数组和。</li>
<li>例如，<code>mat = [[1,10,10],[1,4,5],[2,3,6]]</code>，<code>k = 7</code>。已知前两行的最小数组和<code>last_row = [2,5,6,11,11,14,14,15,15]</code>。我们截取<code>last_row</code>的前<code>k</code>个元素（因为后面的元素不再有竞争力），<code>last_row = [2,5,6,11,11,14,14]</code>。然后遍历第三行的每个元素，与<code>last_row</code>的每个元素求和，排序+截取后得到<code>new_row = [4, 5, 7, 8, 8, 8, 9]</code>。返回第<code>k</code>个元素即可。</li>
</ul>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：$O(m*max(n, klog(k))$。遍历每行，时间复杂度为$O(m)$。对于每一行，遍历每一列的元素为$O(n)$，对该行求出的数组和排序的复杂度为$O(klog(k))$。</li>
<li>空间复杂度：$O(k)$。每行都要存储一个长度不超过<code>k</code>的”数组和”列表。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, mat: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">        last_row = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat)):</span><br><span class="line">            new_row = [] </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(mat[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> last_row:</span><br><span class="line">                    new_row.append(p + mat[i][j])</span><br><span class="line">            new_row.sort()</span><br><span class="line">            <span class="keyword">if</span> len(new_row) &gt; k:</span><br><span class="line">                last_row = new_row[ :k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                last_row = new_row</span><br><span class="line">        <span class="keyword">return</span> last_row[k - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>可以先看下<a href="https://leetcode-cn.com/problems/ugly-number-ii/solution/1-zui-xiao-dui-2-dong-tai-gui-hua-san-zhi-zhen-pyt/" target="_blank" rel="noopener">264. 丑数 II</a>这道题。T264的最小堆解法：每次从堆中弹出最小的丑数，然后把该丑数能生成的新的丑数push入堆。</li>
<li>本题也很相似，每次从堆中弹出最小的数组和<code>curr_sum</code>和对应的指针<code>pointers</code>，然后轮流将指针<code>pointers</code>的每个索引向后移动一位，生成新的<code>new_sum</code>，加入堆中。</li>
</ul>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><ul>
<li>最小堆存储的是<code>[curr_sum, pointers]</code>二元组，<code>pointers</code>是指针数组，<code>curr_sum</code>是该<code>pointers</code>指向的元素的和。初始化<code>pointers</code>全为0，求出相应的<code>curr_sum</code>，并将其入堆。</li>
<li>重复下列步骤k次<ul>
<li>从堆中pop出<code>curr_sum</code>和<code>pointers</code>。</li>
<li>遍历<code>pointers</code>的每个索引，将该索引加一，求出新的和，如果没有出现过，push入堆。</li>
</ul>
</li>
</ul>
<h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><ul>
<li>以<code>mat = [[1,10,10],[1,4,5],[2,3,6]]</code>，<code>k = 7</code>为例，初始化<code>pointers = (0, 0, 0)</code>，<code>curr_sum = 4</code>，哈希表<code>seen</code>加入<code>(0, 0, 0)</code></li>
<li>从堆中pop出最小和，<code>pointers = (0, 0, 0)</code>，<code>curr_sum = 4</code>。新生成<code>[13, (1, 0, 0)]</code>,<code>[7, (0, 1, 0)]</code>，<code>[5, (0, 0, 1)]</code>，在<code>seen</code>中做好标记，然后将三者入堆。重复该步骤<code>k</code>次。</li>
</ul>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度：O(kmlog(k))<em>O</em>(<em>k<strong>m</strong>l<strong>o</strong>g</em>(<em>k</em>))。执行<code>k</code>次循环：每次循环时，出堆操作，是O(log(k)))<em>O</em>(<em>l<strong>o</strong>g</em>(<em>k</em>)))；每次出堆后，要生成<code>m</code>个新的数组和，是O(n)<em>O</em>(<em>n</em>)；将新生成的的数组和入队，是O(logk)<em>O</em>(<em>l<strong>o</strong>g**k</em>)。所以总的是O(k * (log(k) + m * log(k))) = O(kmlog(k)))<em>O</em>(<em>k</em>∗(<em>l<strong>o</strong>g</em>(<em>k</em>)+<em>m</em>∗<em>l<strong>o</strong>g</em>(<em>k</em>)))=<em>O</em>(<em>k<strong>m</strong>l<strong>o</strong>g</em>(<em>k</em>)))</li>
<li>空间复杂度：O(km^2)<em>O</em>(<em>k*<em>m</em>2)。堆中的元素个数不会超过<code>km</code>个，每个的空间是O(m)*O</em>(<em>m</em>)</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, mat, k: int)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(mat), len(mat[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 初始化指针</span></span><br><span class="line">        pointers = [<span class="number">0</span>] * m </span><br><span class="line">        <span class="comment"># 初始化heap</span></span><br><span class="line">        heap = []</span><br><span class="line">        curr_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            curr_sum += mat[i][<span class="number">0</span>]</span><br><span class="line">        heapq.heappush(heap, [curr_sum, tuple(pointers)])</span><br><span class="line">        <span class="comment"># 初始化seen</span></span><br><span class="line">        seen = set()</span><br><span class="line">        seen.add(tuple(pointers))</span><br><span class="line">        <span class="comment"># 执行k次</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="comment"># 从堆中pop出curr_sum(最小数组和)和pointers(指针数组)</span></span><br><span class="line">            curr_sum, pointers = heapq.heappop(heap)</span><br><span class="line">            <span class="comment"># 每个指针轮流后移一位，将new_sum(新的数组和)和new_pointers(新的指针数组)push入堆</span></span><br><span class="line">            <span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(pointers):</span><br><span class="line">                <span class="keyword">if</span> j &lt; n - <span class="number">1</span>:</span><br><span class="line">                    new_pointers = list(pointers)</span><br><span class="line">                    new_pointers[i] = j + <span class="number">1</span></span><br><span class="line">                    new_pointers = tuple(new_pointers)</span><br><span class="line">                    <span class="keyword">if</span> new_pointers <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                        new_sum = curr_sum + mat[i][j + <span class="number">1</span>]- mat[i][j]</span><br><span class="line">                        heapq.heappush(heap, [new_sum, new_pointers])</span><br><span class="line">                        seen.add(new_pointers)</span><br><span class="line">        <span class="keyword">return</span> curr_sum</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>周赛</tag>
        <tag>刷题</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第25场双周赛</title>
    <url>/2020/05/03/2020-05-03-LeetCode-Doubleuble-Contest-25/</url>
    <content><![CDATA[<p>今日参加双周赛，战况不良 <code>661 / 1832</code></p>
<table>
<thead>
<tr>
<th>题目</th>
<th align="center">分值</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/" target="_blank" rel="noopener">5384. 拥有最多糖果的孩子</a></td>
<td align="center">3</td>
<td align="center">简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/max-difference-you-can-get-from-changing-an-integer/" target="_blank" rel="noopener">5385. 改变一个整数能得到的最大差值</a></td>
<td align="center">4</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/check-if-a-string-can-break-another-string/" target="_blank" rel="noopener">5386. 检查一个字符串是否可以打破另一个字符串</a></td>
<td align="center">5</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/number-of-ways-to-wear-different-hats-to-each-other/" target="_blank" rel="noopener">5387. 每个人戴不同帽子的方案数</a></td>
<td align="center">7</td>
<td align="center">困难</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="5384-拥有最多糖果的孩子"><a href="#5384-拥有最多糖果的孩子" class="headerlink" title="5384. 拥有最多糖果的孩子"></a><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/" target="_blank" rel="noopener">5384. 拥有最多糖果的孩子</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个数组 <code>candies</code> 和一个整数 <code>extraCandies</code> ，其中 <code>candies[i]</code> 代表第 <code>i</code> 个孩子拥有的糖果数目。</p>
<p>对每一个孩子，检查是否存在一种方案，将额外的 <code>extraCandies</code> 个糖果分配给孩子们之后，此孩子有 <strong>最多</strong> 的糖果。注意，允许有多个孩子同时拥有 <strong>最多</strong> 的糖果数目。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candies &#x3D; [2,3,5,1,3], extraCandies &#x3D; 3</span><br><span class="line">输出：[true,true,true,false,true] </span><br><span class="line">解释：</span><br><span class="line">孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。</span><br><span class="line">孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。</span><br><span class="line">孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candies &#x3D; [4,2,1,1,2], extraCandies &#x3D; 1</span><br><span class="line">输出：[true,false,false,false,false] </span><br><span class="line">解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candies &#x3D; [12,1,12], extraCandies &#x3D; 10</span><br><span class="line">输出：[true,false,true]</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(candies.<span class="built_in">size</span>(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> maxnum = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:candies)</span><br><span class="line">            maxnum = <span class="built_in">max</span>(maxnum,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;candies.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(candies[i]+extraCandies&gt;=maxnum)</span><br><span class="line">                res[i]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5385-改变一个整数能得到的最大差值"><a href="#5385-改变一个整数能得到的最大差值" class="headerlink" title="5385. 改变一个整数能得到的最大差值"></a><a href="https://leetcode-cn.com/problems/max-difference-you-can-get-from-changing-an-integer/" target="_blank" rel="noopener">5385. 改变一个整数能得到的最大差值</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数 <code>num</code> 。你可以对它进行如下步骤恰好 <strong>两次</strong> ：</p>
<ul>
<li>选择一个数字 <code>x (0 &lt;= x &lt;= 9)</code>.</li>
<li>选择另一个数字 <code>y (0 &lt;= y &lt;= 9)</code> 。数字 <code>y</code> 可以等于 <code>x</code> 。</li>
<li>将 <code>num</code> 中所有出现 <code>x</code> 的数位都用 <code>y</code> 替换。</li>
<li>得到的新的整数 <strong>不能</strong> 有前导 0 ，得到的新整数也 <strong>不能</strong> 是 0 。</li>
</ul>
<p>令两次对 <code>num</code> 的操作得到的结果分别为 <code>a</code> 和 <code>b</code> 。</p>
<p>请你返回 <code>a</code> 和 <code>b</code> 的 <strong>最大差值</strong> 。 </p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 555</span><br><span class="line">输出：888</span><br><span class="line">解释：第一次选择 x &#x3D; 5 且 y &#x3D; 9 ，并把得到的新数字保存在 a 中。</span><br><span class="line">第二次选择 x &#x3D; 5 且 y &#x3D; 1 ，并把得到的新数字保存在 b 中。</span><br><span class="line">现在，我们有 a &#x3D; 999 和 b &#x3D; 111 ，最大差值为 888</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 9</span><br><span class="line">输出：8</span><br><span class="line">解释：第一次选择 x &#x3D; 9 且 y &#x3D; 9 ，并把得到的新数字保存在 a 中。</span><br><span class="line">第二次选择 x &#x3D; 9 且 y &#x3D; 1 ，并把得到的新数字保存在 b 中。</span><br><span class="line">现在，我们有 a &#x3D; 9 和 b &#x3D; 1 ，最大差值为 8</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 123456</span><br><span class="line">输出：820000</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 10000</span><br><span class="line">输出：80000</span><br></pre></td></tr></table></figure>

<h4 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a><strong>示例 5：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 9288</span><br><span class="line">输出：8700</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num &lt;= 10^8</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDiff</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> numstr = to_string(num);</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numstr.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numstr[i]!=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ch = numstr[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch!=<span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numstr.length();i++)</span><br><span class="line">                <span class="keyword">if</span>(numstr[i]==ch)</span><br><span class="line">                    numstr[i]=<span class="string">'9'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxnum = ch==<span class="string">'#'</span>?num:stoi(numstr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minnum = <span class="number">0</span>;</span><br><span class="line">        numstr = to_string(num); </span><br><span class="line">        <span class="comment">//把第一个数字改成1</span></span><br><span class="line">        <span class="keyword">if</span>(numstr.length()==<span class="number">1</span>)</span><br><span class="line">            minnum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numstr[<span class="number">0</span>]!=<span class="string">'1'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ch = numstr[<span class="number">0</span>];    </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numstr.length();i++)</span><br><span class="line">                <span class="keyword">if</span>(numstr[i]==ch)</span><br><span class="line">                    numstr[i]=<span class="string">'1'</span>;            </span><br><span class="line">            minnum = stoi(numstr);      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ch = <span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;numstr.length();i++)</span><br><span class="line">                <span class="keyword">if</span>(numstr[i]!=<span class="string">'0'</span>&amp;&amp;numstr[i]!=<span class="string">'1'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ch = numstr[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(ch!=<span class="string">'#'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;numstr.length();i++)</span><br><span class="line">                    <span class="keyword">if</span>(numstr[i]==ch)</span><br><span class="line">                        numstr[i] = <span class="string">'0'</span>;</span><br><span class="line">                minnum = stoi(numstr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                minnum = num;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxnum-minnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5386-检查一个字符串是否可以打破另一个字符串"><a href="#5386-检查一个字符串是否可以打破另一个字符串" class="headerlink" title="5386. 检查一个字符串是否可以打破另一个字符串"></a><a href="https://leetcode-cn.com/problems/check-if-a-string-can-break-another-string/" target="_blank" rel="noopener">5386. 检查一个字符串是否可以打破另一个字符串</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，它们长度相等，请你检查是否存在一个 <code>s1</code> 的排列可以打破 <code>s2</code> 的一个排列，或者是否存在一个 <code>s2</code> 的排列可以打破 <code>s1</code> 的一个排列。</p>
<p>字符串 <code>x</code> 可以打破字符串 <code>y</code> （两者长度都为 <code>n</code> ）需满足对于所有 <code>i</code>（在 <code>0</code> 到 <code>n - 1</code> 之间）都有 <code>x[i] &gt;= y[i]</code>（字典序意义下的顺序）。 </p>
<h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s1 &#x3D; &quot;abc&quot;, s2 &#x3D; &quot;xya&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;ayx&quot; 是 s2&#x3D;&quot;xya&quot; 的一个排列，&quot;abc&quot; 是字符串 s1&#x3D;&quot;abc&quot; 的一个排列，且 &quot;ayx&quot; 可以打破 &quot;abc&quot; 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s1 &#x3D; &quot;abe&quot;, s2 &#x3D; &quot;acd&quot;</span><br><span class="line">输出：false </span><br><span class="line">解释：s1&#x3D;&quot;abe&quot; 的所有排列包括：&quot;abe&quot;，&quot;aeb&quot;，&quot;bae&quot;，&quot;bea&quot;，&quot;eab&quot; 和 &quot;eba&quot; ，s2&#x3D;&quot;acd&quot; 的所有排列包括：&quot;acd&quot;，&quot;adc&quot;，&quot;cad&quot;，&quot;cda&quot;，&quot;dac&quot; 和 &quot;dca&quot;。然而没有任何 s1 的排列可以打破 s2 的排列。也没有 s2 的排列能打破 s1 的排列。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s1 &#x3D; &quot;leetcodee&quot;, s2 &#x3D; &quot;interview&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>s1.length == n</code></li>
<li><code>s2.length == n</code></li>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li>所有字符串都只包含小写英文字母。</li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfCanBreak</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        sort(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">end</span>());</span><br><span class="line">        sort(s2.<span class="built_in">begin</span>(),s2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">bool</span> left = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> right = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s1.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            left= left&amp;&amp;(s1[i]&gt;=s2[i]);</span><br><span class="line">            right= right&amp;&amp;(s1[i]&lt;=s2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left||right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5387-每个人戴不同帽子的方案数"><a href="#5387-每个人戴不同帽子的方案数" class="headerlink" title="5387. 每个人戴不同帽子的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-wear-different-hats-to-each-other/" target="_blank" rel="noopener">5387. 每个人戴不同帽子的方案数</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>总共有 <code>n</code> 个人和 <code>40</code> 种不同的帽子，帽子编号从 <code>1</code> 到 <code>40</code> 。</p>
<p>给你一个整数列表的列表 <code>hats</code> ，其中 <code>hats[i]</code> 是第 <code>i</code> 个人所有喜欢帽子的列表。</p>
<p>请你给每个人安排一顶他喜欢的帽子，确保每个人戴的帽子跟别人都不一样，并返回方案数。</p>
<p>由于答案可能很大，请返回它对 <code>10^9 + 7</code> 取余后的结果。 </p>
<h4 id="示例-1：-3"><a href="#示例-1：-3" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：hats &#x3D; [[3,4],[4,5],[5]]</span><br><span class="line">输出：1</span><br><span class="line">解释：给定条件下只有一种方法选择帽子。</span><br><span class="line">第一个人选择帽子 3，第二个人选择帽子 4，最后一个人选择帽子 5。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-3"><a href="#示例-2：-3" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：hats &#x3D; [[3,5,1],[3,5]]</span><br><span class="line">输出：4</span><br><span class="line">解释：总共有 4 种安排帽子的方法：</span><br><span class="line">(3,5)，(5,3)，(1,3) 和 (1,5)</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-3"><a href="#示例-3：-3" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：hats &#x3D; [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]</span><br><span class="line">输出：24</span><br><span class="line">解释：每个人都可以从编号为 1 到 4 的帽子中选。</span><br><span class="line">(1,2,3,4) 4 个帽子的排列方案数为 24 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：hats &#x3D; [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]</span><br><span class="line">输出：111</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>n == hats.length</code></li>
<li><code>1 &lt;= n &lt;= 10</code></li>
<li><code>1 &lt;= hats[i].length &lt;= 40</code></li>
<li><code>1 &lt;= hats[i][j] &lt;= 40</code></li>
<li><code>hats[i]</code> 包含一个数字互不相同的整数列表。</li>
</ul>
<h3 id="示例解法"><a href="#示例解法" class="headerlink" title="示例解法"></a>示例解法</h3><p><strong>大佬思路</strong></p>
<p>LeetCode还真是喜欢出状压的题目。还是老套路，看到某一个维度特别小（本题是1\leq n\leq101≤<em>n</em>≤10），就尝试在这一维进行状态压缩。</p>
<p>我们用一个n<em>n</em>位的二进制数记录每个人是否戴上了帽子。因为是对人进行了状压，所以我们需要把题目给的每个人可以戴的帽子先转换成每个帽子可以匹配的人。之后，我们就可以遍历所有帽子，对于每一顶帽子，我们尝试把它分配给一个当前还没有帽子，并且能够匹配这顶帽子的人，来更新状态。</p>
<p>DP的转移方程为：</p>
<p>$dp[state][i]=dp[state][i-1] + \sum dp[state - (1 &lt;&lt; k)][i-1]$</p>
<p>其中state表示当前的戴帽子情况，i表示分配第i号帽子，k满足$k\in S(i)$也即第i号帽子可以分配给第k个人，且$(state - (1 &lt;&lt; k)) &amp; (1 &lt;&lt; k) = 0$，也即前一个状态中第k<em>k</em>个人还没有戴帽子。</p>
<p>边界条件为：</p>
<p>$dp[0][0]=1$</p>
<p>也即所有人都还没戴上帽子，有1种方案。因为转移方程只涉及$i$和$i-1$，所以可以用滚动数组做成一维空间。</p>
<p>总时间复杂度$O(nm2^n)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">numberWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; hats)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = hats.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;ll&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">s</span><span class="params">(<span class="number">41</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> hat : hats[i])</span><br><span class="line">        s[hat].insert(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; ++i) &#123;</span><br><span class="line">      <span class="function"><span class="built_in">vector</span>&lt;ll&gt; <span class="title">ndp</span><span class="params">(dp)</span></span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> state = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; state &gt;= <span class="number">0</span>; --state) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> person : s[i]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (state &amp; (<span class="number">1</span> &lt;&lt; person))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">int</span> nxt = state + (<span class="number">1</span> &lt;&lt; person);</span><br><span class="line">          ndp[nxt] += dp[state];</span><br><span class="line">          ndp[nxt] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(dp, ndp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：lucifer1004</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode-cn.com/problems/number-of-ways-to-wear-different-hats-to-each-//other/solution/zhuang-tai-ya-suo-ji-lu-mei-ge-ren-shi-fou-dai-sha/</span></span><br><span class="line"><span class="comment">// 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>周赛</tag>
        <tag>刷题</tag>
        <tag>双周赛</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第186场周赛</title>
    <url>/2020/05/03/2020-05-03-LeetCode-Contest-186/</url>
    <content><![CDATA[<p>上周参加周赛，战况还行，排名<code>367 / 3107</code></p>
<table>
<thead>
<tr>
<th>题目</th>
<th align="center">分值</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string/" target="_blank" rel="noopener">1422. 分割字符串的最大得分</a></td>
<td align="center">3</td>
<td align="center">简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">1423. 可获得的最大点数</a></td>
<td align="center">4</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">1424. 对角线遍历 II</a></td>
<td align="center">5</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/constrained-subsequence-sum/" target="_blank" rel="noopener">1425. 带限制的子序列和</a></td>
<td align="center">6</td>
<td align="center">困难</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="1422-分割字符串的最大得分"><a href="#1422-分割字符串的最大得分" class="headerlink" title="1422. 分割字符串的最大得分"></a><a href="https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string/" target="_blank" rel="noopener">1422. 分割字符串的最大得分</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个由若干 0 和 1 组成的字符串 <code>s</code> ，请你计算并返回将该字符串分割成两个 <strong>非空</strong> 子字符串（即 <strong>左</strong> 子字符串和 <strong>右</strong> 子字符串）所能获得的最大得分。</p>
<p>「分割字符串的得分」为 <strong>左</strong> 子字符串中 <strong>0</strong> 的数量加上 <strong>右</strong> 子字符串中 <strong>1</strong> 的数量。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;011101&quot;</span><br><span class="line">输出：5 </span><br><span class="line">解释：</span><br><span class="line">将字符串 s 划分为两个非空子字符串的可行方案有：</span><br><span class="line">左子字符串 &#x3D; &quot;0&quot; 且 右子字符串 &#x3D; &quot;11101&quot;，得分 &#x3D; 1 + 4 &#x3D; 5 </span><br><span class="line">左子字符串 &#x3D; &quot;01&quot; 且 右子字符串 &#x3D; &quot;1101&quot;，得分 &#x3D; 1 + 3 &#x3D; 4 </span><br><span class="line">左子字符串 &#x3D; &quot;011&quot; 且 右子字符串 &#x3D; &quot;101&quot;，得分 &#x3D; 1 + 2 &#x3D; 3 </span><br><span class="line">左子字符串 &#x3D; &quot;0111&quot; 且 右子字符串 &#x3D; &quot;01&quot;，得分 &#x3D; 1 + 1 &#x3D; 2 </span><br><span class="line">左子字符串 &#x3D; &quot;01110&quot; 且 右子字符串 &#x3D; &quot;1&quot;，得分 &#x3D; 2 + 1 &#x3D; 3</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;00111&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：当 左子字符串 &#x3D; &quot;00&quot; 且 右子字符串 &#x3D; &quot;111&quot; 时，我们得到最大得分 &#x3D; 2 + 3 &#x3D; 5</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1111&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= s.length &lt;= 500</code></li>
<li>字符串 <code>s</code> 仅由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成。</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp0</span><span class="params">(len,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp1</span><span class="params">(len,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        &#123;           </span><br><span class="line">            dp0[i] = (i==<span class="number">0</span>? <span class="number">0</span> : dp0[i<span class="number">-1</span>]) + (s[i]==<span class="string">'0'</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// dp1[len-1-i] = (i==0? 0 :dp1[len-i]) +(s[i]=='1'?1:0);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len <span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            dp1[i] = (i==len<span class="number">-1</span>?<span class="number">0</span>:dp1[i+<span class="number">1</span>])+(s[i]==<span class="string">'1'</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;dp0[i]&lt;&lt;' '&lt;&lt;dp1[i+1]&lt;&lt;endl;</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,dp0[i]+dp1[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1423-可获得的最大点数"><a href="#1423-可获得的最大点数" class="headerlink" title="1423. 可获得的最大点数"></a><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">1423. 可获得的最大点数</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p>
<p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p>
<p>你的点数就是你拿到手中的所有卡牌的点数之和。</p>
<p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,2,3,4,5,6,1], k &#x3D; 3</span><br><span class="line">输出：12</span><br><span class="line">解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 &#x3D; 12 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [2,2,2], k &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [9,7,7,9,7,7,9], k &#x3D; 7</span><br><span class="line">输出：55</span><br><span class="line">解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,1000,1], k &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,79,80,1,1,1,200,1], k &#x3D; 3</span><br><span class="line">输出：202</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= cardPoints.length &lt;= 10^5</code></li>
<li><code>1 &lt;= cardPoints[i] &lt;= 10^4</code></li>
<li><code>1 &lt;= k &lt;= cardPoints.length</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = cardPoints.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> n:cardPoints)</span><br><span class="line">                sum+=n;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">leftk</span><span class="params">(k+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightk</span><span class="params">(k+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;k+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            leftk[i]=leftk[i<span class="number">-1</span>]+cardPoints[i<span class="number">-1</span>];</span><br><span class="line">            rightk[i] = rightk[i<span class="number">-1</span>]+cardPoints[len-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res,leftk[i]+rightk[k-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            sum += cardPoints[i];</span><br><span class="line">        <span class="keyword">int</span> n = cardPoints.<span class="built_in">size</span>(), ans = sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            sum = sum - cardPoints[k - <span class="number">1</span> - i] + cardPoints[n - <span class="number">1</span> - i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1424-对角线遍历-II"><a href="#1424-对角线遍历-II" class="headerlink" title="1424. 对角线遍历 II"></a><a href="https://leetcode-cn.com/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">1424. 对角线遍历 II</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个列表 <code>nums</code> ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 <code>nums</code> 中对角线上的整数。 </p>
<h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><p><strong><img src="/2020/05/03/2020-05-03-LeetCode-Contest-186/sample_1_1784.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,4,2,7,5,3,8,6,9]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><p><strong><img src="/2020/05/03/2020-05-03-LeetCode-Contest-186/sample_2_1784.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]</span><br><span class="line">输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [[1,2,3],[4],[5,6,7],[8],[9,10,11]]</span><br><span class="line">输出：[1,4,2,5,3,8,6,9,7,10,11]</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [[1,2,3,4,5,6]]</span><br><span class="line">输出：[1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i].length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i][j] &lt;= 10^9</code></li>
<li><code>nums</code> 中最多有 <code>10^5</code> 个数字。</li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//保存各个数组的长度</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; flag=nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            l[i] = nums[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//队列</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        flag[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> row = tmp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> col = tmp[<span class="number">1</span>];</span><br><span class="line">            res.push_back(nums[row][col]);</span><br><span class="line">            <span class="keyword">if</span>(row+<span class="number">1</span>&lt;nums.<span class="built_in">size</span>()&amp;&amp;col&lt;l[row+<span class="number">1</span>]&amp;&amp;flag[row+<span class="number">1</span>][col])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(&#123;row+<span class="number">1</span>,col&#125;);</span><br><span class="line">                flag[row+<span class="number">1</span>][col] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(col+<span class="number">1</span>&lt;l[row]&amp;&amp;flag[row][col+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(&#123;row,col+<span class="number">1</span>&#125;);</span><br><span class="line">                flag[row][col+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化写法：</p>
<p><strong>思路</strong></p>
<ol>
<li>正常遍历</li>
<li>根据顺序，每条对角线肯定是最后的元素先入栈</li>
<li>使用一个堆栈（代码里使用了 vector）来记录每条对角线的元素</li>
<li>最后整合到一起</li>
<li>缺点，可能很慢</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = i + j;</span><br><span class="line">                <span class="keyword">if</span> (k == st.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    st.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                st[k].push_back(nums[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : st) &#123;</span><br><span class="line">            ans.insert(ans.<span class="built_in">end</span>(), s.rbegin(), s.rend());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">作者：ikaruga</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/diagonal-traverse-ii/solution/diagonal-traverse-ii-by-ikaruga/</span></span><br><span class="line">来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="1425-带限制的子序列和"><a href="#1425-带限制的子序列和" class="headerlink" title="1425. 带限制的子序列和"></a><a href="https://leetcode-cn.com/problems/constrained-subsequence-sum/" target="_blank" rel="noopener">1425. 带限制的子序列和</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <strong>非空</strong> 子序列元素和的最大值，子序列需要满足：子序列中每两个 <strong>相邻</strong> 的整数 <code>nums[i]</code> 和 <code>nums[j]</code> ，它们在原数组中的下标 <code>i</code> 和 <code>j</code> 满足 <code>i &lt; j</code> 且 <code>j - i &lt;= k</code> 。</p>
<p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。 </p>
<h4 id="示例-1：-3"><a href="#示例-1：-3" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,2,-10,5,20], k &#x3D; 2</span><br><span class="line">输出：37</span><br><span class="line">解释：子序列为 [10, 2, 5, 20] 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-3"><a href="#示例-2：-3" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,-2,-3], k &#x3D; 1</span><br><span class="line">输出：-1</span><br><span class="line">解释：子序列必须是非空的，所以我们选择最大的数字。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,-2,-10,-5,20], k &#x3D; 2</span><br><span class="line">输出：23</span><br><span class="line">解释：子序列为 [10, -2, -5, 20] 。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><p>思路：<br>结合了动态规划和滑动窗口的思想(239题)。<br>首先定义动态规划转移方程,dp[i]表示以i数字结尾的最大子序列，则转移方程为：<br>$$ dp[i]=max(dp[i-j]+nums[i],nums[i]) 其中 j=1,2…k$$<br>如果直接遍历i的前k个值，然后取最大值会超时，所以我们需要用一个结构来维持前k个值的大小顺序，从而直接获取前k个最大的值，这就回归到了239题的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">constrainedSubsetSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">        sta.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[sta.front()]+nums[i],nums[i]);</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">            <span class="keyword">if</span>(i-sta.front()==k) sta.pop_front();</span><br><span class="line">            <span class="keyword">while</span>(!sta.empty()&amp;&amp;dp[sta.back()]&lt;dp[i]) sta.pop_back();</span><br><span class="line">            sta.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>周赛</tag>
        <tag>刷题</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeeCode 每日打卡4-27~5.3</title>
    <url>/2020/04/30/2020-04-30-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>本周打卡题目如下：</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题56 - I. 数组中数字出现的次数</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></td>
<td>困难</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">202. 快乐数</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></td>
<td>简单</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(nums,left,right,target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">            <span class="keyword">return</span> nums[left]==target?left:<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">int</span> l = helper(nums,left,mid<span class="number">-1</span>,target);</span><br><span class="line">        <span class="keyword">return</span> l==<span class="number">-1</span>?helper(nums,mid+<span class="number">1</span>,right,target):l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：二分搜索"><a href="#方法一：二分搜索" class="headerlink" title="方法一：二分搜索"></a>方法一：二分搜索</h4><p><strong>思路和算法</strong></p>
<p>题目要求算法时间复杂度必须是 $O(\log n)$的级别，这提示我们可以使用二分搜索的方法。但是数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分搜索吗？答案是可以的。可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 <code>6</code> 这个位置分开以后数组变成了 <code>[4, 5, 6]</code> 和 <code>[7, 0, 1, 2]</code> 两个部分，其中左边 <code>[4, 5, 6]</code> 这个部分的数组是有序的，其他也是如此。这启示我们可以在常规二分搜索的时候查看当前 <code>mid</code> 为分割位置分割出来的两个部分 <code>[l, mid]</code> 和 <code>[mid + 1, r]</code> 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分搜索的上下界，因为我们能够根据有序的那部分判断出 <code>target</code> 在不在这个部分：</p>
<ul>
<li>如果 <code>[l, mid - 1]</code> 是有序数组，且 <code>target</code> 的大小满足$ [\textit{nums}[l],\textit{nums}[mid]))$，则我们应该将搜索范围缩小至 <code>[l, mid - 1]</code>，否则在 <code>[mid + 1, r]</code> 中寻找。</li>
<li>如果 <code>[mid, r]</code> 是有序数组，且 <code>target</code> 的大小满足 $(\textit{nums}[mid+1],\textit{nums}[r])$，则我们应该将搜索范围缩小至 <code>[mid + 1, r]</code>，否则在 <code>[l, mid - 1]</code> 中寻找。</li>
</ul>
<p><img src="/2020/04/30/2020-04-30-LeetCode-CheckDaily/33_fig1.png" alt="fig1"></p>
<p>需要注意的是，二分的写法有很多种，所以在判断 <code>target</code> 大小与有序部分的关系的时候可能会出现细节上的差别。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度： $O(\log n)$，其中 n 为$ \textit{nums}[]$ 数组的大小。整个算法时间复杂度即为二分搜索的时间复杂度 $O(\log n)$。</li>
<li>空间复杂度： $O(1)$ 。我们只需要常数级别的空间存放变量。</li>
</ul>
<h2 id="面试题56-I-数组中数字出现的次数"><a href="#面试题56-I-数组中数字出现的次数" class="headerlink" title="面试题56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题56 - I. 数组中数字出现的次数</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>

<p> <strong>限制：</strong></p>
<ul>
<li><code>2 &lt;= nums &lt;= 10000</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : nums)</span><br><span class="line">            s ^= n;</span><br><span class="line">        <span class="keyword">int</span> k = s &amp; (-s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &amp; k)&#123;</span><br><span class="line">                res[<span class="number">0</span>]^=num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[<span class="number">1</span>]^=num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="1095-山脉数组中查找目标值"><a href="#1095-山脉数组中查找目标值" class="headerlink" title="1095. 山脉数组中查找目标值"></a><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>（这是一个 <strong>交互式问题</strong> ）</p>
<p>给你一个 <strong>山脉数组</strong> <code>mountainArr</code>，请你返回能够使得 <code>mountainArr.get(index)</code> <strong>等于</strong> <code>target</code> <strong>最小</strong> 的下标 <code>index</code> 值。如果不存在这样的下标 <code>index</code>，就请返回 <code>-1</code>。 </p>
<p>何为山脉数组？如果数组 <code>A</code> 是一个山脉数组的话，那它满足如下条件：</p>
<p><strong>首先</strong>，<code>A.length &gt;= 3</code></p>
<p><strong>其次</strong>，在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 <code>i</code> 使得：</p>
<ul>
<li><p><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></p>
</li>
<li><p><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></p>
<p>你将 <strong>不能直接访问该山脉数组</strong>，必须通过 <code>MountainArray</code> 接口来获取数据：</p>
</li>
<li><p><code>MountainArray.get(k)</code> - 会返回数组中索引为<code>k</code> 的元素（下标从 0 开始）</p>
</li>
<li><p><code>MountainArray.length()</code> - 会返回该数组的长度</p>
</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：array &#x3D; [1,2,3,4,5,3,1], target &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：array &#x3D; [0,1,2,4,2,1], target &#x3D; 3</span><br><span class="line">输出：-1</span><br><span class="line">解释：3 在数组中没有出现，返回 -1。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= mountain_arr.length() &lt;= 10000</code></li>
<li><code>0 &lt;= target &lt;= 10^9</code></li>
<li><code>0 &lt;= mountain_arr.get(index) &lt;= 10^9</code></li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray &amp;mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = MountainArray.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">peek</span> = findPeek(mountainArr,left,right);</span><br><span class="line">        <span class="keyword">return</span> helper(mountainArr,left,right,target);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(MountainArray &amp;mountainArr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(left=right)</span><br><span class="line">            <span class="keyword">return</span> mountainArr.<span class="built_in">get</span>(left)==target?left:<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midval = mountainArr.<span class="built_in">get</span>(mid);</span><br><span class="line">        <span class="keyword">if</span>(midval==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftval = mountainArr.<span class="built_in">get</span>(left);</span><br><span class="line">        <span class="keyword">if</span>(leftval==target)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rightval = mountainArr.<span class="built_in">get</span>(right);</span><br><span class="line">        <span class="keyword">if</span>(rightval==target)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeek</span><span class="params">(MountainArray &amp;mountainArr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(m+<span class="number">1</span>&lt;= right &amp;&amp; mountainArr.<span class="built_in">get</span>(mid)&lt;mountainArr.<span class="built_in">get</span>(mid+<span class="number">1</span>))</span><br><span class="line">                l = m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r= m;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：二分查找-1"><a href="#方法一：二分查找-1" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(MountainArray &amp;mountain, <span class="keyword">int</span> target, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> key(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">        target = key(target);</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = key(mountain.<span class="built_in">get</span>(mid));</span><br><span class="line">            <span class="keyword">if</span> (cur == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur &lt; target)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray &amp;mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = mountainArr.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mountainArr.<span class="built_in">get</span>(mid) &lt; mountainArr.<span class="built_in">get</span>(mid + <span class="number">1</span>))</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> peak = l;</span><br><span class="line">        <span class="keyword">int</span> index = binary_search(mountainArr, target, <span class="number">0</span>, peak, [](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span>&#123;<span class="keyword">return</span> x;&#125;);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        <span class="keyword">return</span> binary_search(mountainArr, target, peak + <span class="number">1</span>, mountainArr.length() - <span class="number">1</span>, [](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span>&#123;<span class="keyword">return</span> -x;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。如果 <strong>可以变为</strong> 1，那么这个数就是快乐数。</p>
<p>如果 <code>n</code> 是快乐数就返回 <code>True</code> ；不是，则返回 <code>False</code> 。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-2"><a href="#官方解法-2" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：用-HashSet-检测循环"><a href="#方法一：用-HashSet-检测循环" class="headerlink" title="方法一：用 HashSet 检测循环"></a>方法一：用 HashSet 检测循环</h4><p>我们可以先举几个例子。我们从 77 开始。则下一个数字是 4949（因为 7^2=4972=49），然后下一个数字是 9797（因为 4^2+9^2=9742+92=97）。我们可以不断重复该的过程，直到我们得到 11。因为我们得到了 11，我们知道 77 是一个快乐数，函数应该返回 <code>true</code>。</p>
<p><img src="/2020/04/30/2020-04-30-LeetCode-CheckDaily/202_fig1.png" alt="fig1"></p>
<p>再举一个例子，让我们从 116116 开始。通过反复通过平方和计算下一个数字，我们最终得到 5858，再继续计算之后，我们又回到 5858。由于我们回到了一个已经计算过的数字，可以知道有一个循环，因此不可能达到 11。所以对于 116116，函数应该返回 <code>false</code>。</p>
<p><img src="/2020/04/30/2020-04-30-LeetCode-CheckDaily/202_fig2.png" alt="fig2"></p>
<p>根据我们的探索，我们猜测会有以下三种可能。</p>
<ol>
<li>最终会得到 1。</li>
<li>最终会进入循环。</li>
<li>值会越来越大，最后接近无穷大。</li>
</ol>
<p>第三个情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到 11 呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。</p>
<table>
<thead>
<tr>
<th>Digits</th>
<th align="center">Largest</th>
<th align="right">Next</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">9</td>
<td align="right">81</td>
</tr>
<tr>
<td>2</td>
<td align="center">99</td>
<td align="right">162</td>
</tr>
<tr>
<td>3</td>
<td align="center">999</td>
<td align="right">243</td>
</tr>
<tr>
<td>4</td>
<td align="center">9999</td>
<td align="right">324</td>
</tr>
<tr>
<td>13</td>
<td align="center">9999999999999</td>
<td align="right">1053</td>
</tr>
</tbody></table>
<p>对于 33 位数的数字，它不可能大于 243243。这意味着它要么被困在 243243 以下的循环内，要么跌到 11。44 位或 44 位以上的数字在每一步都会丢失一位，直到降到 33 位为止。所以我们知道，最坏的情况下，算法可能会在 243243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 11。但它不会无限期地进行下去，所以我们排除第三种选择。</p>
<p>即使在代码中你不需要处理第三种情况，你仍然需要理解为什么它永远不会发生，这样你就可以证明为什么你不处理它。</p>
<p><strong>算法：</strong></p>
<p>算法分为两部分，我们需要设计和编写代码。</p>
<ol>
<li>给一个数字 n，它的下一个数字是什么？</li>
<li>按照一系列的数字来判断我们是否进入了一个循环。</li>
</ol>
<p>第 1 部分我们按照题目的要求做数位分离，求平方和。</p>
<p>第 2 部分可以使用 HashSet 完成。每次生成链中的下一个数字时，我们都会检查它是否已经在 HashSet 中。</p>
<ul>
<li>如果它不在 HashSet 中，我们应该添加它。</li>
<li>如果它在 HashSet 中，这意味着我们处于一个循环中，因此应该返回 <code>false</code>。</li>
</ul>
<p>我们使用 HashSet 而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集中需要 O(1) 的时间，而对于其他数据结构，则需要 O(n)的时间。选择正确的数据结构是解决这些问题的关键部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private int getNext(int n) &#123;</span><br><span class="line">        int totalSum &#x3D; 0;</span><br><span class="line">        while (n &gt; 0) &#123;</span><br><span class="line">            int d &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            totalSum +&#x3D; d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        return totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsHappy(int n) &#123;</span><br><span class="line">        HashSet &lt;int&gt; seen &#x3D; new HashSet&lt;int&gt;();</span><br><span class="line">        while (n !&#x3D; 1 &amp;&amp; !seen.Contains(n)) &#123;</span><br><span class="line">            seen.Add(n);</span><br><span class="line">            n &#x3D; getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        return n &#x3D;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>确定这个问题的时间复杂度对于一个 “简单” 级别的问题来说是一个挑战。如果您对这些问题还不熟悉，可以尝试只计算 <code>getNext(n)</code> 函数的时间复杂度。</p>
<ul>
<li><p>时间复杂度：</p>
<p>$O(243 \cdot 3 + \log n + \log\log n + \log\log\log n)=O(\log n)$.</p>
<ul>
<li><p>查找给定数字的下一个值的成本为$O(\log n)$，因为我们正在处理数字中的每位数字，而数字中的位数由 $\log n$给定。</p>
</li>
<li><p>要计算出总的时间复杂度，我们需要仔细考虑循环中有多少个数字，它们有多大。</p>
</li>
<li><p>我们在上面确定，一旦一个数字低于 243，它就不可能回到 243 以上。因此，我们就可以用 243以下最长循环的长度来代替 243，不过，因为常数无论如何都无关紧要，所以我们不会担心它。</p>
</li>
<li><p>对于高于 243 的 n，我们需要考虑循环中每个数高于 243 的成本。通过数学运算，我们可以证明在最坏的情况下，这些成本将是 $O(\log n) + O(\log \log n) + O(\log \log \log n)$。幸运的是，$O(\log n)$ 是占主导地位的部分，而其他部分相比之下都很小（总的来说，它们的总和小于$\log n$），所以我们可以忽略它们。</p>
</li>
</ul>
</li>
<li><p>空间复杂度：$O(\log n)$。与时间复杂度密切相关的是衡量我们放入 HashSet 中的数字以及它们有多大的指标。对于足够大的 n，大部分空间将由 n 本身占用。我们可以很容易地优化到 $O(243 \cdot 3) = O(1)$，方法是只保存集合中小于 243 的数字，因为对于较高的数字，无论如何都不可能返回到它们。</p>
</li>
</ul>
<h4 id="方法二：快慢指针法"><a href="#方法二：快慢指针法" class="headerlink" title="方法二：快慢指针法"></a>方法二：快慢指针法</h4><p>通过反复调用 <code>getNext(n)</code> 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。<code>next</code> 指针是通过调用 <code>getNext(n)</code> 函数获得。</p>
<p>意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的快的称为 “乌龟”，跑得快的称为 “兔子”。</p>
<p>不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。</p>
<p><img src="/2020/04/30/2020-04-30-LeetCode-CheckDaily/1.jpg" alt="img"><strong>算法：</strong></p>
<p>我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 <code>getNext(n)</code> 函数的嵌套调用）。如果 <code>n</code> 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。如果 <code>n</code> 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int getNext(int n) &#123;</span><br><span class="line">        int totalSum &#x3D; 0;</span><br><span class="line">        while (n &gt; 0) &#123;</span><br><span class="line">            int d &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            totalSum +&#x3D; d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        return totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsHappy(int n) &#123;</span><br><span class="line">        int slowRunner &#x3D; n;</span><br><span class="line">        int fastRunner &#x3D; getNext(n);</span><br><span class="line">        while (fastRunner !&#x3D; 1 &amp;&amp; slowRunner !&#x3D; fastRunner) &#123;</span><br><span class="line">            slowRunner &#x3D; getNext(slowRunner);</span><br><span class="line">            fastRunner &#x3D; getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        return fastRunner &#x3D;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(\log n)$，该分析建立在对前一种方法的分析的基础上，但是这次我们需要跟踪两个指针而不是一个指针来分析，以及在它们相遇前需要绕着这个循环走多少次。<ul>
<li>如果没有循环，那么快跑者将先到达 1，慢跑者将到达链表中的一半。我们知道最坏的情况下，成本是 $O(2 \cdot \log n) = O(\log n)$。</li>
<li>一旦两个指针都在循环中，在每个循环中，快跑者将离慢跑者更近一步。一旦快跑者落后慢跑者一步，他们就会在下一步相遇。假设循环中有 k个数字。如果他们的起点是相隔 k-1的位置（这是他们可以开始的最远的距离），那么快跑者需要 k-1步才能到达慢跑者，这对于我们的目的来说也是不变的。因此，主操作仍然在计算起始 n 的下一个值，即 $O(\log n)$。</li>
</ul>
</li>
<li>空间复杂度：$O(1)$，对于这种方法，我们不需要哈希集来检测循环。指针需要常数的额外空间。</li>
</ul>
<h4 id="方法三：数学"><a href="#方法三：数学" class="headerlink" title="方法三：数学"></a>方法三：数学</h4><p>前两种方法是面试中应该想到的。第三种方法不是你在面试中会写的，而是针对对数学好奇的人，因为它很有趣。下一个值可能比自己大的最大数字是什么？根据我们之前的分析，我们知道它必须低于 243。因此，我们知道任何循环都必须包含小于 243 的数字，用这么小的数字，编写一个能找到所有周期的强力程序并不困难。如果这样做，您会发现只有一个循环：$4 \rightarrow 16 \rightarrow 37 \rightarrow 58 \rightarrow 89 \rightarrow 145 \rightarrow 42 \rightarrow 20 \rightarrow 4$。所有其他数字都在进入这个循环的链上，或者在进入 11 的链上。因此，我们可以硬编码一个包含这些数字的散列集，如果我们达到其中一个数字，那么我们就知道在循环中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int getNext(int n) &#123;</span><br><span class="line">        int totalSum &#x3D; 0;</span><br><span class="line">        while (n &gt; 0) &#123;</span><br><span class="line">            int d &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            totalSum +&#x3D; d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        return totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsHappy(int n) &#123;</span><br><span class="line">        HashSet&lt;int&gt; cycleMembers &#x3D;</span><br><span class="line">            new HashSet&lt;int&gt;(new int[8] &#123;4, 16, 37, 58, 89, 145, 42, 20&#125;);</span><br><span class="line"></span><br><span class="line">        while (n !&#x3D; 1 &amp;&amp; !cycleMembers.Contains(n)) &#123;</span><br><span class="line">            n &#x3D; getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        return n &#x3D;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(\log n)$。</li>
<li>空间复杂度：$O(1)$，我们没有保留我们所遇到的数字的历史记录。硬编码哈希集的大小是固定的。</li>
</ul>
<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> ListNode;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;=l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1) p-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2) p-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-3"><a href="#官方解法-3" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p>我们可以如下递归地定义两个链表里的 <code>merge</code> 操作（忽略边界情况，比如空链表等）：<br>$$<br>\begin{cases}<br>list1[0] + merge(list1[1:], list2) &amp; list1[0] &lt; list2[0] \<br>list2[0] + merge(list1, list2[1:]) &amp; otherwise<br>\end{cases}<br>$$<br>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并。</p>
<p><strong>算法</strong></p>
<p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p>
<p>如果 <code>l1</code> 或者 <code>l2</code> 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 <code>l1</code> 或者 <code>l2</code> 的头节点（直到至少有一个链表为空），函数 <code>mergeTwoList</code> 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。</li>
<li>空间复杂度：O(n + m)，其中 n和 m分别为两个链表的长度。递归调用 <code>mergeTwoLists</code> 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 <code>mergeTwoLists</code> 函数最多调用 n+m次，因此空间复杂度为 O(n+m)。</li>
</ul>
<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-4"><a href="#我的解法-4" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(ch)==<span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>.insert(ch);</span><br><span class="line">                res = <span class="built_in">max</span>(res,i-left+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(s[left]!=s[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">map</span>.erase(s[left++]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a><strong>进阶:</strong></h4><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p>
<h3 id="我的解法-5"><a href="#我的解法-5" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res ;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">                res = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">                res = <span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-4"><a href="#官方解法-4" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> lSum, rSum, mSum, iSum;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Status <span class="title">pushUp</span><span class="params">(Status l, Status r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iSum = l.iSum + r.iSum;</span><br><span class="line">        <span class="keyword">int</span> lSum = <span class="built_in">max</span>(l.lSum, l.iSum + r.lSum);</span><br><span class="line">        <span class="keyword">int</span> rSum = <span class="built_in">max</span>(r.rSum, r.iSum + l.rSum);</span><br><span class="line">        <span class="keyword">int</span> mSum = <span class="built_in">max</span>(<span class="built_in">max</span>(l.mSum, r.mSum), l.rSum + r.lSum);</span><br><span class="line">        <span class="keyword">return</span> (Status) &#123;lSum, rSum, mSum, iSum&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Status <span class="title">get</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (Status) &#123;a[l], a[l], a[l], a[l]&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Status lSub = <span class="built_in">get</span>(a, l, m);</span><br><span class="line">        Status rSub = <span class="built_in">get</span>(a, m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> pushUp(lSub, rSub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>).mSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>假设序列 <code>a</code>的长度为 <code>n</code>。</p>
<p><strong>时间复杂度</strong>：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界为 $O(\log n)$，这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O(\sum_{i = 1}^{\log n} 2^{i - 1}) = O(n)$，故渐进时间复杂度为$O(n)$。<br>空间复杂度：递归会使用 $O(\log n)$ 的栈空间，故渐进空间复杂度为 $O(\log n)$。</p>
<p><strong>题外话</strong><br>「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？</p>
<p>对于这道题而言，确实是如此的。但是仔细观察「方法二」，它不仅可以解决区间<code>[0, n - 1]</code>，还可以用于解决任意的子区间 <code>[l, r]</code>的问题。如果我们把 <code>[0, n - 1]</code> 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一颗真正的树之后，我们就可以在 $O(\log n)$ 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 $O(\log n)$ 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构——线段树。</p>
<h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值</span></span><br><span class="line">        <span class="keyword">int</span> result = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> numsSize = <span class="keyword">int</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            result = <span class="built_in">max</span>(result, sum);</span><br><span class="line">            <span class="comment">//如果sum &lt; 0，重新开始找子序串</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>堆与优先队列</title>
    <url>/2020/04/23/2020-04-23-Cpp-heap/</url>
    <content><![CDATA[<p>堆（heaps）是一种特殊的数据组织方式，<a href="http://c.biancheng.net/stl/" target="_blank" rel="noopener">STL</a> 中的 priority_queue 容器适配器底层就是采用堆来组织数据存储的。为了弄明白堆是什么，首先要搞清楚什么是树存储结构。</p>
<p>本节就来学习C++中点的堆于优先队列。</p>
<a id="more"></a>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>  堆（heap）是一种非常重要的数据结构（这里我们讨论的是二叉堆），它是一棵满足特定条件的完全二叉树，堆的定义如下：</p>
<p>堆是一棵树完全二叉树，对于该完全二叉树中的每一个结点x，其关键字大于等于(或小于等于）其左右孩子结点，而其左右子树均为一个二叉堆。</p>
<p>在上述的定义中，若堆中父亲结点关键字的值大于等于孩子结点，则称该堆为大顶堆；若堆中父亲结点关键子的值小于等于孩子结点，则称该堆为小顶堆。</p>
<p>由于堆是一棵完全二叉树，所以我们可以很轻易地用一个数组存储堆中的每一个元素，并且由子结点访问到其父亲结点和由父亲结点访问到其子结点</p>
<p>堆是一种用于查找最大值/最小值的二叉树<br>支持添加/减少数据，添加/删除的复杂度是O(logn)，查找的复杂度是O(1)<br>堆的结构：</p>
<p>大根堆：顾名思义，根结点的值比两个子结点都大.<br>小根堆：顾名思义，根节点的值比两个子结点都小.<br>堆中结点序号：若根节点序号为1，则根节点的左结点为2（1<em>2），右结点为3（1</em>2+1）。堆的全部结点均满足该性质.</p>
<h4 id="STL基本操作"><a href="#STL基本操作" class="headerlink" title="STL基本操作"></a>STL基本操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">size</span>(); <span class="comment">//返回堆内元素个数。</span></span><br><span class="line">a.empty();<span class="comment">//如果堆为空，返回真，否则返回假。</span></span><br><span class="line">a.top();<span class="comment">//返回堆顶元素。</span></span><br><span class="line">a.pop();<span class="comment">//删除堆顶元素，自动整理。</span></span><br><span class="line">a.push(x);<span class="comment">//插入一个元素x，自动整理。</span></span><br></pre></td></tr></table></figure>



<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>先来回顾一下<strong>队列</strong>，队列是一种先进先出（FIFO）的数据结构，它的本质是一个线性表，只能在表的一端插入值，在表的另一端删除值。</p>
<ul>
<li>队尾（rear）：允许插入的一端；</li>
<li>队头（front）：允许删除的一端。</li>
</ul>
<img src="/2020/04/23/2020-04-23-Cpp-heap/image-20200426101423861.png" alt="image-20200426101423861" style="zoom:50%;">

<p>优先队列也是一种队列，与队列不同的是，优先队列不再遵循先入先出的原则，而是分成了两种情况：</p>
<ul>
<li>最大优先队列，无论入队顺序，当前最大的元素优先出队。</li>
<li>最小优先队列，无论入队顺序，当前最小的元素优先出队。</li>
</ul>
<p>对于最小优先队列，队列中的每个元素都有一个权值，权值小的优先出队。假如我们将自身的数值作为权值，那么最小优先队列中较小的数会排在队列的前面，当加入一个新值 <code>3</code> 时，<code>3</code> 会在队列中处于合适的位置。</p>
<p>当进行出队操作时，每次会从队首弹出队列中最小的元素：<br><img src="/2020/04/23/2020-04-23-Cpp-heap/image-20200426101437274.png" alt="image-20200426101437274" style="zoom: 67%;"></p>
<p>最大优先队列则与之相反，最先弹出队列中最大的元素。</p>
<p>事实上，优先队列的本质上是一个堆，它是一棵完全二叉树，分为小顶堆和大顶堆：</p>
<ul>
<li>小顶堆是每一个根节点小于左右子节点的完全二叉树，堆顶元素最小，对应最小优先队列；</li>
<li>大顶堆是每一个根节点大于左右子节点的完全二叉树，堆顶元素最大，对应最大优先队列；</li>
</ul>
<p>由于删除堆顶元素时的时间复杂度为 $O(\log N)$，因此在优先队列中入队和出队操作的时间复杂度也是 $O(\log N)$。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><h4 id="面试题41-数据流中的中位数"><a href="#面试题41-数据流中的中位数" class="headerlink" title="面试题41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">面试题41. 数据流中的中位数</a></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian() - 返回目前所有元素的中位数。</li>
</ul>
<h6 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure>

<h6 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure>

<h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><h6 id="思路：使用堆和优先队列"><a href="#思路：使用堆和优先队列" class="headerlink" title="思路：使用堆和优先队列"></a><strong>思路：使用堆和优先队列</strong></h6><p>我们将中位数左边的数保存在大顶堆中，右边的数保存在小顶堆中。这样我们可以在O(1) 时间内得到中位数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; lo;                              <span class="comment">// 大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; hi;   <span class="comment">// 小顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Adds a number into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lo.push(num);                                    <span class="comment">// 加到大顶堆</span></span><br><span class="line"></span><br><span class="line">        hi.push(lo.top());                               <span class="comment">// 平衡</span></span><br><span class="line">        lo.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lo.<span class="built_in">size</span>() &lt; hi.<span class="built_in">size</span>()) &#123;                     <span class="comment">// 维护两个堆元素个数</span></span><br><span class="line">            lo.push(hi.top());</span><br><span class="line">            hi.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the median of current data stream</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lo.<span class="built_in">size</span>() &gt; hi.<span class="built_in">size</span>() ? (<span class="keyword">double</span>) lo.top() : (lo.top() + hi.top()) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：O(logn)。堆插入和删除需要O(logn)，查找中位数需要 O(1)。<br>空间复杂度：O(n)。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优先队列</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>堆与优先队列</title>
    <url>/2020/04/23/C++%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>堆（heaps）是一种特殊的数据组织方式，<a href="http://c.biancheng.net/stl/" target="_blank" rel="noopener">STL</a> 中的 priority_queue 容器适配器底层就是采用堆来组织数据存储的。为了弄明白堆是什么，首先要搞清楚什么是树存储结构。</p>
<p>本节就来学习C++中点的堆于优先队列。</p>
<a id="more"></a>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>  堆（heap）是一种非常重要的数据结构（这里我们讨论的是二叉堆），它是一棵满足特定条件的完全二叉树，堆的定义如下：</p>
<p>堆是一棵树完全二叉树，对于该完全二叉树中的每一个结点x，其关键字大于等于(或小于等于）其左右孩子结点，而其左右子树均为一个二叉堆。</p>
<p>在上述的定义中，若堆中父亲结点关键字的值大于等于孩子结点，则称该堆为大顶堆；若堆中父亲结点关键子的值小于等于孩子结点，则称该堆为小顶堆。</p>
<p>由于堆是一棵完全二叉树，所以我们可以很轻易地用一个数组存储堆中的每一个元素，并且由子结点访问到其父亲结点和由父亲结点访问到其子结点</p>
<p>堆是一种用于查找最大值/最小值的二叉树<br>支持添加/减少数据，添加/删除的复杂度是O(logn)，查找的复杂度是O(1)<br>堆的结构：</p>
<p>大根堆：顾名思义，根结点的值比两个子结点都大.<br>小根堆：顾名思义，根节点的值比两个子结点都小.<br>堆中结点序号：若根节点序号为1，则根节点的左结点为2（1<em>2），右结点为3（1</em>2+1）。堆的全部结点均满足该性质.</p>
<h4 id="STL基本操作"><a href="#STL基本操作" class="headerlink" title="STL基本操作"></a>STL基本操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">size</span>(); <span class="comment">//返回堆内元素个数。</span></span><br><span class="line">a.empty();<span class="comment">//如果堆为空，返回真，否则返回假。</span></span><br><span class="line">a.top();<span class="comment">//返回堆顶元素。</span></span><br><span class="line">a.pop();<span class="comment">//删除堆顶元素，自动整理。</span></span><br><span class="line">a.push(x);<span class="comment">//插入一个元素x，自动整理。</span></span><br><span class="line">a.swap();<span class="comment">//交换内容</span></span><br><span class="line">a.emplace();<span class="comment">//原地构造一个元素并插入队列</span></span><br></pre></td></tr></table></figure>



<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>先来回顾一下<strong>队列</strong>，队列是一种先进先出（FIFO）的数据结构，它的本质是一个线性表，只能在表的一端插入值，在表的另一端删除值。</p>
<ul>
<li>队尾（rear）：允许插入的一端；</li>
<li>队头（front）：允许删除的一端。</li>
</ul>
<img src="/2020/04/23/C++%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image-20200426101423861.png" alt="image-20200426101423861" style="zoom:50%;">

<p>优先队列也是一种队列，与队列不同的是，优先队列不再遵循先入先出的原则，而是分成了两种情况：</p>
<ul>
<li>最大优先队列，无论入队顺序，当前最大的元素优先出队。</li>
<li>最小优先队列，无论入队顺序，当前最小的元素优先出队。</li>
</ul>
<p>对于最小优先队列，队列中的每个元素都有一个权值，权值小的优先出队。假如我们将自身的数值作为权值，那么最小优先队列中较小的数会排在队列的前面，当加入一个新值 <code>3</code> 时，<code>3</code> 会在队列中处于合适的位置。</p>
<p>当进行出队操作时，每次会从队首弹出队列中最小的元素：<br><img src="/2020/04/23/C++%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image-20200426101437274.png" alt="image-20200426101437274" style="zoom: 67%;"></p>
<p>最大优先队列则与之相反，最先弹出队列中最大的元素。</p>
<p>事实上，优先队列的本质上是一个堆，它是一棵完全二叉树，分为小顶堆和大顶堆：</p>
<ul>
<li>小顶堆是每一个根节点小于左右子节点的完全二叉树，堆顶元素最小，对应最小优先队列；</li>
<li>大顶堆是每一个根节点大于左右子节点的完全二叉树，堆顶元素最大，对应最大优先队列；</li>
</ul>
<p>由于删除堆顶元素时的时间复杂度为 $O(\log N)$，因此在优先队列中入队和出队操作的时间复杂度也是 $O(\log N)$。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp1</span>  &#123;</span>    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span>  </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> a&gt;b;<span class="comment">//最小值优先     </span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp2</span>  &#123;</span>    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span>  </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> a&lt;b;<span class="comment">//最大值优先     </span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node1</span>  &#123;</span>    </span><br><span class="line">    <span class="keyword">int</span> u;    </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node1 &amp;a) <span class="keyword">const</span> &#123;    </span><br><span class="line">       <span class="keyword">return</span> u&gt;a.u;<span class="comment">//最小值优先     </span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node2</span>  &#123;</span>    </span><br><span class="line">    <span class="keyword">int</span> u;    </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node2 &amp;a) <span class="keyword">const</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> u&lt;a.u;<span class="comment">//最大值优先     </span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt;q1;<span class="comment">//采用默认优先级构造队列       大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp1&gt;q2;<span class="comment">//最小值优先     </span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp2&gt;q3;<span class="comment">//最大值优先     </span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;q4;<span class="comment">//注意“&gt;&gt;”会被认为错误，     </span></span><br><span class="line">                                                <span class="comment">//这是右移运算符，所以这里用空格号隔开,最小值优先   </span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q5;<span class="comment">//最大值优先      </span></span><br><span class="line">priority_queue&lt;node1&gt;q6;  <span class="comment">//自定义优先级  </span></span><br><span class="line">priority_queue&lt;node2&gt;q7;</span><br></pre></td></tr></table></figure>



<h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><h4 id="面试题41-数据流中的中位数"><a href="#面试题41-数据流中的中位数" class="headerlink" title="面试题41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">面试题41. 数据流中的中位数</a></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian() - 返回目前所有元素的中位数。</li>
</ul>
<h6 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure>

<h6 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure>

<h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><h6 id="思路：使用堆和优先队列"><a href="#思路：使用堆和优先队列" class="headerlink" title="思路：使用堆和优先队列"></a><strong>思路：使用堆和优先队列</strong></h6><p>我们将中位数左边的数保存在大顶堆中，右边的数保存在小顶堆中。这样我们可以在O(1) 时间内得到中位数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; max_heap; <span class="comment">//比中位值小的数</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; min_heap; <span class="comment">//比中位值大的数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        min_heap.push(num);</span><br><span class="line">        max_heap.push(min_heap.top());</span><br><span class="line">        min_heap.pop();</span><br><span class="line">        <span class="keyword">if</span>(min_heap.<span class="built_in">size</span>() &lt; max_heap.<span class="built_in">size</span>() )&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = max_heap.top();</span><br><span class="line">            max_heap.pop();</span><br><span class="line">            min_heap.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(max_heap.<span class="built_in">size</span>()==min_heap.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> (max_heap.top()+min_heap.top())/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">return</span> min_heap.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：O(logn)。堆插入和删除需要O(logn)，查找中位数需要 O(1)。<br>空间复杂度：O(n)。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优先队列</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡 4-20~26</title>
    <url>/2020/04/22/2020-04-22-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>本周打卡题目如下：</p>
<table>
<thead>
<tr>
<th>题目</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币</a></td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a></td>
<td align="center">困难</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></td>
<td align="center">困难</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(col==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flag</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag[i][j]&amp;&amp;grid[i][j]==<span class="string">'1'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">                    q.push(&#123;i,j&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = q.front();</span><br><span class="line">                        q.pop();</span><br><span class="line">                        flag[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">int</span> nx,ny;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            nx = vec[<span class="number">0</span>]+dx[k];</span><br><span class="line">                            ny = vec[<span class="number">1</span>]+dy[k];</span><br><span class="line">                            <span class="keyword">if</span>(<span class="number">0</span>&lt;=nx&amp;&amp;nx&lt;row&amp;&amp;<span class="number">0</span>&lt;=ny&amp;&amp;ny&lt;col&amp;&amp;grid[nx][ny]==<span class="string">'1'</span>&amp;&amp;flag[nx][ny])</span><br><span class="line">                            &#123;</span><br><span class="line">                                q.push(&#123;nx,ny&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; neighbors;</span><br><span class="line">                    neighbors.push(&#123;r, c&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (!neighbors.empty()) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> rc = neighbors.front();</span><br><span class="line">                        neighbors.pop();</span><br><span class="line">                        <span class="keyword">int</span> row = rc.first, col = rc.second;</span><br><span class="line">                        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row<span class="number">-1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row<span class="number">-1</span>, col&#125;);</span><br><span class="line">                            grid[row<span class="number">-1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; nr &amp;&amp; grid[row+<span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row+<span class="number">1</span>, col&#125;);</span><br><span class="line">                            grid[row+<span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col<span class="number">-1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col<span class="number">-1</span>&#125;);</span><br><span class="line">                            grid[row][col<span class="number">-1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nc &amp;&amp; grid[row][col+<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col+<span class="number">1</span>&#125;);</span><br><span class="line">                            grid[row][col+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248. 统计「优美子数组」"></a><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。</p>
<p>如果某个 <strong>连续</strong> 子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p>
<p>请返回这个数组中「优美子数组」的数目。 </p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,1,1], k &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,4,6], k &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line">解释：数列中不包含任何奇数，所以不存在优美子数组。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,1,2,2,1,2,2,2], k &#x3D; 2</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">            cnt += nums[++r] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n &amp;&amp; cnt &lt; k) cnt += nums[++r] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> k_cnt_right_begin = r;</span><br><span class="line">            <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n &amp;&amp; !(nums[r + <span class="number">1</span>] &amp; <span class="number">1</span>)) ++r;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; cnt == k) &#123;</span><br><span class="line">                ans += r - k_cnt_right_begin + <span class="number">1</span>;</span><br><span class="line">                cnt -= nums[l++] &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root)   </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> lastlevel=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> nextlevel = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* p = q.front();</span><br><span class="line">            lastlevel--;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                nextlevel++;</span><br><span class="line">                q.push(p-&gt;left); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                nextlevel++;</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lastlevel==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(p-&gt;val);</span><br><span class="line">                lastlevel = nextlevel;</span><br><span class="line">                nextlevel = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a><strong>示例1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入: n &#x3D; 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure>

<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a><strong>示例2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入: n &#x3D; 10</span><br><span class="line"> 输出：4</span><br><span class="line"> 解释: 有四种方式可以凑成总金额:</span><br><span class="line">10&#x3D;10</span><br><span class="line">10&#x3D;5+5</span><br><span class="line">10&#x3D;5+1+1+1+1+1</span><br><span class="line">10&#x3D;1+1+1+1+1+1+1+1+1+1</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>注意:</p>
<p>你可以假设：</p>
<ul>
<li>0 &lt;= n (总金额) &lt;= 1000000</li>
</ul>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p><strong>思路</strong></p>
<p>首先考虑一个朴素的方法，我们用 $f(i, v)$ 来表示前 i 种面值的硬币构成面值为 v 的方案数量，用 $c_i$来表示第 i 种面值的硬币的面值。</p>
<p>我们可以从 $f(i - 1, v - 0 \times c_i),f(i - 1, v - 1 \times c_i), f(i - 1, v - 2 \times c_i) \cdots f(i - 1, v - k \times c_i) $转移得到，它们表示第 i个面值的硬币选 $0, 1, 2 \cdots k $个的时候，构成面值为 <code>v</code> 的方案数量，其中 <code>k</code>为满足 $v - k \times c_i \geq 0$的最大整数。于是我们可以推导出这样的动态规划转移方程：<br>$$<br>f(i, v) = \sum_{j = 0}^{k} f(i - 1, v - j \times c_i) , , ,k = \lfloor \frac{v}{c_i} \rfloor<br>$$<br><strong>这个方程表示什么意思呢？</strong> 这个方程表示前<code>i</code>种硬币，构成面值<code>v</code> 的方案数量由前 <code>i - 1</code>种面值构成的一些面值的方案数量决定。我们可以考虑 $c_i$取多少个，$c_i$可以取 0 个、1 个、2 个……最大可以取 $\lfloor \frac{v}{c_i} \rfloor$ 个，那么前 i 种硬币，构成面值 v 的方案数量就是如下项的累加：前 $i - 1$ 种硬币构成面值$v$的方案数量（表示不取 $c_i$），前 $i - 1$种硬币构成面值$ v - c_i$的方案数量（表示取 1 个 $c_i$），前 $i - 1$种硬币构成面值$ v - 2 \times c_i $的方案数量（表示取 2个$c_i$），前 $i - 1$ 种硬币构成面值 $v - \lfloor \frac{v}{c_i} \rfloor \times c_i$的方案数量（表示取$ \lfloor \frac{v}{c_i} \rfloor$个 $c_i$）。</p>
<p><strong>举个例子。</strong> 假设这里 $c = {1, 5, 10, 25}$，在 $i = 4 $的时候，$c_i = 25$（假设下标从 1 开始），如果我们要求前 44 种面值构成 90的方案数量，可以这么写：</p>
<p>$f(4, 90) = f(3, 90) + f(3, 90 - 25) + f(3, 90 - 2 \times 25) + f(3, 90 - 3 \times 25)$</p>
<p>这里最多取 3 个 25，所以等式右边一共有四项，分别代表取 0、1、2、3 个 25，即从前 3 种面值构成 90、90 - 25、$90 - 2 \times 25$、$90 - 3 \times 25$四个状态中进行选择。</p>
<p>在实现这样一个转移方程的时候，i 的取值有 4 种，v的取值有$n + 1$ 种，所以状态总数是 $4(n + 1)$，我们需要用到 $O(4 \times (n + 1))$ 的空间代价来存取状态。对于每一个状态，我们需要在区间 <code>[0, k]</code> 枚举 j，所以计算单个状态的时间代价是 $O(\lfloor \frac{v}{c_i} \rfloor)$，所以总的时间代价是 $O(4 \times (n + 1) \times \lfloor \frac{v}{c_i} \rfloor)$。于是我们就可以用三重循环来实现这个朴素的转移方程。</p>
<p><strong>考虑优化方法。</strong></p>
<p><strong>第一步考虑优化时间复杂度。</strong> 我们可以把求和式展开书写：</p>
<p>$f(i, v) = f(i - 1, v) + \color{red}{ f(i - 1, v - c_i) + f(i - 1, v - 2 c_i) \cdots f(i - 1, v - k c_i) }$</p>
<p>共 k + 1 项，其中 $k = \lfloor \frac{v}{c_i} \rfloor$。那么我们可以得到使用 $v - c_i$ 替换 v，得到：</p>
<p>$f(i, v - c_i) = \color{red}{ f(i - 1, v - c_i) + f(i - 1, v - 2 c_i) + f(i - 1, v - 3 c_i) \cdots f(i - 1, v - k c_i) }$</p>
<p>共 k<em>k</em> 项。注意到上面两个方程中标成红色的 k项是完全相同的，于是我们可以用下面式子的左半部分 $f(i, v - c_i)$ 等价替换上面式子红色的 k项，得到化简后的转移方程：</p>
<p>$f(i, v) = f(i - 1, v) + f(i, v - c_i)$</p>
<p>这样我们就可以把原来的三重循环变成两重循环，求解每个状态的时间代价是 <strong>O(1)</strong>，总的时间代价为 $O(4 \times (n + 1))$。</p>
<p><strong>第二步考虑优化空间复杂度。</strong> 朴素实现的时候我们需要一个 $4 \times (n + 1)$的二维数组。观察方程 $f(i, v) = f(i - 1, c_i) + f(i, v - c_i)$，更新二维数组的第 i行只和第 i - 1相关，我们不关心 $[0, i - 2]$行，于是我们可以用「滚动数组」思想来优化这个过程。实现的方法有两种。</p>
<ul>
<li>用两个一维数组来实现转移：通过 i 和 i - 1 的奇偶性相反来实现，即当求到第 i行那一轮的时候，把第 $({i \bmod 2}) {\rm , xor ,} 1$ 行当作是 $i - 1$行，这样就只需要两行，循环利用。</li>
<li>用一个一维数组来实现转移：我们用数组 $F[0 \cdots n]$ 表示，我们在第$i$ 轮计算之前 $i - 1$轮的答案保存在 F 数组中，$F[v]$保存的是 $i - 1$ 轮 $f(i - 1, v)$ 的值，在第 i轮计算结束后，它将保存 $f(i, v)$的值。假设第二维从小到大更新，因为 $f(i, v)$只和 $f(i, v - c_i)$ 和 $f(i - 1, v)$ 相关，在计算 $f(i, v)$ 但是还没有更新 $F[v]$ 值的时候，$F[v]$ 保存的是上一轮的答案 $f(i - 1, v)$，而 $F[0 \cdots v - 1]$ 中保存的是 $f(i, v’), v’ \in [0, v - 1]$ 的值，$f(i, v - c_i)$包含在其中，所以这么做是可行的。<strong>代码中给出了这种方法的实现，如果这里看不懂可以结合代码。</strong></li>
</ul>
<p>这样一来，空间代价就可以从 $O(4 \times (n + 1))$ 变成 $O(2 \times (n + 1))$ 或者 $O(n + 1)$。</p>
<p><strong>其实这个问题是两个非常经典的问题的组合，其一是「完全背包问题」，其二是「背包方案数问题」，如果读者感兴趣的话可以自行阅读《背包九讲》。掌握了这些常见的背包问题的模型，你对动态规划的理解将更进一步。</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; coins = &#123;25,10,5,1&#125;;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coins = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:coins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = c;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i] =(f[i]+ f[i-c])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题51-数组中的逆序对"><a href="#面试题51-数组中的逆序对" class="headerlink" title="面试题51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<h4 id="限制："><a href="#限制：" class="headerlink" title="限制："></a><strong>限制：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="暴力法（超时）"><a href="#暴力法（超时）" class="headerlink" title="暴力法（超时）"></a>暴力法（超时）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                count+=nums[i]&gt;nums[j]?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：归并排序"><a href="#方法一：归并排序" class="headerlink" title="方法一：归并排序"></a>方法一：归并排序</h4><p><strong>预备知识</strong></p>
<p>「归并排序」是分治思想的典型应用，它包含这样三个步骤：</p>
<ul>
<li><strong>分解：</strong> 待排序的区间为 <code>[l, r][*l*,*r*]</code>，令 $m = \lfloor \frac{l + r}{2} \rfloor⌋$，我们把<code>[l, r]</code> 分成 <code>[l, m]</code>和 <code>[m + 1, r]</code>.</li>
<li><strong>解决：</strong> 使用归并排序递归地排序两个子序列</li>
<li><strong>合并：</strong> 把两个已经排好序的子序列 <code>[l, m]</code>和 <code>[m + 1, r]</code>合并起来</li>
</ul>
<p>在待排序序列长度为 1的时候，递归开始「回升」，因为我们默认长度为 1 的序列是排好序的。</p>
<p><strong>思路</strong></p>
<p>那么求逆序对和归并排序又有什么关系呢？关键就在于「归并」当中「并」的过程。我们通过一个实例来看看。假设我们有两个已排序的序列等待合并，分别是 $L = { 8, 12, 16, 22, 100 } $和 $R = { 9, 26, 55, 64, 91 }$。一开始我们用指针 <code>lPtr = 0</code> 指向 L<em>L</em> 的首部，<code>rPtr = 0</code> 指向 R<em>R</em> 的头部。记已经合并好的部分为 M<em>M</em>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; []</span><br><span class="line">     |                          |</span><br><span class="line">   lPtr                       rPtr</span><br></pre></td></tr></table></figure>

<p>我们发现 <code>lPtr</code> 指向的元素小于 <code>rPtr</code> 指向的元素，于是把 <code>lPtr</code> 指向的元素放入答案，并把 <code>lPtr</code> 后移一位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8]</span><br><span class="line">        |                       |</span><br><span class="line">      lPtr                     rPtr</span><br></pre></td></tr></table></figure>

<p>这个时候我们把左边的 8 加入了答案，我们发现右边没有数比 8 小，所以 8 对逆序对总数的「贡献」为 0。</p>
<p>接着我们继续合并，把 9 加入了答案，此时 <code>lPtr</code> 指向 12，<code>rPtr</code> 指向 26。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8, 9]</span><br><span class="line">        |                          |</span><br><span class="line">       lPtr                       rPtr</span><br></pre></td></tr></table></figure>

<p>此时 <code>lPtr</code> 比 <code>rPtr</code> 小，把 <code>lPtr</code> 对应的数加入答案，并考虑它对逆序对总数的贡献为 <code>rPtr</code> 相对 R<em>R</em> 首位置的偏移 1（即右边只有一个数比 12 小，所以只有它和 12 构成逆序对），以此类推。</p>
<p>我们发现用这种「算贡献」的思想在合并的过程中计算逆序对的数量的时候，只在 <code>lPtr</code> 右移的时候计算，是基于这样的事实：当前 <code>lPtr</code> 指向的数字比 <code>rPtr</code> 小，但是比 R<em>R</em> 中 <code>[0 ... rPtr - 1]</code> 的其他数字大，<code>[0 ... rPtr - 1]</code> 的其他数字本应当排在 <code>lPtr</code> 对应数字的左边，但是它排在了右边，所以这里就贡献了 <code>rPtr</code> 个逆序对。</p>
<p>利用这个思路，我们可以写出如下代码。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, pos = l;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp[pos] = nums[i];</span><br><span class="line">                ++i;</span><br><span class="line">                inv_count += (j - (mid + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[pos] = nums[j];</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= mid; ++k) &#123;</span><br><span class="line">            tmp[pos++] = nums[k];</span><br><span class="line">            inv_count += (j - (mid + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= r; ++k) &#123;</span><br><span class="line">            tmp[pos++] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        copy(tmp.<span class="built_in">begin</span>() + l, tmp.<span class="built_in">begin</span>() + r + <span class="number">1</span>, nums.<span class="built_in">begin</span>() + l);</span><br><span class="line">        <span class="keyword">return</span> inv_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums, tmp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong></p>
<p>记序列长度为 n。</p>
<ul>
<li>时间复杂度：同归并排序 $O(n \log n)$。</li>
<li>空间复杂度：同归并排序 $O(n)$，因为归并排序需要用到一个临时数组。</li>
</ul>
<h4 id="方法二：离散化树状数组"><a href="#方法二：离散化树状数组" class="headerlink" title="方法二：离散化树状数组"></a>方法二：离散化树状数组</h4><p><strong>预备知识</strong></p>
<p>「树状数组」是一种可以动态维护序列前缀和的数据结构，它的功能是：</p>
<ul>
<li><strong>单点更新 <code>update(i, v)</code>：</strong> 把序列 i<em>i</em> 位置的数加上一个值 v，这题 v = 1</li>
<li><strong>区间查询 <code>query(i)</code>：</strong> 查询序列 $[1 \cdots i]$ 区间的区间和，即 i位置的前缀和</li>
</ul>
<p>修改和查询的时间代价都是 $O(\log n)$，其中 $n$为需要维护前缀和的序列的长度。</p>
<p><strong>思路</strong></p>
<p>记题目给定的序列为 a，我们规定 $a_i$的取值集合为 a的「值域」。我们用桶来表示值域中的每一个数，桶中记录这些数字出现的次数。假设$a = {5, 5, 2, 3, 6}$，那么遍历这个序列得到的桶是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index  -&gt;  1 2 3 4 5 6 7 8 9</span><br><span class="line">value  -&gt;  0 1 1 0 2 1 0 0 0</span><br></pre></td></tr></table></figure>

<p>我们可以看出它第 i - 1 位的前缀和表示「有多少个数比 i小」。那么我们可以从后往前遍历序列 a，记当前遍历到的元素为 $a_i$，我们把 $a_i$对应的桶的值自增 1，把 i - 1 位置的前缀和加入到答案中算贡献。为什么这么做是对的呢，因为我们在循环的过程中，我们把原序列分成了两部分，后半部部分已经遍历过（已入桶），前半部分是待遍历的（未入桶），那么我们求到的 i - 1 位置的前缀和就是「已入桶」的元素中比 $a_i$大的元素的总和，而这些元素在原序列中排在 $a_i$的后面，但它们本应该排在 $a_i$ 的前面，这样就形成了逆序对。</p>
<p>我们显然可以用数组来实现这个桶，可问题是如果 $a_i$中有很大的元素，比如 $10^9$，我们就要开一个大小为 $10^9$ 的桶，内存中是存不下的。这个桶数组中很多位置是 0，有效位置是稀疏的，我们要想一个办法让有效的位置全聚集到一起，减少无效位置的出现，这个时候我们就需要用到一个方法——离散化。</p>
<p>离散化一个序列的前提是我们只关心这个序列里面元素的相对大小，而不关心绝对大小（即只关心元素在序列中的排名）；离散化的目的是让原来分布零散的值聚集到一起，减少空间浪费。那么如何获得元素排名呢，我们可以对原序列排序后去重，对于每一个 $a_i$ 通过二分查找的方式计算排名作为离散化之后的值。当然这里也可以不去重，不影响排名。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BIT(<span class="keyword">int</span> _n): n(_n), tree(_n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            ret += tree[x];</span><br><span class="line">            x -= lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            ++tree[x];</span><br><span class="line">            x += lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = nums;</span><br><span class="line">        <span class="comment">// 离散化</span></span><br><span class="line">        sort(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; num: nums) &#123;</span><br><span class="line">            num = lower_bound(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), num) - tmp.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 树状数组统计逆序对</span></span><br><span class="line">        <span class="function">BIT <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans += <span class="built_in">bit</span>.query(nums[i] - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">bit</span>.update(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：离散化的过程中使用了时间代价为 $O(n \log n)$的排序，单次二分的时间代价为 $O(\log n)$，一共有 n次，总时间代价为 $O(n \log n)$；循环执行 n次，每次进行$O(\log n)$的修改和 $O(\log n)$的查找，总时间代价为 $O(n \log n)$。故渐进时间复杂度为 $O(n \log n)$。</li>
<li>空间复杂度：树状数组需要使用长度为 n的数组作为辅助空间，故渐进空间复杂度为 O(n)。</li>
</ul>
<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-4"><a href="#我的解法-4" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) &#123;res.push_back(&#123;nums[<span class="number">0</span>]&#125;); <span class="keyword">return</span> res;&#125;</span><br><span class="line">        <span class="keyword">int</span> le = nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        nums.pop_back();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; lres = permute(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> r:lres)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;= r.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = r;</span><br><span class="line">                tmp.insert(tmp.<span class="built_in">begin</span>()+i,<span class="number">1</span>,le);</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-5"><a href="#我的解法-5" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="逐个合并，暴力解法"><a href="#逐个合并，暴力解法" class="headerlink" title="逐个合并，暴力解法"></a>逐个合并，暴力解法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode *head = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:lists)</span><br><span class="line">        &#123;</span><br><span class="line">            head = merge(head,p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode *p1,ListNode*p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p1||!p2)</span><br><span class="line">            <span class="keyword">return</span> p1==<span class="literal">nullptr</span>?p2:p1;</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p1&amp;&amp;p2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val&lt;=p2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = p1;</span><br><span class="line">                p1=p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = p2;</span><br><span class="line">                p2=p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = p1==<span class="literal">nullptr</span>?p2:p1;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(k^2n)$</p>
<p>空间复杂度：$O(1)$</p>
<h3 id="官方解法-2"><a href="#官方解法-2" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法二：分治合并"><a href="#方法二：分治合并" class="headerlink" title="方法二：分治合并"></a>方法二：分治合并</h4><p>考虑优化方法一，用分治的方法进行合并。</p>
<p>将 k 个链表配对并将同一对中的链表合并；<br>第一轮合并以后， k 个链表被合并成了 $\frac{k}{2} $  个链表，平均长度为 $\frac{2n}{k} $ ，然后是 $\frac{k}{4} $  个链表， $\frac{k}{8} $<br>  个链表等等；重复这一过程，直到我们得到了最终的有序链表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!a) || (!b)) <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = aPtr; aPtr = aPtr-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = bPtr; bPtr = bPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = (aPtr ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(<span class="built_in">vector</span> &lt;ListNode*&gt; &amp;lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法三：使用优先队列合并"><a href="#方法三：使用优先队列合并" class="headerlink" title="方法三：使用优先队列合并"></a>方法三：使用优先队列合并</h4><p>这个方法和前两种方法的思路有所不同，我们需要维护当前每个链表没有被合并的元素的最前面一个，kk 个链表就最多有 kk 个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *ptr;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Status &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> val &gt; rhs.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue &lt;Status&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node: lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node) q.push(&#123;node-&gt;val, node&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head, *tail = &amp;head;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.top(); q.pop();</span><br><span class="line">            tail-&gt;next = f.ptr; </span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (f.ptr-&gt;next) q.push(&#123;f.ptr-&gt;next-&gt;val, f.ptr-&gt;next&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第185场周赛</title>
    <url>/2020/04/19/2020-04-19-LeetCode-Contest-185/</url>
    <content><![CDATA[<p>今日参加周赛，战况惨烈，排名<code>1486 / 5002</code></p>
<table>
<thead>
<tr>
<th>题目</th>
<th align="center">分值</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/reformat-the-string/" target="_blank" rel="noopener">5388. 重新格式化字符串</a></td>
<td align="center">3</td>
<td align="center">简单</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/" target="_blank" rel="noopener">5389. 点菜展示表</a></td>
<td align="center">4</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking/" target="_blank" rel="noopener">5390. 数青蛙</a></td>
<td align="center">5</td>
<td align="center">中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/" target="_blank" rel="noopener">5391. 生成数组</a></td>
<td align="center">6</td>
<td align="center">困难</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="5388-重新t格式化字符串"><a href="#5388-重新t格式化字符串" class="headerlink" title="5388. 重新t格式化字符串"></a><a href="https://leetcode-cn.com/problems/reformat-the-string/" target="_blank" rel="noopener">5388. 重新t格式化字符串</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个混合了数字和字母的字符串 <code>s</code>，其中的字母均为小写英文字母。</p>
<p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p>
<p>请你返回 <strong>重新格式化后</strong> 的字符串；如果无法按要求重新格式化，则返回一个 <strong>空字符串</strong> 。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a0b1c2&quot;</span><br><span class="line">输出：&quot;0a1b2c&quot;</span><br><span class="line">解释：&quot;0a1b2c&quot; 中任意两个相邻字符的类型都不同。 &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; 也是满足题目要求的答案。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1229857369&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：&quot;1229857369&quot; 中只有数字，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;covid2019&quot;</span><br><span class="line">输出：&quot;c2o0v1i9d&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a><strong>示例 5：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ab123&quot;</span><br><span class="line">输出：&quot;1a2b3&quot;</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 仅由小写英文字母和/或数字组成。</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reformat</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; num;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; alp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>)</span><br><span class="line">                num.push(ch);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                alp.push(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n =alp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(m-n)&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">if</span>(num.<span class="built_in">size</span>()&gt;alp.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ch = num.top();</span><br><span class="line">            res.append(<span class="number">1</span>,ch);</span><br><span class="line">            num.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!alp.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ch = alp.top();</span><br><span class="line">            res.append(<span class="number">1</span>,ch);</span><br><span class="line">            alp.pop();</span><br><span class="line">            <span class="keyword">if</span>(!num.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                ch = num.top();</span><br><span class="line">                res.append(<span class="number">1</span>,ch);</span><br><span class="line">                num.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5389-点菜展示表"><a href="#5389-点菜展示表" class="headerlink" title="5389. 点菜展示表"></a><a href="https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/" target="_blank" rel="noopener">5389. 点菜展示表</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个数组 <code>orders</code>，表示客户在餐厅中完成的订单，确切地说， <code>orders[i]=[customerNamei,tableNumberi,foodItemi]</code> ，其中 <code>customerNamei</code> 是客户的姓名，<code>tableNumberi</code> 是客户所在餐桌的桌号，而 <code>foodItemi</code> 是客户点的餐品名称。</p>
<p>请你返回该餐厅的 <strong>点菜展示表</strong> <em>。</em>在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p>
<p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：orders &#x3D; [[&quot;David&quot;,&quot;3&quot;,&quot;Ceviche&quot;],[&quot;Corina&quot;,&quot;10&quot;,&quot;Beef Burrito&quot;],[&quot;David&quot;,&quot;3&quot;,&quot;Fried Chicken&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Water&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Ceviche&quot;],[&quot;Rous&quot;,&quot;3&quot;,&quot;Ceviche&quot;]]</span><br><span class="line">输出：[[&quot;Table&quot;,&quot;Beef Burrito&quot;,&quot;Ceviche&quot;,&quot;Fried Chicken&quot;,&quot;Water&quot;],[&quot;3&quot;,&quot;0&quot;,&quot;2&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;5&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],[&quot;10&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]] </span><br><span class="line">解释：</span><br><span class="line">点菜展示表如下所示：</span><br><span class="line">Table,Beef Burrito,Ceviche,Fried Chicken,Water</span><br><span class="line">3    ,0           ,2      ,1            ,0</span><br><span class="line">5    ,0           ,1      ,0            ,1</span><br><span class="line">10   ,1           ,0      ,0            ,0</span><br><span class="line">对于餐桌 3：David 点了 &quot;Ceviche&quot; 和 &quot;Fried Chicken&quot;，而 Rous 点了 &quot;Ceviche&quot;</span><br><span class="line">而餐桌 5：Carla 点了 &quot;Water&quot; 和 &quot;Ceviche&quot;</span><br><span class="line">餐桌 10：Corina 点了 &quot;Beef Burrito&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：orders &#x3D; [[&quot;James&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Ratesh&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Amadeus&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Adam&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;],[&quot;Brianna&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;]]</span><br><span class="line">输出：[[&quot;Table&quot;,&quot;Canadian Waffles&quot;,&quot;Fried Chicken&quot;],[&quot;1&quot;,&quot;2&quot;,&quot;0&quot;],[&quot;12&quot;,&quot;0&quot;,&quot;3&quot;]] </span><br><span class="line">解释：</span><br><span class="line">对于餐桌 1：Adam 和 Brianna 都点了 &quot;Canadian Waffles&quot;</span><br><span class="line">而餐桌 12：James, Ratesh 和 Amadeus 都点了 &quot;Fried Chicken&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：orders &#x3D; [[&quot;Laura&quot;,&quot;2&quot;,&quot;Bean Burrito&quot;],[&quot;Jhon&quot;,&quot;2&quot;,&quot;Beef Burrito&quot;],[&quot;Melissa&quot;,&quot;2&quot;,&quot;Soda&quot;]]</span><br><span class="line">输出：[[&quot;Table&quot;,&quot;Bean Burrito&quot;,&quot;Beef Burrito&quot;,&quot;Soda&quot;],[&quot;2&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= orders.length &lt;= 5 * 10^4</code></li>
<li><code>orders[i].length == 3</code></li>
<li><code>1 &lt;= customerNamei.length, foodItemi.length &lt;= 20</code></li>
<li><code>customerNamei</code> 和 <code>foodItemi</code> 由大小写英文字母及空格字符 <code>&#39; &#39;</code> 组成。</li>
<li><code>tableNumberi</code> 是 <code>1</code> 到 <code>500</code> 范围内的整数。</li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="哈希表-排序"><a href="#哈希表-排序" class="headerlink" title="哈希表+排序"></a>哈希表+排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>; <span class="comment">//桌号 菜 分数</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">set</span>;<span class="comment">//菜</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">displayTable</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; orders)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> gu:orders)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[gu[<span class="number">1</span>]][gu[<span class="number">2</span>]]++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.<span class="built_in">find</span>(gu[<span class="number">2</span>])==<span class="built_in">set</span>.<span class="built_in">end</span>())</span><br><span class="line">                <span class="built_in">set</span>.insert(gu[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">        tmp.push_back(<span class="string">"Table"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter=<span class="built_in">set</span>.<span class="built_in">begin</span>();iter!=<span class="built_in">set</span>.<span class="built_in">end</span>();iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.push_back(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(tmp.<span class="built_in">begin</span>()+<span class="number">1</span>,tmp.<span class="built_in">end</span>());</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter=<span class="built_in">map</span>.<span class="built_in">begin</span>();iter!=<span class="built_in">map</span>.<span class="built_in">end</span>();iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp1;</span><br><span class="line">            tmp1.push_back(iter-&gt;first);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;tmp.<span class="built_in">size</span>();i++)</span><br><span class="line">                tmp1.push_back(to_string(<span class="built_in">map</span>[iter-&gt;first][tmp[i]]));</span><br><span class="line">            res.push_back(tmp1);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.<span class="built_in">begin</span>()+<span class="number">1</span>,res.<span class="built_in">end</span>(),compare);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; a,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = stoi(a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> n2 = stoi(b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> n1&lt;n2; <span class="comment">//如果是从小到大，将"&gt;"变成“&lt;”即可；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5390-数青蛙"><a href="#5390-数青蛙" class="headerlink" title="5390. 数青蛙"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking/" target="_blank" rel="noopener">5390. 数青蛙</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 <code>croakOfFrogs</code>，它表示不同青蛙发出的蛙鸣声（字符串 “croak” ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 <code>croakOfFrogs</code> 中会混合多个 “croak” <em>。</em>请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。</p>
<p><strong>注意：</strong>要想发出蛙鸣 “croak”，青蛙必须 <strong>依序</strong> 输出 <code>‘c’, ’r’, ’o’, ’a’, ’k’</code> 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。</p>
<p>如果字符串 <code>croakOfFrogs</code> 不是由若干有效的 “croak” 字符混合而成，请返回 <code>-1</code> 。</p>
<h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：croakOfFrogs &#x3D; &quot;croakcroak&quot;</span><br><span class="line">输出：1 </span><br><span class="line">解释：一只青蛙 “呱呱” 两次</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：croakOfFrogs &#x3D; &quot;crcoakroak&quot;</span><br><span class="line">输出：2 </span><br><span class="line">解释：最少需要两只青蛙，“呱呱” 声用黑体标注</span><br><span class="line">第一只青蛙 &quot;crcoakroak&quot;</span><br><span class="line">第二只青蛙 &quot;crcoakroak&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：croakOfFrogs &#x3D; &quot;croakcrook&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：给出的字符串不是 &quot;croak&quot; 的有效组合。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：croakOfFrogs &#x3D; &quot;croakcroa&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= croakOfFrogs.length &lt;= 10^5</code></li>
<li>字符串中的字符只有 <code>&#39;c&#39;</code>, <code>&#39;r&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;a&#39;</code> 或者 <code>&#39;k&#39;</code></li>
</ul>
<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="1-通过队列来模拟需要的青蛙数量"><a href="#1-通过队列来模拟需要的青蛙数量" class="headerlink" title="1. 通过队列来模拟需要的青蛙数量"></a>1. 通过队列来模拟需要的青蛙数量</h4><p><strong>思路</strong></p>
<p>需要叫的时候就抓过来一只青蛙，叫完了就放走，统计队里里存在青蛙的最大数量</p>
<p>遍历字符串，现存的字符串中字符串数量 c &gt;= r &gt;= o &gt;= a &gt;= k<br>当遇到字符 c 时我们就往队列里加入一个青蛙，当遇到字符 k时我们就从队列里释放掉一个青蛙，同时把croak从计数的map中去掉<br>这样队列里曾经的最大的大小就是需要青蛙的数量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberOfFrogs</span><span class="params">(<span class="keyword">String</span> croakOfFrogs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curWokrerCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;Character, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">String</span> seq = <span class="string">"croak"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : croakOfFrogs.toCharArray()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(ch, <span class="built_in">map</span>.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!checkSeq(<span class="built_in">map</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'c'</span>) &#123;</span><br><span class="line">            curWokrerCount++;</span><br><span class="line">            res = Math.<span class="built_in">max</span>(res, curWokrerCount);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'k'</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : seq.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>.<span class="built_in">get</span>(c) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">map</span>.<span class="built_in">put</span>(c, <span class="built_in">map</span>.<span class="built_in">get</span>(c) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            curWokrerCount--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curWokrerCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkSeq</span><span class="params">(Map&lt;Character, Integer&gt; <span class="built_in">map</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cc = <span class="built_in">map</span>.getOrDefault(<span class="string">'c'</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rc = <span class="built_in">map</span>.getOrDefault(<span class="string">'r'</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> oc = <span class="built_in">map</span>.getOrDefault(<span class="string">'o'</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ac = <span class="built_in">map</span>.getOrDefault(<span class="string">'a'</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> kc = <span class="built_in">map</span>.getOrDefault(<span class="string">'k'</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cc &gt;= rc &amp;&amp; rc &gt;= oc &amp;&amp; oc &gt;= ac &amp;&amp; ac &gt;= kc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//作者：bigpotato-3</span></span><br><span class="line"><span class="comment">//链接：https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking/solution/tong-guo-dui-lie-lai-mo-ni-xu-yao-de-qing-wa-shu-l/</span></span><br><span class="line"><span class="comment">//来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-维护croak的个数"><a href="#2-维护croak的个数" class="headerlink" title="2. 维护croak的个数"></a>2. 维护croak的个数</h4><p><strong>思路</strong></p>
<p>维护croak的个数，如果遇到当前字母，则肯定是由前面字母过来，前面字母数-1。<br>如遇到r，则必是c-&gt;r，所以c–<br>k代表结尾，其实也是青蛙的起始（一次喊叫结束），所以遇到c的时候，先去消耗k，没有k了，需要新青蛙，答案+1</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberOfFrogs</span><span class="params">(<span class="keyword">String</span> croakOfFrogs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c,r,o,a,k;</span><br><span class="line">        c = <span class="number">0</span>; r = <span class="number">0</span>; o = <span class="number">0</span>; a = <span class="number">0</span>;k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> []chars = croakOfFrogs.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chars[i] == <span class="string">'c'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k &gt; <span class="number">0</span>)&#123;k--;&#125;<span class="keyword">else</span>&#123;res++;&#125;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(chars[i] == <span class="string">'r'</span>)&#123;</span><br><span class="line">                c--;r++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(chars[i] == <span class="string">'o'</span>)&#123;</span><br><span class="line">                r--;o++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(chars[i] == <span class="string">'a'</span>)&#123;</span><br><span class="line">                o--;a++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(chars[i] == <span class="string">'k'</span>)&#123;</span><br><span class="line">                a--;k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c &lt; <span class="number">0</span> || r &lt; <span class="number">0</span> || o &lt; <span class="number">0</span> || a &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c != <span class="number">0</span> || r != <span class="number">0</span> || o != <span class="number">0</span> || a != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">作者：imcover</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/minimum-number-of-frogs-croaking/solution/cai-ji-gong-xian-ge-chun-onzuo-fa-by-imcover/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h2 id="5391-生成数组"><a href="#5391-生成数组" class="headerlink" title="5391. 生成数组"></a><a href="https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/" target="_blank" rel="noopener">5391. 生成数组</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你三个整数 <code>n</code>、<code>m</code> 和 <code>k</code> 。下图描述的算法用于找出正整数数组中最大的元素。</p>
<p><img src="/2020/04/19/2020-04-19-LeetCode-Contest-185/e.png" alt="img"></p>
<p>请你生成一个具有下述属性的数组 <code>arr</code> ：</p>
<ul>
<li><code>arr</code> 中有 <code>n</code> 个整数。</li>
<li><code>1 &lt;= arr[i] &lt;= m</code> 其中 <code>(0 &lt;= i &lt; n)</code> 。</li>
<li>将上面提到的算法应用于 <code>arr</code> ，<code>search_cost</code> 的值等于 <code>k</code> 。</li>
</ul>
<p>返回上述条件下生成数组 <code>arr</code> 的 <strong>方法数</strong> ，由于答案可能会很大，所以 <strong>必须</strong> 对 <code>10^9 + 7</code> 取余。</p>
<h4 id="示例-1：-3"><a href="#示例-1：-3" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, m &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：6</span><br><span class="line">解释：可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-3"><a href="#示例-2：-3" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5, m &#x3D; 2, k &#x3D; 3</span><br><span class="line">输出：0</span><br><span class="line">解释：没有数组可以满足上述条件</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 9, m &#x3D; 1, k &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-2"><a href="#示例-4：-2" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 50, m &#x3D; 100, k &#x3D; 25</span><br><span class="line">输出：34549172</span><br><span class="line">解释：不要忘了对 1000000007 取余</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 37, m &#x3D; 17, k &#x3D; 7</span><br><span class="line">输出：418930126</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 50</code></li>
<li><code>1 &lt;= m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= n</code></li>
</ul>
<h3 id="其它解法-1"><a href="#其它解法-1" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>dp[i][j][k]</code>表示长度为i，最大值为j，<code>search_cost</code>为k的方案数。对于第i+1个数字x，如果x 大于 j,那么<code>dp[i + 1][x][k + 1] += dp[i][j][k]</code>, 否则<code>dp[i + 1][j][k] += dp[i][j][k]</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfArrays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp[n + <span class="number">1</span>][<span class="number">105</span>][k + <span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= k; l++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= m; r++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(r &gt; j)&#123;</span><br><span class="line">                            dp[i + <span class="number">1</span>][r][l + <span class="number">1</span>] += dp[i][j][l];</span><br><span class="line">                            dp[i + <span class="number">1</span>][r][l + <span class="number">1</span>] %= mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            dp[i + <span class="number">1</span>][j][l] += dp[i][j][l];</span><br><span class="line">                            dp[i + <span class="number">1</span>][j][l] %= mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            ans += dp[n][i][k];</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：PerfectSen</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/solution/5391-sheng-cheng-shu-zu-by-perfectsen/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>周赛</tag>
        <tag>刷题</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第24场双周赛</title>
    <url>/2020/04/19/2020-04-19-LeetCode-Double-Contest24/</url>
    <content><![CDATA[<p>LeetCode 第24场双周赛 战绩<code>616/1898</code></p>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>5372. 逐步求和得到正数的最小值</td>
<td>简单</td>
</tr>
<tr>
<td>5373. 和为 K 的最少斐波那契数字数目</td>
<td>中等</td>
</tr>
<tr>
<td>5374. 长度为 n 的开心字符串中字典序第 k 小的字符串</td>
<td>中等</td>
</tr>
<tr>
<td>5375. 恢复数组</td>
<td>困难</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="5372-逐步求和得到正数的最小值"><a href="#5372-逐步求和得到正数的最小值" class="headerlink" title="5372. 逐步求和得到正数的最小值"></a>5372. 逐步求和得到正数的最小值</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> 。你可以选定任意的 <strong>正数</strong> startValue 作为初始值。</p>
<p>你需要从左到右遍历 <code>nums</code> 数组，并将 startValue 依次累加上 <code>nums</code> 数组中的值。</p>
<p>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 <strong>正数</strong> 作为 startValue 。 </p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-3,2,-3,4,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：如果你选择 startValue &#x3D; 4，在第三次累加时，和小于 1 。</span><br><span class="line">                累加求和</span><br><span class="line">                startValue &#x3D; 4 | startValue &#x3D; 5 | nums</span><br><span class="line">                  (4 -3 ) &#x3D; 1  | (5 -3 ) &#x3D; 2    |  -3</span><br><span class="line">                  (1 +2 ) &#x3D; 3  | (2 +2 ) &#x3D; 4    |   2</span><br><span class="line">                  (3 -3 ) &#x3D; 0  | (4 -3 ) &#x3D; 1    |  -3</span><br><span class="line">                  (0 +4 ) &#x3D; 4  | (1 +4 ) &#x3D; 5    |   4</span><br><span class="line">                  (4 +2 ) &#x3D; 6  | (5 +2 ) &#x3D; 7    |   2</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：最小的 startValue 需要是正数。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,-2,-3]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStartValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            res += n;</span><br><span class="line">            <span class="keyword">if</span>(res&lt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s += <span class="number">1</span> - res;</span><br><span class="line">                res = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5373-和为-K-的最少斐波那契数字数目"><a href="#5373-和为-K-的最少斐波那契数字数目" class="headerlink" title="5373. 和为 K 的最少斐波那契数字数目"></a>5373. 和为 K 的最少斐波那契数字数目</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你数字 <code>k</code> ，请你返回和为 <code>k</code> 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p>
<p>斐波那契数字定义为：</p>
<ul>
<li><code>F1 = 1</code></li>
<li><code>F2 = 1</code></li>
<li><code>Fn = Fn-1 + Fn-2</code> ， 其中 n &gt; 2 。</li>
</ul>
<p>数据保证对于给定的 <code>k</code> ，一定能找到可行解。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：k &#x3D; 7</span><br><span class="line">输出：2 </span><br><span class="line">解释：斐波那契数字为：1，1，2，3，5，8，13，……</span><br><span class="line">对于 k &#x3D; 7 ，我们可以得到 2 + 5 &#x3D; 7 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：k &#x3D; 10</span><br><span class="line">输出：2 </span><br><span class="line">解释：对于 k &#x3D; 10 ，我们可以得到 2 + 8 &#x3D; 10 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：k &#x3D; 19</span><br><span class="line">输出：3 </span><br><span class="line">解释：对于 k &#x3D; 19 ，我们可以得到 1 + 5 + 13 &#x3D; 19 。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= 10^9</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fn;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinFibonacciNumbers</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fn.<span class="built_in">size</span>()==<span class="number">0</span>) </span><br><span class="line">            <span class="built_in">end</span> = born(k)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">end</span>&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fn[<span class="built_in">end</span>]==k)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fn[<span class="built_in">end</span>]&lt;k)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">end</span>--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findMinFibonacciNumbers(k-fn[<span class="built_in">end</span>])+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">born</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        fn.push_back(<span class="number">1</span>);</span><br><span class="line">        fn.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(fn[i<span class="number">-2</span>]+fn[i<span class="number">-1</span>]&lt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            fn.push_back(fn[i<span class="number">-2</span>]+fn[i<span class="number">-1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5374-长度为-n-的开心字符串中字典序第-k-小的字符串"><a href="#5374-长度为-n-的开心字符串中字典序第-k-小的字符串" class="headerlink" title="5374. 长度为 n 的开心字符串中字典序第 k 小的字符串"></a>5374. 长度为 n 的开心字符串中字典序第 k 小的字符串</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个 「开心字符串」定义为：</p>
<ul>
<li>仅包含小写字母 <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>.</li>
<li>对所有在 <code>1</code> 到 <code>s.length - 1</code> 之间的 <code>i</code> ，满足 <code>s[i] != s[i + 1]</code> （字符串的下标从 1 开始）。</li>
</ul>
<p>比方说，字符串 <strong>“abc”</strong>，<strong>“ac”，”b”</strong> 和 <strong>“abcbabcbcb”</strong> 都是开心字符串，但是 <strong>“aa”</strong>，<strong>“baa”</strong> 和 <strong>“ababbc”</strong> 都不是开心字符串。</p>
<p>给你两个整数 <code>n</code> 和 <code>k</code> ，你需要将长度为 <code>n</code> 的所有开心字符串按字典序排序。</p>
<p>请你返回排序后的第 k 个开心字符串，如果长度为 <code>n</code> 的开心字符串少于 <code>k</code> 个，那么请你返回 <strong>空字符串</strong> 。</p>
<h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1, k &#x3D; 3</span><br><span class="line">输出：&quot;c&quot;</span><br><span class="line">解释：列表 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 包含了所有长度为 1 的开心字符串。按照字典序排序后第三个字符串为 &quot;c&quot; 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1, k &#x3D; 4</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：长度为 1 的开心字符串只有 3 个。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3, k &#x3D; 9</span><br><span class="line">输出：&quot;cab&quot;</span><br><span class="line">解释：长度为 3 的开心字符串总共有 12 个 [&quot;aba&quot;, &quot;abc&quot;, &quot;aca&quot;, &quot;acb&quot;, &quot;bab&quot;, &quot;bac&quot;, &quot;bca&quot;, &quot;bcb&quot;, &quot;cab&quot;, &quot;cac&quot;, &quot;cba&quot;, &quot;cbc&quot;] 。第 9 个字符串为 &quot;cab&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, k &#x3D; 7</span><br><span class="line">输出：&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a><strong>示例 5：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 10, k &#x3D; 100</span><br><span class="line">输出：&quot;abacbabacb&quot;</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10</code></li>
<li><code>1 &lt;= k &lt;= 100</code></li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getHappyString</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">        tmp = generate(n<span class="number">-1</span>,<span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">            res.push_back(str);</span><br><span class="line">        tmp = generate(n<span class="number">-1</span>,<span class="string">'b'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">            res.push_back(str);</span><br><span class="line">        tmp = generate(n<span class="number">-1</span>,<span class="string">'c'</span>);        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">            res.push_back(str);</span><br><span class="line">        </span><br><span class="line">        sort(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());    </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;<span class="string">' '</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>()&gt;=k?res[k<span class="number">-1</span>]:<span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t.append(<span class="number">1</span>,ch);</span><br><span class="line">            <span class="keyword">return</span> &#123;t&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'a'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = generate(n<span class="number">-1</span>,<span class="string">'b'</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">                res.push_back(<span class="string">"a"</span>+str);    </span><br><span class="line">            tmp = generate(n<span class="number">-1</span>,<span class="string">'c'</span>);        </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">            res.push_back(<span class="string">"a"</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'b'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = generate(n<span class="number">-1</span>,<span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">                res.push_back(<span class="string">"b"</span>+str);    </span><br><span class="line">            tmp = generate(n<span class="number">-1</span>,<span class="string">'c'</span>);        </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">            res.push_back(<span class="string">"b"</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'c'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = generate(n<span class="number">-1</span>,<span class="string">'b'</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">                res.push_back(<span class="string">"c"</span>+str);    </span><br><span class="line">            tmp = generate(n<span class="number">-1</span>,<span class="string">'a'</span>);        </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> str:tmp)</span><br><span class="line">            res.push_back(<span class="string">"c"</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其它解法：</p>
<h2 id="5375-恢复数组"><a href="#5375-恢复数组" class="headerlink" title="5375. 恢复数组"></a>5375. 恢复数组</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 <code>[1, k]</code> 之间，且数组中的数字都没有前导 0 。</p>
<p>给你字符串 <code>s</code> 和整数 <code>k</code> 。可能会有多种不同的数组恢复结果。</p>
<p>按照上述程序，请你返回所有可能输出字符串 <code>s</code> 的数组方案数。</p>
<p>由于数组方案数可能会很大，请你返回它对 <code>10^9 + 7</code> <strong>取余</strong> 后的结果。</p>
<h4 id="示例-1：-3"><a href="#示例-1：-3" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1000&quot;, k &#x3D; 10000</span><br><span class="line">输出：1</span><br><span class="line">解释：唯一一种可能的数组方案是 [1000]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-3"><a href="#示例-2：-3" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1000&quot;, k &#x3D; 10</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在任何数组方案满足所有整数都 &gt;&#x3D; 1 且 &lt;&#x3D; 10 同时输出结果为 s 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-3"><a href="#示例-3：-3" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1317&quot;, k &#x3D; 2000</span><br><span class="line">输出：8</span><br><span class="line">解释：可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7]</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;2020&quot;, k &#x3D; 30</span><br><span class="line">输出：1</span><br><span class="line">解释：唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 &gt; 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-5：-1"><a href="#示例-5：-1" class="headerlink" title="示例 5："></a><strong>示例 5：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1234567890&quot;, k &#x3D; 90</span><br><span class="line">输出：34</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code>.</li>
<li><code>s</code> 只包含数字且不包含前导 0 。</li>
<li><code>1 &lt;= k &lt;= 10^9</code>.</li>
</ul>
<p>其它解法</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>周赛</tag>
        <tag>刷题</tag>
        <tag>双周赛</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每天打卡 4-18~21</title>
    <url>/2020/04/18/2020-04-18-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>最近今日打卡题目如下：</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/count-the-repetitions/" target="_blank" rel="noopener">466. 统计重复个数</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></td>
<td>中等</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p>
<p><img src="/2020/04/18/2020-04-18-LeetCode-CheckDaily/question_11.jpg" alt="img"></p>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res,(right-left)*<span class="built_in">min</span>(<span class="built_in">height</span>[right],<span class="built_in">height</span>[left]));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">height</span>[right]&gt;=<span class="built_in">height</span>[left])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="466-统计重复个数"><a href="#466-统计重复个数" class="headerlink" title="466. 统计重复个数"></a><a href="https://leetcode-cn.com/problems/count-the-repetitions/" target="_blank" rel="noopener">466. 统计重复个数</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>由 n 个连接的字符串 s 组成字符串 S，记作 <code>S = [s,n]</code>。例如，<code>[&quot;abc&quot;,3]</code>=“abcabcabc”。</p>
<p>如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，”abc” 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。</p>
<p>现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 106 和 1 ≤ n2 ≤ 106。现在考虑字符串 S1 和 S2，其中 <code>S1=[s1,n1]</code> 、<code>S2=[s2,n2]</code> 。</p>
<p>请你找出一个可以满足使<code>[S2,M]</code> 从 <code>S1</code> 获得的最大整数 M 。</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">s1 &#x3D;&quot;acb&quot;,n1 &#x3D; 4</span><br><span class="line">s2 &#x3D;&quot;ab&quot;,n2 &#x3D; 2</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：找出循环节"><a href="#方法一：找出循环节" class="headerlink" title="方法一：找出循环节"></a>方法一：找出循环节</h4><p><strong>思路</strong></p>
<p>由于题目中的 <code>n1</code> 和 <code>n2</code> 都很大，因此我们无法真正把 <code>S1 = [s1, n1]</code> 和 <code>S2 = [s2, n2]</code> 都显式地表示出来。由于这两个字符串都是不断循环的，因此我们可以考虑找出 <code>s2</code> 在 <code>S1</code> 中出现的循环节，如果我们找到了循环节，那么我们就可以很快算出 <code>s2</code> 在 <code>S1</code> 中出现了多少次了。</p>
<p>有些读者可能对循环节这个概念会有些陌生，这个概念我们可以类比无限循环小数，如果从小数部分的某一位起向右进行到某一位止的一节数字「循环」出现，首尾衔接，称这种小数为「无限循环小数」，这一节数字称为「无限循环小数」。比如对于 <code>3.56789789789...</code> 这个无限循环小数，它的小数部分就是以 <code>789</code> 为一个「循环节」在无限循环，且开头可能会有部分不循环的部分，这个数字中即为 <code>56</code>。</p>
<p>那么回到这题，我们可以将不断循环的 <code>s2</code> 组成的字符串类比作上面小数部分，去找是否存在一个子串，即「循环节」，满足不断在 <code>S2</code> 中循环，且这个循环节能对应固定数量的 <code>s1</code> 。如下图所示，在第一次出现后，<code>S2</code> 的子串 <code>bdadc</code> 构成一个循环节：之后 <code>bdadc</code> 的每次出现都需要有相应的两段 <code>s1</code>。</p>
<p><img src="/2020/04/18/2020-04-18-LeetCode-CheckDaily/466_fig1.png" alt="fig1"></p>
<p>当我们找出循环节后，我们即可知道一个循环节内包含 <code>s1</code> 的数量，以及在循环节出现前的 <code>s1</code> 的数量，这样就可以在 O(1)<em>O</em>(1) 的时间内，通过简单的运算求出 <code>s2</code> 在 <code>S1</code> 中出现的次数了。当然，由于 <code>S1</code> 中 <code>s1</code> 的数量 <code>n1</code> 是有限的，因此可能会存在循环节最后一个部分没有完全匹配，如上图最后会单独剩一个 <code>s1</code> 出来无法完全匹配完循环节，这部分我们需要单独拿出来遍历处理统计。</p>
<p>有些读者可能会怀疑循环节是否一定存在，这里我们给出的答案是肯定的，根据<a href="https://baike.baidu.com/item/鸽笼" target="_blank" rel="noopener">鸽笼原理</a>，我们最多只要找过 <code>|s2| + 1</code> 个 <code>s1</code>，就一定会出现循环节。</p>
<p><strong>算法</strong></p>
<p>我们设计一个哈希表 <code>recall</code> ：哈希表 <code>recall</code> 以 <code>s2</code> 字符串的下标 <code>index</code> 为索引，存储匹配至第 <code>s1cnt</code> 个 <code>s1</code> 的末尾，当前匹配到第 <code>s2cnt</code> 个 <code>s2</code> 中的第 <code>index</code> 个字符时， 已经匹配过的<code>s1</code> 的个数 <code>s1cnt</code> 和 <code>s2</code> 的个数 <code>s2cnt</code> 。</p>
<p>我们在每次遍历至 <code>s1</code> 的末尾时根据当前匹配到的 <code>s2</code> 中的位置 <code>index</code> 查看哈希表中的对应位置，如果哈希表中对应的位置 <code>index</code> 已经存储元素，则说明我们找到了循环节。循环节的长度可以用当前已经匹配的 <code>s1</code> 与 <code>s2</code> 的数量减去上次出现时经过的数量（即哈希表中存储的值）来得到。</p>
<p>然后我们就可以通过简单的运算求出所有构成循环节的 <code>s2</code> 的数量，对于不参与循环节部分的 <code>s1</code>，直接遍历计算即可，具体实现以及一些细节边界的处理请看下文的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxRepetitions</span><span class="params">(<span class="built_in">string</span> s1, <span class="keyword">int</span> n1, <span class="built_in">string</span> s2, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s1cnt = <span class="number">0</span>, index = <span class="number">0</span>, s2cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// recall 是我们用来找循环节的变量，它是一个哈希映射</span></span><br><span class="line">        <span class="comment">// 我们如何找循环节？假设我们遍历了 s1cnt 个 s1，此时匹配到了第 s2cnt 个 s2 中的第 index 个字符</span></span><br><span class="line">        <span class="comment">// 如果我们之前遍历了 s1cnt' 个 s1 时，匹配到的是第 s2cnt' 个 s2 中同样的第 index 个字符，那么就有循环节了</span></span><br><span class="line">        <span class="comment">// 我们用 (s1cnt', s2cnt', index) 和 (s1cnt, s2cnt, index) 表示两次包含相同 index 的匹配结果</span></span><br><span class="line">        <span class="comment">// 那么哈希映射中的键就是 index，值就是 (s1cnt', s2cnt') 这个二元组</span></span><br><span class="line">        <span class="comment">// 循环节就是；</span></span><br><span class="line">        <span class="comment">//    - 前 s1cnt' 个 s1 包含了 s2cnt' 个 s2</span></span><br><span class="line">        <span class="comment">//    - 以后的每 (s1cnt - s1cnt') 个 s1 包含了 (s2cnt - s2cnt') 个 s2</span></span><br><span class="line">        <span class="comment">// 那么还会剩下 (n1 - s1cnt') % (s1cnt - s1cnt') 个 s1, 我们对这些与 s2 进行暴力匹配</span></span><br><span class="line">        <span class="comment">// 注意 s2 要从第 index 个字符开始匹配</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; recall;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pre_loop, in_loop;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 我们多遍历一个 s1，看看能不能找到循环节</span></span><br><span class="line">            ++s1cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch: s1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == s2[index]) &#123;</span><br><span class="line">                    index += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (index == s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                        ++s2cnt;</span><br><span class="line">                        index = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还没有找到循环节，所有的 s1 就用完了</span></span><br><span class="line">            <span class="keyword">if</span> (s1cnt == n1) &#123;</span><br><span class="line">                <span class="keyword">return</span> s2cnt / n2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 出现了之前的 index，表示找到了循环节</span></span><br><span class="line">            <span class="keyword">if</span> (recall.count(index)) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [s1cnt_prime, s2cnt_prime] = recall[index];</span><br><span class="line">                <span class="comment">// 前 s1cnt' 个 s1 包含了 s2cnt' 个 s2</span></span><br><span class="line">                pre_loop = &#123;s1cnt_prime, s2cnt_prime&#125;;</span><br><span class="line">                <span class="comment">// 以后的每 (s1cnt - s1cnt') 个 s1 包含了 (s2cnt - s2cnt') 个 s2</span></span><br><span class="line">                in_loop = &#123;s1cnt - s1cnt_prime, s2cnt - s2cnt_prime&#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                recall[index] = &#123;s1cnt, s2cnt&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ans 存储的是 S1 包含的 s2 的数量，考虑的之前的 pre_loop 和 in_loop</span></span><br><span class="line">        <span class="keyword">int</span> ans = pre_loop.second + (n1 - pre_loop.first) / in_loop.first * in_loop.second;</span><br><span class="line">        <span class="comment">// S1 的末尾还剩下一些 s1，我们暴力进行匹配</span></span><br><span class="line">        <span class="keyword">int</span> rest = (n1 - pre_loop.first) % in_loop.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rest; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch: s1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == s2[index]) &#123;</span><br><span class="line">                    ++index;</span><br><span class="line">                    <span class="keyword">if</span> (index == s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                        ++ans;</span><br><span class="line">                        index = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// S1 包含 ans 个 s2，那么就包含 ans / n2 个 S2</span></span><br><span class="line">        <span class="keyword">return</span> ans / n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<code>O(|s1|*|s2|)</code>。我们最多找过 <code>|s2| + 1</code> 个 <code>s1</code>，就可以找到循环节，最坏情况下需要遍历的字符数量级为 <code>O(|s1|*|s2|)*</code>。</li>
<li>空间复杂度：<code>O(|s2|)</code>。我们建立的哈希表大小等于 <code>s2</code> 的长度。</li>
</ul>
<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(col==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flag</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag[i][j]&amp;&amp;grid[i][j]==<span class="string">'1'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">                    q.push(&#123;i,j&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = q.front();</span><br><span class="line">                        q.pop();</span><br><span class="line">                        flag[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">int</span> nx,ny;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            nx = vec[<span class="number">0</span>]+dx[k];</span><br><span class="line">                            ny = vec[<span class="number">1</span>]+dy[k];</span><br><span class="line">                            <span class="keyword">if</span>(<span class="number">0</span>&lt;=nx&amp;&amp;nx&lt;row&amp;&amp;<span class="number">0</span>&lt;=ny&amp;&amp;ny&lt;col&amp;&amp;grid[nx][ny]==<span class="string">'1'</span>&amp;&amp;flag[nx][ny])</span><br><span class="line">                            &#123;</span><br><span class="line">                                q.push(&#123;nx,ny&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化一点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; neighbors;</span><br><span class="line">                    neighbors.push(&#123;r, c&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (!neighbors.empty()) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> rc = neighbors.front();</span><br><span class="line">                        neighbors.pop();</span><br><span class="line">                        <span class="keyword">int</span> row = rc.first, col = rc.second;</span><br><span class="line">                        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row<span class="number">-1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row<span class="number">-1</span>, col&#125;);</span><br><span class="line">                            grid[row<span class="number">-1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; nr &amp;&amp; grid[row+<span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row+<span class="number">1</span>, col&#125;);</span><br><span class="line">                            grid[row+<span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col<span class="number">-1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col<span class="number">-1</span>&#125;);</span><br><span class="line">                            grid[row][col<span class="number">-1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nc &amp;&amp; grid[row][col+<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col+<span class="number">1</span>&#125;);</span><br><span class="line">                            grid[row][col+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c] == <span class="string">'1'</span>) dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>) dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>] == <span class="string">'1'</span>) dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>) dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">作者：LeetCode</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：O(MN)，其中 MM 和 NN 分别为行数和列数。</p>
<p>空间复杂度：O(MN)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 MN。</p>
<h2 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248. 统计「优美子数组」"></a><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。</p>
<p>如果某个 <strong>连续</strong> 子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p>
<p>请返回这个数组中「优美子数组」的数目。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,1,1], k &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,4,6], k &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line">解释：数列中不包含任何奇数，所以不存在优美子数组。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,1,2,2,1,2,2,2], k &#x3D; 2</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">            cnt += nums[++r] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n &amp;&amp; cnt &lt; k) cnt += nums[++r] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> k_cnt_right_begin = r;</span><br><span class="line">            <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n &amp;&amp; !(nums[r + <span class="number">1</span>] &amp; <span class="number">1</span>)) ++r;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; cnt == k) &#123;</span><br><span class="line">                ans += r - k_cnt_right_begin + <span class="number">1</span>;</span><br><span class="line">                cnt -= nums[l++] &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根号</p>
<h4 id="方法一：数学"><a href="#方法一：数学" class="headerlink" title="方法一：数学"></a>方法一：数学</h4><p><strong>思路和算法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numberOfSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n &#x3D; (int)nums.size();</span><br><span class="line">        int odd[n + 2], ans &#x3D; 0, cnt &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] &amp; 1) odd[++cnt] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        odd[0] &#x3D; -1, odd[++cnt] &#x3D; n;</span><br><span class="line">        for (int i &#x3D; 1; i + k &lt;&#x3D; cnt; ++i) &#123;</span><br><span class="line">            ans +&#x3D; (odd[i] - odd[i - 1]) * (odd[i + k] - odd[i + k - 1]); </span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h4 id="方法二：前缀和-差分"><a href="#方法二：前缀和-差分" class="headerlink" title="方法二：前缀和 + 差分"></a>方法二：前缀和 + 差分</h4><p><strong>思路和算法</strong></p>
<p>考虑以 i结尾的「优美子数组」个数，我们需要统计符合条件的下标 j的个数，其中 $0\leq j\leq i$且$ [j..i]$这个子数组里的奇数个数恰好为 k 。如果枚举$ [0..i]$里所有的下标来判断是否符合条件，那么复杂度将会达到 <code>O(n^2)</code> ，无法通过所有测试用例，因此我们需要优化枚举的时间复杂度。</p>
<p>我们定义 $\textit{pre}[i]$ 为<code>[0..i]</code>中奇数的个数，则 $\textit{pre}[i]$可以由$\textit{pre}[i-1]$递推而来，即：</p>
<p>$\textit{pre}[i]=\textit{pre}[i-1]+(\textit{nums}[i]&amp;1)$</p>
<p>那么<code>[j..i]</code>这个子数组里的奇数个数恰好为 k，这个条件我们可以转化为</p>
<p>$\textit{pre}[i]-\textit{pre}[j-1]==k$</p>
<p>简单移项可得符合条件的下标 j<em>j</em> 需要满足</p>
<p>$\textit{pre}[j-1] == \textit{pre}[i] - k$</p>
<p>所以我们考虑以 i结尾的「优美子数组」个数时只要统计有多少个奇数个数为 $\textit{pre}[i]-k$ 的 $\textit{pre}[j]$ 即可。我们只要建立频次数组 $\textit{cnt}$ 记录$ \textit{pre}[i]$出现的次数，从左往右边更新 $\textit{cnt}$边计算答案，那么以 $i$结尾的答案 $\textit{cnt}[\textit{pre}[i]-k]$即可 <code>O(1)</code> 得到。最后的答案即为所有下标结尾的「优美子数组」个数之和。</p>
<p>需要注意的是，从左往右边更新x边计算的时候已经保证了$\textit{cnt}[\textit{pre}[i]-k]$里记录的 $\textit{pre}[j]$ 的下标范围是 $0\leq j\leq i$ 。同时，由于$\textit{pre}[i]$的计算只与前一项的答案有关，因此我们可以不用建立 $\textit{pre}$ 数组，直接用 $\textit{odd}$变量来记录 $pre[i-1]$的答案即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        cnt.resize(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            odd += nums[i] &amp; <span class="number">1</span>;</span><br><span class="line">            ans += odd &gt;= k ? cnt[odd - k] : <span class="number">0</span>;</span><br><span class="line">            cnt[odd] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，</li>
<li>空间复杂度：O(n)，</li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 位运算</title>
    <url>/2020/04/15/2020-04-15-Cpp-Bit/</url>
    <content><![CDATA[<p>本节主要学习C++中的位运算。</p>
<p>位运算符列表如下：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>位求反</td>
<td>~expr</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1 &lt;&lt; expr2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>expr1 &gt;&gt; expr2</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>expr1 &amp; expr2</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>expr1 ^ expr2</td>
</tr>
<tr>
<td>|</td>
<td>位或</td>
<td>expr1 | expr2</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="C-位运算"><a href="#C-位运算" class="headerlink" title="C++ 位运算"></a>C++ 位运算</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>位是数据存储的最小单位。在 计算机中的二进制数系统中，位，简记为b,也称为比特，每个0或1就是一个位(bit)。</p>
<h3 id="经典用法"><a href="#经典用法" class="headerlink" title="经典用法"></a>经典用法</h3><h4 id="1-求二进制中1的个数"><a href="#1-求二进制中1的个数" class="headerlink" title="1. 求二进制中1的个数"></a>1. 求二进制中1的个数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">n&amp;n<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-把-data上调至8-的倍数，同理，也可以改成16，32…的倍数。"><a href="#2-把-data上调至8-的倍数，同理，也可以改成16，32…的倍数。" class="headerlink" title="2. 把 data上调至8 的倍数，同理，也可以改成16，32…的倍数。"></a>2. 把 data上调至8 的倍数，同理，也可以改成16，32…的倍数。</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(data + <span class="number">8</span> - <span class="number">1</span>） &amp; (<span class="number">8</span> - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-取int的最值"><a href="#3-取int的最值" class="headerlink" title="3. 取int的最值"></a>3. 取int的最值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>;<span class="comment">//int的最大值</span></span><br><span class="line">(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);<span class="comment">//int的最小值</span></span><br><span class="line">((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span>&lt;&lt;<span class="number">63</span>)<span class="number">-1</span>;<span class="comment">//long long的最大值</span></span><br><span class="line">((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span>&lt;&lt;<span class="number">63</span>);<span class="comment">//long long的最小值</span></span><br></pre></td></tr></table></figure>

<h4 id="4-判断两个数符号是否相同"><a href="#4-判断两个数符号是否相同" class="headerlink" title="4. 判断两个数符号是否相同"></a>4. 判断两个数符号是否相同</h4><p>  这个也很简单，二进制第一位表示符号，所以符号相同就为0（正数），符号不同就为1（负数）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">n^m&gt;=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="5-判断正负"><a href="#5-判断正负" class="headerlink" title="5. 判断正负"></a>5. 判断正负</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n&gt;&gt;31</span><br></pre></td></tr></table></figure>

<h3 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h3><h4 id="1-交换两个数"><a href="#1-交换两个数" class="headerlink" title="1. 交换两个数"></a>1. 交换两个数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a^=b;</span><br><span class="line">b^=a;</span><br><span class="line">a^=b;</span><br></pre></td></tr></table></figure>

<h4 id="2-对这个数二进制的第m位进行处理（从低位到高位）"><a href="#2-对这个数二进制的第m位进行处理（从低位到高位）" class="headerlink" title="2. 对这个数二进制的第m位进行处理（从低位到高位）"></a>2. 对这个数二进制的第m位进行处理（从低位到高位）</h4><p>​    首先为了得到第m位的值，肯定是要将这个数右移(m-1)位，然后为了将其他多余的数清零，我们再进行&amp;1的操作，就可以将第m位提取出来了。如果是想改变第m位的值，那么就不能对这个数进行移动，因为这样会改变这个数的值。所以我们要对1向左移(m-1)位，然后再进行操作更改。如果要将第m位变成1，那么就n|(1&lt;&lt;(m-1))，这样就可以保证其余位不变改变第m位。如果要将第m位变为0，那么就n&amp;~(1&lt;&lt;(m-1))，因为取反后就能得到除了第m位为0其余位都为1的一个数，这样再进行按位与计算就可以只改变第m位的值了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(n&gt;&gt;(m<span class="number">-1</span>))&amp;<span class="number">1</span>;<span class="comment">//取n的二进制的第m位</span></span><br><span class="line">n|(<span class="number">1</span>&lt;&lt;(m<span class="number">-1</span>));<span class="comment">//将n的二进制的第m位改为1</span></span><br><span class="line">n&amp;~(<span class="number">1</span>&lt;&lt;(m<span class="number">-1</span>));<span class="comment">//将n的二进制的第m位改为0</span></span><br></pre></td></tr></table></figure>

<h4 id="3-统计1的个数"><a href="#3-统计1的个数" class="headerlink" title="3. 统计1的个数"></a>3. 统计1的个数</h4><h5 id="1-普通算法"><a href="#1-普通算法" class="headerlink" title="1.普通算法"></a>1.普通算法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitcount1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cou=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">		&#123;</span><br><span class="line">			cou++;</span><br><span class="line">		&#125;</span><br><span class="line">		flag=flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cou;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-快速算法"><a href="#2-快速算法" class="headerlink" title="2. 快速算法"></a>2. 快速算法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitcount2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cou=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">		cou++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cou;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 位运算</title>
    <url>/2020/04/15/2020-04-15-Cpp-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>本节主要学习C++中的位运算。</p>
<p>位运算符列表如下：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>位求反</td>
<td>~expr</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1 &lt;&lt; expr2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>expr1 &gt;&gt; expr2</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>expr1 &amp; expr2</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>expr1 ^ expr2</td>
</tr>
<tr>
<td>|</td>
<td>位或</td>
<td>expr1 | expr2</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="C-位运算"><a href="#C-位运算" class="headerlink" title="C++ 位运算"></a>C++ 位运算</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>位是数据存储的最小单位。在 计算机中的二进制数系统中，位，简记为b,也称为比特，每个0或1就是一个位(bit)。</p>
<h3 id="经典用法"><a href="#经典用法" class="headerlink" title="经典用法"></a>经典用法</h3><h4 id="1-求二进制中1的个数"><a href="#1-求二进制中1的个数" class="headerlink" title="1. 求二进制中1的个数"></a>1. 求二进制中1的个数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">n&amp;n<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-把-data上调至8-的倍数，同理，也可以改成16，32…的倍数。"><a href="#2-把-data上调至8-的倍数，同理，也可以改成16，32…的倍数。" class="headerlink" title="2. 把 data上调至8 的倍数，同理，也可以改成16，32…的倍数。"></a>2. 把 data上调至8 的倍数，同理，也可以改成16，32…的倍数。</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(data + <span class="number">8</span> - <span class="number">1</span>） &amp; (<span class="number">8</span> - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-取int的最值"><a href="#3-取int的最值" class="headerlink" title="3. 取int的最值"></a>3. 取int的最值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>;<span class="comment">//int的最大值</span></span><br><span class="line">(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);<span class="comment">//int的最小值</span></span><br><span class="line">((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span>&lt;&lt;<span class="number">63</span>)<span class="number">-1</span>;<span class="comment">//long long的最大值</span></span><br><span class="line">((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span>&lt;&lt;<span class="number">63</span>);<span class="comment">//long long的最小值</span></span><br></pre></td></tr></table></figure>

<h4 id="4-判断两个数符号是否相同"><a href="#4-判断两个数符号是否相同" class="headerlink" title="4. 判断两个数符号是否相同"></a>4. 判断两个数符号是否相同</h4><p>  这个也很简单，二进制第一位表示符号，所以符号相同就为0（正数），符号不同就为1（负数）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">n^m&gt;=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="5-判断正负"><a href="#5-判断正负" class="headerlink" title="5. 判断正负"></a>5. 判断正负</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n&gt;&gt;31</span><br></pre></td></tr></table></figure>

<h3 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h3><h4 id="1-交换两个数"><a href="#1-交换两个数" class="headerlink" title="1. 交换两个数"></a>1. 交换两个数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a^=b;</span><br><span class="line">b^=a;</span><br><span class="line">a^=b;</span><br></pre></td></tr></table></figure>

<h4 id="2-对这个数二进制的第m位进行处理（从低位到高位）"><a href="#2-对这个数二进制的第m位进行处理（从低位到高位）" class="headerlink" title="2. 对这个数二进制的第m位进行处理（从低位到高位）"></a>2. 对这个数二进制的第m位进行处理（从低位到高位）</h4><p>​    首先为了得到第m位的值，肯定是要将这个数右移(m-1)位，然后为了将其他多余的数清零，我们再进行&amp;1的操作，就可以将第m位提取出来了。如果是想改变第m位的值，那么就不能对这个数进行移动，因为这样会改变这个数的值。所以我们要对1向左移(m-1)位，然后再进行操作更改。如果要将第m位变成1，那么就n|(1&lt;&lt;(m-1))，这样就可以保证其余位不变改变第m位。如果要将第m位变为0，那么就n&amp;~(1&lt;&lt;(m-1))，因为取反后就能得到除了第m位为0其余位都为1的一个数，这样再进行按位与计算就可以只改变第m位的值了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(n&gt;&gt;(m<span class="number">-1</span>))&amp;<span class="number">1</span>;<span class="comment">//取n的二进制的第m位</span></span><br><span class="line">n|(<span class="number">1</span>&lt;&lt;(m<span class="number">-1</span>));<span class="comment">//将n的二进制的第m位改为1</span></span><br><span class="line">n&amp;~(<span class="number">1</span>&lt;&lt;(m<span class="number">-1</span>));<span class="comment">//将n的二进制的第m位改为0</span></span><br></pre></td></tr></table></figure>

<h4 id="3-统计1的个数"><a href="#3-统计1的个数" class="headerlink" title="3. 统计1的个数"></a>3. 统计1的个数</h4><h5 id="1-普通算法"><a href="#1-普通算法" class="headerlink" title="1.普通算法"></a>1.普通算法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitcount1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cou=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">		&#123;</span><br><span class="line">			cou++;</span><br><span class="line">		&#125;</span><br><span class="line">		flag=flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cou;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-快速算法"><a href="#2-快速算法" class="headerlink" title="2. 快速算法"></a>2. 快速算法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitcount2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cou=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">		cou++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cou;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每天打卡4-15~17</title>
    <url>/2020/04/15/2020-04-15-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener">542. 01 矩阵</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></td>
<td>中等</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="542-01-矩阵"><a href="#542-01-矩阵" class="headerlink" title="542. 01 矩阵"></a><a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener">542. 01 矩阵</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p>
<p>两个相邻元素间的距离为 1 。</p>
<p><strong>示例 1:</strong><br>输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong><br>输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 2 1</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> INITMAX = <span class="number">9999</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">updateMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,INITMAX))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flag</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">1</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col ;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(&#123;i,j&#125;);</span><br><span class="line">                    flag[i][j] = <span class="number">0</span>;</span><br><span class="line">                    res[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> dir:dirs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = p[<span class="number">0</span>]+dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> ny = p[<span class="number">1</span>]+dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>( <span class="number">0</span> &lt;= nx &amp;&amp; nx&lt;row &amp;&amp; <span class="number">0</span>&lt;=ny &amp;&amp; ny&lt;col &amp;&amp; flag[nx][ny] )</span><br><span class="line">                &#123;</span><br><span class="line">                    flag[nx][ny] = <span class="number">0</span>;</span><br><span class="line">                    res[nx][ny] = res[p[<span class="number">0</span>]][p[<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">                    q.push(&#123;nx,ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="排序-合并"><a href="#排序-合并" class="headerlink" title="排序+合并"></a>排序+合并</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= start &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= <span class="built_in">end</span> &amp;&amp; intervals[i][<span class="number">1</span>] &gt;= <span class="built_in">end</span> )</span><br><span class="line">                <span class="built_in">end</span> = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; <span class="built_in">end</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back( &#123;start,<span class="built_in">end</span>&#125; );</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                <span class="built_in">end</span> = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(&#123;start,<span class="built_in">end</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=<span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">end</span> = <span class="built_in">max</span>(<span class="built_in">end</span>,start+nums[start]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">end</span>&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            start = <span class="built_in">min</span>(start+<span class="number">1</span>,<span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">if</span>((start&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>)||(<span class="built_in">end</span>==start&amp;&amp;nums[start]==<span class="number">0</span>)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>OPENCV重要函数</title>
    <url>/2020/04/14/2020-04-14-OPENCV-Function/</url>
    <content><![CDATA[<p>本节用来总结SLAM学习过程中，用到的重要的opencv函数</p>
<a id="more"></a>

<h3 id="CalcopticalFlowPyrLK"><a href="#CalcopticalFlowPyrLK" class="headerlink" title="CalcopticalFlowPyrLK()"></a>CalcopticalFlowPyrLK()</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>使用具有金字塔的迭代Lucas-Kanade方法计算稀疏特征集的光流。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::calcOpticalFlowPyrLK</span>	<span class="params">(	</span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray 	prevImg,</span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray 	nextImg,</span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray 	prevPts,</span></span></span><br><span class="line"><span class="function"><span class="params">    InputOutputArray 	nextPts,</span></span></span><br><span class="line"><span class="function"><span class="params">    OutputArray 	status,</span></span></span><br><span class="line"><span class="function"><span class="params">    OutputArray 	err,</span></span></span><br><span class="line"><span class="function"><span class="params">    Size 	winSize = Size(<span class="number">21</span>, <span class="number">21</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> 	maxLevel = <span class="number">3</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    TermCriteria 	criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, <span class="number">30</span>, <span class="number">0.01</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> 	flags = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> 	minEigThreshold = <span class="number">1e-4</span> </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>prevImg ：buildOpticalFlowPyramid构造的第一个8位输入图像或金字塔。</li>
<li>nextImg ：与prevImg相同大小和相同类型的第二个输入图像或金字塔</li>
<li>prevPts ：需要找到流的2D点的矢量(vector of 2D points for which the flow needs to be found;);点坐标必须是单精度浮点数。</li>
<li>nextPts ：输出二维点的矢量（具有单精度浮点坐标），包含第二图像中输入特征的计算新位置;当传递OPTFLOW_USE_INITIAL_FLOW标志时，向量必须与输入中的大小相同。</li>
<li>status ：输出状态向量（无符号字符）;如果找到相应特征的流，则向量的每个元素设置为1，否则设置为0。</li>
<li>err ：输出错误的矢量; 向量的每个元素都设置为相应特征的错误，错误度量的类型可以在flags参数中设置; 如果未找到流，则未定义错误（使用status参数查找此类情况）。</li>
<li>winSize ：每个金字塔等级的搜索窗口的winSize大小。</li>
<li>maxLevel ：基于0的最大金字塔等级数;如果设置为0，则不使用金字塔（单级），如果设置为1，则使用两个级别，依此类推;如果将金字塔传递给输入，那么算法将使用与金字塔一样多的级别，但不超过maxLevel。</li>
<li>criteria ：参数，指定迭代搜索算法的终止条件（在指定的最大迭代次数criteria.maxCount之后或当搜索窗口移动小于criteria.epsilon时）。</li>
<li>flags ：操作标志：</li>
<li>OPTFLOW_USE_INITIAL_FLOW：使用初始估计，存储在nextPts中;如果未设置标志，则将prevPts复制到nextPts并将其视为初始估计。</li>
<li>OPTFLOW_LK_GET_MIN_EIGENVALS：使用最小特征值作为误差测量（参见minEigThreshold描述）;如果没有设置标志，则将原稿周围的色块和移动点之间的L1距离除以窗口中的像素数，用作误差测量。</li>
<li>minEigThreshold ：算法计算光流方程的2x2正常矩阵的最小特征值，除以窗口中的像素数;如果此值小于minEigThreshold，则过滤掉相应的功能并且不处理其流程，因此它允许删除坏点并获得性能提升。<br>该函数实现了金字塔中Lucas-Kanade光流的稀疏迭代版本。</li>
</ul>
<h3 id="cv-circle"><a href="#cv-circle" class="headerlink" title="cv::circle()"></a>cv::circle()</h3><h4 id="功能：画圆"><a href="#功能：画圆" class="headerlink" title="功能：画圆"></a>功能：画圆</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">circle</span><span class="params">(CV_IN_OUT Mat&amp; img, Point center, <span class="keyword">int</span> radius, <span class="keyword">const</span> Scalar&amp; color, <span class="keyword">int</span> thickness=<span class="number">1</span>, <span class="keyword">int</span> lineType=<span class="number">8</span>, <span class="keyword">int</span> shift=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>img：图像，单通道多通道都行，不需要特殊要求</li>
<li>center：画圆的圆心坐标</li>
<li>radius：圆的半径</li>
<li>color：设定圆的颜色，比如用CV_RGB(255, 0,0)设置为红色， CV_RGB(255, 255,255)设置为白色，CV_RGB(0, 0,0)设置为黑色 </li>
<li>thickness：为设置圆线条的粗细，值越大则线条越粗，为负数则是填充效果</li>
</ul>
<h3 id="goodFeaturesToTrack"><a href="#goodFeaturesToTrack" class="headerlink" title="goodFeaturesToTrack"></a>goodFeaturesToTrack</h3><p>  <em>_image：8位或32位浮点型输入图像，单通道</em></p>
<p>  <em>_corners：保存检测出的角点</em></p>
<p>  <em>maxCorners：角点数目最大值，如果实际检测的角点超过此值，则只返回前maxCorners个强角点</em></p>
<p>  <em>qualityLevel：角点的品质因子</em></p>
<p>  <em>minDistance：对于初选出的角点而言，如果在其周围minDistance范围内存在其他更强角点，则将此角点删除</em></p>
<p>  <em>_mask：指定感兴趣区，如不需在整幅图上寻找角点，则用此参数指定ROI</em></p>
<p>  <em>blockSize：计算协方差矩阵时的窗口大小</em></p>
<p>  <em>useHarrisDetector：指示是否使用Harris角点检测，如不指定，则计算shi-tomasi角点</em></p>
<p>  harrisK：Harris角点检测需要的k值 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::goodFeaturesToTrack(cur_img, n_pts, MAX_CNT - cur_pts.<span class="built_in">size</span>(), <span class="number">0.01</span>, MIN_DIST, mask); <span class="comment">//VINS_Fusion中的应用</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 优先队列</title>
    <url>/2020/04/14/2020-04-14-C-priority-queue/</url>
    <content><![CDATA[<p>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。本节来介绍C++中的优先队列。</p>
<a id="more"></a>

<p>优先队列是0个或多个元素的集合,每个元素都有一个优先权或值,对优先队列执行的操作有1) 查找;2) 插入一个新元素;3) 删除.在最小优先队列(min priority queue)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行.</p>
<p>最大优先权队列的<a href="https://baike.baidu.com/item/抽象数据类型" target="_blank" rel="noopener">抽象数据类型</a>描述下所示,最小优先队列的抽象数据类型描述与之类似,只需将最大改为最小即可.</p>
<h2 id="一、相关定义"><a href="#一、相关定义" class="headerlink" title="一、相关定义"></a>一、相关定义</h2><p>优先队列容器与队列一样，只能从队尾插入元素，从队首删除元素。但是它有一个特性，就是队列中最大的元素总是位于队首，所以出队时，并非按照先进先出的原则进行，而是将当前队列中最大的元素出队。这点类似于给队列里的元素进行了由大到小的顺序排序。元素的比较规则默认按元素值由大到小排序，可以重载“&lt;”操作符来重新定义比较规则。</p>
<p>优先级队列可以用向量(vector)或双向队列(deque)来实现(注意list container不能用来实现queue，因为list的迭代器不是任意存取iterator，而pop中用到堆排序时是要求randomaccess iterator 的!)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;vector&lt;int&gt;, less&lt;int&gt; &gt; pq1; 　　　 &#x2F;&#x2F; 使用递增less&lt;int&gt;函数对象排序</span><br><span class="line">priority_queue&lt;deque&lt;int&gt;, greater&lt;int&gt; &gt; pq2; 　　&#x2F;&#x2F; 使用递减greater&lt;int&gt;函数对象排序</span><br></pre></td></tr></table></figure>


<p>其成员函数有“判空(empty)” 、“尺寸(Size)” 、“栈顶元素(top)” 、“压栈(push)” 、“弹栈(pop)”等。</p>
<h2 id="二、priority-queue"><a href="#二、priority-queue" class="headerlink" title="二、priority_queue"></a>二、priority_queue</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>首先要包含头文件<code>#include</code></strong>, 他和<code>queue</code>不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。</p>
<p>优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><blockquote>
<p>和队列基本操作相同:</p>
<ul>
<li>top()           访问队头元素</li>
<li>empty()      队列是否为空</li>
<li>size()          返回队列内元素个数</li>
<li>push()        插入元素到队尾 (并排序)</li>
<li>emplace() 原地构造一个元素并插入队列</li>
<li>pop()         弹出队头元素</li>
<li>swap()       交换内容</li>
</ul>
</blockquote>
<h3 id="头文件："><a href="#头文件：" class="headerlink" title="头文件："></a>头文件：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;queue&gt;</span><br></pre></td></tr></table></figure>

<h3 id="声明方式："><a href="#声明方式：" class="headerlink" title="声明方式："></a>声明方式：</h3><h4 id="1、普通方法："><a href="#1、普通方法：" class="headerlink" title="1、普通方法："></a>1、普通方法：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;  　　　　　　　　　　　  <span class="comment">//通过操作，按照元素从大到小的顺序出队</span></span><br><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q; <span class="comment">//通过操作，按照元素从小到大的顺序出队</span></span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br></pre></td></tr></table></figure>

<h4 id="2、自定义优先级："><a href="#2、自定义优先级：" class="headerlink" title="2、自定义优先级："></a>2、自定义优先级：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">　　<span class="function"><span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>   </span></span><br><span class="line"><span class="function">　　</span>&#123;     </span><br><span class="line">　　　　 <span class="keyword">return</span>　x &gt; y;　　 <span class="comment">// x小的优先级高    //也可以写成其他方式，如： return p[x] &gt; p[y];表示p[i]小的优先级高</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; q;  <span class="comment">//定义方法</span></span><br><span class="line"><span class="comment">//其中，第二个参数为容器类型。第三个参数为比较函数。</span></span><br></pre></td></tr></table></figure>

<h4 id="3、结构体声明方式："><a href="#3、结构体声明方式：" class="headerlink" title="3、结构体声明方式："></a>3、结构体声明方式：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>   </span><br><span class="line">　　<span class="keyword">int</span> x, y; </span><br><span class="line">　　<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a, node b)  </span><br><span class="line">　　&#123;     </span><br><span class="line">　　　　<span class="keyword">return</span> a.x &gt; b.x;  <span class="comment">//结构体中，x小的优先级高   </span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt;q;  <span class="comment">//定义方法</span></span><br><span class="line"><span class="comment">// 在该结构中，y为值, x为优先级。</span></span><br><span class="line"><span class="comment">// 通过自定义operator&lt;操作符来比较元素中的优先级。</span></span><br><span class="line"><span class="comment">// 在重载”&lt;”时，最好不要重载”&gt;”，可能会发生编译错误</span></span><br></pre></td></tr></table></figure>

<h2 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h2><h3 id="1、基本类型优先队列的例子："><a href="#1、基本类型优先队列的例子：" class="headerlink" title="1、基本类型优先队列的例子："></a><strong>1、基本类型优先队列的例子：</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//      这里一定要有空格，不然成了右移运算符↓↓</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="built_in">string</span>&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        a.push(i);</span><br><span class="line">        c.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!c.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        c.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    b.push(<span class="string">"abc"</span>);</span><br><span class="line">    b.push(<span class="string">"abcd"</span>);</span><br><span class="line">    b.push(<span class="string">"cbd"</span>);</span><br><span class="line">    <span class="keyword">while</span> (!b.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        b.pop();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 2 1 0&#96;&#96;0 1 2 3 4&#96;&#96;cbd abcd abc&#96;&#96;请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<h3 id="2、用pair做优先队列元素的例子："><a href="#2、用pair做优先队列元素的例子：" class="headerlink" title="2、用pair做优先队列元素的例子："></a><strong>2、用pair做优先队列元素的例子：</strong></h3><p>规则：pair的比较，先比较第一个元素，第一个相等比较第二个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//      这里一定要有空格，不然成了右移运算符↓↓</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="built_in">string</span>&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        a.push(i);</span><br><span class="line">        c.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!c.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        c.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    b.push(<span class="string">"abc"</span>);</span><br><span class="line">    b.push(<span class="string">"abcd"</span>);</span><br><span class="line">    b.push(<span class="string">"cbd"</span>);</span><br><span class="line">    <span class="keyword">while</span> (!b.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        b.pop();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 5&#96;&#96;1 3&#96;&#96;1 2&#96;&#96;请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<h3 id="3、用自定义类型做优先队列元素的例子"><a href="#3、用自定义类型做优先队列元素的例子" class="headerlink" title="3、用自定义类型做优先队列元素的例子"></a><strong>3、用自定义类型做优先队列元素的例子</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp1</span> //运算符重载&lt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    int x;</span></span><br><span class="line"><span class="class">    tmp1(int a) &#123;x = a;&#125;</span></span><br><span class="line"><span class="class">    bool operator&lt;(const tmp1&amp; a) const</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return x &lt; a.x; //大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//方法2</span></span><br><span class="line"><span class="class">struct tmp2 //重写仿函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    bool operator() (tmp1 a, tmp1 b) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return a.x &lt; b.x; //大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">int main() </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    tmp1 a(1);</span></span><br><span class="line"><span class="class">    tmp1 b(2);</span></span><br><span class="line"><span class="class">    tmp1 c(3);</span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1&gt; d;</span></span><br><span class="line"><span class="class">    d.push(b);</span></span><br><span class="line"><span class="class">    d.push(c);</span></span><br><span class="line"><span class="class">    d.push(a);</span></span><br><span class="line"><span class="class">    while (!d.empty()) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        cout &lt;&lt; d.top().x &lt;&lt; '\n';</span></span><br><span class="line"><span class="class">        d.pop();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span></span><br><span class="line"><span class="class">    f.push(b);</span></span><br><span class="line"><span class="class">    f.push(c);</span></span><br><span class="line"><span class="class">    f.push(a);</span></span><br><span class="line"><span class="class">    while (!f.empty()) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        cout &lt;&lt; f.top().x &lt;&lt; '\n';</span></span><br><span class="line"><span class="class">        f.pop();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;3&#96;</span><br><span class="line">&#96;2&#96;</span><br><span class="line">&#96;1&#96; </span><br><span class="line"></span><br><span class="line">&#96;3&#96;</span><br><span class="line">&#96;2&#96;</span><br><span class="line">&#96;1&#96;</span><br><span class="line"></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<p> 参考资料</p>
<p>[1] <a href="https://www.cnblogs.com/huashanqingzhu/p/11040390.html" target="_blank" rel="noopener">c++优先队列(priority_queue)用法详解</a></p>
<p>[2] [C++STL——优先队列](<a href="https://www.cnblogs.com/xzxl/p/7266404.html）" target="_blank" rel="noopener">https://www.cnblogs.com/xzxl/p/7266404.html）</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 优先队列</title>
    <url>/2020/04/14/C++%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。本节来介绍C++中的优先队列。</p>
<a id="more"></a>

<p>优先队列是0个或多个元素的集合,每个元素都有一个优先权或值,对优先队列执行的操作有1) 查找;2) 插入一个新元素;3) 删除.在最小优先队列(min priority queue)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行.</p>
<p>最大优先权队列的<a href="https://baike.baidu.com/item/抽象数据类型" target="_blank" rel="noopener">抽象数据类型</a>描述下所示,最小优先队列的抽象数据类型描述与之类似,只需将最大改为最小即可.</p>
<h2 id="一、相关定义"><a href="#一、相关定义" class="headerlink" title="一、相关定义"></a>一、相关定义</h2><p>优先队列容器与队列一样，只能从队尾插入元素，从队首删除元素。但是它有一个特性，就是队列中最大的元素总是位于队首，所以出队时，并非按照先进先出的原则进行，而是将当前队列中最大的元素出队。这点类似于给队列里的元素进行了由大到小的顺序排序。元素的比较规则默认按元素值由大到小排序，可以重载“&lt;”操作符来重新定义比较规则。</p>
<p>优先级队列可以用向量(vector)或双向队列(deque)来实现(注意list container不能用来实现queue，因为list的迭代器不是任意存取iterator，而pop中用到堆排序时是要求randomaccess iterator 的!)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;vector&lt;int&gt;, less&lt;int&gt; &gt; pq1; 　　　 &#x2F;&#x2F; 使用递增less&lt;int&gt;函数对象排序</span><br><span class="line">priority_queue&lt;deque&lt;int&gt;, greater&lt;int&gt; &gt; pq2; 　　&#x2F;&#x2F; 使用递减greater&lt;int&gt;函数对象排序</span><br></pre></td></tr></table></figure>


<p>其成员函数有“判空(empty)” 、“尺寸(Size)” 、“栈顶元素(top)” 、“压栈(push)” 、“弹栈(pop)”等。</p>
<h2 id="二、priority-queue"><a href="#二、priority-queue" class="headerlink" title="二、priority_queue"></a>二、priority_queue</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>首先要包含头文件<code>#include</code></strong>, 他和<code>queue</code>不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。</p>
<p>优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><blockquote>
<p>和队列基本操作相同:</p>
<ul>
<li>top()           访问队头元素</li>
<li>empty()      队列是否为空</li>
<li>size()          返回队列内元素个数</li>
<li>push()        插入元素到队尾 (并排序)</li>
<li>emplace() 原地构造一个元素并插入队列</li>
<li>pop()         弹出队头元素</li>
<li>swap()       交换内容</li>
</ul>
</blockquote>
<h3 id="头文件："><a href="#头文件：" class="headerlink" title="头文件："></a>头文件：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br></pre></td></tr></table></figure>

<h3 id="声明方式："><a href="#声明方式：" class="headerlink" title="声明方式："></a>声明方式：</h3><h4 id="1、普通方法："><a href="#1、普通方法：" class="headerlink" title="1、普通方法："></a>1、普通方法：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;  　　　　　　　　　　　  <span class="comment">//通过操作，按照元素从大到小的顺序出队</span></span><br><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q; <span class="comment">//通过操作，按照元素从小到大的顺序出队</span></span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br></pre></td></tr></table></figure>

<h4 id="2、自定义优先级："><a href="#2、自定义优先级：" class="headerlink" title="2、自定义优先级："></a>2、自定义优先级：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">　　<span class="function"><span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>   </span></span><br><span class="line"><span class="function">　　</span>&#123;     </span><br><span class="line">　　　　 <span class="keyword">return</span>　x &gt; y;　　 <span class="comment">// x小的优先级高    //也可以写成其他方式，如： return p[x] &gt; p[y];表示p[i]小的优先级高</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; q;  <span class="comment">//定义方法</span></span><br><span class="line"><span class="comment">//其中，第二个参数为容器类型。第三个参数为比较函数。</span></span><br></pre></td></tr></table></figure>

<h4 id="3、结构体声明方式："><a href="#3、结构体声明方式：" class="headerlink" title="3、结构体声明方式："></a>3、结构体声明方式：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>   </span><br><span class="line">　　<span class="keyword">int</span> x, y; </span><br><span class="line">　　<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a, node b)  </span><br><span class="line">　　&#123;     </span><br><span class="line">　　　　<span class="keyword">return</span> a.x &gt; b.x;  <span class="comment">//结构体中，x小的优先级高   </span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt;q;  <span class="comment">//定义方法</span></span><br><span class="line"><span class="comment">// 在该结构中，y为值, x为优先级。</span></span><br><span class="line"><span class="comment">// 通过自定义operator&lt;操作符来比较元素中的优先级。</span></span><br><span class="line"><span class="comment">// 在重载”&lt;”时，最好不要重载”&gt;”，可能会发生编译错误</span></span><br></pre></td></tr></table></figure>

<h2 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h2><h3 id="1、基本类型优先队列的例子："><a href="#1、基本类型优先队列的例子：" class="headerlink" title="1、基本类型优先队列的例子："></a><strong>1、基本类型优先队列的例子：</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//      这里一定要有空格，不然成了右移运算符↓↓</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="built_in">string</span>&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        a.push(i);</span><br><span class="line">        c.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!c.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        c.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    b.push(<span class="string">"abc"</span>);</span><br><span class="line">    b.push(<span class="string">"abcd"</span>);</span><br><span class="line">    b.push(<span class="string">"cbd"</span>);</span><br><span class="line">    <span class="keyword">while</span> (!b.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        b.pop();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 2 1 0&#96;&#96;0 1 2 3 4&#96;&#96;cbd abcd abc&#96;&#96;请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<h3 id="2、用pair做优先队列元素的例子："><a href="#2、用pair做优先队列元素的例子：" class="headerlink" title="2、用pair做优先队列元素的例子："></a><strong>2、用pair做优先队列元素的例子：</strong></h3><p>规则：pair的比较，先比较第一个元素，第一个相等比较第二个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//      这里一定要有空格，不然成了右移运算符↓↓</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="built_in">string</span>&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        a.push(i);</span><br><span class="line">        c.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!c.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        c.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    b.push(<span class="string">"abc"</span>);</span><br><span class="line">    b.push(<span class="string">"abcd"</span>);</span><br><span class="line">    b.push(<span class="string">"cbd"</span>);</span><br><span class="line">    <span class="keyword">while</span> (!b.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        b.pop();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 5&#96;&#96;1 3&#96;&#96;1 2&#96;&#96;请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<h3 id="3、用自定义类型做优先队列元素的例子"><a href="#3、用自定义类型做优先队列元素的例子" class="headerlink" title="3、用自定义类型做优先队列元素的例子"></a><strong>3、用自定义类型做优先队列元素的例子</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp1</span> //运算符重载&lt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    int x;</span></span><br><span class="line"><span class="class">    tmp1(int a) &#123;x = a;&#125;</span></span><br><span class="line"><span class="class">    bool operator&lt;(const tmp1&amp; a) const</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return x &lt; a.x; //大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//方法2</span></span><br><span class="line"><span class="class">struct tmp2 //重写仿函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    bool operator() (tmp1 a, tmp1 b) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return a.x &lt; b.x; //大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">int main() </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    tmp1 a(1);</span></span><br><span class="line"><span class="class">    tmp1 b(2);</span></span><br><span class="line"><span class="class">    tmp1 c(3);</span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1&gt; d;</span></span><br><span class="line"><span class="class">    d.push(b);</span></span><br><span class="line"><span class="class">    d.push(c);</span></span><br><span class="line"><span class="class">    d.push(a);</span></span><br><span class="line"><span class="class">    while (!d.empty()) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        cout &lt;&lt; d.top().x &lt;&lt; '\n';</span></span><br><span class="line"><span class="class">        d.pop();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span></span><br><span class="line"><span class="class">    f.push(b);</span></span><br><span class="line"><span class="class">    f.push(c);</span></span><br><span class="line"><span class="class">    f.push(a);</span></span><br><span class="line"><span class="class">    while (!f.empty()) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        cout &lt;&lt; f.top().x &lt;&lt; '\n';</span></span><br><span class="line"><span class="class">        f.pop();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;3&#96;</span><br><span class="line">&#96;2&#96;</span><br><span class="line">&#96;1&#96; </span><br><span class="line"></span><br><span class="line">&#96;3&#96;</span><br><span class="line">&#96;2&#96;</span><br><span class="line">&#96;1&#96;</span><br><span class="line"></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<h3 id="剑指offer-面试题5"><a href="#剑指offer-面试题5" class="headerlink" title="剑指offer 面试题5"></a>剑指offer 面试题5</h3><p>题目描述：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">        <span class="keyword">if</span>(input.<span class="built_in">size</span>()&lt;k)</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:input)&#123;</span><br><span class="line">            pq.push(n);</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">size</span>()&gt;k)&#123;</span><br><span class="line">                pq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            num.push_back(pq.top());</span><br><span class="line">            pq.pop();                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://www.cnblogs.com/huashanqingzhu/p/11040390.html" target="_blank" rel="noopener">c++优先队列(priority_queue)用法详解</a></p>
<p>[2] [C++STL——优先队列](<a href="https://www.cnblogs.com/xzxl/p/7266404.html）" target="_blank" rel="noopener">https://www.cnblogs.com/xzxl/p/7266404.html）</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-14</title>
    <url>/2020/04/13/2020-04-13-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>355.设计推特</td>
<td>中等</td>
</tr>
<tr>
<td>2</td>
<td>面试题56 - II. 数组中数字出现的次数 II</td>
<td>中等</td>
</tr>
<tr>
<td>3</td>
<td>面试题64. 求1+2+…+n</td>
<td>中等</td>
</tr>
<tr>
<td>4</td>
<td>两数相加</td>
<td>中等</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="355-设计推特"><a href="#355-设计推特" class="headerlink" title="355. 设计推特"></a>355. 设计推特</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：</p>
<ol>
<li><strong>postTweet(userId, tweetId)</strong>: 创建一条新的推文</li>
<li><strong>getNewsFeed(userId)</strong>: 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。</li>
<li><strong>follow(followerId, followeeId)</strong>: 关注一个用户</li>
<li><strong>unfollow(followerId, followeeId)</strong>: 取消关注一个用户</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Twitter twitter &#x3D; new Twitter();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户1发送了一条新推文 (用户id &#x3D; 1, 推文id &#x3D; 5).</span><br><span class="line">twitter.postTweet(1, 5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.</span><br><span class="line">twitter.getNewsFeed(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户1关注了用户2.</span><br><span class="line">twitter.follow(1, 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户2发送了一个新推文 (推文id &#x3D; 6).</span><br><span class="line">twitter.postTweet(2, 6);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -&gt; [6, 5].</span><br><span class="line">&#x2F;&#x2F; 推文id6应当在推文id5之前，因为它是在5之后发送的.</span><br><span class="line">twitter.getNewsFeed(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户1取消关注了用户2.</span><br><span class="line">twitter.unfollow(1, 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.</span><br><span class="line">&#x2F;&#x2F; 因为用户1已经不再关注用户2.</span><br><span class="line">twitter.getNewsFeed(1);</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>用了四个哈希表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; followmap; <span class="comment">//每个用户有一个订阅列表</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; timemap;   <span class="comment">//每条推文对应的时间</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; postermap; <span class="comment">//每个推文对应的人</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; timeline;  <span class="comment">//每个时间对应的推文</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Twitter() &#123;</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Compose a new tweet. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        time++;</span><br><span class="line">        timemap[tweetId]=time;</span><br><span class="line">        timeline[time] = tweetId;</span><br><span class="line">        postermap[tweetId] = userId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        time++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> t = time;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(postermap[timeline[t]]==userId||(followmap[userId].<span class="built_in">find</span>(postermap[timeline[t]])!=followmap[userId].<span class="built_in">end</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(timeline[t]);</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">10</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            t--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        time++;</span><br><span class="line">        <span class="keyword">if</span>(followmap.<span class="built_in">find</span>(followerId)==followmap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            followmap[followerId] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        followmap[followerId].insert(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        time++;</span><br><span class="line">        followmap[followerId].erase(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="哈希表-链表"><a href="#哈希表-链表" class="headerlink" title="哈希表+链表"></a>哈希表+链表</h4><p>根据题意我们知道，对于每个推特用户，我们需要存储他关注的用户 Id，以及自己发的推文 Id 的集合，为了使每个操作的复杂度尽可能的低，我们需要根据操作来决定存储这些信息的数据结构。注意，由于题目中没有说明用户的 Id 是否连续，所以我们需要用一个以用户 Id 为索引的哈希表来存储用户的信息。</p>
<p>对于操作 3 和操作 4，我们只需要用一个哈希表存储，即可实现插入和删除的时间复杂度都为 <code>O(1)</code>。</p>
<p>对于操作 1 和操作 2，由于操作 2 要知道此用户关注的人和用户自己发出的最近十条推文，因此我们可以考虑对每个用户用链表存储发送的推文。每次创建推文的时候我们在链表头插入，这样能保证链表里存储的推文的时间是从最近到最久的。那么对于操作 2，问题其实就等价于有若干个有序的链表，我们需要找到它们合起来最近的十条推文。由于链表里存储的数据都是有序的，所以我们将这些链表进行线性归并即可得到最近的十条推文。这个操作与 23. 合并K个排序链表 基本等同。</p>
<p><img src="/2020/04/13/2020-04-13-LeetCode-CheckDaily/355_fig1.png" alt="fig1"></p>
<p>如果我们直接照搬「合并K个排序链表」的解法来进行合并，那么无疑会造成空间的部分浪费，因为这个题目不要求你展示用户的所有推文，所以我们只要动态维护用户的链表，存储最近的 recentMax 个推文 Id 即可（题目中的 recentMax 为 10）。那么对于操作 1，当发现链表的节点数等于 recentMax 时，我们按题意删除链表末尾的元素，再插入最新的推文 Id。对于操作 2，在两个链表进行线性归并的时候，只要已合并的数量等于 recentMax，代表已经找到这两个链表合起来后最近的 recentMax 条推文，直接结束合并即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="comment">// 哈希表存储关注人的 Id</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; followee;</span><br><span class="line">        <span class="comment">// 用链表存储 tweetId</span></span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; tweet;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// getNewsFeed 检索的推文的上限以及 tweetId 的时间戳</span></span><br><span class="line">    <span class="keyword">int</span> recentMax, time;</span><br><span class="line">    <span class="comment">// tweetId 对应发送的时间</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tweetTime;</span><br><span class="line">    <span class="comment">// 每个用户存储的信息</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node&gt; user;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Twitter() &#123;</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">        recentMax = <span class="number">10</span>;</span><br><span class="line">        user.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        user[userId].followee.<span class="built_in">clear</span>();</span><br><span class="line">        user[userId].tweet.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (user.<span class="built_in">find</span>(userId) == user.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            init(userId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 达到限制，剔除链表末尾元素</span></span><br><span class="line">        <span class="keyword">if</span> (user[userId].tweet.<span class="built_in">size</span>() == recentMax) &#123;</span><br><span class="line">            user[userId].tweet.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        user[userId].tweet.push_front(tweetId);</span><br><span class="line">        tweetTime[tweetId] = ++time;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans; ans.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = user[userId].tweet.<span class="built_in">begin</span>(); it != user[userId].tweet.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            ans.emplace_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> followeeId: user[userId].followee) &#123;</span><br><span class="line">            <span class="keyword">if</span> (followeeId == userId) <span class="keyword">continue</span>; <span class="comment">// 可能出现自己关注自己的情况</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; res.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = user[followeeId].tweet.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 线性归并</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; (<span class="keyword">int</span>)ans.<span class="built_in">size</span>() &amp;&amp; it != user[followeeId].tweet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tweetTime[(*it)] &gt; tweetTime[ans[i]]) &#123;</span><br><span class="line">                    res.emplace_back(*it);</span><br><span class="line">                    ++it;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.emplace_back(ans[i]);</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 已经找到这两个链表合起来后最近的 recentMax 条推文</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">int</span>)res.<span class="built_in">size</span>() == recentMax) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; (<span class="keyword">int</span>)ans.<span class="built_in">size</span>() &amp;&amp; (<span class="keyword">int</span>)res.<span class="built_in">size</span>() &lt; recentMax; ++i) res.emplace_back(ans[i]);</span><br><span class="line">            <span class="keyword">for</span> (; it != user[followeeId].tweet.<span class="built_in">end</span>() &amp;&amp; (<span class="keyword">int</span>)res.<span class="built_in">size</span>() &lt; recentMax; ++it) res.emplace_back(*it);</span><br><span class="line">            ans.assign(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (user.<span class="built_in">find</span>(followerId) == user.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            init(followerId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (user.<span class="built_in">find</span>(followeeId) == user.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            init(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line">        user[followerId].followee.insert(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        user[followerId].followee.erase(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题56-II-数组中数字出现的次数-II"><a href="#面试题56-II-数组中数字出现的次数-II" class="headerlink" title="面试题56 - II. 数组中数字出现的次数 II"></a>面试题56 - II. 数组中数字出现的次数 II</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,3,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10000</code></li>
<li><code>1 &lt;= nums[i] &lt; 2^31</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="built_in">map</span>[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = <span class="built_in">map</span>.<span class="built_in">begin</span>();iter!= <span class="built_in">map</span>.<span class="built_in">end</span>();iter++)</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;second==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> iter-&gt;first;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p><strong>基本思路</strong>：如果某个数字出现3次，那么这个3个数字的和肯定能被3整除，则其对应二进制位的每一位的和也能被3整除<br>统计数组中每个数字的二进制中每一位的和，判断该和是否能被3整除。<br>若可以，则只出现一次的数字的二进制数中那一位为0，否则为1;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">                <span class="comment">// n &amp; 1 &lt;&lt; i 的值大于0即为真</span></span><br><span class="line">                <span class="keyword">if</span>(n &amp; <span class="number">1</span> &lt;&lt; i) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 构造只出现一次的那个数字，采用异或的方法生成二进制中的每一位</span></span><br><span class="line">            <span class="keyword">if</span>(cnt % <span class="number">3</span> == <span class="number">1</span>) ans ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题64-求1-2-…-n"><a href="#面试题64-求1-2-…-n" class="headerlink" title="面试题64. 求1+2+…+n"></a>面试题64. 求1+2+…+n</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10000</code></li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="amp-amp-的短路特性"><a href="#amp-amp-的短路特性" class="headerlink" title="&amp;&amp;的短路特性"></a>&amp;&amp;的短路特性</h4><ul>
<li>A &amp;&amp; B<ul>
<li>A 为 true，则<strong>计算并返回</strong>表达式 B 的 bool 值</li>
<li>A 为 false，则<strong>直接返回</strong> false</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> (n&gt;<span class="number">0</span>)&amp;&amp;(n+=sumNums(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法-1"><a href="#其它解法-1" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="递归快速加法"><a href="#递归快速加法" class="headerlink" title="递归快速加法"></a>递归快速加法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        (n &gt; <span class="number">0</span>) &amp;&amp; (ans = ans + sum(a &lt;&lt; <span class="number">1</span>, n &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        (n &amp; <span class="number">1</span>) &amp;&amp; (ans = ans + a);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">/*  --以下非递归写法，上面递归写法</span></span><br><span class="line"><span class="comment">            --非递归写法必然用到while或者for，不符合题意，所以要使用递归写法</span></span><br><span class="line"><span class="comment">        int ans = 0;</span></span><br><span class="line"><span class="comment">        while(n) &#123; </span></span><br><span class="line"><span class="comment">            if (n &amp; 1) &#123;</span></span><br><span class="line"><span class="comment">                ans = ans + a;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            a &lt;&lt;= 1; // 在快速幂中这里应该是a = a * a, 快速加应改成a = a + a</span></span><br><span class="line"><span class="comment">                     // 我用位运算优化了两数相加的操作</span></span><br><span class="line"><span class="comment">            n &gt;&gt;= 1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum(n + <span class="number">1</span>, n) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：suzukaze-aoba<span class="number">-2</span></span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/qiu-12n-lcof/solution/cshuang-bai-jie-fa-zui-you-jie-fa-kuai-su-jia-shi-/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h4 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h4><p>这个思路不但没用if这种条件判断语句，连逻辑运算中的短路运算也没有用到，也就是连判断的语义也没用到，确实挺牛的，还好这个题限制了n的大小，即限制了n二进制的位数，不然得累加32次……我在代码里为了可读性用临时变量保存了每一位的累加求解，当然一个return也是没问题的。</p>
<p>作者：shitsurei<br>链接：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/yan-jiu-liao-ban-tian-zhong-yu-kan-dong-da-lao-de-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof/solution/yan-jiu-liao-ban-tian-zhong-yu-kan-dong-da-lao-de-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负数在参与位运算时使用的是补码</span></span><br><span class="line"><span class="comment">     * -1的原码是   10000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="comment">     * -1的反码是   11111111 11111111 11111111 11111110</span></span><br><span class="line"><span class="comment">     * -1的补码是   11111111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">     * 因此任何数与-1做与运算的结果任然为原数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 由等差数列求和公式可知，结果等于n*(n+1)/2，其中除以2可以通过右移1位进行操作</span></span><br><span class="line"><span class="comment">         * 但n*(n+1)在不允许使用乘法的情况下，只能把n或n+1其中一个拆解为2的n次幂数之和，配合另一个来进行位运算和累加</span></span><br><span class="line"><span class="comment">         * 此代码利用了-1和任何整数进行与运算还等于原数的特点</span></span><br><span class="line"><span class="comment">         * -(n + 1 &gt;&gt; 0 &amp; 1)用于求从低到高第i+1位如果为0取，如果为1取-1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> n1 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">0</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n3 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> n4 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">3</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> n5 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">4</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> n6 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">5</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> n7 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">6</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> n8 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">7</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> n9 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">8</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> n10 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">9</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> n11 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">10</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n12 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">11</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">int</span> n13 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">12</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">int</span> n14 = (n &amp; -(n + <span class="number">1</span> &gt;&gt; <span class="number">13</span> &amp; <span class="number">1</span>)) &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">return</span> (n1 + n2 + n3 + n4 + n5 + n6 + n7 + n8 + n9 + n10 + n11 + n12 + n13 + n14) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a>445. 两数相加 II</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个 <strong>非空</strong> 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<h4 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a><strong>进阶：</strong></h4><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><p>翻转链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1||!l2)</span><br><span class="line">            <span class="keyword">return</span> l1==<span class="literal">nullptr</span>?l2:l1;</span><br><span class="line">        l1 = reverse(l1);</span><br><span class="line">        l2 = reverse(l2);</span><br><span class="line">        ListNode* p = l1;</span><br><span class="line">        ListNode* prev;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;val += l2-&gt;val + next;</span><br><span class="line">            next = l1-&gt;val / <span class="number">10</span>;</span><br><span class="line">            l1-&gt;val = l1-&gt;val % <span class="number">10</span>;</span><br><span class="line">            prev=l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = l2;</span><br><span class="line">            l1 = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;val += next;</span><br><span class="line">            next = l1-&gt;val / <span class="number">10</span>;</span><br><span class="line">            l1-&gt;val = l1-&gt;val % <span class="number">10</span>;</span><br><span class="line">            prev=l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* np = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            prev-&gt;next = np;</span><br><span class="line">            np-&gt;val = next;</span><br><span class="line">            np-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverse(p);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* l1)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode head;</span><br><span class="line">        head.next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *p = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            p-&gt;next = head.next;</span><br><span class="line">            head.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法-2"><a href="#其它解法-2" class="headerlink" title="其它解法"></a>其它解法</h3><p>使用栈</p>
<p>本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line">        <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">            s1.push(l1 -&gt; val);</span><br><span class="line">            l1 = l1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">            s2.push(l2 -&gt; val);</span><br><span class="line">            l2 = l2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* ans = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s1.empty() <span class="keyword">or</span> !s2.empty() <span class="keyword">or</span> carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = s1.empty() ? <span class="number">0</span> : s1.top();</span><br><span class="line">            <span class="keyword">int</span> b = s2.empty() ? <span class="number">0</span> : s2.top();</span><br><span class="line">            <span class="keyword">if</span> (!s1.empty()) s1.pop();</span><br><span class="line">            <span class="keyword">if</span> (!s2.empty()) s2.pop();</span><br><span class="line">            <span class="keyword">int</span> cur = a + b + carry;</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            cur %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">auto</span> curnode = <span class="keyword">new</span> ListNode(cur);</span><br><span class="line">            curnode -&gt; next = ans;</span><br><span class="line">            ans = curnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>特征点法的巅峰之作—ORBSLAM2</title>
    <url>/2020/04/13/2020-04-13-ORBSLAM2/</url>
    <content><![CDATA[<p>ORB-SLAM 是西班牙 Zaragoza 大学的 Raúl Mur-Arta 编写的视觉 SLAM 系统。 它是一个完整的 SLAM 系统，包括视觉里程计、跟踪、回环检测，是一种完全基于稀疏特征点的单目 SLAM 系统，同时还有单目、双目、RGBD 相机的接口。其核心是使用 ORB (Orinted FAST and BRIEF) 作为整个视觉 SLAM 中的核心特征。</p>
<a id="more"></a>

<h2 id="ORB-SLAM-基本介绍"><a href="#ORB-SLAM-基本介绍" class="headerlink" title="ORB-SLAM 基本介绍"></a><strong>ORB-SLAM 基本介绍</strong></h2><p>ORB-SLAM 基本延续了 PTAM 的算法框架,但对框架中的大部分组件都做了改进, 归纳起来主要有 4 点:</p>
<ol>
<li>ORB-SLAM 选用了 ORB 特征, 基于 ORB 描述量的特征匹配和重定位, 都比 PTAM 具有更好的视角不变性。此外, 新增三维点的特征匹配效率更高, 因此能更及时地扩展场景。扩展场景及时与否决定了后续帧是否能稳定跟踪。</li>
<li>ORBSLAM 加入了循环回路的检测和闭合机制, 以消除误差累积。系统采用与重定位相同的方法来检测回路(匹配回路两侧关键帧上的公共点), 通过方位图 (Pose Graph) 优化来闭合回路。</li>
<li>PTAM 需要用户指定 2 帧来初始化系统, 2 帧间既要有足够的公共点, 又要有足够的平移量. 平移运动为这些公共点提供视差 (Parallax) , 只有足够的视差才能三角化出精确的三维位置。ORB-SLAM 通过检测视差来自动选择初始化的 2 帧。</li>
<li>PTAM 扩展场景时也要求新加入的关键帧提供足够的视差, 导致场景往往难以扩展. ORB-SLAM 采用一种更鲁棒的关键帧和三维点的选择机制——先用宽松的判断条件尽可能及时地加入新的关键帧和三维点, 以保证后续帧的鲁棒跟踪; 再用严格的判断条件删除冗余的关键帧和不稳定的三维点，以保证 BA 的效率和精度。</li>
</ol>
<p><em>引自《基于单目视觉的同时定位与地图构建方法综述》</em></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>首个支持单目，双目和RGBD相机的完整的开源SLAM方案，能够实现地图重用，回环检测和重新定位的功能</li>
<li>能够在CPU上进行实时工作，比如手机、无人机、汽车。</li>
<li>特征点法的巅峰之作，定位精度极高。</li>
<li>能够实时计出相机的位姿，并生成场景的稀疏三维重建地图。</li>
<li>代码非常整洁，包含很多实际应用中的技巧，非常实用。</li>
<li>支持仅定位模式，该模式适用于轻量级以及在地图已知情况下长期运行，此时不使用局部建图和回环检测的线程。</li>
<li>双目和RGBD相对单目相机的主要优势在于，可以直接获得深度信息，不需要像单目情况中那样做一个特定的SFM初始化</li>
</ul>
<h3 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h3><p><img src="/2020/04/13/2020-04-13-ORBSLAM2/image-20200413105119355.png" alt="image-20200413105119355"></p>
<p>ORB-SLAM 它是由三大块、三个流程同时运行的。第一块是跟踪，第二块是建图，第三块是闭环检测。</p>
<h4 id="1-跟踪（Tracking）"><a href="#1-跟踪（Tracking）" class="headerlink" title="1. 跟踪（Tracking）"></a>1. 跟踪（Tracking）</h4><p>这一部分主要工作是从图像中提取 ORB 特征，根据上一帧进行姿态估计，或者进行通过全局重定位初始化位姿，然后跟踪已经重建的局部地图，优化位姿，再根据一些规则确定新关键帧。</p>
<h4 id="2-建图（LocalMapping）"><a href="#2-建图（LocalMapping）" class="headerlink" title="2. 建图（LocalMapping）"></a>2. 建图（LocalMapping）</h4><p>这一部分主要完成局部地图构建。包括对关键帧的插入，验证最近生成的地图点并进行筛选，然后生成新的地图点，使用局部捆集调整（Local BA），最后再对插入的关键帧进行筛选，去除多余的关键帧。</p>
<h4 id="3-闭环检测（LoopClosing）"><a href="#3-闭环检测（LoopClosing）" class="headerlink" title="3. 闭环检测（LoopClosing）"></a>3. 闭环检测（LoopClosing）</h4><p>这一部分主要分为两个过程，分别是闭环探测和闭环校正。闭环检测先使用 WOB 进行探测，然后通过 Sim3 算法计算相似变换。闭环校正，主要是闭环融合和 Essential Graph 的图优化。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点**"></a>优缺点**</h3><p><strong>优点：</strong></p>
<ul>
<li>一个代码构造优秀的视觉 SLAM 系统，非常适合移植到实际项目。</li>
<li>采用 g2o 作为后端优化工具，能有效地减少对特征点位置和自身位姿的估计误差。</li>
<li>采用 DBOW 减少了寻找特征的计算量，同时回环匹配和重定位效果较好。重定位：比如当机器人遇到一些意外情况之后，它的数据流突然被打断了，在 ORB-SLAM 算法下，可以在短时间内重新把机器人在地图中定位。</li>
<li>使用了类似「适者生存」的方案来进行关键帧的删选，提高系统追踪的鲁棒性和系统的可持续运行。</li>
<li>提供最著名的公共数据集（ KITTI 和 TUM 数据集）的详尽实验结果，以显示其性能。</li>
<li>可以使用开源代码，并且还支持使用 ROS。 (Github: <a href="https://link.zhihu.com/?target=https%3A//github.com/slightech/MYNT-EYE-ORB-SLAM2-Sample">slightech/MYNT-EYE-ORB-SLAM2-Sample</a>）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>构建出的地图是稀疏点云图。只保留了图像中特征点的一部分作为关键点，固定在空间中进行定位，很难描绘地图中的障碍物的存在。</li>
<li>初始化时最好保持低速运动，对准特征和几何纹理丰富的物体。</li>
<li>旋转时比较容易丢帧，特别是对于纯旋转，对噪声敏感，不具备尺度不变性。</li>
<li>如果使用纯视觉 slam 用于机器人导航，可能会精度不高，或者产生累积误差，漂移，尽管可以使用 DBoW 词袋可以用来回环检测。最好使用 VSLAM+IMU 进行融合，可以提高精度上去，适用于实际应用中机器人的导航。</li>
</ul>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>associate：深度图与彩色图之间不能超过0.02s。</p>
<h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ol>
<li>TUM</li>
<li>EuRoC</li>
<li>KITTI</li>
</ol>
<h3 id="地图表示"><a href="#地图表示" class="headerlink" title="地图表示"></a>地图表示</h3><p>红色点表示当前追踪的点，黑色点表示剩下的点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glcloor3f(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>); <span class="comment">//黑色</span></span><br><span class="line">glcloor3f(<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>); <span class="comment">//红色</span></span><br></pre></td></tr></table></figure>

<h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">loadImages(); <span class="comment">//读取图片的函数 用来loadframe</span></span><br></pre></td></tr></table></figure>

<h3 id="System-h"><a href="#System-h" class="headerlink" title="System.h"></a>System.h</h3><p>其中包含的系统类非常重要</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>ORBSLAM2</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第184场周赛</title>
    <url>/2020/04/12/2020-04-12-LeetCode-Contest-184/</url>
    <content><![CDATA[<p>本周周赛战况不佳，只做出前两个来，剩下的其实也很简单。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th align="left">题目</th>
<th align="left">分值</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="left">数组中的字符串匹配</td>
<td align="left">3</td>
</tr>
<tr>
<td>2</td>
<td align="left">查询带键的排列</td>
<td align="left">4</td>
</tr>
<tr>
<td>3</td>
<td align="left">HTML 实体解析器</td>
<td align="left">5</td>
</tr>
<tr>
<td>4</td>
<td align="left">给 N x 3 网格图涂色的方案数</td>
<td align="left">7</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="5380-数组中的字符串匹配"><a href="#5380-数组中的字符串匹配" class="headerlink" title="5380. 数组中的字符串匹配"></a>5380. 数组中的字符串匹配</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串数组 <code>words</code> ，数组中的每个字符串都可以看作是一个单词。请你按 <strong>任意</strong> 顺序返回 <code>words</code> 中是其他单词的子字符串的所有单词。</p>
<p>如果你可以删除 <code>words[j]</code> 最左侧和/或最右侧的若干字符得到 <code>word[i]</code> ，那么字符串 <code>words[i]</code> 就是 <code>words[j]</code> 的一个子字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words &#x3D; [&quot;mass&quot;,&quot;as&quot;,&quot;hero&quot;,&quot;superhero&quot;]</span><br><span class="line">输出：[&quot;as&quot;,&quot;hero&quot;]</span><br><span class="line">解释：&quot;as&quot; 是 &quot;mass&quot; 的子字符串，&quot;hero&quot; 是 &quot;superhero&quot; 的子字符串。</span><br><span class="line">[&quot;hero&quot;,&quot;as&quot;] 也是有效的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words &#x3D; [&quot;leetcode&quot;,&quot;et&quot;,&quot;code&quot;]</span><br><span class="line">输出：[&quot;et&quot;,&quot;code&quot;]</span><br><span class="line">解释：&quot;et&quot; 和 &quot;code&quot; 都是 &quot;leetcode&quot; 的子字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words &#x3D; [&quot;blue&quot;,&quot;green&quot;,&quot;bu&quot;]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 100</code></li>
<li><code>1 &lt;= words[i].length &lt;= 30</code></li>
<li><code>words[i]</code> 仅包含小写英文字母。</li>
<li>题目数据 <strong>保证</strong> 每个 <code>words[i]</code> 都是独一无二的。</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>暴力匹配</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">stringMatching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        sort(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;words.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;words.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=j&amp;&amp;words[j].<span class="built_in">find</span>(words[i])!=<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(words[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5381-查询带键的排列"><a href="#5381-查询带键的排列" class="headerlink" title="5381. 查询带键的排列"></a>5381. 查询带键的排列</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个待查数组 <code>queries</code> ，数组中的元素为 <code>1</code> 到 <code>m</code> 之间的正整数。 请你根据以下规则处理所有待查项 <code>queries[i]</code>（从 <code>i=0</code> 到 <code>i=queries.length-1</code>）：</p>
<ul>
<li>一开始，排列 <code>P=[1,2,3,...,m]</code>。</li>
<li>对于当前的 <code>i</code> ，请你找出待查项 <code>queries[i]</code> 在排列 <code>P</code> 中的位置（<strong>下标从 0 开始</strong>），然后将其从原位置移动到排列 <code>P</code> 的起始位置（即下标为 0 处）。注意， <code>queries[i]</code> 在 <code>P</code> 中的位置就是 <code>queries[i]</code> 的查询结果。</li>
</ul>
<p>请你以数组形式返回待查数组 <code>queries</code> 的查询结果。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：queries &#x3D; [3,1,2,1], m &#x3D; 5</span><br><span class="line">输出：[2,1,2,1] </span><br><span class="line">解释：待查数组 queries 处理如下：</span><br><span class="line">对于 i&#x3D;0: queries[i]&#x3D;3, P&#x3D;[1,2,3,4,5], 3 在 P 中的位置是 2，接着我们把 3 移动到 P 的起始位置，得到 P&#x3D;[3,1,2,4,5] 。</span><br><span class="line">对于 i&#x3D;1: queries[i]&#x3D;1, P&#x3D;[3,1,2,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P&#x3D;[1,3,2,4,5] 。 </span><br><span class="line">对于 i&#x3D;2: queries[i]&#x3D;2, P&#x3D;[1,3,2,4,5], 2 在 P 中的位置是 2，接着我们把 2 移动到 P 的起始位置，得到 P&#x3D;[2,1,3,4,5] 。</span><br><span class="line">对于 i&#x3D;3: queries[i]&#x3D;1, P&#x3D;[2,1,3,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P&#x3D;[1,2,3,4,5] 。 </span><br><span class="line">因此，返回的结果数组为 [2,1,2,1] 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：queries &#x3D; [4,1,2,2], m &#x3D; 4</span><br><span class="line">输出：[3,1,2,0]</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：queries &#x3D; [7,5,5,8,3], m &#x3D; 8</span><br><span class="line">输出：[6,5,0,7,5]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m &lt;= 10^3</code></li>
<li><code>1 &lt;= queries.length &lt;= m</code></li>
<li><code>1 &lt;= queries[i] &lt;= m</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>我的这个解法很不好；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">processQueries</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            P[i+<span class="number">1</span>]=i;</span><br><span class="line">            l[i]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(P[queries[i]]);</span><br><span class="line">            <span class="keyword">int</span> val = queries[i]; <span class="comment">//值</span></span><br><span class="line">            <span class="keyword">int</span> loc = P[queries[i]]; <span class="comment">//位置</span></span><br><span class="line">            <span class="comment">//顺序移动到后边</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = loc<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = P[l[j]];</span><br><span class="line">                P[l[j]] += <span class="number">1</span>;</span><br><span class="line">                l[j+<span class="number">1</span>] = l[j];</span><br><span class="line">            &#125;</span><br><span class="line">            P[val] = <span class="number">0</span>;</span><br><span class="line">            l[<span class="number">0</span>] = val;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5382-HTML-实体解析器"><a href="#5382-HTML-实体解析器" class="headerlink" title="5382. HTML 实体解析器"></a>5382. HTML 实体解析器</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。</p>
<p>HTML 里这些特殊字符和它们对应的字符实体包括：</p>
<ul>
<li><strong>双引号：</strong>字符实体为 <code>&quot;</code> ，对应的字符是 <code>&quot;</code> 。</li>
<li><strong>单引号：</strong>字符实体为 <code>&#39;</code> ，对应的字符是 <code>&#39;</code> 。</li>
<li><strong>与符号：</strong>字符实体为 <code>&amp;</code> ，对应对的字符是 <code>&amp;</code> 。</li>
<li><strong>大于号：</strong>字符实体为 <code>&gt;</code> ，对应的字符是 <code>&gt;</code> 。</li>
<li><strong>小于号：</strong>字符实体为 <code>&lt;</code> ，对应的字符是 <code>&lt;</code> 。</li>
<li><strong>斜线号：</strong>字符实体为 <code>⁄</code> ，对应的字符是 <code>/</code> 。</li>
</ul>
<p>给你输入字符串 <code>text</code> ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text &#x3D; &quot;&amp; is an HTML entity but &amp;ambassador; is not.&quot;</span><br><span class="line">输出：&quot;&amp; is an HTML entity but &amp;ambassador; is not.&quot;</span><br><span class="line">解释：解析器把字符实体 &amp; 用 &amp; 替换</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text &#x3D; &quot;and I quote: &quot;...&quot;&quot;</span><br><span class="line">输出：&quot;and I quote: \&quot;...\&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text &#x3D; &quot;Stay home! Practice on Leetcode :)&quot;</span><br><span class="line">输出：&quot;Stay home! Practice on Leetcode :)&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text &#x3D; &quot;x &gt; y &amp;&amp; x &lt; y is always false&quot;</span><br><span class="line">输出：&quot;x &gt; y &amp;&amp; x &lt; y is always false&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a><strong>示例 5：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text &#x3D; &quot;leetcode.com&amp;frasl;problemset&amp;frasl;all&quot;</span><br><span class="line">输出：&quot;leetcode.com&#x2F;problemset&#x2F;all&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text.length &lt;= 10^5</code></li>
<li>字符串可能包含 256 个ASCII 字符中的任意字符。</li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">entityParser</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">"&amp;quot;"</span>]=<span class="string">"\""</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">"&amp;apos;"</span>]=<span class="string">"'"</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">"&amp;amp;"</span>]=<span class="string">"&amp;"</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">"&amp;gt;"</span>]=<span class="string">"&gt;"</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">"&amp;lt;"</span>]=<span class="string">"&lt;"</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">"&amp;frasl;"</span>]=<span class="string">"/"</span>;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> key=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:<span class="built_in">text</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">'&amp;'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=key;</span><br><span class="line">                key = <span class="string">"&amp;"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">';'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                key.append(<span class="number">1</span>,ch);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(key)!=<span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    res += <span class="built_in">map</span>[key];</span><br><span class="line">                    key = <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                key.append(<span class="number">1</span>,ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!key.empty())</span><br><span class="line">            res+=key;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5383-给-N-x-3-网格图涂色的方案数"><a href="#5383-给-N-x-3-网格图涂色的方案数" class="headerlink" title="5383. 给 N x 3 网格图涂色的方案数"></a>5383. 给 N x 3 网格图涂色的方案数</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>你有一个 <code>n x 3</code> 的网格图 <code>grid</code> ，你需要用 <strong>红，黄，绿</strong> 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。</p>
<p>给你网格图的行数 <code>n</code> 。</p>
<p>请你返回给 <code>grid</code> 涂色的方案数。由于答案可能会非常大，请你返回答案对 <code>10^9 + 7</code> 取余的结果。</p>
<h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：12</span><br><span class="line">解释：总共有 12 种可行的方法：</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：54</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：246</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：106494</span><br></pre></td></tr></table></figure>

<h4 id="示例-5：-1"><a href="#示例-5：-1" class="headerlink" title="示例 5："></a><strong>示例 5：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5000</span><br><span class="line">输出：30228214</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>n == grid.length</code></li>
<li><code>grid[i].length == 3</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
</ul>
<h3 id="他人解法"><a href="#他人解法" class="headerlink" title="他人解法"></a>他人解法</h3><h4 id="1-状态压缩-递推。"><a href="#1-状态压缩-递推。" class="headerlink" title="1. 状态压缩 + 递推。"></a>1. 状态压缩 + 递推。</h4><p><strong>状态压缩</strong><br>用一个数字表示集合的一种状态。<br>在本题中，三个并列的格子可以看作是一个集合。我们用数字表示这个集合的状态，也就是染色方案。</p>
<p><strong>具体的表示方法</strong>如下：<br>因为只有三种颜色，所以可以用三进制数字来表示染色方案。用 0，1，2 分别代表红黄绿。因为每个集合只有三个格子，所以只需要用三位数字。<br>比如21 = 0 + 31 + 92，代表第一个格子为红色，第二个格子为黄色，第三个格子为绿色。<br>我们可以把这个数字称为状态码。</p>
<p>关于状态码的取值范围<br>当三个格子都染成红色时，状态码取得最小值即 0 + 03 + 09 = 0。<br>当三个格子都染成绿色时，状态码取得最大值即 2 + 23 + 29 = 26。<br>所以状态码的取值范围为[0,26]。</p>
<p><strong>递归</strong><br>设 <code>dp[n][sc]</code> 为将前 n 层都染上颜色，且第n层的染色为 <code>sc</code>。<code>sc</code> 即上述的状态码。<br>当 n 等于 1时，<code>dp[n][sc]</code>很好计算，即判断<code>sc</code>代表的染色方案是否合法即可。<br>如果合法 <code>dp[1][sc] = 1</code>，否则 <code>dp[1][sc] = 0</code>。</p>
<p>当 <code>n &gt; 1</code> 时，<code>dp[n][sc]</code>由 <code>dp[n-1][psc]</code>推导得出。<code>sc</code> 为第<code>n</code>行的染色方案，<code>psc</code>为 <code>n-1</code>行的染色方案。</p>
<p>递推式子如下：</p>
<p><code>dp[n][sc] += dp[n-1][psc] (0 &lt;= psc &lt; 27)</code>。</p>
<p><strong>源代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">5001</span>][<span class="number">27</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//根据每个格子的颜色获取状态码</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + j*<span class="number">3</span> + k *<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据状态码获取每个格子的颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cs</span><span class="params">(<span class="keyword">int</span> statusCode, <span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b, <span class="keyword">int</span> &amp;c)</span> </span>&#123;</span><br><span class="line">        a = statusCode % <span class="number">3</span>;</span><br><span class="line">        b = (statusCode - a)%<span class="number">9</span>/<span class="number">3</span>;</span><br><span class="line">        c = statusCode/<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        初始化 n = <span class="number">1</span> 的方案数。</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != j &amp;&amp; j != k) &#123;</span><br><span class="line">                        dp[<span class="number">1</span>][sc(i,j,k)] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//枚举行数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> level = <span class="number">2</span>; level &lt;= n; level++) &#123;</span><br><span class="line">            <span class="comment">//枚举前一行的染色方案</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> pre = <span class="number">0</span>; pre &lt; <span class="number">27</span>; ++pre) &#123;</span><br><span class="line">                <span class="keyword">int</span> a, b, c;</span><br><span class="line">                cs(pre, a, b, c);</span><br><span class="line">                <span class="keyword">if</span>(a == b || b == c) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//枚举当前行的染色方案</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == a) &#123; <span class="keyword">continue</span>; &#125; <span class="comment">//检查是否冲突</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(i == j || j == b) &#123; <span class="keyword">continue</span>; &#125; <span class="comment">//检查是否冲突</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(j == k || k == c) &#123; <span class="keyword">continue</span>; &#125; <span class="comment">//检查是否冲突</span></span><br><span class="line">                            (dp[level][sc(i,j,k)] += dp[level<span class="number">-1</span>][pre]) %= mod; <span class="comment">//当前染色方案可行，累加方案数。</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">            (ans += dp[n][i]) %= mod; <span class="comment">//计算总的方案数。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">5010</span>][<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>];<span class="comment">//f[i][j][k][l]表示第i行涂的颜色为(j,k,l)时的涂色方案数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) <span class="keyword">if</span>(i!=j&amp;&amp;j!=k) f[<span class="number">1</span>][i][j][k] = <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">3</span>; i1++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j1 = <span class="number">0</span>; j1 &lt; <span class="number">3</span>; j1++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k1 = <span class="number">0</span>; k1 &lt; <span class="number">3</span>; k1++) </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt; <span class="number">3</span>; i2++)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt; <span class="number">3</span>; j2++)&#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; <span class="number">3</span>; k2++)&#123;<span class="comment">//枚举相邻两行的状态 再判断是否符合条件即可</span></span><br><span class="line">                                <span class="keyword">if</span>(i2!=j2&amp;&amp;j2!=k2 &amp;&amp; i1!=i2&amp;&amp;j1!=j2&amp;&amp;k1!=k2)<span class="comment">//水平不同 垂直不同 </span></span><br><span class="line">                                    f[i][i2][j2][k2] = (f[i][i2][j2][k2] + f[i<span class="number">-1</span>][i1][j1][k1])%p;</span><br><span class="line">                            &#125; </span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;<span class="comment">//得出结果 即为最后一行所有不同涂色状态时的累加和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) res = (res + f[n][i][j][k])%p; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>周赛</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4.11~12</title>
    <url>/2020/04/10/2020-04-11-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>[困难] 鸡蛋掉落 </li>
<li>[简单] 二叉树的最近公共祖先</li>
<li>[困难] 求两线段交点</li>
</ol>
<a id="more"></a>

<h2 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a>887. 鸡蛋掉落</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>你将获得 <code>K</code> 个鸡蛋，并可以使用一栋从 <code>1</code> 到 <code>N</code> 共有 <code>N</code> 层楼的建筑。</p>
<p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p>
<p>你知道存在楼层 <code>F</code> ，满足 <code>0 &lt;= F &lt;= N</code> 任何从高于 <code>F</code> 的楼层落下的鸡蛋都会碎，从 <code>F</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次<em>移动</em>，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 <code>X</code> 扔下（满足 <code>1 &lt;= X &lt;= N</code>）。</p>
<p>你的目标是<strong>确切地</strong>知道 <code>F</code> 的值是多少。</p>
<p>无论 <code>F</code> 的初始值如何，你确定 <code>F</code> 的值的最小移动次数是多少？</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：K &#x3D; 1, N &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F &#x3D; 0 。</span><br><span class="line">否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F &#x3D; 1 。</span><br><span class="line">如果它没碎，那么我们肯定知道 F &#x3D; 2 。</span><br><span class="line">因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：K &#x3D; 2, N &#x3D; 6</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：K &#x3D; 3, N &#x3D; 14</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= K &lt;= 100</code></li>
<li><code>1 &lt;= N &lt;= 10000</code></li>
</ol>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="背景资料"><a href="#背景资料" class="headerlink" title="背景资料"></a>背景资料</h4><p>本题是谷歌用于面试的一道经典面试题之一。由于本题过于经典，谷歌公司已经不再将这题作为面试的候选题目了。</p>
<p>本题难度较高，要想通过本题，需要一定的动态规划优化或数学功底。本题的标准解法为动态规划，由于篇幅有限，不会叙述 动态规划的边界条件、自底向上的动态规划和自顶向下的动态规划分别怎么实现 等较为基础的知识，而是把重点放在推导动态规划状态转移方程的过程，以及优化的思路、证明以及方法。</p>
<p>读者应当期望在阅读完本题解后，能够对方法一有一个大致的思路，并且可以在尝试中编写出代码。方法一已经是很优秀的解法，本题解也着重于此。而对于方法二和方法三，已经超过了面试难度，是竞赛中的考点，仅供读者挑战自我的极限。</p>
<h4 id="方法一：动态规划-二分搜索"><a href="#方法一：动态规划-二分搜索" class="headerlink" title="方法一：动态规划 + 二分搜索"></a>方法一：动态规划 + 二分搜索</h4><h5 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a>思路和算法</h5><p>我们可以考虑使用动态规划来做这道题，状态可以表示成 <code>(K, N)</code>，其中 <code>K</code>为鸡蛋数，<code>N</code>为楼层数。当我们从第 XX 楼扔鸡蛋的时候：</p>
<p>如果鸡蛋不碎，那么状态变成 <code>(K, N-X)</code>，即我们鸡蛋的数目不变，但答案只可能在上方的 <code>N-X</code>层楼了。也就是说，我们把原问题缩小成了一个规模为 <code>(K, N-X)</code>的子问题；</p>
<p>如果鸡蛋碎了，那么状态变成 <code>(K-1, X-1)</code>，即我们少了一个鸡蛋，但我们知道答案只可能在第<code>X</code>楼下方的 <code>X-1</code>层楼中了。也就是说，我们把原问题缩小成了一个规模为 <code>(K-1, X-1)</code>的子问题。</p>
<p>这样一来，我们定义 <code>dp(K, N)</code>为在状态 <code>(K, N)</code>下最少需要的步数。</p>
<p>根据以上分析我们可以列出状态转移方程：<br>$$<br>dp(K, N) = 1 + \min\limits_{1 \leq X \leq N} \Big( \max(dp(K-1, X-1), dp(K, N-X)) \Big)\<br>dp(K,N)=1+1≤X≤N \min<br> (max(dp(K−1,X−1),dp(K,N−X)))<br>$$<br>这个状态转移方程是如何得来的呢？对于 <code>dp(K, N)</code>而言，我们像上面分析的那样，枚举第一个鸡蛋扔在的楼层数 <code>X</code>。由于我们并不知道真正的 <code>F</code>值，因此我们必须保证 鸡蛋碎了之后接下来需要的步数 和 鸡蛋没碎之后接下来需要的步数 二者的 最大值 最小，这样就保证了在 最坏情况下（也就是无论 <code>F</code> 的值如何） <code>dp(K, N)</code>的值最小。如果能理解这一点，也就能理解上面的状态转移方程。即最小化 $\max(dp(K-1, X-1), dp(K, N-X))$。</p>
<p>如果我们直接暴力转移求解每个状态的<code>dp</code>值，时间复杂度是为 <code>O(KN^2)</code>，即一共有 <code>O(KN)</code>个状态，对于每个状态枚举扔鸡蛋的楼层 <code>X</code>,需要 <code>O(N)</code>的时间。这无疑在当前数据范围下是会超出时间限制的，因此我们需要想办法优化枚举的时间复杂度。</p>
<p>我们观察到 <code>dp(K, N)</code>是一个关于 <code>N</code> 的单调递增函数，也就是说在鸡蛋数 <code>K</code>固定的情况下，楼层数 <code>N</code>越多，需要的步数一定不会变少。在上述的状态转移方程中，第一项$\mathcal{T_1}(X) = dp(K-1, X-1)$是一个随 <code>X</code>的增加而单调递增的函数，第二项 $\mathcal{T_2}(X) = dp(K, N-X)$是一个随着 <code>X</code>的增加而单调递减的函数。这如何帮助我们来优化这个问题呢？当X增加时，$\mathcal{T_1}(X)$单调递增。而$\mathcal{T_2}(X)$单调递减，我们可以想象在一个直角坐标系中，横坐标为 XX，纵坐标为 $\mathcal{T_1}(X)$ 和 $\mathcal{T_2}(X)$。当一个函数单调递增而另一个函数单调递减时，我们如何找到一个位置使得它们的最大值最小呢？</p>
<p>如上图所示，如果这两个函数都是连续函数，那么我们只需要找出这两个函数的交点，在交点处就能保证这两个函数的最大值最小。但在本题中，$\mathcal{T_1}(X)$都是离散函数，也就是说，X的值只能取 <code>1,2,3</code> 等等。在这种情况下，我们需要找到最大的满足 $\mathcal{T_1}(X) &lt; \mathcal{T_2}(X)$ ，以及最小的满足 $\mathcal{T_1}(X) \geq \mathcal{T_2}(X)$，对应到上图中，就是离这两个函数（想象中的）交点左右两侧最近的整数。</p>
<p>我们只需要比较在$X_0$ 和 $X_1$处两个函数的最大值，取一个最小的作为 <code>X</code> 即可。在数学上，我们可以证明出 $X_0$和 $X_1$相差1，这也是比较显然的，因为它们正好夹住了那个想象中的交点，并且相距尽可能地近。因此我们就可以使用二分查找的方法找出 $X_0$ ，再得到$X_1$</p>
<p>我们在所有满足条件的 <code>X</code>X 上进行二分查找。对于状态 <code>(K, N)</code> 而言，<code>X</code>即为 <code>[1, N]</code>中的任一整数；</p>
<p>在二分查找的过程中，假设当前这一步我们查找到了 $X_\textit{mid}$，如果 $\mathcal{T_1}(X_\textit{mid}) &gt; \mathcal{T_2}(X_\textit{mid})$ ,那么真正的 $X_0$  一定在 $X_\textit{mid}$  的左侧，否则真正的 $X_0$  在 $X_\textit{mid}$  的右侧。</p>
<p>二分查找的写法因人而异，本质上我们就是需要找到最大的满足 $\mathcal{T_1}(X) &lt; \mathcal{T_2}(X)$ 的 $X_0$ ，根据 $X_\textit{mid}$  进行二分边界的调整。在得到了<code>X_0</code> 后，我们可以知道 $X_1$  即为 $X_0 + 1$，此时我们只需要比较 $\max(\mathcal{T_1}(X_0), \mathcal{T_2}(X_0))$和$\max(\mathcal{T_1}(X_1), \mathcal{T_2}(X_1))$，取较小的那个对应的位置作为 <code>X</code>即可。</p>
<p>这样一来，对于给定的状态 <code>(K, N)</code>，我们只需要 <code>O(logN)</code> 的时间，通过二分查找就能得到最优的那个<code>X</code>，因此时间复杂度从 <code>O(KN^2)</code>降低至 <code>O(KN \log N)</code>，可以通过本题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">find</span>(N * <span class="number">100</span> + K) == memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans;</span><br><span class="line">            <span class="keyword">if</span> (N == <span class="number">0</span>) ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>) ans = N;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> lo = <span class="number">1</span>, hi = N;</span><br><span class="line">                <span class="keyword">while</span> (lo + <span class="number">1</span> &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> t1 = dp(K<span class="number">-1</span>, x<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">int</span> t2 = dp(K, N-x);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (t1 &lt; t2) lo = x;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) hi = x;</span><br><span class="line">                    <span class="keyword">else</span> lo = hi = x;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ans = <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">max</span>(dp(K<span class="number">-1</span>, lo<span class="number">-1</span>), dp(K, N-lo)),</span><br><span class="line">                                   <span class="built_in">max</span>(dp(K<span class="number">-1</span>, hi<span class="number">-1</span>), dp(K, N-hi)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            memo[N * <span class="number">100</span> + K] = ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[N * <span class="number">100</span> + K];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(K, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题68-II-二叉树的最近公共祖先"><a href="#面试题68-II-二叉树的最近公共祖先" class="headerlink" title="面试题68 - II. 二叉树的最近公共祖先"></a>面试题68 - II. 二叉树的最近公共祖先</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt="img"></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;        </span><br><span class="line">        <span class="keyword">if</span>(root == p||root == q)<span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left ? left : right; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-16-03-交点"><a href="#面试题-16-03-交点" class="headerlink" title="面试题 16.03. 交点"></a>面试题 16.03. 交点</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>给定两条线段（表示为起点<code>start = {X1, Y1}</code>和终点<code>end = {X2, Y2}</code>），如果它们有交点，请计算其交点，没有交点则返回空值。</p>
<p>要求浮点型误差不超过<code>10^-6</code>。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">line1 &#x3D; &#123;0, 0&#125;, &#123;1, 0&#125;</span><br><span class="line">line2 &#x3D; &#123;1, 1&#125;, &#123;0, -1&#125;</span><br><span class="line">输出： &#123;0.5, 0&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">line1 &#x3D; &#123;0, 0&#125;, &#123;3, 3&#125;</span><br><span class="line">line2 &#x3D; &#123;1, 1&#125;, &#123;2, 2&#125;</span><br><span class="line">输出： &#123;1, 1&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">line1 &#x3D; &#123;0, 0&#125;, &#123;1, 1&#125;</span><br><span class="line">line2 &#x3D; &#123;1, 0&#125;, &#123;2, 1&#125;</span><br><span class="line">输出： &#123;&#125;，两条线段没有交点</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li>坐标绝对值不会超过 2^7</li>
<li>输入的坐标均是有效的二维坐标</li>
</ul>
<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="叉积法"><a href="#叉积法" class="headerlink" title="叉积法"></a>叉积法</h4><p>我们也可以不用表示出线段的方程，通过向量的基本运算来解决这个问题。这里引入一些向量运算的基本概念。</p>
<p>向量叉积的模：对于向量 $\boldsymbol{a} = (x_1, y_1)$和 $\boldsymbol{b} = (x_2, y_2)$，定义向量的叉积的模为<br>$$<br>|\boldsymbol{c}| = |\boldsymbol{a} \times \boldsymbol{b}| = |\boldsymbol{a}||\boldsymbol{b}| \sin \langle \boldsymbol{a}, \boldsymbol{b} \rangle = x_1 y_2 - x_2 y_1<br>$$</p>
<p>其中 $\langle \boldsymbol{a}, \boldsymbol{b} \rangle$表示 $\boldsymbol{a}$ 和 $\boldsymbol{b}$的夹角。这个模的正负性可以表示这两个向量的位置关系，如果 $\boldsymbol{a}$可以逆时针旋转与 $\boldsymbol{b}$共线，那么这个模大于 0；如果 $\boldsymbol{a}$可以顺时针旋转与 $\boldsymbol{b}$共线，那么这个模小于 0；如果已经共线，则等于 0。</p>
<p>三角形的面积：有了叉积的定义，我们可以这样计算三角形 ABCABC 的面积<br>$$<br>S = \frac{|\boldsymbol{AB}\times \boldsymbol{AC}|}{2}<br>$$</p>
<p>很好理解，画图可以看出 $\sin \langle \boldsymbol{a}, \boldsymbol{b}\rangle$ 相当于把一个向量投影成了另一个向量为底边的高。</p>
<p>定比分点：若 P(x, y)P(x,y) 在线段 ABAB 上，端点坐标$A(x_1, y_2)，B(x_2, y_2)$，且 <code>AP</code>和 <code>BP</code>的长度之比为 $\lambda$，那么<br>$$<br>\left { \begin{aligned} x &amp;=&amp; \frac{x_1 + \lambda x_2}{1 + \lambda} \ y &amp;=&amp; \frac{y_1 + \lambda y_2}{1 + \lambda} \end{aligned} \right .<br>$$</p>
<p><strong>说明</strong></p>
<p>题目要求「如果有交点则计算交点，没有则返回空值」，并说明有多个交点的时候返回以 <code>x</code>为第一关键字，以 <code>y</code> 为第二关键字排序的最小点。</p>
<p>首先我们要判断线段 <code>AB</code>和 <code>CD</code>是否存在交点，等价转换这个条件就是 <code>A</code>和 <code>B</code>位于<code>CD</code>的两侧并且 <code>C</code>和 <code>D</code> 位于 <code>AB</code>的两侧。那么如何判断「<code>P</code> 和<code>Q</code>位于<code>MN</code>的两侧」呢？我们可以连接<code>PM</code>和<code>QM</code>，如果能满足 $(\boldsymbol{MN} \times \boldsymbol{MP})(\boldsymbol{MN} \times \boldsymbol{MQ}) \leq 0$，即把 $\boldsymbol{MN}$ 向两个不同的方向旋转可以分别得到 $\boldsymbol{MP}$ 和 $\boldsymbol{MQ}$，则说明<code>P</code> 和<code>Q</code>位于 <code>MN</code>的两侧。考虑：什么时候等于 0？ 很明显当 <code>P</code> 或<code>Q</code>位于 <code>MN</code>上的时候，这个值等于 <code>0</code>。这里我们也可以先通过叉积的方法判断 $\boldsymbol{MN}$和$\boldsymbol{PQ}$是否共线，如果 $\boldsymbol{MN} \times \boldsymbol{MP}$和$ \boldsymbol{MN} \times \boldsymbol{MQ}$都为 <code>0</code>，则说明共线。对于共线的情况，我们可以根据方法一的做法做四个 <code>update</code>。</p>
<p>当已经确定两个线段 <code>AB</code>和 <code>CD</code>是相交的时候，如何求解线段的交点呢？我们可以把 <code>AB</code>和 <code>CD</code> 看成一个四边形的两条对角线，它们相交于点 O。我们可以通过三角形面积公式求出 <code>ABC</code> 和 <code>ABD</code>的面积，它们的比值就是 <code>OC</code>和 <code>OD</code> 的比值，然后再用<strong>定比分点公式</strong>求出 <code>O</code> 的坐标。</p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Coor = <span class="built_in">vector</span> &lt;<span class="keyword">double</span>&gt;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> EPS = <span class="number">1E-6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; start1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; end1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; start2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; end2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ax = start1[<span class="number">0</span>], ay = start1[<span class="number">1</span>], bx = end1[<span class="number">0</span>], by = end1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cx = start2[<span class="number">0</span>], cy = start2[<span class="number">1</span>], dx = end2[<span class="number">0</span>], dy = end2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> acx = cx - ax, acy = cy - ay, abx = bx - ax, aby = by - ay, adx = dx - ax, ady = dy - ay;</span><br><span class="line">        <span class="keyword">int</span> cax = ax - cx, cay = ay - cy, cbx = bx - cx, cby = by - cy, cdx = dx - cx, cdy = dy - cy;</span><br><span class="line">        <span class="comment">// 叉积运算</span></span><br><span class="line">        <span class="keyword">auto</span> cross = [] (<span class="keyword">int</span> ux, <span class="keyword">int</span> uy, <span class="keyword">int</span> vx, <span class="keyword">int</span> vy) &#123;</span><br><span class="line">            <span class="keyword">return</span> ux * vy - vx * uy;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 判断线段 (ux, uy) -- (vx, vy) 是否包含 (mx, my)  </span></span><br><span class="line">        <span class="keyword">auto</span> bothSide = [&amp;] (<span class="keyword">int</span> mx, <span class="keyword">int</span> my, <span class="keyword">int</span> ux, <span class="keyword">int</span> uy, <span class="keyword">int</span> vx, <span class="keyword">int</span> vy) &#123;</span><br><span class="line">            <span class="keyword">double</span> um = <span class="built_in">sqrt</span>((ux - mx) * (ux - mx) + (uy - my) * (uy - my));</span><br><span class="line">            <span class="keyword">double</span> vm = <span class="built_in">sqrt</span>((vx - mx) * (vx - mx) + (vy - my) * (vy - my));</span><br><span class="line">            <span class="keyword">double</span> uv = <span class="built_in">sqrt</span>((vx - ux) * (vx - ux) + (vy - uy) * (vy - uy));</span><br><span class="line">            <span class="keyword">return</span> (ux - mx) * (vx - mx) &lt;= <span class="number">0</span> &amp;&amp; (uy - my) * (vy - my) &lt;= <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 以 x 为第一关键字，y 为第二关键字比较两个点的大小</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [] (<span class="keyword">const</span> Coor&amp; u, <span class="keyword">const</span> Coor&amp; v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u.<span class="built_in">size</span>() == <span class="number">0</span> || v.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> v.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (u[<span class="number">0</span>] != v[<span class="number">0</span>]) ? (u[<span class="number">0</span>] &lt; v[<span class="number">0</span>]) : (u[<span class="number">1</span>] &lt; v[<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 共线处理和 T 形处理</span></span><br><span class="line">        <span class="keyword">if</span> (cross(cax, cay, cbx, cby) == <span class="number">0</span> || cross(adx, ady, abx, aby) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">bool</span> aInCd = bothSide(ax, ay, cx, cy, dx, dy), bInCd = bothSide(bx, by, cx, cy, dx, dy);</span><br><span class="line">            <span class="keyword">bool</span> cInAb = bothSide(cx, cy, ax, ay, bx, by), dInAb = bothSide(dx, dy, ax, ay, bx, by);</span><br><span class="line">            Coor ans;</span><br><span class="line">            <span class="keyword">if</span> (aInCd) ans = <span class="built_in">min</span>(ans, Coor(&#123;(<span class="keyword">double</span>)ax, (<span class="keyword">double</span>)ay&#125;), cmp) ;</span><br><span class="line">            <span class="keyword">if</span> (bInCd) ans = <span class="built_in">min</span>(ans, Coor(&#123;(<span class="keyword">double</span>)bx, (<span class="keyword">double</span>)by&#125;), cmp);</span><br><span class="line">            <span class="keyword">if</span> (cInAb) ans = <span class="built_in">min</span>(ans, Coor(&#123;(<span class="keyword">double</span>)cx, (<span class="keyword">double</span>)cy&#125;), cmp);</span><br><span class="line">            <span class="keyword">if</span> (dInAb) ans = <span class="built_in">min</span>(ans, Coor(&#123;(<span class="keyword">double</span>)dx, (<span class="keyword">double</span>)dy&#125;), cmp);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断两条线段是否有公共点</span></span><br><span class="line">        <span class="keyword">auto</span> intersect = [&amp;] () &#123;</span><br><span class="line">            <span class="keyword">return</span> cross(acx, acy, abx, aby) * cross(adx, ady, abx, aby) &lt;= <span class="number">0</span> &amp;&amp; cross(cax, cay, cdx, cdy) * cross(cbx, cby, cdx, cdy) &lt;= <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (!intersect()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Coor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算三角形 PQM 的面积</span></span><br><span class="line">        <span class="keyword">auto</span> getArea = [&amp;] (<span class="keyword">int</span> px, <span class="keyword">int</span> py, <span class="keyword">int</span> qx, <span class="keyword">int</span> qy, <span class="keyword">int</span> mx, <span class="keyword">int</span> my) -&gt; <span class="keyword">double</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mpx = px - mx, mpy = py - my, mqx = qx - mx, mqy = qy - my;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="keyword">double</span>(<span class="number">0.5</span>) * cross(mpx, mpy, mqx, mqy));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 定比分点</span></span><br><span class="line">        <span class="keyword">double</span> ck = getArea(ax, ay, bx, by, cx, cy), dk = getArea(ax, ay, bx, by, dx, dy);</span><br><span class="line">        <span class="keyword">double</span> k = ck / dk;</span><br><span class="line">        <span class="keyword">double</span> rx = (cx + k * dx) / (<span class="number">1</span> + k), ry = (cy + k * dy) / (<span class="number">1</span> + k);</span><br><span class="line">        <span class="keyword">return</span> Coor(&#123;rx, ry&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在代码中「共线处理和 T 形处理」部分，为什么只判断了 ABCABC 共线或者 ABDABD 共线呢？</p>
<p>如果 <code>ABC</code> 共线且 <code>ABD</code>共线，那么说明 <code>ABCD</code>共线<br>如果 <code>ABC</code>共线但 <code>ABD</code>不共线，那么说明<code>C</code>在「直线」<code>AB</code>上，如果 <code>C</code> 在「线段」<code>AB</code>上则形成一个 <code>T</code> 形结构<br>如果 <code>ABD</code>共线但是 ABCABC 不共线，那么说明 DD 在「直线」ABAB 上，如果 DD 在「线段」ABAB 上则形成一个 T 形结构<br>这里只能判断点是否在「直线」上，在 if 里面才可以判断点是否在线段上。这三种情况都能得到正确的结果，因为经过四个取 min 的操作（即方法一中的四个 update），所有「点 PP 在 MNMN 上」的情况可以被讨论出来，所以这里不仅处理的是共线的情况，还有四种 T 形的情况中的两种。思考：为什么不用处理剩下的两种呢？ 不判断 ACDACD 和 BCDBCD，因为后面定比分点用的是 ABCABC 和 ABDABD 的面积，前面 ABCABC 共线和 ABDABD 共线被处理掉之后，就不存在面积为 00 的状况，也就不会出现分母为 00。即使 ACDACD 和 BCDBCD 共线，ABCABC 和 ABDABD 的面积依然是大于 00 的，不影响定比分点。</p>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：<code>O(1)</code>。</p>
<p>空间复杂度：<code>O(1)</code>。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-9</title>
    <url>/2020/04/09/2020-04-09-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>括号生成</li>
<li>翻转字符串里的单词</li>
<li>不用加减乘除做加法</li>
</ol>
<a id="more"></a>

<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure>

<h3 id="我的解法：递归"><a href="#我的解法：递归" class="headerlink" title="我的解法：递归"></a>我的解法：递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">""</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">"()"</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp1 = generateParenthesis(i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp2 = generateParenthesis(n-i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> str1:tmp1)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> str2:tmp2)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">"("</span>+str1+<span class="string">")"</span>+str2);</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>+str1+<span class="string">")"</span>+str2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它方法一：暴力法"><a href="#其它方法一：暴力法" class="headerlink" title="其它方法一：暴力法"></a>其它方法一：暴力法</h3><p>思路</p>
<p>我们可以生成所有 2^{2n}2<br>2n<br>  个 ‘(‘ 和 ‘)’ 字符构成的序列，然后我们检查每一个是否有效即可。</p>
<p>算法</p>
<p>为了生成所有序列，我们可以使用递归。长度为 n 的序列就是在长度为 n-1 的序列前加一个 ‘(‘ 或 ‘)’。</p>
<p>为了检查序列是否有效，我们遍历这个序列，并使用一个变量 balance 表示左括号的数量减去右括号的数量。如果在遍历过程中 balance 的值小于零，或者结束时 balance 的值不为零，那么该序列就是无效的，否则它是有效的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str)</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>)</span><br><span class="line">                ++balance;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                --balance;</span><br><span class="line">                <span class="keyword">if</span> (balance &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> balance == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generate_all</span><span class="params">(<span class="built_in">string</span>&amp; current, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == current.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid(current))</span><br><span class="line">                result.push_back(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current += <span class="string">'('</span>;</span><br><span class="line">        generate_all(current, n, result);</span><br><span class="line">        current.pop_back();</span><br><span class="line">        current += <span class="string">')'</span>;</span><br><span class="line">        generate_all(current, n, result);</span><br><span class="line">        current.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="built_in">string</span> current;</span><br><span class="line">        generate_all(current, n * <span class="number">2</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其它方法二：DFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuffer sbq = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">        dfs(sbq,n,n);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(StringBuffer sb, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span>.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(sb.append(<span class="string">'('</span>), left - <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(sb.append(<span class="string">')'</span>), left, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a>151. 翻转字符串里的单词</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a><strong>说明：</strong></h4><ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">        <span class="built_in">string</span> temp = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp!=<span class="string">""</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    st.push(temp);</span><br><span class="line">                    temp=<span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp+=ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="string">""</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(temp);</span><br><span class="line">            temp=<span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            res+=temp;</span><br><span class="line">            <span class="keyword">if</span>(!st.empty())</span><br><span class="line">                res+=<span class="string">" "</span>;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题65-不用加减乘除做加法"><a href="#面试题65-不用加减乘除做加法" class="headerlink" title="面试题65. 不用加减乘除做加法"></a>面试题65. 不用加减乘除做加法</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: a &#x3D; 1, b &#x3D; 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">int</span> plus1 = (a ^ b); <span class="comment">// 求和（不计进位）. 相同位置0，相反位置1</span></span><br><span class="line">        <span class="keyword">int</span> plus2 = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>); <span class="comment">// 计算进位. 先保留同为1的位，都为1的位要向左进位，因此左移1位</span></span><br><span class="line">        <span class="keyword">return</span> add(plus1,plus2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果是十进制的话，我们是如何完成加法计算的？<code>15 + 12 = ？</code> 个位数和十位数的数字分别相加先不管进位的问题，<code>2 + 5 = 7</code>；<code>1 + 1 = 2</code>；所以得到结果 27。</p>
<p><strong>计算产生进位的数字</strong> </p>
<p>这里有进位吗？没有，那么就是0, 把上面两步的结果进行相加：<code>27 + 0 = 27</code>；<code>99 + 111 = ？</code> 个、十、百位 的数字分别相加先不管进位的问题：<br>个位：9 + 1 = 0<br>十位：9 + 1 = 0<br>百位：0 + 1 = 1<br>得到临时结果：100</p>
<p><strong>计算进位的数字</strong><br>1 + 9 = 10;<br>10 + 90 = 100;<br>得到进位结果：110</p>
<p><strong>相加得到结果</strong><br>100 + 110 = 210<br>如何用二进制完成以上的步骤？</p>
<p><strong>问题1： 二进制的加法利用以上的步骤可以得到正确的结果吗？</strong><br>12 二进制：1100<br>15 二进制：1111</p>
<p>各位置上的数字分别相加先不管进位的问题：<br>1100 + 1111 = 0011<br>得到临时二进制结果：0011</p>
<p>计算进位的数字：<br>0100 + 0100 = 1000<br>1000 + 1000= 10000<br>得到进位结果：11000</p>
<p>相加得到结果<br>0011 + 11000 = 11011（十进制：27）<br>就目前来看，是可以的。</p>
<p><strong>问题2：第一步骤不用加法如何得到相同结果？异或</strong><br>异或：相同为0，相异为1</p>
<p>1100 ^ 1111 = 0011</p>
<p><strong>问题3：第二步骤不用加法如何得到相同结果？相与，左移一位</strong><br>如果一个位置上的数字相遇能得到1 ，那么表示，位置上的数字都是1，然后在往左移动一位，就是步骤二 进位得到的结果</p>
<p>(1100 &amp; 1111) &lt;&lt; 1 = 11000</p>
<p><strong>问题4：第三步骤不用加法如何得到相同结果？其实这是个套娃</strong><br>第三步不用加法实现最难，因为第三步是前两步的和，还是个加法；如果不用加法，就只能不断调用前两步的步骤。<br>我想用下面的一张图来说明：</p>
<p><img src="/2020/04/09/2020-04-09-LeetCode-CheckDaily/0fdd8e927c61b5f70bdc3e7da0ac100dcd1e3b2f66de5bdf3ebcfb1f6a73c64f-image.png" alt="image.png"></p>
<p>从上图，你大概可以看出，这个就是在不断重复第一，第二的步骤，那么退出条件是什么？<br>其实我们可以设想一个最坏的情况，那就是，这个循环到了一个情况，会在一直循环的情况，结果依然不变？<br>无疑，那就是，进位的结果为0的情况，所以，其实在不考虑溢位的情况下，其实最多最多就是循环32次就行,<br>所以，一下代码已经可以得到正确的结果了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 32; i++) &#123;</span><br><span class="line">		int tempSum &#x3D; a ^ b;</span><br><span class="line">		int carrySum &#x3D; (a &amp; b) &lt;&lt; 1;</span><br><span class="line">		a &#x3D; tempSum;</span><br><span class="line">		b &#x3D; carrySum;</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是以上的代码依然利用了加法运算，依然不不符合题意。<br>那么只能根据 条件 进位的结果为0的情况 进行判断停止了，就有了一下正确的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> tempSum = a ^ b;</span><br><span class="line">		<span class="keyword">int</span> carrySum = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		a = tempSum;</span><br><span class="line">		b = carrySum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>作者：fakerleet<br>链接：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/jin-zhi-tao-wa-ru-he-yong-wei-yun-suan-wan-cheng-j/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/jin-zhi-tao-wa-ru-he-yong-wei-yun-suan-wan-cheng-j/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</em></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-8</title>
    <url>/2020/04/08/2020-04-08-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>机器人的运动范围</li>
<li>用两个栈实现队列</li>
<li>从上到下打印二叉树 II</li>
</ol>
<a id="more"></a>

<h2 id="面试题13-机器人的运动范围"><a href="#面试题13-机器人的运动范围" class="headerlink" title="面试题13. 机器人的运动范围"></a>面试题13. 机器人的运动范围</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ </p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= n,m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p><strong>BFS</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy=&#123;<span class="number">0</span> ,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( k &lt; <span class="number">0</span> || ( !m &amp;&amp; !n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flag</span><span class="params">(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">1</span>))</span></span>;</span><br><span class="line">        flag[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; val = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = val.first+dx[i];</span><br><span class="line">                <span class="keyword">int</span> y = val.second+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span>&lt;=x &amp;&amp; x&lt;m &amp;&amp; <span class="number">0</span> &lt;=y &amp;&amp; y&lt;n &amp;&amp; flag[x][y] &amp;&amp; (countbit(x)+countbit(y)&lt;=k) )</span><br><span class="line">                &#123;</span><br><span class="line">                    flag[x][y]=<span class="number">0</span>;</span><br><span class="line">                    q.push(&#123;x,y&#125;);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countbit</span><span class="params">(<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=m%<span class="number">10</span>;</span><br><span class="line">            m/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题09-用两个栈实现队列"><a href="#面试题09-用两个栈实现队列" class="headerlink" title="面试题09. 用两个栈实现队列"></a>面试题09. 用两个栈实现队列</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>

<h4 id="提示：-1"><a href="#提示：-1" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= values &lt;= 10000</code></li>
<li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="1-设计两个栈，每次取数据都倒腾一下"><a href="#1-设计两个栈，每次取数据都倒腾一下" class="headerlink" title="1. 设计两个栈，每次取数据都倒腾一下"></a>1. 设计两个栈，每次取数据都倒腾一下</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mst;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nst;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        mst.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mst.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(mst.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> val = mst.top();</span><br><span class="line">            nst.push(val);</span><br><span class="line">            mst.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = mst.top();</span><br><span class="line">        mst.pop();</span><br><span class="line">        <span class="keyword">while</span>(!nst.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nst.top();</span><br><span class="line">            nst.pop();</span><br><span class="line">            mst.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p>执行用时：<strong>1532 ms</strong></p>
<p>内存消耗：<strong>110.9 MB</strong></p>
<h4 id="2-设计两个栈，出栈为空时才倒腾"><a href="#2-设计两个栈，出栈为空时才倒腾" class="headerlink" title="2. 设计两个栈，出栈为空时才倒腾"></a>2. 设计两个栈，出栈为空时才倒腾</h4><p>两个栈，一个负责入，一个负责出，取数据时先去出栈找，如果栈为空则把入栈的数据都丢到出栈里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CQueue &#123;</span><br><span class="line">    stack&lt;int&gt; ist;</span><br><span class="line">    stack&lt;int&gt; ost;</span><br><span class="line">public:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void appendTail(int value) &#123;</span><br><span class="line">        ist.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int deleteHead() &#123;</span><br><span class="line">        if(ost.empty())</span><br><span class="line">        &#123; </span><br><span class="line">            while(!ist.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                int tmp &#x3D; ist.top();</span><br><span class="line">                ist.pop();</span><br><span class="line">                ost.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ost.empty()) return -1;</span><br><span class="line">        int val &#x3D; ost.top();</span><br><span class="line">        ost.pop();</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p>执行用时 : <strong>996 ms</strong></p>
<p>内存消耗 : <strong>103.5 MB</strong></p>
<h2 id="面试题32-II-从上到下打印二叉树-II"><a href="#面试题32-II-从上到下打印二叉树-II" class="headerlink" title="面试题32 - II. 从上到下打印二叉树 II"></a>面试题32 - II. 从上到下打印二叉树 II</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<h4 id="例如"><a href="#例如" class="headerlink" title="例如:"></a>例如:</h4><p>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><p>层次遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>,nk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level = &#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* pt = q.front();</span><br><span class="line">            level.push_back(pt-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(pt-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(pt-&gt;left);</span><br><span class="line">                nk++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pt-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(pt-&gt;right);</span><br><span class="line">                nk++;</span><br><span class="line">            &#125;</span><br><span class="line">            q.pop();</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(level);</span><br><span class="line">                level = &#123;&#125;;</span><br><span class="line">                k = nk;</span><br><span class="line">                nk = <span class="number">0</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-7</title>
    <url>/2020/04/07/2020-04-07-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>旋转矩阵</li>
<li>非递增顺序的最小子序列</li>
<li>将二进制表示减到1的步骤数</li>
</ol>
<a id="more"></a>

<h2 id="面试题-01-07-旋转矩阵"><a href="#面试题-01-07-旋转矩阵" class="headerlink" title="面试题 01.07. 旋转矩阵"></a>面试题 01.07. 旋转矩阵</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="1-拷贝一个矩阵"><a href="#1-拷贝一个矩阵" class="headerlink" title="1. 拷贝一个矩阵"></a>1. 拷贝一个矩阵</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//a[i][j] = A[j][N-1-i];</span></span><br><span class="line">        <span class="comment">//A[i][j] = a[N-1-j][i]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">A</span><span class="params">(N,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                A[i][j] = matrix[N<span class="number">-1</span>-j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix = A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-原地解法"><a href="#2-原地解法" class="headerlink" title="2. 原地解法"></a>2. 原地解法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;N<span class="number">-1</span>-i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[N<span class="number">-1</span>-j][i];</span><br><span class="line">                matrix[N<span class="number">-1</span>-j][i] = matrix[N<span class="number">-1</span>-i][N<span class="number">-1</span>-j];</span><br><span class="line">                matrix[N<span class="number">-1</span>-i][N<span class="number">-1</span>-j] = matrix[j][N<span class="number">-1</span>-i];</span><br><span class="line">                matrix[j][N<span class="number">-1</span>-i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1403-非递增顺序的最小子序列"><a href="#1403-非递增顺序的最小子序列" class="headerlink" title="1403. 非递增顺序的最小子序列"></a>1403. 非递增顺序的最小子序列</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个数组 <code>nums</code>，请你从中抽取一个子序列，满足该子序列的元素之和 <strong>严格</strong> 大于未包含在该子序列中的各元素之和。</p>
<p>如果存在多个解决方案，只需返回 <strong>长度最小</strong> 的子序列。如果仍然有多个解决方案，则返回 <strong>元素之和最大</strong> 的子序列。</p>
<p>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。</p>
<p><strong>注意</strong>，题目数据保证满足所有约束条件的解决方案是 <strong>唯一</strong> 的。同时，返回的答案应当按 <strong>非递增顺序</strong> 排列。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,3,10,9,8]</span><br><span class="line">输出：[10,9] </span><br><span class="line">解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,4,7,6,7]</span><br><span class="line">输出：[7,7,6] </span><br><span class="line">解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 &#x3D; 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [6]</span><br><span class="line">输出：[6]</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>排序+再依次计算就好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minSubsequence</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums) sum+=n;</span><br><span class="line">        <span class="keyword">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">            sum2+=nums[i];</span><br><span class="line">            sum-=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum2&gt;sum)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1404-将二进制表示减到-1-的步骤数"><a href="#1404-将二进制表示减到-1-的步骤数" class="headerlink" title="1404. 将二进制表示减到 1 的步骤数"></a>1404. 将二进制表示减到 1 的步骤数</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个以二进制形式表示的数字 <code>s</code> 。请你返回按下述规则将其减少到 1 所需要的步骤数：</p>
<ul>
<li>如果当前数字为偶数，则将其除以 2 。</li>
<li>如果当前数字为奇数，则将其加上 1 。</li>
</ul>
<p>题目保证你总是可以按上述规则将测试用例变为 1 。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1101&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：&quot;1101&quot; 表示十进制数 13 。</span><br><span class="line">Step 1) 13 是奇数，加 1 得到 14 </span><br><span class="line">Step 2) 14 是偶数，除 2 得到 7</span><br><span class="line">Step 3) 7  是奇数，加 1 得到 8</span><br><span class="line">Step 4) 8  是偶数，除 2 得到 4  </span><br><span class="line">Step 5) 4  是偶数，除 2 得到 2 </span><br><span class="line">Step 6) 2  是偶数，除 2 得到 1</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;10&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：&quot;10&quot; 表示十进制数 2 。</span><br><span class="line">Step 1) 2 是偶数，除 2 得到 1</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li>
<li><code>s[0] == &#39;1&#39;</code></li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSteps</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">"1"</span>||s==<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[len<span class="number">-1</span>]==<span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">return</span> numSteps(s.substr(<span class="number">0</span>,len<span class="number">-1</span>))+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[len<span class="number">-1</span>]==<span class="string">'1'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum*=<span class="number">2</span>;</span><br><span class="line">                sum+=s[i]-<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">            s = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span>(sum)</span><br><span class="line">            &#123;</span><br><span class="line">                s+=sum%<span class="number">2</span>+<span class="string">'0'</span>;</span><br><span class="line">                sum/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> numSteps(s)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第23场双周赛</title>
    <url>/2020/04/06/2020-04-06-LeetCode-Double-Contest23/</url>
    <content><![CDATA[<p>这次参加了LeeCode双周赛，差了一分钟拿到四个pass，最后排名是585/2044；</p>
<table>
<thead>
<tr>
<th>题目列表</th>
<th>得分</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/count-largest-group/" target="_blank" rel="noopener">统计最大组的数目</a></td>
<td><strong>3</strong></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/construct-k-palindrome-strings/" target="_blank" rel="noopener">构造 K 个回文字符串</a></td>
<td>5</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/circle-and-rectangle-overlapping/" target="_blank" rel="noopener">圆和矩形是否有重叠</a></td>
<td>5</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/reducing-dishes/" target="_blank" rel="noopener">做菜顺序</a></td>
<td>6</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="1-统计最大组的数目"><a href="#1-统计最大组的数目" class="headerlink" title="1. 统计最大组的数目"></a>1. 统计最大组的数目</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数 <code>n</code> 。请你先求出从 <code>1</code> 到 <code>n</code> 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。</p>
<p>请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：4</span><br><span class="line">解释：总共有 9 个组，将 1 到 13 按数位求和后这些组分别是：</span><br><span class="line">[1,10]，[2,11]，[3,12]，[4,13]，[5]，[6]，[7]，[8]，[9]。总共有 4 个组拥有的数字并列最多。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：总共有 2 个大小为 1 的组 [1]，[2]。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 15</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 24</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countLargestGroup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Maxnum = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = BitSum(i);</span><br><span class="line">            <span class="built_in">map</span>[sum]++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[sum]&gt;Maxnum)</span><br><span class="line">            &#123;</span><br><span class="line">                Maxnum = <span class="built_in">map</span>[sum];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[sum] == Maxnum)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">BitSum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=i%<span class="number">10</span>;</span><br><span class="line">            i/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-构造K个回文字符串"><a href="#2-构造K个回文字符串" class="headerlink" title="2. 构造K个回文字符串"></a>2. 构造K个回文字符串</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>难度中等2</p>
<p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。请你用 <code>s</code> 字符串中 <strong>所有字符</strong> 构造 <code>k</code> 个非空 <strong>回文串</strong> 。</p>
<p>如果你可以用 <code>s</code> 中所有字符构造 <code>k</code> 个回文字符串，那么请你返回 <strong>True</strong> ，否则返回 <strong>False</strong> 。</p>
<h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;annabelle&quot;, k &#x3D; 2</span><br><span class="line">输出：true</span><br><span class="line">解释：可以用 s 中所有字符构造 2 个回文字符串。</span><br><span class="line">一些可行的构造方案包括：&quot;anna&quot; + &quot;elble&quot;，&quot;anbna&quot; + &quot;elle&quot;，&quot;anellena&quot; + &quot;b&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;, k &#x3D; 3</span><br><span class="line">输出：false</span><br><span class="line">解释：无法用 s 中所有字符构造 3 个回文串。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;true&quot;, k &#x3D; 4</span><br><span class="line">输出：true</span><br><span class="line">解释：唯一可行的方案是让 s 中每个字符单独构成一个字符串。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;yzyzyzyzyzyzyzy&quot;, k &#x3D; 2</span><br><span class="line">输出：true</span><br><span class="line">解释：你只需要将所有的 z 放在一个字符串中，所有的 y 放在另一个字符串中。那么两个字符串都是回文串。</span><br></pre></td></tr></table></figure>

<h4 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a><strong>示例 5：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;cr&quot;, k &#x3D; 7</span><br><span class="line">输出：false</span><br><span class="line">解释：我们没有足够的字符去构造 7 个回文串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>s</code> 中所有字符都是小写英文字母。</li>
<li><code>1 &lt;= k &lt;= 10^5</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator  iter;</span><br><span class="line">        <span class="keyword">for</span>(iter = <span class="built_in">map</span>.<span class="built_in">begin</span>();iter!=<span class="built_in">map</span>.<span class="built_in">end</span>();iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            i+=iter-&gt;second%<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;k&lt;&lt;len&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> i&lt;=k&amp;&amp;(len-i)&gt;=k-i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="3-圆和矩形是否有重叠"><a href="#3-圆和矩形是否有重叠" class="headerlink" title="3. 圆和矩形是否有重叠"></a>3. 圆和矩形是否有重叠</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个以 (<code>radius</code>, <code>x_center</code>, <code>y_center</code>) 表示的圆和一个与坐标轴平行的矩形 (<code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>)，其中 (<code>x1</code>, <code>y1</code>) 是矩形左下角的坐标，(<code>x2</code>, <code>y2</code>) 是右上角的坐标。</p>
<p>如果圆和矩形有重叠的部分，请你返回 True ，否则返回 False 。</p>
<p>换句话说，请你检测是否 <strong>存在</strong> 点 (xi, yi) ，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。</p>
<h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/04/sample_4_1728.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：radius &#x3D; 1, x_center &#x3D; 0, y_center &#x3D; 0, x1 &#x3D; 1, y1 &#x3D; -1, x2 &#x3D; 3, y2 &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line">解释：圆和矩形有公共点 (1,0)</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/04/sample_2_1728.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：radius &#x3D; 1, x_center &#x3D; 0, y_center &#x3D; 0, x1 &#x3D; -1, y1 &#x3D; 0, x2 &#x3D; 0, y2 &#x3D; 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/04/sample_6_1728.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：radius &#x3D; 1, x_center &#x3D; 1, y_center &#x3D; 1, x1 &#x3D; -3, y1 &#x3D; -3, x2 &#x3D; 3, y2 &#x3D; 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-2"><a href="#示例-4：-2" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：radius &#x3D; 1, x_center &#x3D; 1, y_center &#x3D; 1, x1 &#x3D; 1, y1 &#x3D; -3, x2 &#x3D; 2, y2 &#x3D; -1</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>1 &lt;= radius &lt;= 2000</code></li>
<li><code>-10^4 &lt;= x_center, y_center, x1, y1, x2, y2 &lt;= 10^4</code></li>
<li><code>x1 &lt; x2</code></li>
<li><code>y1 &lt; y2</code></li>
</ul>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>1.</strong> 先计算矩形中心，边长；</p>
<p><strong>2.</strong> 把矩形中心，圆心投影到坐标轴上；</p>
<p><strong>3.</strong> 计算矩形中心与圆心在坐标轴上的距离；</p>
<p><strong>4.</strong> 判断，圆心超出矩形的距离是否小于圆的半径;</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkOverlap</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x_center, <span class="keyword">int</span> y_center, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x= <span class="number">0.5</span>*(x1+x2),y=<span class="number">0.5</span>*(y1+y2);</span><br><span class="line">        <span class="keyword">double</span> lenx = x2-x1,leny = y2-y1;</span><br><span class="line">        <span class="keyword">double</span> disx = <span class="built_in">abs</span>(x_center-x);</span><br><span class="line">        <span class="keyword">double</span> disy = <span class="built_in">abs</span>(y_center-y);</span><br><span class="line">        <span class="keyword">double</span> dis = <span class="built_in">max</span>(disx-lenx/<span class="number">2</span>,<span class="number">0.0</span>)*<span class="built_in">max</span>(disx-lenx/<span class="number">2</span>,<span class="number">0.0</span>)+<span class="built_in">max</span>(disy-leny/<span class="number">2</span>,<span class="number">0.0</span>)*<span class="built_in">max</span>(disy-leny/<span class="number">2</span>,<span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">return</span> dis&lt;=radius*radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><p><a href="https://www.zhihu.com/question/24251545" target="_blank" rel="noopener">一个很经典的解法</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">checkOverlap</span><span class="params">(<span class="keyword">int</span> radius,<span class="keyword">int</span> x_center,<span class="keyword">int</span> y_center,<span class="keyword">int</span> XI, Int y1, <span class="keyword">int</span> X2, <span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a =<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">max</span>(X1-x_center, x_center -X2));</span><br><span class="line">	<span class="keyword">int</span> b= <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">max</span>(y1-y_center, y_center -y2));</span><br><span class="line">	<span class="keyword">return</span> a*a+b*b&lt;=radius*radius;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="4-做菜顺序"><a href="#4-做菜顺序" class="headerlink" title="4. 做菜顺序"></a>4. 做菜顺序</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个厨师收集了他 <code>n</code> 道菜的满意程度 <code>satisfaction</code> ，这个厨师做出每道菜的时间都是 1 单位时间。</p>
<p>一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是 <code>time[i]</code>*<code>satisfaction[i]</code> 。</p>
<p>请你返回做完所有菜 「喜爱时间」总和的最大值为多少。</p>
<p>你可以按 <strong>任意</strong> 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。</p>
<h4 id="示例-1：-3"><a href="#示例-1：-3" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：satisfaction &#x3D; [-1,-8,0,5,-9]</span><br><span class="line">输出：14</span><br><span class="line">解释：去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1*1 + 0*2 + 5*3 &#x3D; 14) 。每道菜都需要花费 1 单位时间完成。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：-3"><a href="#示例-2：-3" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：satisfaction &#x3D; [4,3,2]</span><br><span class="line">输出：20</span><br><span class="line">解释：按照原来顺序相反的时间做菜 (2*1 + 3*2 + 4*3 &#x3D; 20)</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：-3"><a href="#示例-3：-3" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：satisfaction &#x3D; [-1,-4,-5]</span><br><span class="line">输出：0</span><br><span class="line">解释：大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4：-3"><a href="#示例-4：-3" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：satisfaction &#x3D; [-2,5,-1,0,3,-3]</span><br><span class="line">输出：35</span><br></pre></td></tr></table></figure>

<h4 id="提示：-1"><a href="#提示：-1" class="headerlink" title="提示："></a><strong>提示：</strong></h4><ul>
<li><code>n == satisfaction.length</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>-10^3 &lt;= satisfaction[i] &lt;= 10^3</code></li>
</ul>
<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>首先对满意度排序，满意度越大的菜方法放到后边越好</li>
<li>首先把满意度为正的菜的序号拿出来；</li>
<li>然后逐步放进满意度为负的菜；一直到总体满意度下降为止；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfaction</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; satisfaction)</span> </span>&#123;</span><br><span class="line">        sort(satisfaction.<span class="built_in">begin</span>(),satisfaction.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> maxT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;satisfaction.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(satisfaction[i]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = pos;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = Compute(satisfaction,j);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;temp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;maxT)</span><br><span class="line">                maxT = temp;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> maxT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Compute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; satisfaction,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos;i&lt;satisfaction.<span class="built_in">size</span>();i++)</span><br><span class="line">            sum += satisfaction[i]* (++c);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM 岗位求职与简历书写</title>
    <url>/2020/04/04/2020-04-04-SLAM-CV/</url>
    <content><![CDATA[<p>本文学习自B站计算机视觉Life的<a href="https://www.bilibili.com/video/BV1mE411t7rT?from=search&seid=15622956175563291600" target="_blank" rel="noopener">如何写简历</a>。</p>
<a id="more"></a>

<h2 id="当前求职背景怎么样"><a href="#当前求职背景怎么样" class="headerlink" title="当前求职背景怎么样"></a>当前求职背景怎么样</h2><p>2019计算机直觉算法岗的求职情况为：</p>
<ol>
<li>候选人数很多，优秀者极少</li>
<li>找工作不仅需要实力，也需要运气</li>
</ol>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>贸易战影响：华为、海康、大华、商汤、旷视、依图、讯飞。</li>
<li>宏观经济下行：裁员潮商业落地困难大量其他行业转行到AI人才成本高</li>
<li>视觉算法的未来依然前途光明（智能手机、无人汽车、机器人、无人机等)。</li>
</ul>
<h2 id="简历内容怎么写"><a href="#简历内容怎么写" class="headerlink" title="简历内容怎么写"></a>简历内容怎么写</h2><h4 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h4><p>姓名、电话、邮箱（尽量用edu结尾的邮箱）、Github、博客、个人网站等</p>
<p>Github主页最好展示自己最有含金量的工作。</p>
<p>个人网站：自己、项目、论文、荣誉、生活博客</p>
<h4 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h4><p>从本科开始，包括时间、专业、成绩排名；</p>
<p>本科学校211以上就没问题了</p>
<p>相关课程：图像处理；模式识别啥的；参加过的培训；</p>
<h4 id="相关科研项目经历"><a href="#相关科研项目经历" class="headerlink" title="相关科研项目经历"></a>相关科研项目经历</h4><p>从最后学历开始，最重要的写前面。条理要清晰（背景、原理、结果）、用词要准确。</p>
<p>项目实现细节，成果（指标、论文、专利）。</p>
<p>可以放一个直观的研究成果展示，项目主页。</p>
<p>好的实习、竞赛、科研交流经历：简洁、突出结果。、行业知名公司</p>
<p>行业知名竞赛：Kitti，Kaggle，天池</p>
<h4 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h4><p>提到的方向尽量对口</p>
<p>内容：编程、奖学金、竞赛获奖、论文</p>
<p>语言得体不要夸大：精通C++，算法掌握程度</p>
<p>量化一下技能结果，比如国家励志奖学金、Kaggle比赛（3/1000）、ACM竞赛、CVPR论文（状态、几座、创新点、细节）</p>
<h4 id="什么是不需要的"><a href="#什么是不需要的" class="headerlink" title="什么是不需要的"></a>什么是不需要的</h4><ul>
<li><p>个人评价：没有区分度</p>
</li>
<li><p>社会活动经历、兴趣爱好、照片</p>
</li>
</ul>
<h2 id="其它注意事项"><a href="#其它注意事项" class="headerlink" title="其它注意事项"></a>其它注意事项</h2><ul>
<li><p>简历有很多格式格式：pdf，Word，Wps等，最好用pdf格式。</p>
</li>
<li><p>可以针对性地准备几份简历；</p>
</li>
<li><p>尽可能了解你投递的公司、岗位。（新闻，内部员工等途径）</p>
</li>
<li><p>可以根据不同公司、不同岗位调整简历。</p>
</li>
</ul>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ol>
<li>重视数学、编程；</li>
<li>传统图像处理、计算机视觉算法不可忽视；</li>
<li>挖掘底层技术原理，知其所以然；</li>
<li>注重CV领域和其它方向结合；</li>
<li>关注产品落地</li>
<li>越是站在浪潮之巅，越要保持清醒头脑</li>
</ol>
<h2 id="求职经历与心路历程"><a href="#求职经历与心路历程" class="headerlink" title="求职经历与心路历程"></a>求职经历与心路历程</h2><p>可能有SLAM岗位的公司：</p>
<p>企业：地平线、商汤、网易(3D视觉算法工程师)、百度、阿里菜鸟、海康威视、旷视、百度、大疆、大华、360、OPPO、奥比中光、臻迪、华为、图森未来、驭势科技、地平线、联想、滴滴、美团、优必选、博世、小马智行、纵目科技、步飞科技、宽凳科技爱笔科技、高仙、托斯达、瓜子二手车、速腾聚创、博智林、亿嘉和、四维图新、极智嘉、九阳、虹软（3维重建）。</p>
<p>其它：九号机器人、 Auto、银星智能、中车、徐工</p>
<p>研究所比较稳定</p>
<p>薪资：25w+</p>
<p><img src="/2020/04/04/2020-04-04-SLAM-CV/image-20200404020123103.png" alt="image-20200404020123103"></p>
<h2 id="需要准备的东西"><a href="#需要准备的东西" class="headerlink" title="需要准备的东西"></a>需要准备的东西</h2><ol>
<li>刷题（剑指offer(面试)、LeeCode（笔试）、牛客(笔试)）</li>
<li>简历</li>
<li>往届面试题 </li>
<li>项目情况压缩包及简介（VINS初始化/ORB）一定要了解VINS</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>求职</category>
      </categories>
      <tags>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM 岗位求职与简历书写</title>
    <url>/2020/04/04/SLAM%E5%B2%97%E4%BD%8D%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<p>本文学习自B站计算机视觉Life的<a href="https://www.bilibili.com/video/BV1mE411t7rT?from=search&seid=15622956175563291600" target="_blank" rel="noopener">如何写简历</a>。</p>
<a id="more"></a>

<h2 id="当前求职背景怎么样"><a href="#当前求职背景怎么样" class="headerlink" title="当前求职背景怎么样"></a>当前求职背景怎么样</h2><p>2019计算机直觉算法岗的求职情况为：</p>
<ol>
<li>候选人数很多，优秀者极少</li>
<li>找工作不仅需要实力，也需要运气</li>
</ol>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>贸易战影响：华为、海康、大华、商汤、旷视、依图、讯飞。</li>
<li>宏观经济下行：裁员潮商业落地困难大量其他行业转行到AI人才成本高</li>
<li>视觉算法的未来依然前途光明（智能手机、无人汽车、机器人、无人机等)。</li>
</ul>
<h2 id="简历内容怎么写"><a href="#简历内容怎么写" class="headerlink" title="简历内容怎么写"></a>简历内容怎么写</h2><h4 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h4><p>姓名、电话、邮箱（尽量用edu结尾的邮箱）、Github、博客、个人网站等</p>
<p>Github主页最好展示自己最有含金量的工作。</p>
<p>个人网站：自己、项目、论文、荣誉、生活博客</p>
<h4 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h4><p>从本科开始，包括时间、专业、成绩排名；</p>
<p>本科学校211以上就没问题了</p>
<p>相关课程：图像处理；模式识别啥的；参加过的培训；</p>
<h4 id="相关科研项目经历"><a href="#相关科研项目经历" class="headerlink" title="相关科研项目经历"></a>相关科研项目经历</h4><p>从最后学历开始，最重要的写前面。条理要清晰（背景、原理、结果）、用词要准确。</p>
<p>项目实现细节，成果（指标、论文、专利）。</p>
<p>可以放一个直观的研究成果展示，项目主页。</p>
<p>好的实习、竞赛、科研交流经历：简洁、突出结果。、行业知名公司</p>
<p>行业知名竞赛：Kitti，Kaggle，天池</p>
<h4 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h4><p>提到的方向尽量对口</p>
<p>内容：编程、奖学金、竞赛获奖、论文</p>
<p>语言得体不要夸大：精通C++，算法掌握程度</p>
<p>量化一下技能结果，比如国家励志奖学金、Kaggle比赛（3/1000）、ACM竞赛、CVPR论文（状态、几座、创新点、细节）</p>
<h4 id="什么是不需要的"><a href="#什么是不需要的" class="headerlink" title="什么是不需要的"></a>什么是不需要的</h4><ul>
<li><p>个人评价：没有区分度</p>
</li>
<li><p>社会活动经历、兴趣爱好、照片</p>
</li>
</ul>
<h2 id="其它注意事项"><a href="#其它注意事项" class="headerlink" title="其它注意事项"></a>其它注意事项</h2><ul>
<li><p>简历有很多格式格式：pdf，Word，Wps等，最好用pdf格式。</p>
</li>
<li><p>可以针对性地准备几份简历；</p>
</li>
<li><p>尽可能了解你投递的公司、岗位。（新闻，内部员工等途径）</p>
</li>
<li><p>可以根据不同公司、不同岗位调整简历。</p>
</li>
</ul>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ol>
<li>重视数学、编程；</li>
<li>传统图像处理、计算机视觉算法不可忽视；</li>
<li>挖掘底层技术原理，知其所以然；</li>
<li>注重CV领域和其它方向结合；</li>
<li>关注产品落地</li>
<li>越是站在浪潮之巅，越要保持清醒头脑</li>
</ol>
<h2 id="求职经历与心路历程"><a href="#求职经历与心路历程" class="headerlink" title="求职经历与心路历程"></a>求职经历与心路历程</h2><p>可能有SLAM岗位的公司：</p>
<p>企业：地平线、商汤、网易(3D视觉算法工程师)、百度、阿里菜鸟、海康威视、旷视、百度、大疆、大华、360、OPPO、奥比中光、臻迪、华为、图森未来、驭势科技、地平线、联想、滴滴、美团、优必选、博世、小马智行、纵目科技、步飞科技、宽凳科技爱笔科技、高仙、托斯达、瓜子二手车、速腾聚创、博智林、亿嘉和、四维图新、极智嘉、九阳、虹软（3维重建）。</p>
<p>其它：九号机器人、 Auto、银星智能、中车、徐工</p>
<p>研究所比较稳定</p>
<p>薪资：25w+</p>
<p><img src="/2020/04/04/SLAM%E5%B2%97%E4%BD%8D%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C/image-20200404020123103.png" alt="image-20200404020123103"></p>
<h2 id="需要准备的东西"><a href="#需要准备的东西" class="headerlink" title="需要准备的东西"></a>需要准备的东西</h2><ol>
<li>刷题（剑指offer(面试)、LeeCode（笔试）、牛客(笔试)）</li>
<li>简历</li>
<li>往届面试题 </li>
<li>项目情况压缩包及简介（VINS初始化/ORB）一定要了解VINS</li>
</ol>
]]></content>
      <categories>
        <category>求职</category>
      </categories>
      <tags>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-3~6</title>
    <url>/2020/04/03/2020-04-03-LeetCodeCheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<p>日打卡题目如下：</p>
<p>最近几日打卡题目如下：</p>
<ol>
<li>字符串转整数（4.3）</li>
<li>接雨水（4.4）</li>
<li>LFU缓存（4.5）</li>
<li>编辑距离（4.6）</li>
</ol>
<a id="more"></a>

<h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<ul>
<li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li>
<li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li>
<li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</li>
</ul>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</li>
<li>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。 </li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4:"></a><strong>示例 4:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure>

<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5:"></a><strong>示例 5:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>本需要测试很多的边界条件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">bit</span> =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">' '</span>&amp;&amp;<span class="built_in">bit</span>==<span class="number">0</span>&amp;&amp;!count)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">' '</span>&amp;&amp;(<span class="built_in">bit</span>||count))</span><br><span class="line">                <span class="keyword">return</span> res*flag;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((str[i]==<span class="string">'+'</span>||str[i]==<span class="string">'-'</span>)&amp;&amp;!<span class="built_in">bit</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = str[i]==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'0'</span>&lt;=str[i]&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">bit</span>++;</span><br><span class="line">                res=res*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">                res = flag == <span class="number">1</span> ? <span class="built_in">min</span>(res, (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MAX) : <span class="built_in">min</span>(res, -(<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> res*flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 <strong>感谢 Marcos</strong> 贡献此图。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>从左扫一遍，从右扫一遍，取最小值，减去原图；</p>
<p><img src="https://pic.leetcode-cn.com/53ab7a66023039ed4dce42b709b4997d2ba0089077912d39a0b31d3572a55d0b-trapping_rain_water.png" alt="trapping_rain_water.png"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!s) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="built_in">height</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lr</span><span class="params">(s,M)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            lr[i] = <span class="built_in">max</span>(M , <span class="built_in">height</span>[i]);</span><br><span class="line">            M = lr[i];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        M = <span class="built_in">height</span>[s<span class="number">-1</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rl</span><span class="params">(s,M)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s<span class="number">-1</span>; i&gt;=<span class="number">0</span> ; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            rl[i] = <span class="built_in">max</span>(M,<span class="built_in">height</span>[i]);</span><br><span class="line">            M = rl[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s; i++)</span><br><span class="line">            res+=<span class="built_in">min</span>(lr[i],rl[i])-<span class="built_in">height</span>[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="460-LFU缓存"><a href="#460-LFU缓存" class="headerlink" title="460. LFU缓存"></a><a href="https://leetcode-cn.com/problems/lfu-cache/" target="_blank" rel="noopener">460. LFU缓存</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>请你为 <a href="https://baike.baidu.com/item/缓存算法" target="_blank" rel="noopener">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。它应该支持以下操作：<code>get</code> 和 <code>put</code>。</p>
<ul>
<li><code>get(key)</code> - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。</li>
<li><code>put(key, value)</code> - 如果键不存在，请设置或插入值。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近</strong> 最少使用的键。</li>
</ul>
<p>「项的使用次数」就是自插入该项以来对其调用 <code>get</code> 和 <code>put</code> 函数的次数之和。使用次数会在对应项被移除后置为 0 。 </p>
<p><strong>进阶：</strong><br>你是否可以在 <strong>O(1)</strong> 时间复杂度内执行两项操作？ </p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LFUCache cache &#x3D; new LFUCache( 2 &#x2F;* capacity (缓存容量) *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; 去除 key 2</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到key 2)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; 返回 3</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; 去除 key 1</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到 key 1)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; 返回 3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a>思路和算法</h4><p>我们定义两个哈希表，第一个 freq_table 以频率 freq 为索引，每个索引存放一个双向链表，这个链表里存放所有使用频率为 freq 的缓存，缓存里存放三个信息，分别为键 key，值 value，以及使用频率 freq。第二个 key_table 以键值 key 为索引，每个索引存放对应缓存在 freq_table 中链表里的内存地址，这样我们就能利用两个哈希表来使得两个操作的时间复杂度均为 O(1)O(1)。同时需要记录一个当前缓存最少使用的频率 minFreq，这是为了删除操作服务的。</p>
<p>对于 get(key) 操作，我们能通过索引 key 在 key_table 中找到缓存在 freq_table 中的链表的内存地址，如果不存在直接返回 -1，否则我们能获取到对应缓存的相关信息，这样我们就能知道缓存的键值还有使用频率，直接返回 key 对应的值即可。</p>
<p>但是我们注意到 get 操作后这个缓存的使用频率加一了，所以我们需要更新缓存在哈希表 freq_table 中的位置。已知这个缓存的键 key，值 value，以及使用频率 freq，那么该缓存应该存放到 freq_table 中 freq + 1 索引下的链表中。所以我们在当前链表中 <code>O(1)</code> 删除该缓存对应的节点，根据情况更新 minFreq 值，然后将其O(1)O(1) 插入到 freq + 1 索引下的链表头完成更新。这其中的操作复杂度均为 <code>O(1)</code>。你可能会疑惑更新的时候为什么是插入到链表头，这其实是为了保证缓存在当前链表中从链表头到链表尾的插入时间是有序的，为下面的删除操作服务。</p>
<p>对于 <code>put(key, value)</code> 操作，我们先通过索引 <code>key</code>在 <code>key_table</code> 中查看是否有对应的缓存，如果有的话，其实操作等价于 <code>get(key)</code>操作，唯一的区别就是我们需要将当前的缓存里的值更新为 <code>value</code>。如果没有的话，相当于是新加入的缓存，如果缓存已经到达容量，需要先删除最近最少使用的缓存，再进行插入。</p>
<p>先考虑插入，由于是新插入的，所以缓存的使用频率一定是 1，所以我们将缓存的信息插入到 <code>freq_table</code> 中 1 索引下的列表头即可，同时更新 <code>key_table[key]</code> 的信息，以及更新 <code>minFreq = 1</code>。</p>
<p>那么剩下的就是删除操作了，由于我们实时维护了 <code>minFreq</code>，所以我们能够知道 <code>freq_table</code> 里目前最少使用频率的索引，同时因为我们保证了链表中从链表头到链表尾的插入时间是有序的，所以 <code>freq_table[minFreq]</code> 的链表中链表尾的节点即为使用频率最小且插入时间最早的节点，我们删除它同时根据情况更新 <code>minFreq</code> ，整个时间复杂度均为 <code>O(1)</code>。</p>
<p>源代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存的节点信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, val, freq;</span><br><span class="line">    Node(<span class="keyword">int</span> _key,<span class="keyword">int</span> _val,<span class="keyword">int</span> _freq): key(_key), val(_val), freq(_freq)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> minfreq, capacity;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;Node&gt;::iterator&gt; key_table;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;Node&gt;&gt; freq_table;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> _capacity) &#123;</span><br><span class="line">        minfreq = <span class="number">0</span>;</span><br><span class="line">        capacity = _capacity;</span><br><span class="line">        key_table.<span class="built_in">clear</span>();</span><br><span class="line">        freq_table.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">list</span>&lt;Node&gt;::iterator node = it -&gt; second;</span><br><span class="line">        <span class="keyword">int</span> val = node -&gt; val, freq = node -&gt; freq;</span><br><span class="line">        freq_table[freq].erase(node);</span><br><span class="line">        <span class="comment">// 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq</span></span><br><span class="line">        <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            freq_table.erase(freq);</span><br><span class="line">            <span class="keyword">if</span> (minfreq == freq) minfreq += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入到 freq + 1 中</span></span><br><span class="line">        freq_table[freq + <span class="number">1</span>].push_front(Node(key, val, freq + <span class="number">1</span>));</span><br><span class="line">        key_table[key] = freq_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 缓存已满，需要进行删除操作</span></span><br><span class="line">            <span class="keyword">if</span> (key_table.<span class="built_in">size</span>() == capacity) &#123;</span><br><span class="line">                <span class="comment">// 通过 minFreq 拿到 freq_table[minFreq] 链表的末尾节点</span></span><br><span class="line">                <span class="keyword">auto</span> it2 = freq_table[minfreq].back();</span><br><span class="line">                key_table.erase(it2.key);</span><br><span class="line">                freq_table[minfreq].pop_back();</span><br><span class="line">                <span class="keyword">if</span> (freq_table[minfreq].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    freq_table.erase(minfreq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            freq_table[<span class="number">1</span>].push_front(Node(key, value, <span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">            minfreq = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 与 get 操作基本一致，除了需要更新缓存的值</span></span><br><span class="line">            <span class="built_in">list</span>&lt;Node&gt;::iterator node = it -&gt; second;</span><br><span class="line">            <span class="keyword">int</span> freq = node -&gt; freq;</span><br><span class="line">            freq_table[freq].erase(node);</span><br><span class="line">            <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                freq_table.erase(freq);</span><br><span class="line">                <span class="keyword">if</span> (minfreq == freq) minfreq += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            freq_table[freq + <span class="number">1</span>].push_front(Node(key, value, freq + <span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个单词 <em>word1</em> 和 <em>word2*，请你计算出将 *word1</em> 转换成 <em>word2</em> 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们可以对任意一个单词进行三种操作：</p>
<ul>
<li>插入一个字符；</li>
<li>删除一个字符；</li>
<li>替换一个字符。</li>
</ul>
<p>题目给定了两个单词，设为 A 和 B，这样我们就能够六种操作方法。</p>
<p>但我们可以发现，如果我们有单词 A 和单词 B：</p>
<ul>
<li>对单词 A 删除一个字符和对单词 B 插入一个字符是等价的。例如当单词 A 为 doge，单词 B 为 dog 时，我们既可以删除单词 A 的最后一个字符 e，得到相同的 dog，也可以在单词 B 末尾添加一个字符 e，得到相同的 doge；</li>
<li>同理，对单词 B 删除一个字符和对单词 A 插入一个字符也是等价的；</li>
<li>对单词 A 替换一个字符和对单词 B 替换一个字符是等价的。例如当单词 A 为 bat，单词 B 为 cat 时，我们修改单词 A 的第一个字母 b -&gt; c，和修改单词 B 的第一个字母 c -&gt; b 是等价的。</li>
</ul>
<p>这样以来，本质不同的操作实际上只有三种：</p>
<ul>
<li><p>在单词 A 中插入一个字符；</p>
</li>
<li><p>在单词 B 中插入一个字符；</p>
</li>
<li><p>修改单词 A 的一个字符。</p>
</li>
</ul>
<p>这样以来，我们就可以把原问题转化为规模较小的子问题。我们用 A = horse，B = ros 作为例子，来看一看是如何把这个问题转化为规模较小的若干子问题的。</p>
<ul>
<li>在单词 A 中插入一个字符：如果我们知道 horse 到 ro 的编辑距离为 a，那么显然 horse 到 ros 的编辑距离不会超过 a + 1。这是因为我们可以在 a 次操作后将 horse 和 ro 变为相同的字符串，只需要额外的 1 次操作，在单词 A 的末尾添加字符 s，就能在 a + 1 次操作后将 horse 和 ro 变为相同的字符串；</li>
<li>在单词 B 中插入一个字符：如果我们知道 hors 到 ros 的编辑距离为 b，那么显然 horse 到 ros 的编辑距离不会超过 b + 1，原因同上；</li>
<li>修改单词 A 的一个字符：如果我们知道 hors 到 ro 的编辑距离为 c，那么显然 horse 到 ros 的编辑距离不会超过 c + 1，原因同上。</li>
</ul>
<p>那么从 horse 变成 ros 的编辑距离应该为 min(a + 1, b + 1, c + 1)。</p>
<p>注意：为什么我们总是在单词 A 和 B 的末尾插入或者修改字符，能不能在其它的地方进行操作呢？答案是可以的，但是我们知道，操作的顺序是不影响最终的结果的。例如对于单词 cat，我们希望在 c 和 a 之间添加字符 d 并且将字符 t 修改为字符 b，那么这两个操作无论为什么顺序，都会得到最终的结果 cdab。</p>
<p>你可能觉得 horse 到 ro 这个问题也很难解决。但是没关系，我们可以继续用上面的方法拆分这个问题，对于这个问题拆分出来的所有子问题，我们也可以继续拆分，直到：</p>
<p>字符串 A 为空，如从 转换到 ro，显然编辑距离为字符串 B 的长度，这里是 2；</p>
<p>字符串 B 为空，如从 horse 转换到 ，显然编辑距离为字符串 A 的长度，这里是 5。</p>
<p>因此，我们就可以使用动态规划来解决这个问题了。我们用 D[i][j] 表示 A 的前 i 个字母和 B 的前 j 个字母之间的编辑距离。</p>
<p>如上所述，当我们获得 D[i][j-1]，D[i-1][j] 和 D[i-1][j-1] 的值之后就可以计算出 D[i][j]。</p>
<p>D[i][j-1] 为 A 的前 i 个字符和 B 的前 j - 1 个字符编辑距离的子问题。即对于 B 的第 j 个字符，我们在 A 的末尾添加了一个相同的字符，那么 D[i][j] 最小可以为 D[i][j-1] + 1；</p>
<p>D[i-1][j] 为 A 的前 i - 1 个字符和 B 的前 j 个字符编辑距离的子问题。即对于 A 的第 i 个字符，我们在 B 的末尾添加了一个相同的字符，那么 D[i][j] 最小可以为 D[i-1][j] + 1；</p>
<p>D[i-1][j-1] 为 A 前 i - 1 个字符和 B 的前 j - 1 个字符编辑距离的子问题。即对于 B 的第 j 个字符，我们修改 A 的第 i 个字符使它们相同，那么 D[i][j] 最小可以为 D[i-1][j-1] + 1。特别地，如果 A 的第 i 个字符和 B 的第 j 个字符原本就相同，那么我们实际上不需要进行修改操作。在这种情况下，D[i][j] 最小可以为 D[i-1][j-1]。</p>
<p>那么我们可以写出如下的状态转移方程：</p>
<p>若 A 和 B 的最后一个字母相同：<br>$$<br>\begin{aligned} D[i][j] &amp;= \min(D[i][j - 1] + 1, D[i - 1][j]+1, D[i - 1][j - 1])\ &amp;= 1 + \min(D[i][j - 1], D[i - 1][j], D[i - 1][j - 1] - 1) \end{aligned}<br>$$<br>若 A 和 B 的最后一个字母不同：<br>$$<br>D[i][j] = 1 + \min(D[i][j - 1], D[i - 1][j], D[i - 1][j - 1])<br>$$<br>所以每一步结果都将基于上一步的计算结果，示意如下：</p>
<p><img src="https://pic.leetcode-cn.com/3241789f2634b72b917d769a92d4f6e38c341833247391fb1b45eb0441fe5cd2-72_fig2.PNG" alt="72_fig2.PNG"></p>
<p>对于边界情况，一个空串和一个非空串的编辑距离为 <code>D[i][0] = i</code> 和 <code>D[0][j] = j</code>，<code>D[i][0]</code> 相当于对 word1 执行 i 次删除操作，<code>D[0][j]</code> 相当于对 word1执行 j 次插入操作。</p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.length();</span><br><span class="line">        <span class="keyword">int</span> m = word2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有一个字符串为空串</span></span><br><span class="line">        <span class="keyword">if</span> (n * m == <span class="number">0</span>) <span class="keyword">return</span> n + m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DP 数组</span></span><br><span class="line">        <span class="keyword">int</span> D[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界状态初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            D[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            D[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> left = D[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> down = D[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> left_down = D[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]) left_down += <span class="number">1</span>;</span><br><span class="line">                D[i][j] = <span class="built_in">min</span>(left, <span class="built_in">min</span>(down, left_down));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> D[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛182</title>
    <url>/2020/04/02/2020-03-28-LeetCode-Contest182/</url>
    <content><![CDATA[<p>LeeCode第182场周赛题目如下:</p>
<ol>
<li>找出数组中的幸运数</li>
<li>统计作战单位数</li>
<li>设计地铁系统t</li>
<li>找到所有好字符串</li>
</ol>
<a id="more"></a>

<h2 id="1394-找出数组中的幸运数"><a href="#1394-找出数组中的幸运数" class="headerlink" title="1394. 找出数组中的幸运数"></a>1394. 找出数组中的幸运数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。</p>
<p>给你一个整数数组 <code>arr</code>，请你从中找出并返回一个幸运数。</p>
<ul>
<li>如果数组中存在多个幸运数，只需返回 <strong>最大</strong> 的那个。</li>
<li>如果数组中不含幸运数，则返回 <strong>-1</strong> 。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,2,3,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,2,3,3,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a><strong>示例 3</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,2,2,3,3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：数组中不存在幸运数。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a><strong>示例 4</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [5]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a><strong>示例 5</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 500</code></li>
<li><code>1 &lt;= arr[i] &lt;= 500</code></li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLucky</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:arr)</span><br><span class="line">            <span class="built_in">set</span>[n]++;</span><br><span class="line">        <span class="keyword">int</span> maxnum = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">        <span class="keyword">for</span>(iter = <span class="built_in">set</span>.<span class="built_in">begin</span>();iter!=<span class="built_in">set</span>.<span class="built_in">end</span>();iter++)</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;first==iter-&gt;second)</span><br><span class="line">                maxnum = <span class="built_in">max</span>(maxnum,iter-&gt;first);</span><br><span class="line">        <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1395-统计作战单位数"><a href="#1395-统计作战单位数" class="headerlink" title="1395. 统计作战单位数"></a>1395. 统计作战单位数</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p> <code>n</code> 名士兵站成一排。每个士兵都有一个 <strong>独一无二</strong> 的评分 <code>rating</code> 。</p>
<p>每 <strong>3</strong> 个士兵可以组成一个作战单位，分组规则如下：</p>
<ul>
<li>从队伍中选出下标分别为 <code>i</code>、<code>j</code>、<code>k</code> 的 3 名士兵，他们的评分分别为 <code>rating[i]</code>、<code>rating[j]</code>、<code>rating[k]</code></li>
<li>作战单位需满足： <code>rating[i] &lt; rating[j] &lt; rating[k]</code> 或者 <code>rating[i] &gt; rating[j] &gt; rating[k]</code> ，其中 <code>0 &lt;= i &lt; j &lt; k &lt; n</code></li>
</ul>
<p>请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。</p>
<p><strong>示例 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rating &#x3D; [2,5,3,4,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rating &#x3D; [2,1,3]</span><br><span class="line">输出：0</span><br><span class="line">解释：根据题目条件，我们无法组建作战单位。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rating &#x3D; [1,2,3,4]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTeams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rating)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rating.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>;<span class="comment">// 顺序增大的个数</span></span><br><span class="line">        <span class="keyword">int</span> num2=<span class="number">0</span>;<span class="comment">// 顺序减小的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;n;k++)</span><br><span class="line">                    <span class="keyword">if</span>(rating[i]&lt;rating[j]&amp;&amp;rating[j]&lt;rating[k])</span><br><span class="line">                        num1++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(rating[i]&gt;rating[j]&amp;&amp;rating[j]&gt;rating[k])</span><br><span class="line">                        num2++;</span><br><span class="line">        <span class="keyword">return</span> num1+num2;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1396-设计地铁系统"><a href="#1396-设计地铁系统" class="headerlink" title="1396. 设计地铁系统"></a>1396. 设计地铁系统</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>请你实现一个类 <code>UndergroundSystem</code> ，它支持以下 3 种方法：</p>
<p>1.<code>checkIn(int id, string stationName, int t)</code></p>
<ul>
<li>编号为 <code>id</code> 的乘客在 <code>t</code> 时刻进入地铁站 <code>stationName</code> 。</li>
<li>一个乘客在同一时间只能在一个地铁站进入或者离开。</li>
</ul>
<p>2.<code>checkOut(int id, string stationName, int t)</code></p>
<ul>
<li>编号为 <code>id</code> 的乘客在 <code>t</code> 时刻离开地铁站 <code>stationName</code> 。</li>
</ul>
<p>3.<code>getAverageTime(string startStation, string endStation)</code> </p>
<ul>
<li>返回从地铁站 <code>startStation</code> 到地铁站 <code>endStation</code> 的平均花费时间。</li>
<li>平均时间计算的行程包括当前为止所有从 <code>startStation</code> <strong>直接到达</strong> <code>endStation</code> 的行程。</li>
<li>调用 <code>getAverageTime</code> 时，询问的路线至少包含一趟行程。</li>
</ul>
<p>你可以假设所有对 <code>checkIn</code> 和 <code>checkOut</code> 的调用都是符合逻辑的。也就是说，如果一个顾客在 <strong>t1</strong> 时刻到达某个地铁站，那么他离开的时间 <strong>t2</strong> 一定满足 <strong>t2 &gt; t1</strong> 。所有的事件都按时间顺序给出。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;UndergroundSystem&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;,&quot;getAverageTime&quot;,&quot;checkIn&quot;,&quot;getAverageTime&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;]</span><br><span class="line">[[],[45,&quot;Leyton&quot;,3],[32,&quot;Paradise&quot;,8],[27,&quot;Leyton&quot;,10],[45,&quot;Waterloo&quot;,15],[27,&quot;Waterloo&quot;,20],[32,&quot;Cambridge&quot;,22],[&quot;Paradise&quot;,&quot;Cambridge&quot;],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Leyton&quot;,24],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Waterloo&quot;,38],[&quot;Leyton&quot;,&quot;Waterloo&quot;]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,null,null,null,14.0,11.0,null,11.0,null,12.0]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">UndergroundSystem undergroundSystem &#x3D; new UndergroundSystem();</span><br><span class="line">undergroundSystem.checkIn(45, &quot;Leyton&quot;, 3);</span><br><span class="line">undergroundSystem.checkIn(32, &quot;Paradise&quot;, 8);</span><br><span class="line">undergroundSystem.checkIn(27, &quot;Leyton&quot;, 10);</span><br><span class="line">undergroundSystem.checkOut(45, &quot;Waterloo&quot;, 15);</span><br><span class="line">undergroundSystem.checkOut(27, &quot;Waterloo&quot;, 20);</span><br><span class="line">undergroundSystem.checkOut(32, &quot;Cambridge&quot;, 22);</span><br><span class="line">undergroundSystem.getAverageTime(&quot;Paradise&quot;, &quot;Cambridge&quot;);       &#x2F;&#x2F; 返回 14.0。从 &quot;Paradise&quot;（时刻 8）到 &quot;Cambridge&quot;(时刻 22)的行程只有一趟</span><br><span class="line">undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);          &#x2F;&#x2F; 返回 11.0。总共有 2 躺从 &quot;Leyton&quot; 到 &quot;Waterloo&quot; 的行程，编号为 id&#x3D;45 的乘客出发于 time&#x3D;3 到达于 time&#x3D;15，编号为 id&#x3D;27 的乘客于 time&#x3D;10 出发于 time&#x3D;20 到达。所以平均时间为 ( (15-3) + (20-10) ) &#x2F; 2 &#x3D; 11.0</span><br><span class="line">undergroundSystem.checkIn(10, &quot;Leyton&quot;, 24);</span><br><span class="line">undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);          &#x2F;&#x2F; 返回 11.0</span><br><span class="line">undergroundSystem.checkOut(10, &quot;Waterloo&quot;, 38);</span><br><span class="line">undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);          &#x2F;&#x2F; 返回 12.0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>总共最多有 <code>20000</code> 次操作。</li>
<li><code>1 &lt;= id, t &lt;= 10^6</code></li>
<li>所有的字符串包含大写字母，小写字母和数字。</li>
<li><code>1 &lt;= stationName.length &lt;= 10</code></li>
<li>与标准答案误差在 <code>10^-5</code> 以内的结果都视为正确结果。</li>
</ul>
<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用 checkRecord 根据 id 来保存上车 车站名字 和 时间<br>在下车车站，把乘车时间计算出来，按两个 车站名字 保存起来，同时还要保存 乘车次数<br>取得平均时间时，只需要查询两个车站，得到总时间，和总次数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergroundSystem</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; checkRecord;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;&gt; count;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UndergroundSystem() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkIn</span><span class="params">(<span class="keyword">int</span> id, <span class="built_in">string</span> stationName, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        checkRecord[id] = &#123; stationName, t &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkOut</span><span class="params">(<span class="keyword">int</span> id, <span class="built_in">string</span> stationName, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> name = getStationName(checkRecord[id].first, stationName);</span><br><span class="line">        t -= checkRecord[id].second;</span><br><span class="line">        count[name].first += (<span class="keyword">double</span>)t;</span><br><span class="line">        count[name].second += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAverageTime</span><span class="params">(<span class="built_in">string</span> startStation, <span class="built_in">string</span> endStation)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> name = getStationName(startStation, endStation);</span><br><span class="line">        <span class="keyword">double</span> ans = count[name].first / (<span class="keyword">double</span>)count[name].second;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getStationName</span><span class="params">(<span class="built_in">string</span> startStation, <span class="built_in">string</span> endStation)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startStation + endStation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="1397-找到所有好字符串"><a href="#1397-找到所有好字符串" class="headerlink" title="1397. 找到所有好字符串"></a>1397. 找到所有好字符串</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个长度为 <code>n</code> 的字符串 <code>s1</code> 和 <code>s2</code> ，以及一个字符串 <code>evil</code> 。请你返回 <strong>好字符串</strong> 的数目。</p>
<p><strong>好字符串</strong> 的定义为：它的长度为 <code>n</code> ，字典序大于等于 <code>s1</code> ，字典序小于等于 <code>s2</code> ，且不包含 <code>evil</code> 为子字符串。</p>
<p>由于答案可能很大，请你返回答案对 10^9 + 7 取余的结果。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, s1 &#x3D; &quot;aa&quot;, s2 &#x3D; &quot;da&quot;, evil &#x3D; &quot;b&quot;</span><br><span class="line">输出：51 </span><br><span class="line">解释：总共有 25 个以 &#39;a&#39; 开头的好字符串：&quot;aa&quot;，&quot;ac&quot;，&quot;ad&quot;，...，&quot;az&quot;。还有 25 个以 &#39;c&#39; 开头的好字符串：&quot;ca&quot;，&quot;cc&quot;，&quot;cd&quot;，...，&quot;cz&quot;。最后，还有一个以 &#39;d&#39; 开头的好字符串：&quot;da&quot;。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 8, s1 &#x3D; &quot;leetcode&quot;, s2 &#x3D; &quot;leetgoes&quot;, evil &#x3D; &quot;leet&quot;</span><br><span class="line">输出：0 </span><br><span class="line">解释：所有字典序大于等于 s1 且小于等于 s2 的字符串都以 evil 字符串 &quot;leet&quot; 开头。所以没有好字符串。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a><strong>示例 3</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, s1 &#x3D; &quot;gx&quot;, s2 &#x3D; &quot;gz&quot;, evil &#x3D; &quot;x&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>s1.length == n</code></li>
<li><code>s2.length == n</code></li>
<li><code>s1 &lt;= s2</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>1 &lt;= evil.length &lt;= 50</code></li>
<li>所有字符串都只包含小写英文字母。</li>
</ul>
<h3 id="其它解法-1"><a href="#其它解法-1" class="headerlink" title="其它解法"></a>其它解法</h3><h4 id="思路数位DP-前缀数组"><a href="#思路数位DP-前缀数组" class="headerlink" title="思路数位DP + 前缀数组"></a>思路数位DP + 前缀数组</h4><p>看到题目，很容易能够想到是动态规划问题来解决，接下来就是定义状态方程，该如何定义？</p>
<p>从题目中我们知道判断某一位的状态取决于前面的字符匹配情况，有三种：</p>
<p>s1为下限，s2为上限<br>s1为下限，s2无限制<br>s1无限制，s2为上限<br>s1和s2均无限制，即可以选任意小写字母<br>这种思想很容易联想到数位DP(数位DP不熟悉的可以查阅下相关资料)，那么在数位DP的基础上我们还要增加一个维度来解决不包含子串问题：</p>
<p>那么增加的维度表示前面已经匹配的evil的长度, 想计算加入当前字符后最长匹配的evil长度是需要使用KMP算法的前缀数组来解决的，如果不是很熟悉这个算法参考下上周周赛的最后一题最长快乐前缀。</p>
<p>因此一个维度表示遍历的索引，一个维度表示当前可选字符的限制，一个维度表示已经匹配的evil的长度，因此三维的状态就可以定义出来了，具体的可以看代码的注释。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findGoodStrings</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">string</span> a, <span class="built_in">string</span> b, <span class="built_in">string</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> en = e.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fa</span><span class="params">(en+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = fa[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i&lt;en; i++, j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; e[j]!=e[i])j=fa[j];</span><br><span class="line">            fa[i+<span class="number">1</span>]=j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> plen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.substr(<span class="number">0</span>, i) == b.substr(<span class="number">0</span>, i))plen = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>, flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;plen; i++, now++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; a[i]!=e[now])&#123;</span><br><span class="line">                now=fa[now];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now==en<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(plen == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sc</span><span class="params">(en, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a[plen]-<span class="string">'a'</span>+<span class="number">1</span>; i&lt;b[plen]-<span class="string">'a'</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> noww = now;</span><br><span class="line">            <span class="keyword">while</span>(noww!=<span class="number">-1</span> &amp;&amp; i+<span class="string">'a'</span>!=e[noww])&#123;</span><br><span class="line">                noww=fa[noww];</span><br><span class="line">            &#125;noww++;</span><br><span class="line">            <span class="keyword">if</span>(noww&lt;en)sc[noww]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nowa = now;</span><br><span class="line">        <span class="keyword">while</span>(nowa!=<span class="number">-1</span> &amp;&amp; a[plen]!=e[nowa])&#123;</span><br><span class="line">            nowa=fa[nowa];</span><br><span class="line">        &#125;nowa++;</span><br><span class="line">        <span class="keyword">int</span> nowb = now;</span><br><span class="line">        <span class="keyword">while</span>(nowb!=<span class="number">-1</span> &amp;&amp; b[plen]!=e[nowb])&#123;</span><br><span class="line">            nowb=fa[nowb];</span><br><span class="line">        &#125;nowb++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=plen+<span class="number">1</span>; p&lt;n; p++)&#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(en, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(nowa&lt;en)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=a[p]-<span class="string">'a'</span>+<span class="number">1</span>; i&lt;<span class="number">26</span>; i++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> noww = nowa;</span><br><span class="line">                    <span class="keyword">while</span>(noww!=<span class="number">-1</span> &amp;&amp; i+<span class="string">'a'</span>!=e[noww])&#123;</span><br><span class="line">                        noww=fa[noww];</span><br><span class="line">                    &#125;noww++;</span><br><span class="line">                    <span class="keyword">if</span>(noww&lt;en)d[noww]++;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(nowb&lt;en)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;b[p]-<span class="string">'a'</span>; i++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> noww = nowb;</span><br><span class="line">                    <span class="keyword">while</span>(noww!=<span class="number">-1</span> &amp;&amp; i+<span class="string">'a'</span>!=e[noww])&#123;</span><br><span class="line">                        noww=fa[noww];</span><br><span class="line">                    &#125;noww++;</span><br><span class="line">                    <span class="keyword">if</span>(noww&lt;en)d[noww]++;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;<span class="number">26</span>; c++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> nn=<span class="number">0</span>; nn&lt;en; nn++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> now = nn;</span><br><span class="line">                    <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; c+<span class="string">'a'</span>!=e[now])&#123;</span><br><span class="line">                        now=fa[now];</span><br><span class="line">                    &#125;now++;</span><br><span class="line">                    <span class="keyword">if</span>(now&lt;en)(d[now]+=sc[nn])%=mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sc=d;</span><br><span class="line">            <span class="keyword">if</span>(nowa&lt;en)&#123;</span><br><span class="line">                <span class="keyword">while</span>(nowa!=<span class="number">-1</span> &amp;&amp; a[p]!=e[nowa])&#123;</span><br><span class="line">                    nowa=fa[nowa];</span><br><span class="line">                &#125;nowa++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nowb&lt;en)&#123;</span><br><span class="line">                <span class="keyword">while</span>(nowb!=<span class="number">-1</span> &amp;&amp; b[p]!=e[nowb])&#123;</span><br><span class="line">                    nowb=fa[nowb];</span><br><span class="line">                &#125;nowb++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;en; j++)&#123;</span><br><span class="line">            ans=(ans+sc[j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=(nowa&lt;en)+(nowb&lt;en);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>周赛</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-2</title>
    <url>/2020/04/02/2020-04-02-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下:</p>
<ol>
<li>289.生命游戏</li>
<li>链表中倒数第k个节点</li>
<li>从尾到头打印链表</li>
</ol>
<a id="more"></a>

<h2 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289. 生命游戏"></a>289. 生命游戏</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>根据 <a href="https://baike.baidu.com/item/生命游戏/2926434?fr=aladdin" target="_blank" rel="noopener">百度百科</a> ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p>
<p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<ol>
<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li>
<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li>
<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li>
<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li>
</ol>
<p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,1,1],</span><br><span class="line">  [0,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong></p>
<ul>
<li>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</li>
<li>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>用哈希表保存点与状态，然后按照哈希表保存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cood</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x,y,num;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        row = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!row) <span class="keyword">return</span>;</span><br><span class="line">        col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">queue</span>&lt;cood&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> num = countalive(board,i,j);</span><br><span class="line">                q.push(&#123;i,j,num&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            cood c = q.front();</span><br><span class="line">            <span class="keyword">if</span>(board[c.x][c.y]&amp;&amp;c.num&lt;<span class="number">2</span>)</span><br><span class="line">                board[c.x][c.y]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[c.x][c.y]&amp;&amp;c.num&lt;=<span class="number">3</span>)</span><br><span class="line">                board[c.x][c.y]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[c.x][c.y]&amp;&amp;c.num&gt;<span class="number">3</span>)</span><br><span class="line">                board[c.x][c.y]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!board[c.x][c.y]&amp;&amp;c.num==<span class="number">3</span>)</span><br><span class="line">                board[c.x][c.y]=<span class="number">1</span>;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countalive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        res += i<span class="number">-1</span> &gt;=<span class="number">0</span>  ? board[i<span class="number">-1</span>][j]:<span class="number">0</span>;</span><br><span class="line">        res += i+<span class="number">1</span> &lt;row ? board[i+<span class="number">1</span>][j]:<span class="number">0</span>;</span><br><span class="line">        res += j<span class="number">-1</span> &gt;=<span class="number">0</span>  ? board[i][j<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">        res += j+<span class="number">1</span> &lt;col ? board[i][j+<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res += i<span class="number">-1</span> &gt;= <span class="number">0</span>  &amp;&amp;  j<span class="number">-1</span> &gt;= <span class="number">0</span>  ? board[i<span class="number">-1</span>][j<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">        res += i+<span class="number">1</span> &lt; row &amp;&amp;  j<span class="number">-1</span> &gt;= <span class="number">0</span>  ? board[i+<span class="number">1</span>][j<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">        res += i<span class="number">-1</span> &gt;= <span class="number">0</span>  &amp;&amp;  j+<span class="number">1</span> &lt; col ? board[i<span class="number">-1</span>][j+<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res += i+<span class="number">1</span> &lt; row &amp;&amp;  j+<span class="number">1</span> &lt; col ? board[i+<span class="number">1</span>][j+<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗 :7.1 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
<table>
<thead>
<tr>
<th align="left">提交时间</th>
<th align="left">提交结果</th>
<th align="left">执行用时</th>
<th align="left">内存消耗</th>
<th align="left">语言</th>
</tr>
</thead>
<tbody><tr>
<td align="left">几秒前</td>
<td align="left">通过</td>
<td align="left">0 ms</td>
<td align="left">7.1 MB</td>
<td align="left">Cpp</td>
</tr>
<tr>
<td align="left">几秒前</td>
<td align="left">通过</td>
<td align="left">0 ms</td>
<td align="left">7.3 MB</td>
<td align="left">Cp</td>
</tr>
</tbody></table>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：复制原数组进行模拟"><a href="#方法一：复制原数组进行模拟" class="headerlink" title="方法一：复制原数组进行模拟"></a>方法一：复制原数组进行模拟</h4><ul>
<li>复制一份原始数组；</li>
<li>根据复制数组中邻居细胞的状态来更新 <code>board</code> 中的细胞状态。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> neighbors[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建复制数组 copyBoard</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;copyBoard(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从原数组复制一份到 copyBoard 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                copyBoard[row][col] = board[row][col];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历面板每一个格子里的细胞</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于每一个细胞统计其八个相邻位置里的活细胞数量</span></span><br><span class="line">                <span class="keyword">int</span> liveNeighbors = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!(neighbors[i] == <span class="number">0</span> &amp;&amp; neighbors[j] == <span class="number">0</span>)) &#123;</span><br><span class="line">                            <span class="keyword">int</span> r = (row + neighbors[i]);</span><br><span class="line">                            <span class="keyword">int</span> c = (col + neighbors[j]);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 查看相邻的细胞是否是活细胞</span></span><br><span class="line">                            <span class="keyword">if</span> ((r &lt; rows &amp;&amp; r &gt;= <span class="number">0</span>) &amp;&amp; (c &lt; cols &amp;&amp; c &gt;= <span class="number">0</span>) &amp;&amp; (copyBoard[r][c] == <span class="number">1</span>)) &#123;</span><br><span class="line">                                liveNeighbors += <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 规则 1 或规则 3      </span></span><br><span class="line">                <span class="keyword">if</span> ((copyBoard[row][col] == <span class="number">1</span>) &amp;&amp; (liveNeighbors &lt; <span class="number">2</span> || liveNeighbors &gt; <span class="number">3</span>)) &#123;</span><br><span class="line">                    board[row][col] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 规则 4</span></span><br><span class="line">                <span class="keyword">if</span> (copyBoard[row][col] == <span class="number">0</span> &amp;&amp; liveNeighbors == <span class="number">3</span>) &#123;</span><br><span class="line">                    board[row][col] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="方法二：使用额外的状态"><a href="#方法二：使用额外的状态" class="headerlink" title="方法二：使用额外的状态"></a>方法二：使用额外的状态</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>方法一中 <code>O(mn)</code>的空间复杂度在数组很大的时候内存消耗是非常昂贵的。题目中每个细胞只有两种状态 <code>live(1)</code> 或 <code>dead(0)</code>，但我们可以拓展一些复合状态使其包含之前的状态。举个例子，如果细胞之前的状态是 0，但是在更新之后变成了 1，我们就可以给它定义一个复合状态 2。这样我们看到 2，既能知道目前这个细胞是活的，还能知道它之前是死的。</p>
<h5 id="遍历-board-中的细胞。"><a href="#遍历-board-中的细胞。" class="headerlink" title="遍历 board 中的细胞。"></a>遍历 board 中的细胞。</h5><p>根据数组的细胞状态计算新一轮的细胞状态，这里会用到能同时代表过去状态和现在状态的复合状态。</p>
<p>具体的计算规则如下所示：</p>
<ul>
<li><p>规则 1：如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡。这时候，将细胞值改为 -1，代表这个细胞过去是活的现在死了；</p>
</li>
<li><p>规则 2：如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活。这时候不改变细胞的值，仍为 1；</p>
</li>
<li><p>规则 3：如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡。这时候，将细胞的值改为 -1，代表这个细胞过去是活的现在死了。可以看到，因为规则 1 和规则 3 下细胞的起始终止状态是一致的，因此它们的复合状态也一致；</p>
</li>
<li><p>规则 4：如果死细胞周围正好有三个活细胞，则该位置死细胞复活。这时候，将细胞的值改为 2，代表这个细胞过去是死的现在活了。</p>
</li>
</ul>
<p>根据新的规则更新数组；</p>
<p>现在复合状态隐含了过去细胞的状态，所以我们可以在不复制数组的情况下完成原地更新；</p>
<p>对于最终的输出，需要将 board 转成 0，1 的形式。因此这时候需要再遍历一次数组，将复合状态为 2 的细胞的值改为 1，复合状态为 -1 的细胞的值改为 0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> neighbors[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历面板每一个格子里的细胞</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于每一个细胞统计其八个相邻位置里的活细胞数量</span></span><br><span class="line">                <span class="keyword">int</span> liveNeighbors = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!(neighbors[i] == <span class="number">0</span> &amp;&amp; neighbors[j] == <span class="number">0</span>)) &#123;</span><br><span class="line">                            <span class="comment">// 相邻位置的坐标</span></span><br><span class="line">                            <span class="keyword">int</span> r = (row + neighbors[i]);</span><br><span class="line">                            <span class="keyword">int</span> c = (col + neighbors[j]);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 查看相邻的细胞是否是活细胞</span></span><br><span class="line">                            <span class="keyword">if</span> ((r &lt; rows &amp;&amp; r &gt;= <span class="number">0</span>) &amp;&amp; (c &lt; cols &amp;&amp; c &gt;= <span class="number">0</span>) &amp;&amp; (<span class="built_in">abs</span>(board[r][c]) == <span class="number">1</span>)) &#123;</span><br><span class="line">                                liveNeighbors += <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 规则 1 或规则 3 </span></span><br><span class="line">                <span class="keyword">if</span> ((board[row][col] == <span class="number">1</span>) &amp;&amp; (liveNeighbors &lt; <span class="number">2</span> || liveNeighbors &gt; <span class="number">3</span>)) &#123;</span><br><span class="line">                    <span class="comment">// -1 代表这个细胞过去是活的现在死了</span></span><br><span class="line">                    board[row][col] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 规则 4</span></span><br><span class="line">                <span class="keyword">if</span> (board[row][col] == <span class="number">0</span> &amp;&amp; liveNeighbors == <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="comment">// 2 代表这个细胞过去是死的现在活了</span></span><br><span class="line">                    board[row][col] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 board 得到一次更新后的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[row][col] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    board[row][col] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    board[row][col] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：<code>O(mn)</code>，其中 <code>m</code>，<code>n</code>分别为 <code>board</code> 的行数和列数。</p>
<p>空间复杂度：<code>O(1)</code>，除原数组外只需要常数的空间存放若干变量。</p>
<h2 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22. 链表中倒数第k个节点"></a>面试题22. 链表中倒数第k个节点</h2><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>计算长度，然后数数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            len++;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(len&gt;k)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len==k? p:<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其它解法：快慢指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;k)&#123;</span><br><span class="line">                fast=fast-&gt;next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i&lt;k?<span class="literal">nullptr</span>:slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题06-从尾到头打印链表"><a href="#面试题06-从尾到头打印链表" class="headerlink" title="面试题06. 从尾到头打印链表"></a>面试题06. 从尾到头打印链表</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>


<p>限制：</p>
<p><code>0 &lt;= 链表长度 &lt;= 10000</code></p>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><p>栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Res;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> val = st.top();</span><br><span class="line">            Res.push_back(val);</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 简析容器Vector</title>
    <url>/2020/04/02/2020-04-02-Cpp-Vector/</url>
    <content><![CDATA[<p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p>
<a id="more"></a>

<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p>
<h2 id="二、容器特性"><a href="#二、容器特性" class="headerlink" title="二、容器特性"></a>二、容器特性</h2><h3 id="1-顺序序列"><a href="#1-顺序序列" class="headerlink" title="1. 顺序序列"></a>1. 顺序序列</h3><p>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p>
<h3 id="2-动态数组"><a href="#2-动态数组" class="headerlink" title="2. 动态数组"></a>2. 动态数组</h3><p>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</p>
<h3 id="3-能够感知内存分配器的（Allocator-aware）"><a href="#3-能够感知内存分配器的（Allocator-aware）" class="headerlink" title="3. 能够感知内存分配器的（Allocator-aware）"></a>3. 能够感知内存分配器的（Allocator-aware）</h3><p>容器使用一个内存分配器对象来动态地处理它的存储需求。</p>
<h2 id="三、基本函数"><a href="#三、基本函数" class="headerlink" title="三、基本函数"></a>三、基本函数</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><ul>
<li>vector():创建一个空vector</li>
<li>vector(int nSize):创建一个vector,元素个数为nSize</li>
<li>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</li>
<li>vector(const vector&amp;):复制构造函数</li>
<li>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</li>
</ul>
<h3 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2.增加函数"></a>2.增加函数</h3><ul>
<li>void push_back(const T&amp; x):向量尾部增加一个元素X</li>
<li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li>
<li>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</li>
<li>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</li>
</ul>
<h3 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h3><ul>
<li>iterator erase(iterator it):删除向量中迭代器指向元素</li>
<li>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</li>
<li>void pop_back():删除向量中最后一个元素</li>
<li>void clear():清空向量中所有元素</li>
</ul>
<h3 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h3><ul>
<li>reference at(int pos):返回pos位置元素的引用</li>
<li>reference front():返回首元素的引用</li>
<li>reference back():返回尾元素的引用</li>
<li>iterator begin():返回向量头指针，指向第一个元素</li>
<li>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置</li>
<li>reverse_iterator rbegin():反向迭代器，指向最后一个元素</li>
<li>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</li>
</ul>
<h3 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h3><ul>
<li>bool empty() const:判断向量是否为空，若为空，则向量中无元素</li>
</ul>
<h3 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h3><ul>
<li>int size() const:返回向量中元素的个数</li>
<li>int capacity() const:返回当前向量所能容纳的最大元素值</li>
<li>int max_size() const:返回最大可允许的vector元素数量值</li>
</ul>
<h3 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h3><ul>
<li>void swap(vector&amp;):交换两个同类型向量的数据</li>
<li>void assign(int n,const T&amp; x):设置向量中第n个元素的值为x</li>
<li>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</li>
</ul>
<h3 id="8-看着清楚"><a href="#8-看着清楚" class="headerlink" title="8.看着清楚"></a>8.看着清楚</h3><table>
<thead>
<tr>
<th></th>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">push_back( )</td>
<td align="center">在数组的最后添加一个数据</td>
</tr>
<tr>
<td>2</td>
<td align="center">pop_back()</td>
<td align="center">去掉数组的最后一个数据</td>
</tr>
<tr>
<td>3</td>
<td align="center">at</td>
<td align="center">得到编号位置的数据</td>
</tr>
<tr>
<td>4</td>
<td align="center">begin</td>
<td align="center">得到数组头的指针</td>
</tr>
<tr>
<td>5</td>
<td align="center">end</td>
<td align="center">得到数组的最后一个单元+1的指针</td>
</tr>
<tr>
<td>6</td>
<td align="center">front</td>
<td align="center">得到数组头的引用</td>
</tr>
<tr>
<td>7</td>
<td align="center">back</td>
<td align="center">得到数组的最后一个单元的引用</td>
</tr>
<tr>
<td>8</td>
<td align="center">max_size</td>
<td align="center">得到vector最大可以是多大</td>
</tr>
<tr>
<td>9</td>
<td align="center">capacity</td>
<td align="center">当前vector分配的大小</td>
</tr>
<tr>
<td>10</td>
<td align="center">size</td>
<td align="center">当前使用数据的大小</td>
</tr>
<tr>
<td>11</td>
<td align="center">resize</td>
<td align="center">改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</td>
</tr>
<tr>
<td>12</td>
<td align="center">reserve</td>
<td align="center">改变当前vecotr所分配空间的大小</td>
</tr>
<tr>
<td>13</td>
<td align="center">erase</td>
<td align="center">删除指针指向的数据项</td>
</tr>
<tr>
<td>14</td>
<td align="center">clear</td>
<td align="center">清空当前的vector</td>
</tr>
<tr>
<td>15</td>
<td align="center">rbegin</td>
<td align="center">将vector反转后的开始指针返回(其实就是原来的end-1)</td>
</tr>
<tr>
<td>16</td>
<td align="center">rend</td>
<td align="center">将vector反转构的结束指针返回(其实就是原来的begin-1)</td>
</tr>
<tr>
<td>17</td>
<td align="center">empty</td>
<td align="center">判断vector是否为空</td>
</tr>
<tr>
<td>18</td>
<td align="center">swap</td>
<td align="center">与另一个vector交换数据</td>
</tr>
</tbody></table>
<h2 id="四、二维Vector初始化"><a href="#四、二维Vector初始化" class="headerlink" title="四、二维Vector初始化"></a>四、二维Vector初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二维vector初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vt;<span class="comment">//初始化一个 二维vector</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">vect</span><span class="params">(vt)</span></span>;<span class="comment">//使用另一个 二维 vector 初始化当前二维vector</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">vec</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(column))</span></span>;<span class="comment">//初始化一个 二维的vector 行row,列column,且值为0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">visited</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(column,<span class="number">6</span>))</span></span>;<span class="comment">//初始化一个 二维vector 行row,列column ,且 值为data=6 自定义data;</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">vecto</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vt[<span class="number">0</span>].<span class="built_in">begin</span>()+<span class="number">1</span>,vt[<span class="number">0</span>].<span class="built_in">begin</span>()+<span class="number">3</span>))</span></span>;<span class="comment">////初始化一个 二维vector 行row,第二个参数为一维vector;</span></span><br></pre></td></tr></table></figure>

<h3 id="五、排序"><a href="#五、排序" class="headerlink" title="五、排序"></a>五、排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">sort(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序</span></span><br><span class="line"><span class="keyword">auto</span> compare = [](<span class="built_in">string</span> sa, <span class="built_in">string</span> sb)&#123;<span class="keyword">return</span> sa+sb &lt; sb+sa;&#125;;</span><br><span class="line">sort(numstr.<span class="built_in">begin</span>(),numstr.<span class="built_in">end</span>(),compare);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 简析容器Vector</title>
    <url>/2020/04/02/C++%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p>
<a id="more"></a>

<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p>
<h2 id="二、容器特性"><a href="#二、容器特性" class="headerlink" title="二、容器特性"></a>二、容器特性</h2><h3 id="1-顺序序列"><a href="#1-顺序序列" class="headerlink" title="1. 顺序序列"></a>1. 顺序序列</h3><p>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p>
<h3 id="2-动态数组"><a href="#2-动态数组" class="headerlink" title="2. 动态数组"></a>2. 动态数组</h3><p>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</p>
<h3 id="3-能够感知内存分配器的（Allocator-aware）"><a href="#3-能够感知内存分配器的（Allocator-aware）" class="headerlink" title="3. 能够感知内存分配器的（Allocator-aware）"></a>3. 能够感知内存分配器的（Allocator-aware）</h3><p>容器使用一个内存分配器对象来动态地处理它的存储需求。</p>
<h2 id="三、基本函数"><a href="#三、基本函数" class="headerlink" title="三、基本函数"></a>三、基本函数</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><ul>
<li>vector():创建一个空vector</li>
<li>vector(int nSize):创建一个vector,元素个数为nSize</li>
<li>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</li>
<li>vector(const vector&amp;):复制构造函数</li>
<li>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</li>
</ul>
<h3 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2.增加函数"></a>2.增加函数</h3><ul>
<li>void push_back(const T&amp; x):向量尾部增加一个元素X</li>
<li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li>
<li>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</li>
<li>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</li>
</ul>
<h3 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h3><ul>
<li>iterator erase(iterator it):删除向量中迭代器指向元素</li>
<li>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</li>
<li>void pop_back():删除向量中最后一个元素</li>
<li>void clear():清空向量中所有元素</li>
</ul>
<h3 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h3><ul>
<li>reference at(int pos):返回pos位置元素的引用</li>
<li>reference front():返回首元素的引用</li>
<li>reference back():返回尾元素的引用</li>
<li>iterator begin():返回向量头指针，指向第一个元素</li>
<li>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置</li>
<li>reverse_iterator rbegin():反向迭代器，指向最后一个元素</li>
<li>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</li>
</ul>
<h3 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h3><ul>
<li>bool empty() const:判断向量是否为空，若为空，则向量中无元素</li>
</ul>
<h3 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h3><ul>
<li>int size() const:返回向量中元素的个数</li>
<li>int capacity() const:返回当前向量所能容纳的最大元素值</li>
<li>int max_size() const:返回最大可允许的vector元素数量值</li>
</ul>
<h3 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h3><ul>
<li>void swap(vector&amp;):交换两个同类型向量的数据</li>
<li>void assign(int n,const T&amp; x):设置向量中第n个元素的值为x</li>
<li>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</li>
</ul>
<h3 id="8-看着清楚"><a href="#8-看着清楚" class="headerlink" title="8.看着清楚"></a>8.看着清楚</h3><table>
<thead>
<tr>
<th></th>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">push_back( )</td>
<td align="center">在数组的最后添加一个数据</td>
</tr>
<tr>
<td>2</td>
<td align="center">pop_back()</td>
<td align="center">去掉数组的最后一个数据</td>
</tr>
<tr>
<td>3</td>
<td align="center">at</td>
<td align="center">得到编号位置的数据</td>
</tr>
<tr>
<td>4</td>
<td align="center">begin</td>
<td align="center">得到数组头的指针</td>
</tr>
<tr>
<td>5</td>
<td align="center">end</td>
<td align="center">得到数组的最后一个单元+1的指针</td>
</tr>
<tr>
<td>6</td>
<td align="center">front</td>
<td align="center">得到数组头的引用</td>
</tr>
<tr>
<td>7</td>
<td align="center">back</td>
<td align="center">得到数组的最后一个单元的引用</td>
</tr>
<tr>
<td>8</td>
<td align="center">max_size</td>
<td align="center">得到vector最大可以是多大</td>
</tr>
<tr>
<td>9</td>
<td align="center">capacity</td>
<td align="center">当前vector分配的大小</td>
</tr>
<tr>
<td>10</td>
<td align="center">size</td>
<td align="center">当前使用数据的大小</td>
</tr>
<tr>
<td>11</td>
<td align="center">resize</td>
<td align="center">改变当前使用数据的大小，如果它比当前使用的大，则填充默认值</td>
</tr>
<tr>
<td>12</td>
<td align="center">reserve</td>
<td align="center">改变当前vecotr所分配空间的大小</td>
</tr>
<tr>
<td>13</td>
<td align="center">erase</td>
<td align="center">删除指针指向的数据项</td>
</tr>
<tr>
<td>14</td>
<td align="center">clear</td>
<td align="center">清空当前的vector</td>
</tr>
<tr>
<td>15</td>
<td align="center">rbegin</td>
<td align="center">将vector反转后的开始指针返回(其实就是原来的end-1)</td>
</tr>
<tr>
<td>16</td>
<td align="center">rend</td>
<td align="center">将vector反转构的结束指针返回(其实就是原来的begin-1)</td>
</tr>
<tr>
<td>17</td>
<td align="center">empty</td>
<td align="center">判断vector是否为空</td>
</tr>
<tr>
<td>18</td>
<td align="center">swap</td>
<td align="center">与另一个vector交换数据</td>
</tr>
<tr>
<td>19</td>
<td align="center">reverse</td>
<td align="center">翻转容器</td>
</tr>
</tbody></table>
<h3 id="9-交换元素"><a href="#9-交换元素" class="headerlink" title="9.交换元素"></a>9.交换元素</h3><p>比如要交换第0号元素和第四号元素的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">swap(v[<span class="number">0</span>],v[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>



<h2 id="四、二维Vector初始化"><a href="#四、二维Vector初始化" class="headerlink" title="四、二维Vector初始化"></a>四、二维Vector初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二维vector初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vt;<span class="comment">//初始化一个 二维vector</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">vect</span><span class="params">(vt)</span></span>;<span class="comment">//使用另一个 二维 vector 初始化当前二维vector</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">vec</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(column))</span></span>;<span class="comment">//初始化一个 二维的vector 行row,列column,且值为0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">visited</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(column,<span class="number">6</span>))</span></span>;<span class="comment">//初始化一个 二维vector 行row,列column ,且 值为data=6 自定义data;</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">vecto</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vt[<span class="number">0</span>].<span class="built_in">begin</span>()+<span class="number">1</span>,vt[<span class="number">0</span>].<span class="built_in">begin</span>()+<span class="number">3</span>))</span></span>;<span class="comment">////初始化一个 二维vector 行row,第二个参数为一维vector;</span></span><br></pre></td></tr></table></figure>

<h2 id="五、排序"><a href="#五、排序" class="headerlink" title="五、排序"></a>五、排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">sort(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序</span></span><br><span class="line"><span class="keyword">auto</span> compare = [](<span class="built_in">string</span> sa, <span class="built_in">string</span> sb)&#123;<span class="keyword">return</span> sa+sb &lt; sb+sa;&#125;;</span><br><span class="line">sort(numstr.<span class="built_in">begin</span>(),numstr.<span class="built_in">end</span>(),compare);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡4-1</title>
    <url>/2020/04/01/2020-04-01-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>1111.有效括号的嵌套深度</li>
<li>面试题29. 顺时针打印矩阵</li>
<li>面试题10- II. 青蛙跳台阶问题</li>
</ol>
<a id="more"></a>

<h2 id="1111-有效括号的嵌套深度"><a href="#1111-有效括号的嵌套深度" class="headerlink" title="1111. 有效括号的嵌套深度"></a>1111. 有效括号的嵌套深度</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><strong>有效括号字符串</strong> 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「<strong>有效括号字符串</strong>」部分。</p>
<p><strong>嵌套深度</strong> <code>depth</code> 定义：即有效括号字符串嵌套的层数，<code>depth(A)</code> 表示有效括号字符串 <code>A</code> 的嵌套深度。详情参见题末「<strong>嵌套深度</strong>」部分。</p>
<p>有效括号字符串类型与对应的嵌套深度计算方法如下图所示：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/01/1111.png" alt="img"></p>
<p>给你一个「有效括号字符串」 <code>seq</code>，请你将其分成两个不相交的有效括号字符串，<code>A</code> 和 <code>B</code>，并使这两个字符串的深度最小。</p>
<ul>
<li>不相交：每个 <code>seq[i]</code> 只能分给 <code>A</code> 和 <code>B</code> 二者中的一个，不能既属于 <code>A</code> 也属于 <code>B</code> 。</li>
<li><code>A</code> 或 <code>B</code> 中的元素在原字符串中可以不连续。</li>
<li><code>A.length + B.length = seq.length</code></li>
<li>深度最小：<code>max(depth(A), depth(B))</code> 的可能取值最小。 </li>
</ul>
<p>划分方案用一个长度为 <code>seq.length</code> 的答案数组 <code>answer</code> 表示，编码规则如下：</p>
<ul>
<li><code>answer[i] = 0</code>，<code>seq[i]</code> 分给 <code>A</code> 。</li>
<li><code>answer[i] = 1</code>，<code>seq[i]</code> 分给 <code>B</code> 。</li>
</ul>
<p>如果存在多个满足要求的答案，只需返回其中任意 <strong>一个</strong> 即可。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：seq &#x3D; &quot;(()())&quot;</span><br><span class="line">输出：[0,1,1,1,1,0]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：seq &#x3D; &quot;()(())()&quot;</span><br><span class="line">输出：[0,0,0,1,1,0,1,1]</span><br><span class="line">解释：本示例答案不唯一。</span><br><span class="line">按此输出 A &#x3D; &quot;()()&quot;, B &#x3D; &quot;()()&quot;, max(depth(A), depth(B)) &#x3D; 1，它们的深度最小。</span><br><span class="line">像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A &#x3D; &quot;()()()&quot;, B &#x3D; &quot;()&quot;, max(depth(A), depth(B)) &#x3D; 1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt; seq.size &lt;= 10000</code> </li>
</ul>
<p><strong>有效括号字符串：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">仅由 &quot;(&quot; 和 &quot;)&quot; 构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。</span><br><span class="line">下述几种情况同样属于有效括号字符串：</span><br><span class="line"></span><br><span class="line">  1. 空字符串</span><br><span class="line">  2. 连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串</span><br><span class="line">  3. 嵌套，可以记作 (A)，其中 A 是有效括号字符串</span><br></pre></td></tr></table></figure>

<p><strong>嵌套深度：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)：</span><br><span class="line"></span><br><span class="line">  1. s 为空时，depth(&quot;&quot;) &#x3D; 0</span><br><span class="line">  2. s 为 A 与 B 连接时，depth(A + B) &#x3D; max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串</span><br><span class="line">  3. s 为嵌套情况，depth(&quot;(&quot; + A + &quot;)&quot;) &#x3D; 1 + depth(A)，其中 A 是有效括号字符串</span><br><span class="line"></span><br><span class="line">例如：&quot;&quot;，&quot;()()&quot;，和 &quot;()(()())&quot; 都是有效括号字符串，嵌套深度分别为 0，1，2，而 &quot;)(&quot; 和 &quot;(()&quot; 都不是有效括号字符串。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>要求划分出使得最大嵌套深度最小的分组，我们首先得知道如何计算嵌套深度。我们可以通过栈实现括号匹配来计算：</p>
<p>维护一个栈 s，从左至右遍历括号字符串中的每一个字符：</p>
<p>如果当前字符是 (，就把 ( 压入栈中，此时这个 ( 的嵌套深度为栈的高度；</p>
<p>如果当前字符是 )，此时这个 ) 的嵌套深度为栈的高度，随后再从栈中弹出一个 (。</p>
<p>下面给出了括号序列 (()(())()) 在每一个字符处的嵌套深度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">括号序列   ( ( ) ( ( ) ) ( ) )</span><br><span class="line">下标编号   <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">嵌套深度   <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>知道如何计算嵌套深度，问题就很简单了：只要在遍历过程中，我们保证栈内一半的括号属于序列 A，一半的括号属于序列 B，那么就能保证拆分后最大的嵌套深度最小，是当前最大嵌套深度的一半。要实现这样的对半分配，我们只需要把奇数层的 ( 分配给 A，偶数层的 ( 分配给 B 即可。对于上面的例子，我们将嵌套深度为 1 和 3 的所有括号 (()) 分配给 A，嵌套深度为 2 的所有括号 ()()() 分配给 B。<br>此外，由于在这个问题中，栈中只会存放 (，因此我们不需要维护一个真正的栈，只需要用一个变量模拟记录栈<br>的大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxDepthAfterSplit</span><span class="params">(<span class="built_in">string</span> seq)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:seq)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                A.push_back(st.<span class="built_in">size</span>()%<span class="number">2</span>);</span><br><span class="line">                st.push(<span class="string">'('</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                A.push_back(st.<span class="built_in">size</span>()%<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题29-顺时针打印矩阵"><a href="#面试题29-顺时针打印矩阵" class="headerlink" title="面试题29. 顺时针打印矩阵"></a>面试题29. 顺时针打印矩阵</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<h3 id="我的解题"><a href="#我的解题" class="headerlink" title="我的解题"></a>我的解题</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对矩阵进行顺时针访问时，利用一个标志矩阵判断是否访问过该元素。如果发生越界或者碰到已访问节点则会退一格，并换个方向继续访问。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表示方向:→、↓、←、↑</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; di = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;; </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dj = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空值情况处理</span></span><br><span class="line">        <span class="keyword">if</span>(!matrix.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(!matrix[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">return</span> matrix[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Res;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>(),col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> num = row*col;      <span class="comment">//矩阵元素个数</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y=<span class="number">0</span> ;        <span class="comment">//待访问元素坐标</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flag</span><span class="params">(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">1</span>))</span></span>; <span class="comment">//是否访问过该数组</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;              <span class="comment">//遍历方向        </span></span><br><span class="line">    <span class="keyword">while</span>(Res.<span class="built_in">size</span>()&lt; num)&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="number">0</span>&lt;= x &amp;&amp; x&lt;row &amp;&amp; <span class="number">0</span>&lt;= y &amp;&amp; y&lt;col &amp;&amp; flag[x][y])&#123;</span><br><span class="line">            Res.push_back(matrix[x][y]);</span><br><span class="line">            flag[x][y]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;               <span class="comment">//越界则回溯一个值，然后换个方向继续走</span></span><br><span class="line">            x-=di[k]; y-=dj[k];</span><br><span class="line">            k=(++k)%<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x+=di[k]; y+=dj[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*判断是否为空*/</span></span><br><span class="line">      <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      <span class="comment">/*设置上下左右四个界限*/</span></span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; <span class="comment">/*存储遍历结果*/</span></span><br><span class="line">      <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> bottom = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">      <span class="comment">/*此算法模拟顺时针输出的过程，请联想打印过程*/</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/*1.top行从左到右遍历*/</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">              res.push_back(matrix[top][i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*top移动至下一行，并进行边界检测*/</span></span><br><span class="line">          top++;</span><br><span class="line">          <span class="keyword">if</span>(top &gt; bottom ) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*2.right列从上到下遍历*/</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&lt;=bottom;i++)&#123;</span><br><span class="line">              res.push_back(matrix[i][right]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*right左移，并进行边界检测*/</span></span><br><span class="line">          right--;</span><br><span class="line">          <span class="keyword">if</span>(right &lt; left) <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">/*3.bottom行从右往左遍历*/</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = right;i&gt;=left;i--)&#123;</span><br><span class="line">              res.push_back(matrix[bottom][i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*bottom行上移，并进行边界检测*/</span></span><br><span class="line">          bottom -- ;</span><br><span class="line">          <span class="keyword">if</span>(bottom &lt; top) <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">/*4.left列从下往上遍历*/</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom;i&gt;=top;i--)&#123;</span><br><span class="line">              res.push_back(matrix[i][left]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*left右移，并进行边界检测*/</span></span><br><span class="line">          left++;</span><br><span class="line">          <span class="keyword">if</span>(left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*返回遍历结果*/</span></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题10-II-青蛙跳台阶问题"><a href="#面试题10-II-青蛙跳台阶问题" class="headerlink" title="面试题10- II. 青蛙跳台阶问题"></a>面试题10- II. 青蛙跳台阶问题</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h4 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>递归方法容易超时，因此采用哈希表保存中间结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(n<span class="number">-1</span>) == <span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">map</span>[n<span class="number">-1</span>]= numWays(n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(n<span class="number">-2</span>) == <span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">map</span>[n<span class="number">-2</span>]= numWays(n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">map</span>[n<span class="number">-1</span>]+<span class="built_in">map</span>[n<span class="number">-2</span>])%<span class="number">1000000007</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-31</title>
    <url>/2020/03/31/2020-03-31-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>排序数组</li>
</ol>
<p>各种排序算法</p>
<ol>
<li>冒泡排序</li>
<li>插入排序t</li>
<li>快速排序</li>
<li>堆排序</li>
<li>桶排序</li>
</ol>
<a id="more"></a>

<h2 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a>912. 排序数组</h2><p>给定一个整数数组 <code>nums</code>，将该数组升序排列。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-50000 &lt;= A[i] &lt;= 50000</code></li>
</ol>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        quicksort(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> num = nums[low];</span><br><span class="line">        <span class="keyword">int</span> left = low+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = high;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right &amp;&amp; nums[left]&lt;=num) left++;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right &amp;&amp; nums[right]&gt;=num) right--;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[left],nums[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = nums[right];</span><br><span class="line">        nums[right] = num;</span><br><span class="line">        quicksort(nums,low,right<span class="number">-1</span>);</span><br><span class="line">        quicksort(nums,right+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="十种常见排序算法"><a href="#十种常见排序算法" class="headerlink" title="十种常见排序算法"></a>十种常见排序算法</h1><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><strong>比较类排序</strong></li>
</ul>
<p>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</p>
<ul>
<li><strong>非比较类排序</strong></li>
</ul>
<p>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </p>
<h3 id="各算法复杂度"><a href="#各算法复杂度" class="headerlink" title="各算法复杂度"></a>各算法复杂度</h3><p><img src="/2020/03/31/2020-03-31-LeetCode-CheckDaily/849589-20180402133438219-1946132192.png" alt="img"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><strong>相关概念</strong></h3><ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li><strong>空间复杂度：</strong>是指算法在计算机</li>
</ul>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h3><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h3><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a>4. 快速排序</h3><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h3><h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h3><ol start="7">
<li><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3></li>
</ol>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 排序算法</title>
    <url>/2020/03/31/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>排序数组</li>
</ol>
<p>各种排序算法</p>
<ol>
<li>冒泡排序</li>
<li>插入排序t</li>
<li>快速排序</li>
<li>堆排序</li>
<li>桶排序</li>
</ol>
<p>C++中的自定义排序算法</p>
<a id="more"></a>

<h2 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a>912. 排序数组</h2><p>给定一个整数数组 <code>nums</code>，将该数组升序排列。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-50000 &lt;= A[i] &lt;= 50000</code></li>
</ol>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        quicksort(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> num = nums[low];</span><br><span class="line">        <span class="keyword">int</span> left = low+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = high;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right &amp;&amp; nums[left]&lt;=num) left++;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right &amp;&amp; nums[right]&gt;=num) right--;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[left],nums[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = nums[right];</span><br><span class="line">        nums[right] = num;</span><br><span class="line">        quicksort(nums,low,right<span class="number">-1</span>);</span><br><span class="line">        quicksort(nums,right+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="十种常见排序算法"><a href="#十种常见排序算法" class="headerlink" title="十种常见排序算法"></a>十种常见排序算法</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><strong>比较类排序</strong></li>
</ul>
<p>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</p>
<ul>
<li><strong>非比较类排序</strong></li>
</ul>
<p>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </p>
<h3 id="各算法复杂度"><a href="#各算法复杂度" class="headerlink" title="各算法复杂度"></a>各算法复杂度</h3><img src="/2020/03/31/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/849589-20180402133438219-1946132192.png" alt="img" style="zoom: 50%;">

<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><strong>相关概念</strong></h3><ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li><strong>空间复杂度：</strong>是指算法在计算机</li>
</ul>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p><strong>思想：</strong>从左往右遍历，比较相邻两个元素的大小，将大的一个放在后面，每遍历一趟，可找到一个最大值放置在最后，经过n-1趟遍历即可。</p>
<p><strong>性能：</strong>时间复杂度为O(n2)，元素比较次数与初始状态无关，性能略低于插入排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(<span class="keyword">int</span>* A,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j]&gt;A[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> t = A[j+<span class="number">1</span>];</span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">                A[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h3><p><strong>思想：</strong>  将当前元素与它前面已排好序的元素依次进行比较，最后放置在合适的位置，初始时可从第二个元素开始，认为第一个元素已排好序。</p>
<p><strong>性能：</strong> 算法时间复杂度为$O(n^2)$，在序列规模较小时，性能比较好，且元素比较次数与初始序列杂乱程度相关，最优复杂度为O(n)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_Sort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> key = A[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; key  &lt; A[j])&#123;</span><br><span class="line">            A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h3><p><strong>思想：</strong>遍历数组，每次遍历都在未排序的部分找到最小元素的下标，在此次遍历结束后将最小元素放到遍历开始的位置。</p>
<p><strong>性能：</strong>时间复杂度为$O(n^2)$，算法比较次数与初始序列状态无关，性能在所有排序算法中最差。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Violence_Sort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len;j++)</span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[k])</span><br><span class="line">                k = j;</span><br><span class="line">        <span class="keyword">if</span>(k != i)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = A[i];</span><br><span class="line">            A[i] = A[k];</span><br><span class="line">            A[k] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a>4. 快速排序</h3><p><strong>思想：</strong>与归并排序类似，也使用分治思想，选择一个元素值（一般选择最后一个元素），将比它小的放在左边部分，比它大的放在右边，然后对两部分分别进行上述操作知道递归结束，关键步骤在于元素的分类，且只占用O(1)的额外存储空间。</p>
<p><strong>性能：</strong>时间复杂度为$O(n \lg n)$，与归并排序不同，该算法占用常数级额外存储，在大规模序列排序应用中性能较好。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">patition</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = p[left];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; key &lt;= p[right]) right--;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right) p[left++] = p[right];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; key &gt;= p[left]) left++;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right) p[right--] = p[left];</span><br><span class="line">    &#125;</span><br><span class="line">    p[left] = key;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = patition(p, left, right);</span><br><span class="line">    quick_sort(p, left, mid<span class="number">-1</span>);</span><br><span class="line">    quick_sort(p, mid+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h3><p><strong>思想：</strong>使用分治思想，将原始序列分为两部分分别排序，然后合并，重点在于合并过程。</p>
<p><strong>性能：</strong>时间复杂度为$O(n\lg n)$，不过合并过程会使用额外的存储空间，占用内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cp[high-low+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = low; i &lt;= high; i++)</span><br><span class="line">        cp[i-low] = A[i];</span><br><span class="line">    <span class="keyword">int</span> l = low, r = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = low; i &lt;= high; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; mid) &#123;A[i] = cp[r - low]; r++;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r &gt; high) &#123;A[i] = cp[l - low]; l++;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cp[l-low] &lt;= cp[r-low]) &#123;A[i] = cp[l -low]; l++;&#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;A[i] = cp[r -low]; r++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(high &gt; low)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        Merge_Sort(A, low, mid);</span><br><span class="line">        Merge_Sort(A, mid+<span class="number">1</span>, high);</span><br><span class="line">        Merge(A, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h3><p><strong>思想</strong>：使用堆数据结构进行排序，堆是一种用数组存储的二叉树，根据父节点和子节点的大小关系分为最大堆和最小堆，这里使用最大堆进行排序。</p>
<p><strong>性能</strong>：时间复杂度为$O(n\lg n)$，在实际使用中，堆排序的排序性能通常逊与快速排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Max_Heapify</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> i,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">2</span>*i;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> large = i;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= <span class="built_in">size</span> &amp;&amp; A[l] &gt; A[i])</span><br><span class="line">                large = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                large = i;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= <span class="built_in">size</span> &amp;&amp; A[r] &gt; A[large])</span><br><span class="line">                large = r;</span><br><span class="line">        <span class="keyword">if</span>(large != i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = A[large];</span><br><span class="line">        A[large] = A[i];</span><br><span class="line">        A[i] = t;</span><br><span class="line">        Max_Heapify(A, large, <span class="built_in">size</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build_Max_Heap</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">size</span>/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">                Max_Heapify(A,i,<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        Build_Max_Heap(A, len);</span><br><span class="line">        <span class="keyword">while</span>(len<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = A[<span class="number">1</span>];</span><br><span class="line">                A[<span class="number">1</span>] = A[i];</span><br><span class="line">                A[i] = t;</span><br><span class="line">                len--;</span><br><span class="line">                Max_Heapify(A,<span class="number">1</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-希尔排序"><a href="#7-希尔排序" class="headerlink" title="7. 希尔排序"></a>7. 希尔排序</h3><p><strong>思想</strong>：利用插入排序的思想，考虑到插入排序在序列基本有序且数量较少时性能较高，因此先对序列进行逻辑上的分组然后插入排序，如：设定初始增量为x，则0，0+x，0+x+x …为一组，1，1+x，1+x+x …为第二组，共有x组，分别进行排序。那个随后减少增量，增加分组，直到增量为1。</p>
<p><strong>性能：</strong>算法时间复杂度为$O(n^{1.3}) -O(n2)$，性能取决于增量序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> gap = len/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> key = A[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i-gap; j&gt;=<span class="number">0</span> &amp;&amp; A[j] &gt; key; j-= gap)</span><br><span class="line">                A[j+gap] = A[j];</span><br><span class="line">            A[j+gap] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8. 基数排序"></a>8. 基数排序</h3><p><strong>基本思想：</strong><br>BinSort想法非常简单，首先创建数组A[MaxValue]；然后将每个数放到相应的位置上（例如17放在下标17的数组位置）；最后遍历数组，即为排序后的结果。</p>
<p><strong>图示：</strong></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/09/88808" alt="img"></p>
<p>BinSort</p>
<ul>
<li><strong>问题：</strong> 当序列中存在较大值时，BinSort 的排序方法会浪费大量的空间开销。</li>
</ul>
<p>RadixSort</p>
<ul>
<li><p><strong>基本思想：</strong> 基数排序是在BinSort的基础上，通过基数的限制来减少空间的开销。</p>
</li>
<li><p>过程：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/09/101010010" alt="10101001"></p>
<p>过程1</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/09/99909" alt="9990"></p>
<p>过程2</p>
</li>
</ul>
<p>（1）首先确定基数为10，数组的长度也就是10.每个数34都会在这10个数中寻找自己的位置。<br>（2）不同于BinSort会直接将数34放在数组的下标34处，基数排序是将34分开为3和4，第一轮排序根据最末位放在数组的下标4处，第二轮排序根据倒数第二位放在数组的下标3处，然后遍历数组即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> temp[],<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> r,<span class="keyword">int</span> cnt[])</span></span>&#123;</span><br><span class="line">   <span class="comment">//A:原数组</span></span><br><span class="line">   <span class="comment">//temp:临时数组</span></span><br><span class="line">   <span class="comment">//n:序列的数字个数</span></span><br><span class="line">   <span class="comment">//k:最大的位数2</span></span><br><span class="line">   <span class="comment">//r:基数10</span></span><br><span class="line">   <span class="comment">//cnt:存储bin[i]的个数</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> , rtok=<span class="number">1</span>; i&lt;k ; i++ ,rtok = rtok*r)&#123;</span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;r;j++)&#123;</span><br><span class="line">           cnt[j] = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//计算每个箱子的数字个数</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">           cnt[(A[j]/rtok)%r]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//cnt[j]的个数修改为前j个箱子一共有几个数字</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;r;j++)&#123;</span><br><span class="line">           cnt[j] = cnt[j<span class="number">-1</span>] + cnt[j];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;      <span class="comment">//重点理解</span></span><br><span class="line">           cnt[(A[j]/rtok)%r]--;</span><br><span class="line">           temp[cnt[(A[j]/rtok)%r]] = A[j];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">           A[j] = temp[j];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h2><h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Com</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">sort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), Com()); <span class="comment">// Com()为临时对象</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 匿名lambda表达式</span></span><br><span class="line">sort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), [](<span class="built_in">string</span> a, <span class="built_in">string</span> b) &#123;</span><br><span class="line">     <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.具名lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> lam = [](<span class="built_in">string</span> a, <span class="built_in">string</span> b) &#123;</span><br><span class="line">     <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line"> &#125;;</span><br><span class="line">sort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), lam);;</span><br></pre></td></tr></table></figure>

<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="keyword">static</span> <span class="title">com</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加static的原因：类成员函数有隐藏的this指针,static 可以去this指针</span></span><br><span class="line">sort(str.begin(), str.end(), com);</span><br></pre></td></tr></table></figure>



<p>STL标准库中包含几个可供关联式容器使用的排序规则，如表 1 表示。</p>
<table>
<thead>
<tr>
<th>排序规则</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>std::less<T></T></td>
<td>底层采用 &lt; 运算符实现升序排序，各关联式容器默认采用的排序规则。</td>
</tr>
<tr>
<td>std::greater<T></T></td>
<td>底层采用 &gt; 运算符实现降序排序，同样适用于各个关联式容器。</td>
</tr>
<tr>
<td>std::less_equal<T></T></td>
<td>底层采用 &lt;= 运算符实现升序排序，多用于 multimap 和 multiset 容器。</td>
</tr>
<tr>
<td>std::greater_equal<T></T></td>
<td>底层采用 &gt;= 运算符实现降序排序，多用于 multimap 和 multiset 容器。</td>
</tr>
</tbody></table>
<p>值得一提的是，表 1 中的这些排序规则，其底层也是采用函数对象的方式实现的。以 std::less<T> 为例，其底层实现为：</T></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;	</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span> &#123;</span>    <span class="comment">//定义新的排序规则    </span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;_lhs, <span class="keyword">const</span> T &amp;_rhs)</span> <span class="keyword">const</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> _lhs &lt; _rhs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>C++</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM中的后端优化</title>
    <url>/2020/03/30/2020-03-30-Bundle-adjustment/</url>
    <content><![CDATA[<p>本节介绍SLAM中的后端优化过程</p>
<a id="more"></a>

<h2 id="一、问题阐述"><a href="#一、问题阐述" class="headerlink" title="一、问题阐述"></a>一、问题阐述</h2><p>同时对三维点位置和相机参数进行非线性优化</p>
<p><img src="/2020/03/30/2020-03-30-Bundle-adjustment/BA%E4%BC%98%E5%8C%96.jpg" alt="BA原理"></p>
<h2 id="二、LM法的原理与优势"><a href="#二、LM法的原理与优势" class="headerlink" title="二、LM法的原理与优势"></a>二、LM法的原理与优势</h2><p> <strong>原理</strong>：是一种“信赖域”的方法，当收敛速度较快时，增大信赖域使算法趋向于高斯牛顿法；当收敛速度较慢时，减小信赖域使算法趋向于最速下降法。</p>
<p><strong>优势</strong>：速度快；可以在距离初始值较远处得到最优解。</p>
<h4 id="SLAM优化算法对比"><a href="#SLAM优化算法对比" class="headerlink" title="SLAM优化算法对比"></a>SLAM优化算法对比</h4><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">缺点</th>
<th align="center">优点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">KF/EKF</td>
<td align="center">假设噪声为高斯分布，在高维状态空间时计算效率较低，不适合大规模场景的地图构建</td>
<td align="center">原理简单，小场景下收敛性好。</td>
</tr>
<tr>
<td align="center">PF</td>
<td align="center">会不可避免出现粒子退化现象，每个粒子需包含整张地图信息导致不适合大场景地图构建</td>
<td align="center">将运动方程表示为一组粒子，通过蒙特卡罗方法求解，能够处理非线性非高斯噪声。</td>
</tr>
<tr>
<td align="center">EM</td>
<td align="center">计算量大，不能用于大规模场景</td>
<td align="center">有效解决了数据关联问题</td>
</tr>
<tr>
<td align="center">图优化</td>
<td align="center">对闭环检测算法的要求严格</td>
<td align="center">出现多种图优化框架，能够有效解决滤波器算法的缺陷，能用于大规模场景的地图创建</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>BA</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM中的后端优化</title>
    <url>/2020/03/30/SLAM%E4%B8%AD%E7%9A%84%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>本节介绍SLAM中的后端优化过程</p>
<a id="more"></a>

<h2 id="一、问题阐述"><a href="#一、问题阐述" class="headerlink" title="一、问题阐述"></a>一、问题阐述</h2><p>同时对三维点位置和相机参数进行非线性优化</p>
<p><img src="/2020/03/30/SLAM%E4%B8%AD%E7%9A%84%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/BA%E4%BC%98%E5%8C%96.jpg" alt="BA原理"></p>
<h2 id="二、LM法的原理与优势"><a href="#二、LM法的原理与优势" class="headerlink" title="二、LM法的原理与优势"></a>二、LM法的原理与优势</h2><p> <strong>原理</strong>：是一种“信赖域”的方法，当收敛速度较快时，增大信赖域使算法趋向于高斯牛顿法；当收敛速度较慢时，减小信赖域使算法趋向于最速下降法。</p>
<p><strong>优势</strong>：速度快；可以在距离初始值较远处得到最优解。</p>
<h4 id="SLAM优化算法对比"><a href="#SLAM优化算法对比" class="headerlink" title="SLAM优化算法对比"></a>SLAM优化算法对比</h4><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">缺点</th>
<th align="center">优点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">KF/EKF</td>
<td align="center">假设噪声为高斯分布，在高维状态空间时计算效率较低，不适合大规模场景的地图构建</td>
<td align="center">原理简单，小场景下收敛性好。</td>
</tr>
<tr>
<td align="center">PF</td>
<td align="center">会不可避免出现粒子退化现象，每个粒子需包含整张地图信息导致不适合大场景地图构建</td>
<td align="center">将运动方程表示为一组粒子，通过蒙特卡罗方法求解，能够处理非线性非高斯噪声。</td>
</tr>
<tr>
<td align="center">EM</td>
<td align="center">计算量大，不能用于大规模场景</td>
<td align="center">有效解决了数据关联问题</td>
</tr>
<tr>
<td align="center">图优化</td>
<td align="center">对闭环检测算法的要求严格</td>
<td align="center">出现多种图优化框架，能够有效解决滤波器算法的缺陷，能用于大规模场景的地图创建</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>BA</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-30</title>
    <url>/2020/03/30/2020-03-30-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>面试题62. 圆圈中最后t剩下的数字</li>
</ol>
<a id="more"></a>

<h2 id="面试题62-圆圈中最后剩下的数字"><a href="#面试题62-圆圈中最后剩下的数字" class="headerlink" title="面试题62. 圆圈中最后剩下的数字"></a>面试题62. 圆圈中最后剩下的数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p> <strong>示例 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p> <strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= m &lt;= 10^6</code></li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>该问题为约瑟夫环问题。</p>
<p>存储一个数组，每次删除一个元素，使用递归进行求解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++) num[i]=i;</span><br><span class="line">        <span class="keyword">return</span> deletem(num,n,<span class="number">0</span>,m<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deletem</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num,<span class="keyword">int</span> n,<span class="keyword">int</span> start,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> num[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=num.<span class="built_in">begin</span>();</span><br><span class="line">        num.erase(it+(start+m)%n);</span><br><span class="line">        start = (start+m)%n;</span><br><span class="line">        <span class="keyword">return</span> deletem(num,n<span class="number">-1</span>,start,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果：超时</p>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：数学-递归"><a href="#方法一：数学-递归" class="headerlink" title="方法一：数学 + 递归"></a>方法一：数学 + 递归</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>题目中的要求可以表述为：给定一个长度为 n 的序列，每次向后数 m 个元素并删除，那么最终留下的是第几个元素？</p>
<p>这个问题很难快速给出答案。但是同时也要看到，这个问题似乎有拆分为较小子问题的潜质：如果我们知道对于一个长度 n - 1 的序列，留下的是第几个元素，那么我们就可以由此计算出长度为 n 的序列的答案。</p>
<p>算法</p>
<p>我们将上述问题建模为函数 <code>f(n, m)</code>，该函数的返回值为最终留下的元素的序号。</p>
<p>首先，长度为 n 的序列会先删除第<code>m % n</code> 个元素，然后剩下一个长度为 n - 1 的序列。那么，我们可以递归地求解 f(n - 1, m)，就可以知道对于剩下的 n - 1 个元素，最终会留下第几个元素，我们设答案为 <code>x = f(n - 1, m)</code>。</p>
<p>由于我们删除了第 <code>m % n</code> 个元素，将序列的长度变为 <code>n - 1</code>。当我们知道了 <code>f(n - 1, m)</code> 对应的答案 <code>x</code> 之后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。因此有 <code>f(n, m) = (m % n + x) % n = (m + x) % n</code>。</p>
<p>我们递归计算 <code>f(n, m), f(n - 1, m), f(n - 2, m), ...</code>直到递归的终点<code>f(1, m)</code>。当序列长度为 1 时，一定会留下唯一的那个元素，它的编号为 0。</p>
<p>下面的代码实现了上述的递归函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x=lastRemaining(n<span class="number">-1</span>,m);</span><br><span class="line">        <span class="keyword">return</span> (x+m)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：<code>O(n)</code>，需要求解的函数值有 <code>n</code> 个。</p>
<p>空间复杂度：<code>O(n)</code>，函数的递归深度为 <code>n</code>，需要使用 <code>O(n)</code>的栈空间。</p>
<h4 id="方法二：数学-迭代"><a href="#方法二：数学-迭代" class="headerlink" title="方法二：数学 + 迭代"></a>方法二：数学 + 迭代</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>上面的递归可以改写为迭代，避免递归使用栈空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i != n + <span class="number">1</span>; ++i)</span><br><span class="line">            f = (m + f) % i;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：<code>O(n)</code>，需要求解的函数值有 <code>n</code> 个。</p>
<p>空间复杂度：<code>O(1)</code>，只使用常数个变量。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-29</title>
    <url>/2020/03/29/2020-03-29-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>1162.地图分析t</li>
<li>面试题05. 替换空格</li>
<li>面试题58 - II. 左旋转字符串</li>
</ol>
<a id="more"></a>

<h2 id="1162-地图分析"><a href="#1162-地图分析" class="headerlink" title="1162. 地图分析"></a>1162. 地图分析</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>你现在手里有一份大小为 N x N 的『地图』（网格） <code>grid</code>，上面的每个『区域』（单元格）都用 <code>0</code> 和 <code>1</code> 标记好了。其中 <code>0</code> 代表海洋，<code>1</code> 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。</p>
<p>我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：<code>(x0, y0)</code> 和 <code>(x1, y1)</code> 这两个区域之间的距离是 <code>|x0 - x1| + |y0 - y1|</code> 。</p>
<p>如果我们的地图上只有陆地或者海洋，请返回 <code>-1</code>。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><p><strong><img src="/2020/03/29/2020-03-29-LeetCode-CheckDaily/1.jpeg" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,0,1],[0,0,0],[1,0,1]]</span><br><span class="line">输出：2</span><br><span class="line">解释： </span><br><span class="line">海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><p><strong><img src="/2020/03/29/2020-03-29-LeetCode-CheckDaily/2.jpeg" alt="img"></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释： </span><br><span class="line">海洋区域 (<span class="number">2</span>, <span class="number">2</span>) 和所有陆地区域之间的距离都达到最大，最大距离为 <span class="number">4</span>。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= grid.length == grid[0].length &lt;= 100</code></li>
<li><code>grid[i][j]</code> 不是 <code>0</code> 就是 <code>1</code></li>
</ol>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>思路：先用哈希表存储海洋和陆地节点。</p>
<p>然后遍历寻找每个海洋节点的最近陆地。时间复杂度达到$O(N^4)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; sea; <span class="comment">//海洋</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; con; <span class="comment">//陆地</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;grid.<span class="built_in">size</span>();x++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = &#123;x,y&#125;;</span><br><span class="line">                <span class="keyword">if</span>(grid[x][y])</span><br><span class="line">                    con.push_back(temp);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sea.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(sea.<span class="built_in">size</span>()==grid.<span class="built_in">size</span>()*grid.<span class="built_in">size</span>()||con.<span class="built_in">size</span>()==grid.<span class="built_in">size</span>()*grid.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxdis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nearcon;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sea.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mindis = grid.<span class="built_in">size</span>()&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;con.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                mindis = <span class="built_in">min</span>(mindis,mahtdis(sea[i],con[j]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxdis&lt;mindis)</span><br><span class="line">            &#123;</span><br><span class="line">                maxdis = mindis;</span><br><span class="line">                nearcon = mindis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nearcon;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mahtdis</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sea,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; con)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(sea[<span class="number">0</span>]-con[<span class="number">0</span>])+<span class="built_in">abs</span>(sea[<span class="number">1</span>]-con[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果：超时</p>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h5><p>考虑最朴素的方法，即求出每一个海洋区域（<code>grid[i][j] == 0</code> 的区域）的「最近陆地区域」，然后记录下它们的距离，然后在这些距离里面取一个最大值。</p>
<p>对于一个给定的区域<code>(x, y)</code> ，求它的「最近陆地区域」，可以使用宽度优先搜索思想。我们把每个区域的坐标作以及这个区域与 <code>(x, y)</code>的曼哈顿距离为搜索状态，即 Coordinate 结构体的 <code>x</code>、<code>y</code>和<code>step</code> 属性。findNearestLand 方法实现了宽度优先搜索的过程，我们用一个 <code>vis[u][v]</code> 数组记录<code>(u, v)</code> 区域是否被访问过，在拓展新状态的时候按照如下四个方向：</p>
<p><code>(x - 1, y)</code>,<code>(x, y + 1)</code>,<code>(x + 1, y)</code>,<code>(x, y - 1)</code><br>在这里我们可以把四个方向定义为常量增量数组 <code>dx</code> 和 <code>dy</code>。</p>
<p>思考：我们需不需要搜索到队列为空才停止 BFS ？ 答案是不需要。当我们搜索到一个新入队的区域它的 grid 值为 1，即这个区域是陆地区域的时候我们就可以停止搜索，因为 BFS 能保证当前的这个区域是最近的陆地区域（BFS 的性质决定了这里求出来的一定是最短路）。</p>
<p><code>findNearestLand</code>如果我们找不不到任何一个点是陆地区域则返回 -1。最终我们把 ans 的初始值置为 -1，然后与所有的 BFS 结果取最大。</p>
<h4 id="方法一：宽度优先搜索"><a href="#方法一：宽度优先搜索" class="headerlink" title="方法一：宽度优先搜索"></a>方法一：宽度优先搜索</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Coordinate</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y, <span class="built_in">step</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxdis = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!grid[i][j])</span><br><span class="line">                    maxdis = <span class="built_in">max</span>(maxdis, findNearestLand(i, j, grid, row, col));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxdis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNearestLand</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="built_in">queue</span> &lt;Coordinate&gt; q;</span><br><span class="line">        q.push(&#123;x, y, <span class="number">0</span>&#125;);</span><br><span class="line">        vis[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.front(); </span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (!(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt;= row - <span class="number">1</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt;= col - <span class="number">1</span>)) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!vis[nx][ny]) </span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(&#123;nx, ny, f.<span class="built_in">step</span> + <span class="number">1</span>&#125;);</span><br><span class="line">                    vis[nx][ny] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[nx][ny]) </span><br><span class="line">                        <span class="keyword">return</span> f.<span class="built_in">step</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p><strong>时间复杂度</strong>：该算法最多执行 <code>n^2</code>  次 BFS，即我们考虑最坏情况所有的区域都是海洋，那么每一个区域都会进行 BFS。对于每一次 BFS，最坏的情况是找不到陆地区域，我们只能遍历完剩下的 <code>n^2 - 1</code>个海洋区域，由于 vis 数组确保每个区域只被访问一次，所以单次 BFS 的渐进时间复杂度是 <code>O(n^2)</code>，程序的总的渐进时间复杂度是 <code>O(n^4)</code>。</p>
<p><strong>空间复杂度</strong>：该算法使用了 <code>vis</code> 数组，渐进空间复杂度为 <code>O(n^2)</code></p>
<h4 id="方法二：多源最短路"><a href="#方法二：多源最短路" class="headerlink" title="方法二：多源最短路"></a>方法二：多源最短路</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>其实在方法一中我们已经发现我们 BFS 的过程是求最短路的过程，但是这里不是求某一个海洋区域到陆地区域的最短路，而是求所有的海洋区域到陆地区域这个「点集」的最短路。显然这不是一个「单源」最短路问题（SSSP）。在我们学习过的最短路算法中，求解 SSSP 问题的方法有 Dijkstra 算法和 SPFA算法，而求解任意两点之间的最短路一般使用 Floyd 算法。那我们在这里就应该使用 Floyd 算法吗？要考虑这个问题，我们需要分析一下这里使用 Floyd 算法的时间复杂度。我们知道在网格图中求最短路，每个区域（格子）相当于图中的顶点，而每个格子和上下左右四个格子的相邻关系相当于边，我们记顶点的个数为 VV，Floyd 算法的时间复杂度为 $O(V^3)$,而这里 $V = n^2$ ，所以 $O(V^3) = O(n^6)$，显然是不现实的。</p>
<p>考虑 <code>SSSP</code> 是求一个源点到一个点集中所有点的最短路，而这个问题的本质是求某个点集到另一个点集中所有点的最短路，即「多源最短路」，我们只需要对 <code>Dijkstra</code> 算法或者<code>SPFA</code> 算法稍作修改。这里以 <code>Dijkstra</code> 算法为例，我们知道堆优化的 <code>Dijkstra</code> 算法实际上是 BFS 的一个变形，把 BFS 中的队列变成了优先队列，在拓展新状态的时候加入了松弛操作。<code>Dijkstra</code> 的堆优化版本第一步是源点入队，我们只需要把它改成源点集合中的所有的点入队就可以实现求「多源最短路」。</p>
<p>思考：为什么？ 因为我们这样做相当于建立了一个超级源点 SS，这个点与源点集中的 $s_0, s_1, s_2 \cdots s_{|V|}$<br>都有边，并且权都为 0。这样求源点集到目标点集的最短路就变成了求超级源点 SS 到它们的最短路，于是又转化成了 SSSP 问题。</p>
<p>思考：海洋区域和陆地区域，应该哪一个作为源点集？ 也许你分析出「我们需要找一个海洋区域，满足它到陆地的最小距离是最大」会把海洋区域作为源点集。我们可以考虑后续的实现，我们知道 Dijkstra 中一个 <code>d</code>数组用来维护当前源点集到其他点的最短路，而对于源点集中的任意一个点 <code>s</code>，<code>d[s_x][s_y] = 0</code>，这很好理解，源点到源点的最短路就是 <code>0</code>。如果我们把海洋区域作为源点集、陆地区域作为目标点集，假设 tt 是目标点集中的一个点，算法执行结束后 <code>d[t_x][t_y]</code> 就是海洋区域中的点到 <code>t</code> 的最短距离，但是我们却不知道哪些 <code>t</code> 是海洋区域的这些点的「最近陆地区域」，我们也不知道每个 <code>s</code> 距离它的「最近陆地区域」的曼哈顿距离。考虑我们把陆地区域作为源点集、海洋区域作为目标点集，目标点集中的点 <code>t</code>对应的 <code>d[t_x][t_y]</code> 就是海洋区域 <code>t</code>对应的距离它的「最近陆地区域」的曼哈顿距离，正是我们需要的，所以应该把陆地区域作为源点集。</p>
<p>最终我们只需要比出 <code>d[t_x][t_y]</code> 的最大值即可。Dijkstra 算法在初始化 <code>d</code> 数组的时候，把每个元素预置为 <code>INF</code>，所以如果发现最终比出的最大值为 <code>INF</code>，那么就返回 <code>-1</code>。</p>
<p>由于这里的边权为 <code>1</code>，也可以直接使用多源 <code>BFS</code>，在这里每个点都只会被松弛一次。</p>
<p><strong>代码实现</strong></p>
<ul>
<li>Dijkstra 版</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> INF = <span class="keyword">int</span>(<span class="number">1E6</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> d[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> v, x, y;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Status &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v &gt; rhs.v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue &lt;Status&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> &amp;a = grid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]) &#123;</span><br><span class="line">                    d[i][j] = <span class="number">0</span>;</span><br><span class="line">                    q.push(&#123;<span class="number">0</span>, i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.top(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (!(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt;= n - <span class="number">1</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt;= n - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (f.v + <span class="number">1</span> &lt; d[nx][ny]) &#123;</span><br><span class="line">                    d[nx][ny] = f.v + <span class="number">1</span>;</span><br><span class="line">                    q.push(&#123;d[nx][ny], nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a[i][j]) ans = <span class="built_in">max</span>(ans, d[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (ans == INF) ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>多源 BFS 版</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> INF = <span class="keyword">int</span>(<span class="number">1E6</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> d[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Coordinate</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> &lt;Coordinate&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> &amp;a = grid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]) &#123;</span><br><span class="line">                    d[i][j] = <span class="number">0</span>;</span><br><span class="line">                    q.push(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (!(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt;= n - <span class="number">1</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt;= n - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (d[nx][ny] &gt; d[f.x][f.y] + <span class="number">1</span>) &#123;</span><br><span class="line">                    d[nx][ny] = d[f.x][f.y] + <span class="number">1</span>;</span><br><span class="line">                    q.push(&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a[i][j]) ans = <span class="built_in">max</span>(ans, d[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (ans == INF) ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：考虑这里的「多源最短路」的本质还是「单源最短路」，因此就是 Dijkstra 算法堆优化版本的渐进时间复杂度 $O(E \log V)$，这里 <code>E</code> 为边的个数，约等于$ \frac{4n^2}{2} $ ，<code>V</code> 为顶点个数，约等于 $n^2$ ，所以这里的渐进时间复杂度为 $O(n^2 \log n^2) = O(n^2 \log n)$。</p>
<p>在多源 BFS 当中，由于每个点只能被访问一次，渐进时间复杂度为 $O(V+E) = O(n^2)$。</p>
<p>SPFA 算法的理论渐进上界是 $O(VE) = O(n^2)$，但是由于这里的边权都为 <code>1</code>，于是它退化成了 <code>BFS</code>，渐进时间复杂度 $O(n^2)$。<br>空间复杂度：该算法使用了 <code>d</code> 数组，渐进空间复杂度为 $O(n^2)$。</p>
<h4 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h4><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>考虑优化方法二中的「把陆地区域作为源点集、海洋区域作为目标点集，求最短路」的过程。我们知道对于每个海洋区域 <code>(x, y)</code>，离它最近的陆地区域到它的路径要么从上方或者左方来，要么从右方或者下方来。考虑做两次动态规划，第一次从左上到右下，第二次从右下到左上，记 f(x, y) 为(x,y) 距离最近的陆地区域的曼哈顿距离，则我们可以推出这样的转移方程：</p>
<p>第一阶段<br>$$<br>f(x, y) = \left { \begin{aligned} &amp; 0 &amp; , &amp; (x, y) {\rm , is, land} \ &amp; \min { f(x - 1, y), f(x, y - 1) } + 1 &amp; , &amp; (x, y) {\rm , is,ocean} \end{aligned} \right.<br>$$<br>第二阶段<br>$$<br>f(x, y) = \left { \begin{aligned} &amp; 0 &amp; , &amp; (x, y) {\rm , is, land} \ &amp; \min { f(x + 1, y), f(x, y + 1) } + 1 &amp; , &amp; (x, y) {\rm , is,ocean} \end{aligned} \right.<br>$$</p>
<p>我们初始化的时候把陆地的 f 值全部预置为 0，海洋的 f 全部预置为 <code>INF</code>，做完两个阶段的动态规划后，我们在所有的不为零的 <code>f[i][j]</code> 中比一个最大值即可，如果最终比较出的最大值为 <code>INF</code>，就返回 <code>-1</code>。</p>
<p>思考：如果用 <code>f(x, y)</code> 记录左上方的 DP 结果，<code>g(x, y)</code> 记录右下方的DP结果可行吗？ 答案是不可行。因为考虑距离点 <code>(x, y)</code>最近的点可能既不来自左上方，也不来自右下方，比如它来自右上方，这个时候，第二阶段我们就需要用到第一阶段的计算结果。</p>
<p>代码实现如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> INF = <span class="keyword">int</span>(<span class="number">1E6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> f[MAX_N][MAX_N];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a = grid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = (a[i][j] ? <span class="number">0</span> : INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a[i][j]) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, f[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ans == INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p><strong>时间复杂度</strong>：从代码不难看出，这个算法的过程就是四个双重 <code>for</code> 循环，渐进时间复杂度为 <code>O(n^2）</code></p>
<p><strong>空间复杂度</strong>：该算法使用了 <code>f</code> 数组，渐进空间复杂度为 <code>O(n^2)</code></p>
<h2 id="面试题05-替换空格"><a href="#面试题05-替换空格" class="headerlink" title="面试题05. 替换空格"></a>面试题05. 替换空格</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>字符转字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:s)</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">' '</span>) res+=<span class="string">"%20"</span>;</span><br><span class="line">            <span class="keyword">else</span> res.append(<span class="number">1</span>,ch);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span>::size_type <span class="title">pos</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((pos=s.<span class="built_in">find</span>(<span class="string">" "</span>))!=<span class="built_in">string</span>::npos)<span class="comment">//找到了空格</span></span><br><span class="line">        s.replace(pos,<span class="number">1</span>,<span class="string">"%20"</span>);<span class="comment">//替换</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题58-II-左旋转字符串"><a href="#面试题58-II-左旋转字符串" class="headerlink" title="面试题58 - II. 左旋转字符串"></a>面试题58 - II. 左旋转字符串</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="*示例 *"></a>*<em>示例 *</em></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="*示例 *"></a>*<em>示例 *</em></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> num = n%len;</span><br><span class="line">        res = s.substr(num,len-num)+s.substr(<span class="number">0</span>,num);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>相机标定</title>
    <url>/2020/03/28/2020-03-28-Camera-Calibration/</url>
    <content><![CDATA[<p>本节将探讨相机标定，主要探讨以下三个问题</p>
<ol>
<li>相机标定原理</li>
<li>实现过程</li>
<li>棋盘格的好处</li>
</ol>
<a id="more"></a>

<h2 id="相机标定"><a href="#相机标定" class="headerlink" title="相机标定"></a>相机标定</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>图像测量过程以及计算器视觉中，为确定空间物体某点的三维几何关系位置与其在图像中对应点之间的相互关系，必须建立相机成像的几何模型，模型的参数就是相机的参数。<strong>求解参数的过程</strong>称为相机标定。</p>
<p><strong>目的</strong>：求出相机的内、外参数，以及畸变参数。</p>
<p>标定相机后做的两件事：</p>
<ol>
<li>通过相机标定校正这种镜头畸变，生成矫正后的图像；</li>
<li>是根据获得的图像重构三维场景。</li>
</ol>
<h3 id="2-标定原理"><a href="#2-标定原理" class="headerlink" title="2. 标定原理"></a>2. 标定原理</h3><p>先定义以下<strong>涉及概念</strong>：</p>
<p><strong>世界坐标系</strong>：用户定义的三维世界的坐标系，为了描述目标物在真实世界里的位置而被引入。单位为m。</p>
<p><strong>相机坐标系</strong>：在相机上建立的坐标系，为了从相机的角度描述物体位置而定义，作为沟通世界坐标系和图像/像素坐标系的中间一环。单位为m。</p>
<p><strong>图像坐标系</strong>：为了描述成像过程中物体从相机坐标系到图像坐标系的投影透射关系而引入，方便进一步得到像素坐标系下的坐标。 单位为m。</p>
<p><strong>像素坐标系</strong>：为了描述物体成像后的像点在数字图像上（相片）的坐标而引入，即从相机内读取到的信息所在的坐标系。单位为像素。</p>
<p>下图可以清晰地表达四个坐标系之间的关系：</p>
<p><img src="/2020/03/28/2020-03-28-Camera-Calibration/%E5%9D%90%E6%A0%87%E7%B3%BB.jpg" alt="img"></p>
<p>世界坐标系：<code>Xw</code>、<code>Yw</code>、<code>Zw</code>。相机坐标系： <code>Xc</code>、<code>Yc</code>、<code>Zc</code>。图像坐标系：<code>x</code>、<code>y</code>。像素坐标系：<code>u</code>、<code>v</code>。</p>
<p>其中，相机坐标系的<code>Zc</code>轴与光轴重合，且垂直于图像坐标系平面并通过图像坐标系的原点，相机坐标系与图像坐标系之间的距离为焦距f（也即图像坐标系原点与焦点重合）。像素坐标系平面<code>u-v</code>和图像坐标系平面<code>x-y</code>重合，但像素坐标系原点位于图中左上角（之所以这么定义，目的是从存储信息的首地址开始读写）。</p>
<p>下面将依次对刚体进行一系列变换，使之从世界坐标系进行仿射变换、投影透射，最终得到像素坐标系下的离散图像点，过程中会逐步引入各参数矩阵。</p>
<h4 id="A-从世界坐标系到相机坐标系"><a href="#A-从世界坐标系到相机坐标系" class="headerlink" title="A. 从世界坐标系到相机坐标系"></a>A. 从世界坐标系到相机坐标系</h4><p>刚体从世界坐标系转换到相机坐标系的过程，可以通过旋转和平移来得到，我们将其变换矩阵由一个旋转矩阵和平移向量组合成的齐次坐标矩阵（为什么要引入齐次坐标可见后续文章）来表示：</p>
<p><img src="https://img-blog.csdn.net/20180204203239598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>其中，R为旋转矩阵，t为平移向量，因为假定在世界坐标系中物点所在平面过世界坐标系原点且与Zw轴垂直（也即棋盘平面与Xw-Yw平面重合，目的在于方便后续计算），所以<code>zw=0</code>，可直接转换成式1的形式。其中变换矩阵<br>$$<br>\left[<br>\begin{matrix}<br>R&amp;t\<br>0_3^T&amp;1<br>\end{matrix}<br>\right]<br>$$<br>即为前文提到的外参矩阵，之所称之为外参矩阵可以理解为只与相机外部参数有关，且外参矩阵随刚体位置的变化而变化。</p>
<p><img src="https://img-blog.csdn.net/20180204203322511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h4 id="B-从相机坐标系到理想图像坐标系（不考虑畸变）"><a href="#B-从相机坐标系到理想图像坐标系（不考虑畸变）" class="headerlink" title="B. 从相机坐标系到理想图像坐标系（不考虑畸变）"></a>B. 从相机坐标系到理想图像坐标系（不考虑畸变）</h4><p>该过程进行了从三维坐标到二维坐标的转换，也即投影透视过程（用中心投影法将物体投射到投影面上，从而获得的一种较为接近视觉效果的单面投影图，也就是使我们人眼看到景物近大远小的一种成像方式）。以针孔成像为例（除了成像亮度低外，成像效果和透镜成像是一样的，但是光路更简单）。成像过程如图二所示：</p>
<p>针孔面（相机坐标系）在图像平面（图像坐标系）和物点平面（棋盘平面）之间，所成图像为倒立实像。</p>
<p><img src="https://img-blog.csdn.net/20180204203348763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>为了在数学上更方便描述，我们将相机坐标系和图像坐标系位置对调，变成图三所示的布置方式（没有实际的物理意义，只是方便计算）：</p>
<p><img src="https://img-blog.csdn.net/20180204203408825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>此时，假设相机坐标系中有一点M，则在理想图像坐标系下（无畸变）的成像点P的坐标为（可由相似三角形原则得出）：<br>$$<br>x_p=f\frac{x_M}{z_M},y_p=f\frac{y_M}{z_M}<br>$$<br>将上式化为齐次坐标表示形式为：<br>$$<br>z_M<br>\left[\begin{matrix}f&amp;0&amp;0&amp;0\0&amp;f&amp;0&amp;0\0&amp;0&amp;1&amp;0\\end{matrix}\right]<br>\left[\begin{matrix}x_M\y_M\z_M\1\end{matrix}\right]=<br>\left[\begin{matrix}f&amp;0&amp;0\0&amp;f&amp;0\0&amp;0&amp;1\\end{matrix}\right]<br>\left[\begin{matrix}1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;0\\end{matrix}\right]<br>\left[\begin{matrix}x_M\y_M\z_M\1\end{matrix}\right]<br>$$</p>
<h4 id="C-从理想图像坐标系到实际图像坐标系（考虑畸变）"><a href="#C-从理想图像坐标系到实际图像坐标系（考虑畸变）" class="headerlink" title="C. 从理想图像坐标系到实际图像坐标系（考虑畸变）"></a>C. 从理想图像坐标系到实际图像坐标系（考虑畸变）</h4><p>透镜的畸变主要分为径向畸变和切向畸变，还有薄透镜畸变等等，但都没有径向和切向畸变影响显著，所以我们在这里只考虑径向和切向畸变。</p>
<h5 id="径向畸变"><a href="#径向畸变" class="headerlink" title="径向畸变"></a><strong>径向畸变</strong></h5><p>由于透镜形状的制造工艺导致。且越向透镜边缘移动径向畸变越严重。下图所示是径向畸变的两种类型：桶形畸变和枕形畸变。</p>
<p><img src="https://img-blog.csdn.net/20180204203515701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>实际情况中我们常用r=0处的泰勒级数展开的前几项来近似描述径向畸变。矫正径向畸变前后的坐标关系为：<br>$$<br>\left{<br>\begin<br>\end<br>\right<br>$$</p>
<p><img src="https://img-blog.csdn.net/20180204203540542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>由此可知对于径向畸变，我们有3个畸变参数需要求解。</p>
<h5 id="切向畸变"><a href="#切向畸变" class="headerlink" title="切向畸变"></a><strong>切向畸变</strong></h5><p>由于透镜和CMOS或者CCD的安装位置误差导致。因此，如果存在切向畸变，一个矩形被投影到成像平面上时，很可能会变成一个梯形。切向畸变需要两个额外的畸变参数来描述，矫正前后的坐标关系为：</p>
<p><img src="https://img-blog.csdn.net/20180204203600045?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>由此可知对于切向畸变，我们有2个畸变参数需要求解。</p>
<p>综上，我们一共需要5个畸变参数（<code>k1</code>、<code>k2</code>、<code>k3</code>、<code>p1</code>和<code>p2</code> ）来描述透镜畸变。</p>
<p>下图表示了用<code>R</code>，<code>t</code>将上述世界坐标系转换到相机坐标系的过程。</p>
<h4 id="D-从图像坐标系到像素坐标系"><a href="#D-从图像坐标系到像素坐标系" class="headerlink" title="D. 从图像坐标系到像素坐标系"></a>D. 从图像坐标系到像素坐标系</h4><p>像素坐标系原点与图像坐标系原点不重合。假设像素坐标系原点在图像坐标系下的坐标为<code>（u0，v0）</code>，每个像素点在图像坐标系x轴、y轴方向的尺寸为：<code>dx</code>、<code>dy</code>，且像点在实际图像坐标系下的坐标为<code>（xc，yc）</code>，可得到像点在像素坐标系下的坐标为：<br>$$<br>u=\frac{x_t}{d_x}+u_0,v=\frac{y_c}{dy}+v_0<br>$$<br>化为齐次坐标表示形式可得：<br>$$<br>\left[\begin{matrix}u\v\1\end{matrix}\right]=<br>\left[\begin{matrix}1/d_x&amp;0&amp;u_0\0&amp;1/d_y&amp;v_0\0&amp;0&amp;1\end{matrix}\right]<br>\left[\begin{matrix}x_c\y_c\1\end{matrix}\right]<br>$$</p>
<p>公式2中1<code>(xp, yp)</code>与公式5中<code>(xc, yc)</code>相同，都是图像坐标系下的坐标。</p>
<p>若暂不考虑透镜畸变，则将式2与式5的转换矩阵相乘即为内参矩阵M：</p>
<p><img src="https://img-blog.csdn.net/20180204203659583?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM2ODU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>之所以称之为内参矩阵可以理解为矩阵内各值只与相机内部参数有关，且不随物体位置变化而变化。</p>
<p>最后用一幅图来总结从世界坐标系到像素坐标系（不考虑畸变）的转换关系：</p>
<p><strong>总结：</strong>从世界坐标系到像素坐标系（不考虑畸变）的转换关系</p>
<p><img src="/2020/03/28/2020-03-28-Camera-Calibration/%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B.jpg" alt="img"></p>
<h3 id="3-标定方法"><a href="#3-标定方法" class="headerlink" title="3. 标定方法"></a>3. 标定方法</h3><h4 id="传统相机标定法"><a href="#传统相机标定法" class="headerlink" title="传统相机标定法"></a>传统相机标定法</h4><p>传统相机标定法需要使用尺寸已知的标定物，通过建立标定物上坐标已知的点与其图像点之间的对应，利用一定的算法获得相机模型的内外参数。根据标定物的不同可分为三维标定物和平面型标定物。三维标定物可由单幅图像进行标定，标定精度较高，但高精密三维标定物的加工和维护较困难。平面型标定物比三维标定物制作简单，精度易保证，但标定时必须采用两幅或两幅以上的图像。</p>
<p><strong>缺点：</strong>传统相机标定法在标定过程中始终需要标定物，且标定物的制作精度会影响标定结果。同时有些场合不适合放置标定物也限制了传统相机标定法的应用。</p>
<h4 id="相机自标定法"><a href="#相机自标定法" class="headerlink" title="相机自标定法"></a>相机自标定法</h4><p>​    目前出现的自标定算法中主要是利用相机运动的约束。相机的运动约束条件太强，因此使得其在实际中并不实用。利用场景约束主要是利用场景中的一些平行或者正交的信息。其中空间平行线在相机图像平面上的交点被称为消失点，它是射影几何中一个非常重要的特征，所以很多学者研究了基于消失点的相机自标定方法。</p>
<p><strong>优点：</strong>自标定方法灵活性强，可对相机进行在线定标。</p>
<p><strong>缺点：</strong>但由于它是基于绝对二次曲线或曲面的方法，其算法鲁棒性差。</p>
<h4 id="主动视觉相机标定方法"><a href="#主动视觉相机标定方法" class="headerlink" title="主动视觉相机标定方法"></a>主动视觉相机标定方法</h4><p>基于主动视觉的相机标定法是指已知相机的某些运动信息对相机进行标定。该方法不需要标定物，但需要控制相机做某些特殊运动，利用这种运动的特殊性可以计算出相机内部参数。</p>
<p><strong>优点：</strong>是算法简单，往往能够获得线性解，故鲁棒性较高；</p>
<p><strong>缺点：</strong>是系统的成本高、实验设备昂贵、实验条件要求高，而且不适合于运动参数未知或无法控制的场合。</p>
<h3 id="4-棋盘格"><a href="#4-棋盘格" class="headerlink" title="4. 棋盘格"></a>4. 棋盘格</h3><p><strong>棋盘</strong>是一块由黑白方块间隔组成的标定板，我们用它来作为相机标定的标定物（从真实世界映射到数字图像内的对象）。之所以我们用棋盘作为标定物是因为平面棋盘模式更容易处理（相对于复杂的三维物体），但与此同时，二维物体相对于三维物体会缺少一部分信息，于是我们会多次改变棋盘的方位来捕捉图像，以求获得更丰富的坐标信息。如下图所示，是相机在不同方向下拍摄的同一个棋盘图像。</p>
<p><img src="/2020/03/28/2020-03-28-Camera-Calibration/%E6%A3%8B%E7%9B%98.jpg" alt="img"></p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><h3 id="5-张正友标定法"><a href="#5-张正友标定法" class="headerlink" title="5. 张正友标定法"></a>5. 张正友标定法</h3>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>相机标定</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 字符串</title>
    <url>/2020/03/28/2020-03-28-Cpp-String/</url>
    <content><![CDATA[<p>string是C++标准库的一个重要的部分，主要用于字符串处理。可以使用输入输出流方式直接进行string操作，也可以通过文件等手段进行string操作。同时，C++的算法库对string类也有着很好的支持，并且string类还和c语言的字符串之间有着良好的接口。</p>
<p>本文将介绍字符串的基本概念和C++的常用操作。</p>
<a id="more"></a>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>字符串或串(String)是由数字、字母、下划线组成的一串字符。一般记为 <code>s=“a1a2···an”(n&gt;=0)</code>。它是编程语言中表示文本的数据类型。在程序设计中，字符串（string）为符号或数值的一个连续序列，如符号串（一串字符）或二进制数字串（一串二进制数字）。</p>
<p>通常以串的整体作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。两个字符串相等的充要条件是：长度相等，并且各个对应位置上的字符都相等。设p、q是两个串，求q在p中首次出现的位置的运算叫做模式匹配。</p>
<p>串的两种最基本的存储方式是顺序存储方式和链接存储方式。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="1-常规方式"><a href="#1-常规方式" class="headerlink" title="1. 常规方式"></a>1. 常规方式</h4><p>下标+operator[]</p>
<h4 id="2-使用迭代器遍历"><a href="#2-使用迭代器遍历" class="headerlink" title="2. 使用迭代器遍历"></a>2. 使用迭代器遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>::iterator it = str.<span class="built_in">begin</span>();<span class="comment">//返回第一个位置的迭代器（类似于指针）</span></span><br><span class="line"><span class="keyword">while</span> (it != str.<span class="built_in">end</span>()) <span class="comment">//str.end()是最后一个数据的下一个位置 </span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line">    it++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-新式for循环"><a href="#3-新式for循环" class="headerlink" title="3. 新式for循环"></a>3. 新式for循环</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> ch:s)  <span class="built_in">cout</span>&lt;&lt;ch;</span><br></pre></td></tr></table></figure>



<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a><strong>成员函数</strong></h3><h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len = str.length();</span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h4><p>find() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果指定范围内如果包含指定索引值，返回的是索引值在字符串中的起始位置。如果不包含索引值，返回-1。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>对string字符串进行插入和删除字符操作函数原型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>; <span class="comment">//在指定位置插入n个字符</span></span><br></pre></td></tr></table></figure>

<h4 id="添加字符"><a href="#添加字符" class="headerlink" title="添加字符"></a>添加字符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">str.append(<span class="number">1</span>,ch); <span class="comment">//在末尾添加一个字符ch</span></span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cstring&amp; erase(int pos, int n &#x3D; npos); &#x2F;&#x2F;删除从Pos开始的n个字符</span><br></pre></td></tr></table></figure>

<h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>实现在字符串末尾拼接字符串；重载很多</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span>* str); <span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span> c); <span class="comment">//重载+=操作符s</span></span><br><span class="line">tring&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str); <span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>; <span class="comment">//把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>; <span class="comment">//把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>; <span class="comment">//同operator+=(const string&amp; str)</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span></span>;<span class="comment">//字符串s中从pos开始的n个字符连接到字符串结尾</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：例如在 C++ 中，res += s 和 res = res + s 的含义是不一样的。前者是直接在 res 后面添加字符串；后者是用一个临时对象计算 res + s，会消耗很多时间和内存。</p>
<h4 id="提取子串"><a href="#提取子串" class="headerlink" title="提取子串"></a>提取子串</h4><p>函数substr可以提取string字符串中的子字符串，该函数有两个参数，第一个参数为需要提取的子字符串的起始下标，第二个参数是需要提取的子字符串的长度。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"first second third"</span>;  </span><br><span class="line"><span class="built_in">string</span> s2;  s2 = s1.substr(<span class="number">6</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(str.<span class="built_in">begin</span>(),src.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h4 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">replace()</span><br></pre></td></tr></table></figure>

<h4 id="整型转串"><a href="#整型转串" class="headerlink" title="整型转串"></a>整型转串</h4><p>使用to_string()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> s = to_string(num);</span><br></pre></td></tr></table></figure>

<h4 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h4><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody></table>
<h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><p>读写string对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1, s2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;</span><br></pre></td></tr></table></figure>

<p>读取一整行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"><span class="keyword">while</span>(getline(ci,nline))</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">line</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-28</title>
    <url>/2020/03/28/2020-03-28-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>820.单词的压缩编码</li>
<li>232.用栈实现队列t</li>
<li>242.有效的字母异位词</li>
</ol>
<a id="more"></a>

<h2 id="820-单词的压缩编码"><a href="#820-单词的压缩编码" class="headerlink" title="820. 单词的压缩编码"></a>820. 单词的压缩编码</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 <code>S</code> 与一个索引列表 <code>A</code>。</p>
<p>例如，如果这个列表是 <code>[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</code>，我们就可以将其表示为 <code>S = &quot;time#bell#&quot;</code> 和 <code>indexes = [0, 2, 5]</code>。</p>
<p>对于每一个索引，我们可以通过从字符串 <code>S</code> 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p>
<p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: words &#x3D; [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</span><br><span class="line">输出: 10</span><br><span class="line">说明: S &#x3D; &quot;time#bell#&quot; ， indexes &#x3D; [0, 2, 5] 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= words.length &lt;= 2000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 7</code></li>
<li>每个单词都是小写字母 。</li>
</ol>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> leni = words[i].length();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="built_in">set</span>.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> lastword = <span class="built_in">set</span>[j];</span><br><span class="line">                <span class="keyword">int</span> lenl = <span class="built_in">set</span>[j].length();</span><br><span class="line">                <span class="keyword">if</span>((leni&lt;=lenl) &amp;&amp; (lastword.substr(lenl-leni,leni)==words[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((leni&gt;lenl) &amp;&amp; (lastword==words[i].substr(leni-lenl,lenl)))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">set</span>.erase(<span class="built_in">set</span>.<span class="built_in">begin</span>()+j);</span><br><span class="line">                    len = len - lenl<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">set</span>.push_back(words[i]);</span><br><span class="line">                len += leni+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果：<strong>超时</strong></p>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="方法一：存储后缀"><a href="#方法一：存储后缀" class="headerlink" title="方法一：存储后缀"></a>方法一：存储后缀</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>如果单词 X 是 Y 的后缀，那么单词 X 就不需要考虑了，因为编码 Y 的时候就同时将 X 编码了。例如，如果 words 中同时有 “me” 和 “time”，我们就可以在不改变答案的情况下不考虑 “me”。</p>
<p>如果单词 Y 不在任何别的单词 X 的后缀中出现，那么 Y 一定是编码字符串的一部分。</p>
<p>因此，目标就是保留所有不是其他单词后缀的单词，最后的结果就是这些单词长度加一的总和，因为每个单词编码后后面还需要跟一个 # 符号。</p>
<p><img src="/2020/03/28/2020-03-28-LeetCode-CheckDaily/820_1.gif" alt="fig1"></p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>由数据范围可知一个单词最多含有 7 个后缀，所以我们可以枚举单词所有的后缀。对于每个后缀，如果其存在 words 列表中，我们就将其从列表中删除。为了高效删除，我们将 words 用哈希集合（HashSet）来存储。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">set</span><span class="params">(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="keyword">word</span>: words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="keyword">word</span>.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                <span class="built_in">set</span>.erase(<span class="keyword">word</span>.substr(k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="keyword">word</span>: <span class="built_in">set</span>) &#123;</span><br><span class="line">            ans += <span class="keyword">word</span>.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(\sum w_i^2)$，其中 $w_i$是 words[i] 的长度。每个单词有 $w_i$ 个后缀，对于每个后缀，查询其是否在集合中时需要进行 $O(w_i)$的哈希值计算。</p>
<p>空间复杂度：$O(\sum w_i)$，存储单词的空间开销。</p>
<h4 id="方法二：字典树"><a href="#方法二：字典树" class="headerlink" title="方法二：字典树"></a>方法二：字典树</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>如方法一所说，目标就是保留所有不是其他单词后缀的单词。</p>
<h5 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h5><p>去找到是否不同的单词具有相同的后缀，我们可以将其反序之后插入字典树中。例如，我们有 “time” 和 “me”，可以将 “emit” 和 “em” 插入字典树中。</p>
<p><img src="/2020/03/28/2020-03-28-LeetCode-CheckDaily/820_2.jpg" alt="fig2"></p>
<p>然后，字典树的叶子节点（没有孩子的节点）就代表没有后缀的单词，统计叶子节点代表的单词长度加一的和即为我们要的答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">    TrieNode* children[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) children[i] = <span class="literal">NULL</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TrieNode* <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (children[c - <span class="string">'a'</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> children[c - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        TrieNode* trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;TrieNode*, <span class="keyword">int</span>&gt; nodes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> <span class="keyword">word</span> = words[i];</span><br><span class="line">            TrieNode* cur = trie;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="keyword">word</span>.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                cur = cur-&gt;<span class="built_in">get</span>(<span class="keyword">word</span>[j]);</span><br><span class="line">            nodes[cur] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [node, idx] : nodes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += words[idx].length() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(\sum w_i)$，其中 $w_i$是 <code>words[i]</code>的长度。对于每个单词中的每个字母，只需要进行常数次操作。</p>
<p>空间复杂度：$O(S*\sum w_i)$，字典树的空间开销，其中 <code>S</code> 为字符集大小。</p>
<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a>232. 用栈实现队列</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (63.49%)</td>
<td align="center">151</td>
<td align="center">-</td>
</tr>
</tbody></table>
<details style="color: rgb(212, 212, 212); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, Ubuntu, &quot;Droid Sans&quot;, sans-serif, &quot;Microsoft Yahei UI&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary></details>

<details style="color: rgb(212, 212, 212); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, Ubuntu, &quot;Droid Sans&quot;, sans-serif, &quot;Microsoft Yahei UI&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Companies</strong></summary></details>

<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) – 将一个元素放入队列的尾部。</li>
<li>pop() – 从队列首部移除元素。</li>
<li>peek() – 返回队列首部的元素。</li>
<li>empty() – 返回队列是否为空。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyQueue queue &#x3D; new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.pop();   &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.empty(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ul>
<li>你只能使用标准的栈操作 – 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sst;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            sst.push(st.top());</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = sst.top();</span><br><span class="line">        sst.pop();</span><br><span class="line">        <span class="keyword">while</span>(!sst.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(sst.top());</span><br><span class="line">            sst.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sst;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            sst.push(st.top());</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = sst.top();</span><br><span class="line">        <span class="keyword">while</span>(!sst.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(sst.top());</span><br><span class="line">            sst.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (58.98%)</td>
<td align="center">170</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>你可以假设字符串只包含小写字母。</p>
<p><strong>进阶:</strong><br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        sort(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s==t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;       <span class="comment">//构建哈希数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:s)</span><br><span class="line">            hash[n-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:t)</span><br><span class="line">            hash[n-<span class="string">'a'</span>]--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(hash[i]!=<span class="number">0</span>)   <span class="keyword">return</span> <span class="literal">false</span>;          <span class="comment">//如果两数组不完全相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-27</title>
    <url>/2020/03/27/2020-03-27-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>914.卡牌分组</li>
<li>226.翻转二叉树</li>
<li>231.2的幂</li>
<li>278.第一个错误的版本</li>
<li>258.各位相加</li>
</ol>
<a id="more"></a>

<h2 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a>914. 卡牌分组</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<ul>
<li>每组都有 <code>X</code> 张牌。</li>
<li>组内所有的牌上都写着相同的整数。</li>
</ul>
<p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,2,2,2,3,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>

<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]</span><br></pre></td></tr></table></figure>

<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,2,2,2,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[2,2]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>1 &lt;= deck.length &lt;= 10000</li>
<li>0 &lt;= deck[i] &lt; 10000</li>
</ul>
<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>思路：统计各个数字的个数，然后求最大公约数；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!deck.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:deck)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[n]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="built_in">map</span>[deck[<span class="number">0</span>]];</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator  iter;</span><br><span class="line">       	<span class="keyword">for</span>(iter = <span class="built_in">map</span>.<span class="built_in">begin</span>(); iter != <span class="built_in">map</span>.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        &#123;</span><br><span class="line">           res = gcd(res,iter-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res&gt;=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: deck) cnt[x]++;</span><br><span class="line">        <span class="keyword">int</span> g = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)<span class="keyword">if</span>(cnt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (~g) g = gcd(g, cnt[i]);</span><br><span class="line">            <span class="keyword">else</span> g = cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g &gt;= <span class="number">2</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：<code>O(N log C)</code>，其中<code>N</code> 是卡牌的个数，<code>C</code> 是数组 <code>deck</code> 中数的范围，在本题中 C 的值为 10000。求两个数最大公约数的复杂度是 <code>O(log C)</code>，需要求最多 <code>N-1</code>次。</p>
<p>空间复杂度：<code>O(N + C)</code> 或 <code>O(N)</code>。</p>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (74.43%)</td>
<td align="center">393</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>翻转一棵二叉树。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>递归思路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        swap(root-&gt;left,root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            invertTree(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            invertTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a>231. 2的幂</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (47.79%)</td>
<td align="center">173</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个函数来判断它是否是 2 的幂次方。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a><strong>示例 1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: true</span><br><span class="line">解释: 20 &#x3D; 1</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a><strong>示例 2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 16</span><br><span class="line">输出: true</span><br><span class="line">解释: 24 &#x3D; 16</span><br></pre></td></tr></table></figure>

<h4 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a><strong>示例 3</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 218</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><p>位操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=n&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(res&gt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278.第一个错误的版本"></a>278.第一个错误的版本</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (37.51%)</td>
<td align="center">148</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 n &#x3D; 5，并且 version &#x3D; 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><p>使用二分查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">            &#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：求mid的时候要防止int溢出。</p>
<h2 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258. 各位相加"></a>258. 各位相加</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (65.90%)</td>
<td align="center">219</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 38</span><br><span class="line">输出: 2 </span><br><span class="line">解释: 各位相加的过程为：3 + 8 &#x3D; 11, 1 + 1 &#x3D; 2。 由于 2 是一位数，所以返回 2。</span><br></pre></td></tr></table></figure>

<h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a><strong>进阶</strong></h5><p>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p>
<h3 id="我的解法-4"><a href="#我的解法-4" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;=<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=num%<span class="number">10</span>;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=num;</span><br><span class="line">        <span class="keyword">return</span> sum&lt;<span class="number">10</span>?sum:addDigits(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h3><p>时间复杂度为O(1)的解法：</p>
<ul>
<li><p>除个位外，每一位上的值都是通过(9+1)进位的过程得到的，想一下拨算盘进位</p>
</li>
<li><p>把整数n看成n样物品，原本是以10个1份打包的，现在从这些10个1份打包好的里面，拿出1个，让它们以9个为1份打包。</p>
<p>这样就出现了两部分的东西：</p>
</li>
<li><p>原本10个现在9个1份的，打包好的物品，这些，我们不用管零散的物品，它们还可以分成：</p>
<ul>
<li>从原来打包的里面拿出来的物品，<strong>它们的总和 =》 原来打包好的份数 =》 10进制进位的次数 =》 10进制下，除个位外其他位上的值的总和</strong></li>
<li>以10个为1份打包时，打不进去的零散物品 =》 10进制个位上的值</li>
</ul>
</li>
<li><p>如上零散物品的总数，就是第一次处理num后得到的累加值<br>如果这个累加值&gt;9，那么如题就还需要将各个位上的值再相加，直到结果为个位数为止。也就意味着还需要来一遍如上的过程。</p>
<p>那么按照如上的思路，似乎可以通过n % 9得到最后的值。但是有1个关键的问题，如果num是9的倍数，那么就不适用上述逻辑。原本我是想得到n被打包成10个1份的份数+打不进10个1份的散落个数的和。通过与9取模，去获得那个不能整除的1，作为计算份数的方式，但是如果可以被9整除，我就无法得到那个1，也得不到个位上的数。<br>所以需要做一下特殊处理，<code>(num - 1) % 9 + 1</code><br>可以这么做的原因：原本可以被完美分成9个为一份的n样物品，我故意去掉一个，那么就又可以回到上述逻辑中去得到我要的n被打包成10个一份的份数+打不进10个一份的散落个数的和。而这个减去的1就相当于从，在10个1份打包的时候散落的个数中借走的，本来就不影响原来10个1份打包的份数，先拿走再放回来，都只影响散落的个数，所以没有关系。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>刷题</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>对极约束</title>
    <url>/2020/03/26/2020-03-26-Epipolar-constraint/</url>
    <content><![CDATA[<p>本文旨在了解一下几点：</p>
<ol>
<li>对极约束是什么</li>
<li>基础矩阵F</li>
<li>F的秩有什么意义</li>
<li>本质矩阵E</li>
<li>E与F的区别与联系</li>
</ol>
<a id="more"></a>

<h2 id="对极约束"><a href="#对极约束" class="headerlink" title="对极约束"></a>对极约束</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>在已知 2D像素坐标的前提下，根据两幅图像间多组2D像素点对来估计相机的运动。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><p><img src="/2020/03/26/2020-03-26-Epipolar-constraint/image-20200326152746588.png" alt="image-20200326152746588"></p>
<p>如上图所示，我们希望求取两帧图像 $I_1$,$ I_2$ 之间的运动，设第一帧到第二帧的运动为 $R$，$t$。两个相机中心分别为 $O_1$,$O_2$。现在，考虑 $I_1$ 中有一个特征点 $p_1$，它在 $I_2$ 中对应着特征点 $p_2$。我们知道两者是通过特征匹配得到的。首先，连线 $O_2P$与$O_1P$ 在三维空间中会相交于点 P。由$O_1$, $O_2$, $P$ 三点确定的平面为<strong>极平面</strong>（<code>Epipolar plane</code>）。$O_1O_2$ 连线与像平面 $I_1$, $I_2$ 的交点$e_1$, $e_2$ 称为<strong>极点</strong>（<code>Epipoles</code>），$O_1O_2$ 被称为<strong>基线</strong>（<code>Baseline</code>）。我们称极平面与两个像平面 $I_1$, $I_2$ 之间的相交线 $l_1$, $l_2$ 为<strong>极线</strong>（<code>Epipolar line</code>）。</p>
<p>设P的空间位置为 $P=[X,Y,Z]^T$。则根据针孔模型，两个像素点$p_1,p_2$的像素位置为:<br>$$<br>s_1p_1=KP,s_2p_2=K(RP+t)<br>$$<br>其中，K为相机内参矩阵，R，t为两个坐标系的相机运动。具体来说，计算的是$R_{21}$，$t_{21}$，因为他们把第一个坐标系下的坐标转换到了第二个坐标系下。其也可写作是李代数形式。</p>
<p>尺度意义下相等记作：$sp\simeq p$，可表示投影关系。</p>
<p>因此有:<br>$$<br>x_1=K^{-1}p_1, x_2=K^{-1}p_2<br>$$<br>其中，$x_1$,$x_2$表示像素点在归一化平面上的坐标。代入上式，得：<br>$$<br>x_2\simeq Rx_1+t<br>$$<br>两边同时左乘<code>t^</code>。因此得到:<br>$$<br>t^{.}x_2\simeq t^{.}Rx_1<br>$$<br>然后同时左乘<code>x2^</code>，得到</p>
<p><img src="/2020/03/26/2020-03-26-Epipolar-constraint/image-20200326155950749.png" alt="image-20200326155950749"></p>
<p>重新带入$p_1,p_2$有:</p>
<p><img src="/2020/03/26/2020-03-26-Epipolar-constraint/image-20200326160100489.png" alt="image-20200326160100489"></p>
<p>上述两式称为<strong>对极约束</strong>。</p>
<p><strong>几何意义</strong>:    $O_1,P,O_2$三者共面。</p>
<p>把中间部分记作两个矩阵，基础矩阵F和本质矩阵E，可进一步检核对极约束：<code>E=t^R</code>，$F=K^{-T}EK^{-1}$，$x^T_2Ex^1=p^T_2Fp_1=0$。</p>
<p>可看出，对极约束简洁地给出了两个匹配点之间的中间位置关系。</p>
<p>于是位子估计变为以下两部:</p>
<ol>
<li>根据配对点的像素为最初求出E或者F。</li>
<li>根据E或者F求出R,t。</li>
</ol>
<p>由于E和F只相差了相机内参，而内参在SLAM通常是已知的，因此实践中往往使用形式更简单的E。</p>
<h2 id="基础矩阵F"><a href="#基础矩阵F" class="headerlink" title="基础矩阵F"></a>基础矩阵F</h2><h2 id="本质矩阵E"><a href="#本质矩阵E" class="headerlink" title="本质矩阵E"></a>本质矩阵E</h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>对极约束</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表与C++</title>
    <url>/2020/03/26/2020-03-26-Hash-Table/</url>
    <content><![CDATA[<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<p>本节将介绍哈希表的基本概念，与C++实现方法。</p>
<a id="more"></a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>若关键字为<strong>k</strong>，则其值存放在<strong>f(k)</strong>的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系<strong>f</strong>为散列函数，按这个思想建立的表为散列表。</p>
</li>
<li><p>对不同的关键字可能得到同一散列地址，即<code>k1≠k2</code>，而<code>f(k1)=f(k2)</code>，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数<code>f(k)</code>和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。</p>
</li>
<li><p>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</p>
</li>
</ol>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。</p>
<p>实际工作中需视不同的情况采用不同的哈希函数，通常考虑的因素有：</p>
<ol>
<li><p>计算哈希函数所需时间</p>
</li>
<li><p>关键字的长度</p>
</li>
<li><p>哈希表的大小</p>
</li>
<li><p>关键字的分布情况</p>
</li>
<li><p>记录的查找频率</p>
</li>
</ol>
<h3 id="1-直接寻址法"><a href="#1-直接寻址法" class="headerlink" title="1. 直接寻址法"></a>1. 直接寻址法</h3><p>取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种<a href="https://baike.baidu.com/item/散列函数" target="_blank" rel="noopener">散列函数</a>叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。</p>
<h3 id="2-数字分析法"><a href="#2-数字分析法" class="headerlink" title="2. 数字分析法"></a>2. 数字分析法</h3><p>分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p>
<h3 id="3-平方取中法"><a href="#3-平方取中法" class="headerlink" title="3. 平方取中法"></a>3. 平方取中法</h3><p>当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。 [1] </p>
<p>例：我们把英文字母在字母表中的位置序号作为该英文字母的内部编码。例如K的内部编码为11，E的内部编码为05，Y的内部编码为25，A的内部编码为01, B的内部编码为02。由此组成关键字“KEYA”的内部代码为11052501，同理我们可以得到关键字“KYAB”、“AKEY”、“BKEY”的内部编码。之后对关键字进行平方运算后，取出第7到第9位作为该关键字哈希地址，如下图所示</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>内部编码</th>
<th>内部编码的平方值</th>
<th>H(k)关键字的哈希地址</th>
</tr>
</thead>
<tbody><tr>
<td>KEYA</td>
<td>11052501</td>
<td>122157778355001</td>
<td>778</td>
</tr>
<tr>
<td>KYAB</td>
<td>11250102</td>
<td>126564795010404</td>
<td>795</td>
</tr>
<tr>
<td>AKEY</td>
<td>01110525</td>
<td>001233265775625</td>
<td>265</td>
</tr>
<tr>
<td>BKEY</td>
<td>02110525</td>
<td>004454315775625</td>
<td>315</td>
</tr>
</tbody></table>
<h3 id="4-折叠法"><a href="#4-折叠法" class="headerlink" title="4. 折叠法"></a>4. 折叠法</h3><p>将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。</p>
<h3 id="5-随机数法"><a href="#5-随机数法" class="headerlink" title="5. 随机数法"></a>5. 随机数法</h3><p>选择一随机函数，取关键字的随机值作为散列地址，即$H(key)=random(key)$其中random为随机函数,通常用于关键字长度不等的场合。</p>
<h3 id="6-除留余数法"><a href="#6-除留余数法" class="headerlink" title="6. 除留余数法"></a>6. 除留余数法</h3><p>取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即$H(key) = key \mod p,p&lt;=m$。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。</p>
<h2 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h2><h3 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1. 开放寻址法"></a>1. 开放寻址法</h3><p>$H_i=(H(key) + d_i) MOD m,i=1,2，…，k(k&lt;=m-1）$，其中<code>H(key）</code>为散列函数，<code>m</code>为散列表长，$d_i$为增量序列，可有下列三种取法：<br>1.1. di=1,2,3，…，m-1，称线性探测再散列；<br>1.2. di=1^2,-1^2,2^2,-2^2，⑶^2，…，±（k)^2,(k&lt;=m/2）称二次探测再散列；<br>1.3. di=伪随机数序列，称伪随机探测再散列。</p>
<h3 id="2-再散列法"><a href="#2-再散列法" class="headerlink" title="2. 再散列法"></a>2. 再散列法</h3><p>$H_i=RH_i(key), i=1,2，…，k$ ,$RH_i$均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。</p>
<h3 id="3-链地址法（拉链法）"><a href="#3-链地址法（拉链法）" class="headerlink" title="3. 链地址法（拉链法）"></a>3. 链地址法（拉链法）</h3><h3 id="4-建立一个公共溢出区"><a href="#4-建立一个公共溢出区" class="headerlink" title="4. 建立一个公共溢出区"></a>4. 建立一个公共溢出区</h3><h2 id="查找性能"><a href="#查找性能" class="headerlink" title="查找性能"></a>查找性能</h2><p>​        散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平均查找长度来衡量。<br>​        查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素：</p>
<ol>
<li>散列函数是否均匀；</li>
<li>处理冲突的方法；</li>
<li>散列表的装填因子。<br>散列表的装填因子定义为：α= 填入表中的元素个数 / 散列表的长度<br>α是散列表装满程度的标志因子。由于表长是定值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。<br>实际上，散列表的平均查找长度是装填因子α的函数，只是不同处理冲突的方法有不同的函数。</li>
</ol>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>C++中的STL提供了hash_map来实现哈希表功能，但在C++11中，<code>unordered_map</code>作为一种关联容器，替代了<code>hash_map</code>，<code>unordered_map</code>的底层实现是<code>hash</code>表，所以被称为无序关联容器。<br>不管是map还是unordered_map都是一种 key-map(value) 映射的容器，提供非常高的查找效率，下面我们来了解<code>unordered_map</code>的用法。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>在讲解<code>unordered_map</code>之前，我们先得了解一些预备知识：</p>
<h4 id="元素类型"><a href="#元素类型" class="headerlink" title="元素类型"></a>元素类型</h4><p>除常用的语言内置类型以外，<code>unordered_map</code>的元素类型大致有以下几种：</p>
<ul>
<li>value_type : unordered_map元素类型，这种类型的形式为 key-map类型，key和map的类型都是模板类型。</li>
<li>key_type : key，模板类型</li>
<li>mapped_type ：map，即我们常说的value，模板类型</li>
<li>pair类型 ：pair类型也是STL中的常用类型，原型为template &lt;class T1, class T2&gt; struct pair;由于unordered_map使用的就是Key-Map匹配对，所以在这里使用比较多。</li>
</ul>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>插槽：英文为bucket，又可以翻译成桶。在hash表中，hash函数通常返回一个整型(或无符号整型)元素，对应hash表的数组下标，但是数组类型通常为指针指向一片内存或者是一个链表头，对应许多元素，就像一个桶可以装很多元素，这里称为插槽。</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">unordered_map</span> <span class="params">( size_type n = N,<span class="keyword">const</span> hasher&amp; hf = hasher(),<span class="keyword">const</span> key_equal&amp; eql = key_equal(),<span class="keyword">const</span> allocator_type&amp; alloc = allocator_type() )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个构造函数接受无参数构造</p>
<ul>
<li>n：为hash表的最小插槽数，如果未指定，将会被自动确定(取决于特定的库实现，并不固定)</li>
<li>hf: hash函数，因为底层实现是hash表，必然就有hash函数，STL提供了非常全面的不同类型的hash函数实现，也可以自己实现hash函数。</li>
<li>key_equal:判断两个key对象的hash值相等以确定查找的命中，STL提供了大部分的不同类型的key_equal实现，同样也可以实现hash函数</li>
<li>alloc：容易使用的内存构造器，可选择不同的内存构建方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explicit unordered_map ( const allocator_type&amp; alloc );</span><br></pre></td></tr></table></figure>

<p>指定unordered_map的构造器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class InputIterator&gt;</span><br><span class="line">unordered_map ( InputIterator first, InputIterator last,size_type n &#x3D; N,const hasher&amp; hf &#x3D; hasher(),const key_equal&amp; eql &#x3D; key_equal(),const allocator_type&amp; alloc &#x3D; allocator_type() );</span><br></pre></td></tr></table></figure>

<p>接收输入迭代器构造方式，将迭代器指向的元素区间进行复制构造</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unordered_map ( const unordered_map&amp; ump );</span><br><span class="line">unordered_map ( const unordered_map&amp; ump, const allocator_type&amp; alloc );</span><br></pre></td></tr></table></figure>

<p>复制构造，第二个可指定构造器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unordered_map ( unordered_map&amp;&amp; ump );</span><br><span class="line">unordered_map ( unordered_map&amp;&amp; ump, const allocator_type&amp; alloc );</span><br></pre></td></tr></table></figure>

<p>移动构造方式，这个C++11中新支持的特性，移动构造方式提供临时变量的引用，即右值引用的功能,&amp;表示左值引用，&amp;&amp;表示右值引用。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unordered_map ( initializer_list&lt;value_type&gt; il,size_type n &#x3D; N,const hasher&amp; hf &#x3D; hasher(),const key_equal&amp; eql &#x3D; key_equal(),const allocator_type&amp; alloc &#x3D; allocator_type() );</span><br></pre></td></tr></table></figure>

<p>以传入列表的形式构造</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>[<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>](<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>) strmap( &#123;&#123;<span class="string">"name"</span>,<span class="string">"downey"</span>&#125;,&#123;<span class="string">"age"</span>,<span class="string">"500"</span>&#125;&#125; );</span><br></pre></td></tr></table></figure>

<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h5 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">mapped_type&amp; <span class="title">at</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> mapped_type&amp; <span class="title">at</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>根据Key值查找容器内元素，并返回map元素的引用。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mymap=&#123;<span class="string">"key"</span>,<span class="number">111</span>&#125;;</span><br><span class="line"><span class="built_in">map</span>.at(<span class="string">"key"</span>)=<span class="number">123</span>;</span><br><span class="line"><span class="built_in">map</span>.at(<span class="string">"key"</span>)+=<span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<h5 id="begin"><a href="#begin" class="headerlink" title="begin()"></a>begin()</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">local_iterator <span class="title">begin</span> <span class="params">( size_type n )</span></span>;</span><br><span class="line"><span class="function">const_local_iterator <span class="title">begin</span> <span class="params">( size_type n )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>指向容器内第一个元素的迭代器。迭代器访问元素时，it-&gt;first对应key，it-&gt;second对应map(value).</p>
<h5 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">local_iterator <span class="title">end</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function">const_local_iterator <span class="title">end</span> <span class="params">(size_type n)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>指向容器内最后一个元素的后一个位置的迭代器。</p>
<h5 id="cbegin"><a href="#cbegin" class="headerlink" title="cbegin()"></a>cbegin()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const_iterator cbegin() const noexcept;</span><br><span class="line">const_local_iterator cbegin ( size_type n ) const;</span><br></pre></td></tr></table></figure>

<p>返回const类型的第一位置迭代器</p>
<h5 id="cend"><a href="#cend" class="headerlink" title="cend()"></a>cend()</h5><p>返回const类型的最后一个位置的下一位置的迭代器。</p>
<h4 id="清空：clear"><a href="#清空：clear" class="headerlink" title="清空：clear()"></a>清空：clear()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void clear() noexcept;</span><br></pre></td></tr></table></figure>

<p>删除容器内所有元素。</p>
<h4 id="计数：count"><a href="#计数：count" class="headerlink" title="计数：count()"></a>计数：count()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_type count ( const key_type&amp; k ) const;</span><br></pre></td></tr></table></figure>

<p>某个key值对应的map(value)值的数量，因为unordered_map不允许重复元素，所以返回值总是0或1</p>
<h4 id="emplace"><a href="#emplace" class="headerlink" title="emplace()"></a>emplace()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class... Args&gt;</span><br><span class="line">pair&lt;iterator, bool&gt; emplace ( Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure>

<p>如果key元素是唯一的，在unordered_map中插入新元素，使用Args作为元素构造函数的参数来构造这个新元素。参数为右值引用。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mymap.emplace (&quot;NCC-1701&quot;, &quot;J.T. Kirk&quot;);</span><br></pre></td></tr></table></figure>

<p>即可插入相应的map元素</p>
<h4 id="emplace-hint"><a href="#emplace-hint" class="headerlink" title="emplace_hint()"></a>emplace_hint()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class... Args&gt;</span><br><span class="line">iterator emplace_hint ( const_iterator position, Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure>

<p>与emplace()操作一致，position参数则是提供一个建议搜索位置的起点的提示，可以优化执行时间。</p>
<h4 id="判断是否为空：empty"><a href="#判断是否为空：empty" class="headerlink" title="判断是否为空：empty()"></a>判断是否为空：empty()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool empty() const noexcept;</span><br></pre></td></tr></table></figure>

<p>判断容器是否为空，返回bool值</p>
<h4 id="擦除：erase"><a href="#擦除：erase" class="headerlink" title="擦除：erase()"></a>擦除：erase()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iterator erase ( const_iterator position );</span><br><span class="line">size_type erase ( const key_type&amp; k );</span><br><span class="line">iterator erase ( const_iterator first, const_iterator last );</span><br></pre></td></tr></table></figure>

<p>根据不同的索引擦除插槽中的元素.</p>
<h4 id="查找：find"><a href="#查找：find" class="headerlink" title="查找：find()"></a>查找：find()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iterator find ( const key_type&amp; k );</span><br><span class="line">const_iterator find ( const key_type&amp; k ) const;</span><br></pre></td></tr></table></figure>

<p>查找函数，通过key查找一个元素，返回迭代器类型。</p>
<h4 id="查找：bucket"><a href="#查找：bucket" class="headerlink" title="查找：bucket()"></a>查找：bucket()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">bucket</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>以key值寻找元素在容器中的位置。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">str_map map1;</span><br><span class="line">map1.insert(&#123;<span class="string">"downey"</span>,<span class="string">"hello"</span>&#125;);   </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;map1.bucket (it-&gt;first)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">output:</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>从返回值可以看出，即使是插入的第一个元素，位置也不一定是1，这跟容器的hash实现相关。</p>
<h4 id="插入：insert"><a href="#插入：insert" class="headerlink" title="插入：insert()"></a>插入：insert()</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">pair&lt;iterator,bool&gt; insert ( const value_type&amp; val );</span><br></pre></td></tr></table></figure>

<p>直接插入元素类型，返回pair类型，返回值pair第一元素是插入元素迭代器，第二元素表示操作是否成功</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator,bool&gt; <span class="title">insert</span> ( <span class="title">P</span>&amp;&amp; <span class="title">val</span> );</span></span><br></pre></td></tr></table></figure>

<p>移动插入方式，可以传入右值插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">( const_iterator hint, <span class="keyword">const</span> value_type&amp; val )</span></span>;</span><br></pre></td></tr></table></figure>

<p>用户给出一个插入起点以优化查找时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">( const_iterator hint, P&amp;&amp; val )</span></span>;</span><br><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( InputIterator first, InputIterator last )</span></span>;</span><br></pre></td></tr></table></figure>

<p>复制型插入，将(first,last]所包含的内容全部复制插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( <span class="built_in">initializer_list</span>&lt;value_type&gt; il )</span></span>;</span><br></pre></td></tr></table></figure>

<p>插入一个列表形式的元素</p>
<h4 id="比较：key-eq"><a href="#比较：key-eq" class="headerlink" title="比较：key_eq()"></a>比较：key_eq()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回比较关键相等性的函数。获取key equal函数，key_equal函数为判断key值是否匹配，在一般情况下，hash函数并不能保证每一个输入对应一个独一无二的输出，可能多个输入会对应同一个输出，这就是hash冲突。可能一个槽内同时由多个元素，这时候就需要使用key_equal来进行进一步判断。</p>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><h5 id="‘-’-运算符重载"><a href="#‘-’-运算符重载" class="headerlink" title="‘=’ 运算符重载"></a>‘=’ 运算符重载</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&amp; <span class="keyword">operator</span>= ( <span class="keyword">const</span> <span class="built_in">unordered_map</span>&amp; ump );</span><br><span class="line"><span class="built_in">unordered_map</span>&amp; <span class="keyword">operator</span>= ( <span class="built_in">unordered_map</span>&amp;&amp; ump );</span><br><span class="line"><span class="built_in">unordered_map</span>&amp; <span class="keyword">operator</span>= ( intitializer_list&lt;value_type&gt; il );</span><br></pre></td></tr></table></figure>

<p>以不同方式对容器进行赋值。</p>
<h5 id="‘-’-操作符重载"><a href="#‘-’-操作符重载" class="headerlink" title="‘[]’ 操作符重载"></a>‘[]’ 操作符重载</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mapped_type&amp; operator[] ( const key_type&amp; k );</span><br><span class="line">mapped_type&amp; operator[] ( key_type&amp;&amp; k );</span><br></pre></td></tr></table></figure>

<p>[]操作符重载，使得容易可以通过map[Key]的方式进行索引。</p>
<h4 id="重建：rehash"><a href="#重建：rehash" class="headerlink" title="重建：rehash()"></a>重建：rehash()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void rehash( size_type n );</span><br></pre></td></tr></table></figure>

<p>重建hash表，将插槽的数量扩展的n，如果n小于目前插槽数量，这个函数并不起作用。</p>
<h4 id="翻转：reserve"><a href="#翻转：reserve" class="headerlink" title="翻转：reserve()"></a>翻转：reserve()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void reserve ( size_type n );</span><br></pre></td></tr></table></figure>

<p>将容器的插槽数设置成最适合n个元素的情况，这样可以避免多次rehash和直接rehash空间的浪费。</p>
<p>与rehash相比，这个函数由用户给一个插槽数量建议值，由系统去分配空间，而rehash则是指定容器的插槽值</p>
<h4 id="大小：size"><a href="#大小：size" class="headerlink" title="大小：size()"></a>大小：size()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_type size() const noexcept;</span><br></pre></td></tr></table></figure>

<p>返回当前容器中元素的个数</p>
<h4 id="交换：swap"><a href="#交换：swap" class="headerlink" title="交换：swap()"></a>交换：swap()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap ( unordered_map&amp; ump )</span><br></pre></td></tr></table></figure>

<p>交换两个容器的内容，两个容器的类型必须一致，但大小可以不同。</p>
<h4 id="内部信息获取"><a href="#内部信息获取" class="headerlink" title="内部信息获取"></a>内部信息获取</h4><h5 id="get-allocator"><a href="#get-allocator" class="headerlink" title="get_allocator()"></a>get_allocator()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allocator_type get_allocator() const noexcept;</span><br></pre></td></tr></table></figure>

<p>返回容器目前使用的内存构造器。</p>
<h5 id="hash-function"><a href="#hash-function" class="headerlink" title="hash_function()"></a>hash_function()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hasher hash_function() const;</span><br></pre></td></tr></table></figure>

<p>获取hash容器当前使用的hash函数</p>
<h5 id="bucket-count"><a href="#bucket-count" class="headerlink" title="bucket_count()"></a>bucket_count()</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回hash表的插槽值个数，这个函数的值对应构造函数中的n(最小插槽数)参数。</p>
<h5 id="max-bucket-count"><a href="#max-bucket-count" class="headerlink" title="max_bucket_count()"></a>max_bucket_count()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_type max_bucket_count() const noexcept;</span><br></pre></td></tr></table></figure>

<p>返回容器所能支持的最大插槽数，根据平台不同而不同，一般是一个非常大的数字。</p>
<h5 id="bucket-size"><a href="#bucket-size" class="headerlink" title="bucket_size()"></a>bucket_size()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_type bucket_size ( size_type n ) const;</span><br></pre></td></tr></table></figure>

<p>这个函数返回每个插槽中的元素数量。</p>
<h5 id="max-load-factor"><a href="#max-load-factor" class="headerlink" title="max_load_factor()"></a>max_load_factor()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float max_load_factor() const noexcept;</span><br><span class="line">void max_load_factor ( float z );</span><br></pre></td></tr></table></figure>

<p>第一个函数是查询目前容器最大的负载因子，默认为1。</p>
<p>第二个函数是进行最大的负载因子的设置。</p>
<h5 id="max-size"><a href="#max-size" class="headerlink" title="max_size()"></a>max_size()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_type max_size() const noexcept;</span><br></pre></td></tr></table></figure>

<p>容器可支持的元素最大数量，linux平台下，使用4.8.5的STL库中这个值是：268435455</p>
<h5 id="load-factor"><a href="#load-factor" class="headerlink" title="load_factor()"></a>load_factor()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float load_factor() const noexcept;</span><br></pre></td></tr></table></figure>

<p>load factor在中文中被翻译成负载因子，负载因子是容器中元素数量与插槽数量之间的比例。即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load_factor &#x3D; size &#x2F; bucket_count</span><br></pre></td></tr></table></figure>

<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><h5 id="使用迭代器遍历"><a href="#使用迭代器遍历" class="headerlink" title="使用迭代器遍历"></a>使用迭代器遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> n:deck)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">map</span>[n]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=<span class="built_in">map</span>[deck[<span class="number">0</span>]];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator  iter;</span><br><span class="line"><span class="keyword">for</span>(iter = <span class="built_in">map</span>.<span class="built_in">begin</span>(); iter != <span class="built_in">map</span>.<span class="built_in">end</span>(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">    res = gcd(res,iter-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res&gt;=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-26</title>
    <url>/2020/03/26/2020-03-26-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>999.车的可用捕获量</li>
<li>205.同构字符串</li>
<li>217.存在重复元素</li>
<li>219.存在重复元素||</li>
</ol>
<a id="more"></a>

<h2 id="999-车的可用捕获量"><a href="#999-车的可用捕获量" class="headerlink" title="999. 车的可用捕获量"></a>999. 车的可用捕获量</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p>
<p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。</p>
<p>返回车能够在一次移动中捕获到的卒的数量。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><p><img src="/2020/03/26/2020-03-26-LeetCode-CheckDaily/1253_example_1_improved.PNG" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">在本例中，车能够捕获所有的卒。</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>上下左右依次遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> col=board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'R'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> right = j+<span class="number">1</span>;right&lt;col;right++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][right]==<span class="string">'B'</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][right]==<span class="string">'p'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            flag++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> left = j<span class="number">-1</span>;left&gt;=<span class="number">0</span>;left--)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][left]==<span class="string">'B'</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][left]==<span class="string">'p'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            flag++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> down = i+<span class="number">1</span>;down&lt;row;down++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[down][j]==<span class="string">'B'</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span>(board[down][j]==<span class="string">'p'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            flag++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> up = i<span class="number">-1</span>;up&gt;=<span class="number">0</span>;up--)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[up][j]==<span class="string">'B'</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span>(board[up][j]==<span class="string">'p'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            flag++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> flag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：<code>O(n^2)</code>中 <code>n</code> 是棋盘的边长。找白色车在棋盘中的位置需要 <code>O(n^2)</code>的时间复杂度，模拟车在四个方向上捕获颜色相反的卒需要 <code>O(n)</code> 的时间复杂度，所以一共需要 <code>O(n^2+n) = O(n^2)</code>的时间复杂度。</p>
<p>空间复杂度：O(1)，只需要常数空间存放若干变量。</p>
<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, st = <span class="number">0</span>, ed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    st = i;</span><br><span class="line">                    ed = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>;; ++<span class="built_in">step</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> tx = st + <span class="built_in">step</span> * dx[i];</span><br><span class="line">                <span class="keyword">int</span> ty = ed + <span class="built_in">step</span> * dy[i];</span><br><span class="line">                <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= <span class="number">8</span> || ty &lt; <span class="number">0</span> || ty &gt;= <span class="number">8</span> || board[tx][ty] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[tx][ty] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a>205. 同构字符串</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (47.32%)</td>
<td align="center">172</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <strong>t</strong> ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;paper&quot;, t &#x3D; &quot;title&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>你可以假设 <strong><em>s</em></strong> 和 <strong><em>t\</em></strong> 具有相同的长度。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>使用哈希表，对一个字符，去检测其第一次出现的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = t.length();</span><br><span class="line">        <span class="keyword">if</span>(len1!=len2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; sHash;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; tHash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sHash.count(s[i])&amp;&amp;tHash.count(t[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(sHash[s[i]]!=tHash[t[i]])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sHash.count(s[i])||tHash.count(t[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!sHash.count(s[i])&amp;&amp;!tHash.count(t[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                sHash[s[i]]=i;</span><br><span class="line">                tHash[t[i]]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h4 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p><strong>哈希表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.<span class="built_in">find</span>(n)==<span class="built_in">set</span>.<span class="built_in">end</span>())</span><br><span class="line">                <span class="built_in">set</span>.insert(n);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="219-存在重复元素"><a href="#219-存在重复元素" class="headerlink" title="219. 存在重复元素||"></a>219. 存在重复元素||</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (37.80%)</td>
<td align="center">149</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的 <strong>绝对值</strong> 至多为 <em>k</em>。</p>
<h4 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1], k &#x3D; 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,0,1,1], k &#x3D; 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h4 id="示例-3-2"><a href="#示例-3-2" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(nums[i])==<span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">                <span class="built_in">map</span>[nums[i]]=i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="built_in">map</span>[nums[i]]-i)&lt;=k)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">map</span>[nums[i]]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-25</title>
    <url>/2020/03/25/2020-03-25-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li>三维形体的表面积t</li>
<li>202.快乐数</li>
<li>204.计算质数</li>
<li>263.丑数</li>
<li>268.缺失数字</li>
</ol>
<a id="more"></a>

<h2 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892. 三维形体的表面积"></a>892. 三维形体的表面积</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在 <code>N * N</code> 的网格上，我们放置一些 <code>1 * 1 * 1</code>  的立方体。</p>
<p>每个值 <code>v = grid[i][j]</code> 表示 v 个正方体叠放在对应单元格 <code>(i, j)</code> 上。</p>
<p>请你返回最终形体的表面积。</p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2]]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure>

<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2],[3,4]]</span><br><span class="line">输出：34</span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,0],[0,2]]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>

<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure>

<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">输出：46</span><br></pre></td></tr></table></figure>

<h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>计算每一个小方块的面积将其叠加起来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j])</span><br><span class="line">                    sum+=<span class="number">2</span>; <span class="comment">//上下</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;grid[i][j];k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>||grid[i<span class="number">-1</span>][j]<span class="number">-1</span>&lt;k) <span class="comment">//左</span></span><br><span class="line">                        temp++;</span><br><span class="line">                    <span class="keyword">if</span>(i==row<span class="number">-1</span>||grid[i+<span class="number">1</span>][j]<span class="number">-1</span>&lt;k) <span class="comment">//右</span></span><br><span class="line">                        temp++;</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>||grid[i][j<span class="number">-1</span>]<span class="number">-1</span>&lt;k)    <span class="comment">//前</span></span><br><span class="line">                        temp++;</span><br><span class="line">                    <span class="keyword">if</span>(j==col<span class="number">-1</span>||grid[i][j+<span class="number">1</span>]<span class="number">-1</span>&lt;k) <span class="comment">//后</span></span><br><span class="line">                        temp++;</span><br><span class="line">                    sum += temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><p>我们单独计算每一个 <code>v = grid[i][j]</code> 所贡献的表面积，再将所有的 v 值相加就能得到最终形体的表面积：</p>
<p>对于顶面和底面的表面积，如果 <code>v &gt; 0</code>，那么顶面和底面各贡献了 1 的表面积，总计 <code>2</code> 的表面积；</p>
<p>对于四个侧面的表面积，只有在相邻位置的高度小于 v 时，对应的那个侧面才会贡献表面积，且贡献的数量为 <code>v - nv</code>，其中 <code>nv</code> 是相邻位置的高度。我们可以将其写成 <code>max(v - nv, 0)</code>。</p>
<p>举一个例子，对于网格</p>
<p><code>1 5
6 7</code><br>而言，位置 <code>grid[0][1]</code> 的高度为 5：</p>
<p>因为 <code>5 &gt; 0</code>，所以贡献了 <code>2</code> 的顶面和底面表面积；</p>
<p>该位置的上方和右侧没有单元格，可以看成高度为 0，所以分别贡献了 <code>max(5 - 0, 0) = 5</code> 的表面积；</p>
<p>该位置的左侧高度为 1，所以贡献了 <code>max(5 - 1, 0) = 4</code> 的表面积；</p>
<p>该位置的下方高度为 7，所以贡献了 <code>max(5 - 7, 0) = 0</code> 的表面积。</p>
<p>因此 grid[0][1] 贡献的表面积总和为 <code>2 + 5 + 5 + 4 + 0 = 16</code>。</p>
<p><strong>算法</strong></p>
<p>对于每个 <code>v = grid[r][c] &gt; 0</code>，计算 <code>ans += 2</code>，对于 <code>grid[r][c]</code> 四个方向的每个相邻值<code>nv</code> 还要加上 <code>max(v - nv, 0)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dr[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dc[]&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; N; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; ++c)</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] &gt; <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    ans += <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> nr = r + dr[k];</span><br><span class="line">                        <span class="keyword">int</span> nc = c + dc[k];</span><br><span class="line">                        <span class="keyword">int</span> nv = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; N &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; N)</span><br><span class="line">                            nv = grid[nr][nc];</span><br><span class="line"></span><br><span class="line">                        ans += <span class="built_in">max</span>(grid[r][c] - nv, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个算法来判断一个数是不是“快乐数”。</p>
<p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 19</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h3><p>本问题的关键在于找到出口，否则会无限循环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">7</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;         </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = n%<span class="number">10</span>;</span><br><span class="line">            sum+=i*i;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isHappy(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>使用“快慢指针”思想找出循环：“快指针”每次走两步，“慢指针”每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。</p>
<p>注意：此题不建议用集合记录每次的计算结果来判断是否进入循环，因为这个集合可能大到无法存储；另外，也不建议使用递归，同理，如果递归层次较深，会直接导致调用栈崩溃。不要因为这个题目给出的整数是int型而投机取巧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">bit</span> = n % <span class="number">10</span>;</span><br><span class="line">            sum += <span class="built_in">bit</span> * <span class="built_in">bit</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = n, fast = n;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = bitSquareSum(slow);</span><br><span class="line">            fast = bitSquareSum(fast);</span><br><span class="line">            fast = bitSquareSum(fast);</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (32.86%)</td>
<td align="center">309</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>

<h3 id="筛法解法"><a href="#筛法解法" class="headerlink" title="筛法解法"></a>筛法解法</h3><p>素数筛法</p>
<p>有一张很好理解的图</p>
<p><img src="/2020/03/25/2020-03-25-LeetCode-CheckDaily/%E7%AD%9B%E6%B3%95.gif" alt="1.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">7</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;         </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = n%<span class="number">10</span>;</span><br><span class="line">            sum+=i*i;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isHappy(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>算法复杂度</strong>： <code>O(N * loglogN)</code></p>
<h2 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263. 丑数"></a>263. 丑数</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (48.98%)</td>
<td align="center">108</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个程序判断给定的数是否为丑数。</p>
<p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 6</span><br><span class="line">输出: true</span><br><span class="line">解释: 6 &#x3D; 2 × 3</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: true</span><br><span class="line">解释: 8 &#x3D; 2 × 2 × 2</span><br></pre></td></tr></table></figure>

<h4 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 14</span><br><span class="line">输出: false </span><br><span class="line">解释: 14 不是丑数，因为它包含了另外一个质因数 7。</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><code>1</code> 是丑数。</li>
<li>输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。</li>
</ol>
<h3 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>||num==<span class="number">2</span>||num==<span class="number">3</span>||num==<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(num ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> isUgly(num/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> isUgly(num/<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> isUgly(num/<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a>268. 缺失数字</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (54.70%)</td>
<td align="center">227</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。</p>
<h3 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h3 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p>
<h3 id="我的解法-3"><a href="#我的解法-3" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(s+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)</span><br><span class="line">            A[n]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s+<span class="number">1</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(!A[i])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><strong>时间复杂度</strong>：O(n)。集合的插入操作的时间复杂度都是 O(1)，一共插入了 n 个数，时间复杂度为 O(n)。</p>
<p>集合的查询操作的时间复杂度同样是 O(1)，最多查询 n+1 次，时间复杂度为 O(n)。因此总的时间复杂度为 O(n)。<br><strong>空间复杂度</strong>：O(n)。集合中会存储 nn 个数，因此空间复杂度为 O(n)O(n)。</p>
<h3 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h3><p><strong>思路</strong></p>
<p>如果数组是有序的，那么就很容易知道缺失的数字是哪个了。</p>
<p><strong>算法</strong></p>
<p>首先我们对数组进行排序，随后我们可以在常数时间内判断两种特殊情况：0 没有出现在数组的首位，以及 n没有出现在数组的末位。如果这两种特殊情况都不满足，那么缺失的数字一定在 0 和 n 之间（不包括两者）。此时我们可以在线性时间内扫描这个数组，如果某一个数比它前面的那个数大了超过 1，那么这两个数之间的那个数即为缺失的数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Ensure that n is at the last index</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">-1</span>] != len(nums):</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="comment"># Ensure that 0 is at the first index</span></span><br><span class="line">        <span class="keyword">elif</span> nums[<span class="number">0</span>] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If we get here, then the missing number is on the range (0, n)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            expected_num = nums[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] != expected_num:</span><br><span class="line">                <span class="keyword">return</span> expected_num</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n\log n)。由于排序的时间复杂度为 O(n\log n)，扫描数组的时间复杂度为O(n)，因此总的时间复杂度为 O(n\log n)。<br>空间复杂度：O(1)或 O(n)。空间复杂度取决于使用的排序算法，根据排序算法是否进行原地排序（即不使用额外的数组进行临时存储），空间复杂度为 O(1)或 O(n)。</p>
<h3 id="方法三：位运算"><a href="#方法三：位运算" class="headerlink" title="方法三：位运算"></a>方法三：位运算</h3><p><strong>思路</strong></p>
<p>由于异或运算（XOR）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数，因此我们可以通过异或运算找到缺失的数字。</p>
<p><strong>算法</strong></p>
<p>我们知道数组中有 <code>n</code> 个数，并且缺失的数在<code>[0..n]</code>中。因此我们可以先得到 <code>[0..n]</code>的异或值，再将结果对数组中的每一个数进行一次异或运算。未缺失的数在 <code>[0..n]</code> 和数组中各出现一次，因此异或后得到 0。而缺失的数字只在<code>[0..n]</code> 中出现了一次，在数组中没有出现，因此最终的异或结果即为这个缺失的数字。</p>
<p>在编写代码时，由于 <code>[0..n]</code> 恰好是这个数组的下标加上 <code>n</code>，因此可以用一次循环完成所有的异或运算，例如下面这个例子：</p>
<p>下标    0    1    2    3<br>数字    0    1    3    4<br>可以将结果的初始值设为 nn，再对数组中的每一个数以及它的下标进行一个异或运算，即：<br>$$<br>\begin{aligned} \mathrm{missing} &amp;= 4 \wedge (0 \wedge 0) \wedge (1 \wedge 1) \wedge (2 \wedge 3) \wedge (3 \wedge 4) \ &amp;= (4 \wedge 4) \wedge (0 \wedge 0) \wedge (1 \wedge 1) \wedge (3 \wedge 3) \wedge 2 \ &amp;= 0 \wedge 0 \wedge 0 \wedge 0 \wedge 2 \ &amp;= 2 \end{aligned}<br>$$</p>
<p>就得到了缺失的数字为 2。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> missing = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            missing ^= i^nums[i];</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h2><table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Likes</th>
<th align="center">Dislikes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy (44.66%)</td>
<td align="center">358</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>删除链表中等于给定值 <strong><em>val\</em></strong> 的所有节点。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val &#x3D; 6</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<h3 id="我的解法-4"><a href="#我的解法-4" class="headerlink" title="我的解法"></a>我的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;val == val)</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        ListNode *res = head;</span><br><span class="line">        <span class="keyword">while</span>( res )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( res -&gt; next &amp;&amp; res-&gt;next-&gt;val == val )</span><br><span class="line">            &#123;</span><br><span class="line">                res-&gt;next = res-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            res=res-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM中的三角测量</title>
    <url>/2020/03/24/2020-03-24-Triangulation/</url>
    <content><![CDATA[<p>三角测量是SLAM中，利用相机运动估计特征点空间位置的过程。</p>
<p>本节旨在解决以下问题：</p>
<ol>
<li>三角测量的概念</li>
<li>三角测量的过程及代码实现；</li>
<li>三角测量有哪些不确定性</li>
<li>如何提高三角测量的精度</li>
</ol>
<a id="more"></a>

<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>在SLAM中，利用对极几何约束估计相机运动之后，我们还需要通过三角测量来估计地图点的深度。三角测量（三角化）指的是，通过在两处观测同一个点的夹角，从而确定该点的距离。</p>
<p>SLAM中主要用三角化来估计像素点的距离。</p>
<p><img src="/2020/03/24/2020-03-24-Triangulation/%E4%B8%89%E8%A7%92%E6%B5%8B%E9%87%8F.png" alt="image-20200324165223362"></p>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h2><p>按照对极几何的定义，设$x_1,x_2$为两个特征点的归一化坐标，那么他们满足：<br>$$<br>s_1x_1=s_2Rx_2+t.<br>$$<br>经过对极几何之后，已得到了运动$R,t$，需要求解两个特征点的深度$s_1$,$s_2$。</p>
<p>两个深度可以分开算。若先算$s_2$,那么对上市两个做成一个$x_1$^,得：</p>
<p><img src="/2020/03/24/2020-03-24-Triangulation/%E6%96%B9%E7%A8%8B.png" alt="image-20200324170444757"></p>
<p>该式子左侧为0，右侧可看成是$s_2$的一个方程，可以根据它直接求$s_2$。有了$s_2$,$s_1$也非常容易求出。预测就可以得到两帧下的深度，即确定了空间坐标。</p>
<h2 id="3-代码实现；"><a href="#3-代码实现；" class="headerlink" title="3. 代码实现；"></a>3. 代码实现；</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangulation</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="built_in">vector</span>&lt;KeyPoint&gt;&amp; keypoint_1,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="built_in">vector</span>&lt;KeyPoint&gt;&amp; keypoint_2,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt;&amp; matches,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> Mat&amp; R, <span class="keyword">const</span> Mat&amp; t,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="built_in">vector</span>&lt;Point3d&gt;&amp; points</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangulation</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="built_in">vector</span>&lt; KeyPoint &gt;&amp; keypoint_1,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="built_in">vector</span>&lt; KeyPoint &gt;&amp; keypoint_2,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt;&amp; matches,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> Mat&amp; R, <span class="keyword">const</span> Mat&amp; t,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="built_in">vector</span>&lt; Point3d &gt;&amp; points )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mat T1 = (Mat_&lt;<span class="keyword">double</span>&gt; (<span class="number">3</span>,<span class="number">4</span>) &lt;&lt;</span><br><span class="line">	<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	Mat T2 = (Mat_&lt;<span class="keyword">double</span>&gt; (<span class="number">3</span>,<span class="number">4</span>) &lt;&lt;</span><br><span class="line">	R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">	R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">	R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Mat K = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point2d&gt; pts_1, pts_2;</span><br><span class="line">    <span class="keyword">for</span> ( DMatch m:matches )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将像素坐标转换至相机坐标</span></span><br><span class="line">        pts_1.push_back ( pixel2cam( keypoint_1[m.queryIdx].pt, K) );</span><br><span class="line">        pts_2.push_back ( pixel2cam( keypoint_2[m.trainIdx].pt, K) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat pts_4d;</span><br><span class="line">    cv::triangulatePoints( T1, T2, pts_1, pts_2, pts_4d );</span><br><span class="line">    <span class="comment">// 转换成非齐次坐标</span></span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pts_4d.cols; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">        Mat x = pts_4d.col(i);</span><br><span class="line">        x /= x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>,<span class="number">0</span>); <span class="comment">// 归一化</span></span><br><span class="line">        <span class="function">Point3d <span class="title">p</span> <span class="params">(x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>),x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>),x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">	points.push_back( p );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，在main函数中增加三角测量部分，并验证重投影关系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>∗∗ argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// .....</span></span><br><span class="line">	<span class="comment">//􀀀􀀀 三角化</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Point3d&gt; points;</span><br><span class="line">	triangulation( keypoints_1, keypoints_2, matches, R, t, points );</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//􀀀􀀀 验证三角化点与特征点的重投影关系</span></span><br><span class="line">	Mat K = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matches.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Point2d pt1_cam = pixel2cam( keypoints_1[ matches[i].queryIdx ].pt, K );</span><br><span class="line">        <span class="function">Point2d <span class="title">pt1_cam_3d</span> <span class="params">(points[i].x/points[i].z, points[i].y/points[i].z )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"point in the first camera frame: "</span>&lt;&lt;pt1_cam&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"point projected from 3D "</span>&lt;&lt;pt1_cam_3d&lt;&lt;<span class="string">", d="</span>&lt;&lt;points[i].z&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2幅图</span></span><br><span class="line">        Point2f pt2_cam = pixel2cam( keypoints_2[ matches[i].trainIdx ].pt, K );</span><br><span class="line">        Mat pt2_trans = R∗( Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>,<span class="number">1</span>) &lt;&lt; points[i].x, points[i].y, points[i].z ) + t;</span><br><span class="line">        pt2_trans /= pt2_trans.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"point in the second camera frame: "</span>&lt;&lt;pt2_cam&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"point reprojected from second frame: "</span>&lt;&lt;pt2_trans.t()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们打印了每个空间点在两个相机坐标系下的投影坐标与像素坐标——相当于P 的投影位置与看到的特征点位置。由于误差的存在，它们会有一些微小的差异。以下是某一特征点的信息：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">point</span> in the first camera frame: [<span class="number">0.0844072</span>, <span class="number">0.0734976</span>]</span><br><span class="line"><span class="built_in">point</span> projected from <span class="number">3</span>D [<span class="number">0.0843702</span>, <span class="number">0.0743606</span>], d=<span class="number">14.9895</span></span><br><span class="line"><span class="built_in">point</span> in the second camera frame: [<span class="number">0.0431343</span>, <span class="number">0.0459876</span>]</span><br><span class="line"><span class="built_in">point</span> reprojected from second frame: [<span class="number">0.04312769812378599</span>, <span class="number">0.04515455276163744</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>可以看到，误差的量级大约在小数点后第3 位。可以看到，三角化特征点的距离大约为15。</p>
<p>但由于尺度不确定性，我们并不知道这里的15 究竟是多少米。</p>
<h2 id="4-不确定性因素"><a href="#4-不确定性因素" class="headerlink" title="4. 不确定性因素"></a>4. 不确定性因素</h2><ol>
<li>由于<strong>噪声</strong>的存在，我们估得的运动R; t 不一定精确使(1)式为零，所以更常见的做法是求最小二乘解而不是零解。</li>
<li>三角测量是由平移得到的，有平移才会有对极几何中的三角形，才谈得上三角测量。因此，<strong>纯旋转</strong>是无法使用三角测量的，因为对极约束将永远满足。在平移存在的情况下，我们还要关心三角测量的不确定性，这会引出一个三角测量的矛盾</li>
<li>当平移很小时，<strong>像素上的不确定性</strong>将导致较大的深度不确定性。即若特征点运动一个像素x，使得视线角变化了一个角度，那么将测量到深度值有d 的变化。从几何关系可以看出，当t 较大时，d 将明显变小，这说明平移较大时，在同样的相机分辨率下，三角化测量将更精确。对该过程的定量分析可以使用正弦定理得到，不过这里先考虑定性分析。</li>
</ol>
<h2 id="5-如何提高精度"><a href="#5-如何提高精度" class="headerlink" title="5. 如何提高精度"></a>5. 如何提高精度</h2><p>要提高三角化的精度，主要有两种方法：</p>
<ol>
<li>提高特征点的提取精度，也就是提高图像分辨率——但这会导致图像变大，增加计算成本。</li>
<li>使平移量增大。但是，这会导致图像的外观发生明显的变化，比如箱子原先被挡住的侧面显示出来，又比如反射光发生变化，等等。外观变化会使得特征提取与匹配变得困难。</li>
</ol>
<p>总而言之，增大平移，会导致匹配失效；而平移太小，则三角化精度不够——这就是三角化的矛盾。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>面试</tag>
        <tag>三角化</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-24</title>
    <url>/2020/03/24/2020-03-24-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li><p>面试题17.16、按摩师 【每日打卡24】</p>
</li>
<li><p>198、打家劫舍</p>
</li>
<li><p>213、打家劫舍II</p>
</li>
</ol>
<a id="more"></a>

<h2 id="面试题17-16-按摩师"><a href="#面试题17-16-按摩师" class="headerlink" title="面试题17.16 按摩师"></a>面试题17.16 按摩师</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入： [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出： <span class="number">4</span></span><br><span class="line">解释： 选择 <span class="number">1</span> 号预约和 <span class="number">3</span> 号预约，总时长 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span>。</span><br></pre></td></tr></table></figure>

<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入： [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出： <span class="number">12</span></span><br><span class="line">解释： 选择 <span class="number">1</span> 号预约、 <span class="number">3</span> 号预约和 <span class="number">5</span> 号预约，总时长 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span>。</span><br></pre></td></tr></table></figure>

<h4 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入： [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出： <span class="number">12</span></span><br><span class="line">解释： 选择 <span class="number">1</span> 号预约、 <span class="number">3</span> 号预约、 <span class="number">5</span> 号预约和 <span class="number">8</span> 号预约，总时长 = <span class="number">2</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">3</span> = <span class="number">12</span>。</span><br></pre></td></tr></table></figure>

<h4 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h4><p><strong>动态规划</strong></p>
<p>状态转移方程：<br>$$<br>dp[i]=max[dp[i-1],dp[i-2]+nums[i]]<br>$$</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">time</span><span class="params">(s,<span class="number">0</span>)</span></span>;</span><br><span class="line">        time[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        time[<span class="number">1</span>] = max(time[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt; s;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            time[i] = max(time[i<span class="number">-1</span>],time[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time[s<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相似题目：<code>198.打家劫舍</code></p>
<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍|"></a>198. 打家劫舍|</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><p><strong>动态规划</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>( s==<span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( s==<span class="number">1</span> ) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">money</span><span class="params">(s,<span class="number">0</span>)</span></span>;</span><br><span class="line">        money[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        money[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;s;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            money[i]=<span class="built_in">max</span>(money[i<span class="number">-1</span>],money[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money[s<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="213-打家劫舍"><a href="#213-打家劫舍" class="headerlink" title="213. 打家劫舍||"></a>213. 打家劫舍||</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>

<h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<h4 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,3,6,7,10,7,1,8,5,9,1,4,4,3]</span><br><span class="line">输出：41</span><br></pre></td></tr></table></figure>



<h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>在原来的基础标记是否使用过0号元素。但是考虑情况还不够，需要另外设置一个数组来防止中间标记都消失的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = nums.size();</span><br><span class="line">        <span class="keyword">if</span>( s==<span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( s==<span class="number">1</span> ) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">flag</span><span class="params">(s,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">money</span><span class="params">(s,<span class="number">0</span>)</span></span>;</span><br><span class="line">        money[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        money[<span class="number">1</span>]=max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> money[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">money0</span><span class="params">(s,<span class="number">0</span>)</span></span>;</span><br><span class="line">        money0[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        flag[<span class="number">1</span>] = nums[<span class="number">1</span>]&lt;nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;s<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            money0[i] = max(money0[i<span class="number">-1</span>],money0[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">            flag[i]=money[i<span class="number">-1</span>]&gt;money[i<span class="number">-2</span>]+nums[i]?flag[i<span class="number">-1</span>]:flag[i<span class="number">-2</span>];</span><br><span class="line">            money[i] = max(money[i<span class="number">-1</span>],money[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        money0[s<span class="number">-1</span>] = max(money0[s<span class="number">-2</span>],money0[s<span class="number">-3</span>]+nums[s<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(flag[s<span class="number">-3</span>])</span><br><span class="line">            money[s<span class="number">-1</span>]=money[s<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            money[s<span class="number">-1</span>]=max(money[s<span class="number">-2</span>],money[s<span class="number">-3</span>]+nums[s<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> max(money[s<span class="number">-1</span>],money0[s<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它思路："><a href="#其它思路：" class="headerlink" title="其它思路："></a>其它思路：</h3><ol>
<li>要求第0家和第n-1家永远也不能同时被偷，所以考虑第0家的时候不要包含第n-1家，考虑第n-1家的时候不要包含第0家；用这两个线性表分别去做198题的动态规划，取大的即可</li>
</ol>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>每日打卡</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM初始化</title>
    <url>/2020/03/23/2020-03-24-SLAM%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>本节的学习要点：</p>
<ol>
<li>初始化的目的(单目/双目)</li>
<li>初始化的两种方法</li>
<li>初始化过程</li>
</ol>
<a id="more"></a>

<h2 id="初始化的目的"><a href="#初始化的目的" class="headerlink" title="初始化的目的"></a>初始化的目的</h2><p>​        单目SLAM初始化的目的是 ==<strong>构建初始的三维点云地图（空间点）并为之后的计算提供初始值</strong>==。</p>
<p>​        由于仅从单帧的图像不能得到深度信息，因此需要从图像序列中选取两帧以上的图像以估计相机机姿态并重建出初始的三维点云。</p>
<h2 id="常见的方法"><a href="#常见的方法" class="headerlink" title="常见的方法"></a>常见的方法</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​        追踪一个已知物体。单帧图像的每一个点都对应于空间的一条射线。通过不同角度不同位置扫描同一个物体，期望能够将三维点的不确定性缩小到可接受的范围。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​        基于假设空间存在一个平面物体，选取两帧不同位置的图像，通过计算<strong>单应矩阵</strong>来估计位姿。这类方法在视差较小或者平面上的点靠近某个主点时效果不好。</p>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>​        根据两帧之间的特征点匹配计算<strong>基础矩阵</strong>，进一步估计位姿。这种方法要求存在不共面的特征点。</p>
<h2 id="单目初始化"><a href="#单目初始化" class="headerlink" title="单目初始化"></a>单目初始化</h2><h3 id="方法流程"><a href="#方法流程" class="headerlink" title="方法流程"></a>方法流程</h3><ol>
<li>匹配初始帧；</li>
<li>位姿计算；</li>
<li>三角测量和地图创建；</li>
<li>BA优化。</li>
</ol>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><h4 id="1-匹配初始帧"><a href="#1-匹配初始帧" class="headerlink" title="1. 匹配初始帧"></a>1. 匹配初始帧</h4><p>​        该阶段工作是，根据连续两帧图片中能够匹配的特征点数量来判断其是否可以作为初始帧，即只有连续两帧中能够匹配的特征点的数量大于某个值时才认为该帧（前一帧）为初始帧；<br>​        在ORM-SLAM2中认为连续帧匹配点的数量大于100时可以将前一帧作为初始帧并记录两帧的匹配关系；<br>​        以下是在ORB-SLAM2中相关部分的代码，功能为对两帧图片进行ORB特征点提取并进行匹配，当匹配的点的数量大于100时认为前一帧可以作为初始帧；可以通过修改代码中的参数来调整判断是否能够作为初始帧的条件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nmatches = matcher.SearchForInitialization(mInitialFrame,mCurrentFrame,mvbPrevMatched,mvIniMatches,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>



<h4 id="2-位姿计算"><a href="#2-位姿计算" class="headerlink" title="2. 位姿计算"></a>2. 位姿计算</h4><p>​        得到超过100对匹配点后，ORB-SLAM2同时计算适用于平面场景的单应矩阵H和适用于普通场景的基础矩阵F;<br>方法是：首先由抽样点计算出单次抽样的H（四对点）和F矩阵（八点法）,通过若干次RANSAC抽样计算出最优的H和F矩阵；然后选择最合适的结果作为相机的初始位姿。</p>
<h5 id="2-1-八点法"><a href="#2-1-八点法" class="headerlink" title="2.1. 八点法"></a>2.1. 八点法</h5><p>相机位姿估计问题是为了求解本质矩阵E或者基础矩阵F，然后求解旋转R和平移t。<br> 对于E矩阵认为是一个3*3的矩阵，因为任意常数乘以E不变，所以E矩阵的自由度是8。实际上E矩阵的自由度是5（反对称），但是对于SLAM运算中八点法和五点法区别不大且会增加麻烦所以我们只考虑E矩阵的尺度等价性用八点法来计算），从上式可以看出一对点可以确定一个关于E矩阵的方程，8个自由度就需要8对点来求解E矩阵，这就是八点法。</p>
<h5 id="2-2-计算位姿"><a href="#2-2-计算位姿" class="headerlink" title="2.2 计算位姿"></a>2.2 计算位姿</h5><p>在同时计算单应矩阵和基础矩阵后对两个模型进行打分选择得分高的那个模型用来位姿计算，打分是用求得的E矩阵和F矩阵将前一帧上的特征点投影到下一帧并将下一帧的特征点投影到前一帧来计算重投影误差的和，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat Hn = ComputeH21(vPn1i,vPn2i); <span class="comment">//计算单应矩阵        </span></span><br><span class="line">currentScore = CheckHomography(H21i, H12i, vbCurrentInliers, mSigma); <span class="comment">//进行评分</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat Fn = ComputeF21(vPn1i,vPn2i);<span class="comment">//计算基础矩阵         </span></span><br><span class="line">currentScore = CheckFundamental(F21i, vbCurrentInliers, mSigma);<span class="comment">//   进行评分</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> RH = SH/(SH+SF);<span class="comment">//计算评分比,如果RH&gt;0.4，选择单应矩阵来恢复相机位姿，否则选择基础矩阵来恢复相机位姿。</span></span><br></pre></td></tr></table></figure>

<p>在计算完E矩阵和F矩阵并确定模型后，如果是本质矩阵E，进行SVD分解会得到4组可能的R，t，对这些解进行检查求出唯一真正的解；如果是单应矩阵进行分解（数值法、解析法）得到4组解，利用先验信息进行排除得到唯一解。</p>
<h4 id="3-三角测量和地图创建"><a href="#3-三角测量和地图创建" class="headerlink" title="3. 三角测量和地图创建"></a>3. 三角测量和地图创建</h4><p>已知位姿后通过三角测量可以计算出特征点对应的深度从而生成点云；并以第一帧为世界坐标系创建地图并进行数据关联。</p>
<p>三角测量是指通过在两处观察同一个点的夹角从而确定该点的距离。数学上可以从上式进行求解，设$x_1$,$x_2$是两个特征点的归一化坐标，那么存在<br>$$<br>s_1x_1=s_2Rx_2+t<br>$$<br>现在已知$R$,$t$要求解$s_1$,$s_2$,先求解$s_2$,对上式左乘$x_1$^:</p>
<p><img src="/2020/03/23/2020-03-24-SLAM%E5%88%9D%E5%A7%8B%E5%8C%96/image-20200323214017168.png" alt="image-20200323214017168"></p>
<h5 id="数据关联"><a href="#数据关联" class="headerlink" title="数据关联"></a>数据关联</h5><ol>
<li><strong>地图点与关键帧关联</strong></li>
</ol>
<p>一个地图点可被多个关键帧观测到，将观测到这个地图点的关键帧与这个地图点进行关联，同时记录关键帧上哪一个特征点与这个地图点有关联。对于单目初始化来说，地图点需要关联第一步创建的两个关键帧；地图点与关键帧上的特征点关联后，计算最合适的描述子来描述该地图点，用于之后跟踪的匹配。</p>
<ol start="2">
<li><strong>关键帧与地图点关联</strong></li>
</ol>
<p>一个关键帧上的特征点由多个地图点投影而成，将关键帧与地图点关联。</p>
<ol start="3">
<li><strong>关键帧与关键帧关联</strong></li>
</ol>
<p>关键帧之间会共视一个地图点，如果共视的地图点个数越多，说明这两个关键帧之间的联系越紧密。对于某个关键帧，统计其与其他关键帧共视的特征点个数，如果大于某个阈值，那么将这两个关键帧进行关联。</p>
<ol start="4">
<li><strong>将关键帧和地图点加入到地图中</strong></li>
</ol>
<h4 id="4-BA优化。"><a href="#4-BA优化。" class="headerlink" title="4. BA优化。"></a>4. BA优化。</h4><p>初始化的最后一步将对只有两个关键帧的地图进行BA优化来优化位姿和路标点，以优化后的结果来重新生成点云地图。<br>同局部BA优化来最小化重投影误差不同，全局BA优化是在求解观测误差的最小二乘。由于观测误差的最小二乘是非线性的，利用了雅克比矩阵和H矩阵的稀疏性进行边缘化来简化运算，其中也使用了图优化理论。<br>实际上求解观测误差的最小二乘的过程是较复杂的，在这里就不多赘述了。<br>值得一提的是，由于单目没有尺度，因此在地图尺寸初始化时<strong>选择生成点深度的中位数作为单位尺寸1当作基准</strong>来进行地图的尺寸初始化。</p>
<h2 id="双目初始化"><a href="#双目初始化" class="headerlink" title="双目初始化"></a>双目初始化</h2><p>由于双目和RGB-D相机不需要通过两个相邻帧来恢复地图点深度，所以初始化过程极其相似。</p>
<p>只要得到两个满足条件的关键帧即可开始初始化。</p>
<p>双目/RGB-D相机已知若干个特征点的深度（通过双目匹配、结构光或者飞行时间等深度计算方法），可以求解二维点对应的世界坐标系下的空间点，即已知若干个3D空间点及其投影的位置；此时使用PnP来估计相机运动;PnP问题的求解方法有很多种，包括<code>P3P</code>, <code>DLT</code>,<code>EPnP</code>,<code>UPnP</code>, BA等，其中<code>ORM-SLAM2</code>使用的<code>PnP</code>方法是<code>EPnP</code>,具体计算方不作赘述。</p>
<h2 id="RGB-D初始化"><a href="#RGB-D初始化" class="headerlink" title="RGB-D初始化"></a>RGB-D初始化</h2><ol>
<li>初始化的目的是建立三维的空间点和地图并为之后的计算提供初始值；</li>
<li>同双目/RGB-D SLAM不同，单目SLAM无法从一帧图片中计算出深度，因此初始化需要两帧连续满足条件的图片来进行初始化；</li>
<li>单目SLAM初始化计算位姿是一个对极约束问题，而双目/RGB-D SLAM的初始化计算位姿是一个PnP问题；</li>
<li>在初始化成功后单目SLAM和双目SLAM一样是通过PnP来求解相机位姿的；</li>
<li>单目SLAM尺度不确定性的原因是因为在通过SVD分解E矩阵求解R，t时计算的t是没有单位的；</li>
<li>单目SLAM初始化的过程中对t进行了归一化来固定尺度，即以求解的初始帧的t为单位1，而后的轨迹和平移都将以这个t为单位；</li>
<li>单目SLAM的初始化一定要有一定程度的平移，纯旋转是无法完成初始化的。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>初始化</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM初始化</title>
    <url>/2020/03/23/2020-03-24-SLAM%20Init/</url>
    <content><![CDATA[<p>本节的学习要点：</p>
<ol>
<li>初始化的目的(单目/双目)</li>
<li>初始化的两种方法</li>
<li>初始化过程</li>
</ol>
<a id="more"></a>

<h2 id="初始化的目的"><a href="#初始化的目的" class="headerlink" title="初始化的目的"></a>初始化的目的</h2><p>​        单目SLAM初始化的目的是 ==<strong>构建初始的三维点云地图（空间点）并为之后的计算提供初始值</strong>==。</p>
<p>​        由于仅从单帧的图像不能得到深度信息，因此需要从图像序列中选取两帧以上的图像以估计相机机姿态并重建出初始的三维点云。</p>
<h2 id="常见的方法"><a href="#常见的方法" class="headerlink" title="常见的方法"></a>常见的方法</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​        追踪一个已知物体。单帧图像的每一个点都对应于空间的一条射线。通过不同角度不同位置扫描同一个物体，期望能够将三维点的不确定性缩小到可接受的范围。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​        基于假设空间存在一个平面物体，选取两帧不同位置的图像，通过计算<strong>单应矩阵</strong>来估计位姿。这类方法在视差较小或者平面上的点靠近某个主点时效果不好。</p>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>​        根据两帧之间的特征点匹配计算<strong>基础矩阵</strong>，进一步估计位姿。这种方法要求存在不共面的特征点。</p>
<h2 id="单目初始化"><a href="#单目初始化" class="headerlink" title="单目初始化"></a>单目初始化</h2><h3 id="方法流程"><a href="#方法流程" class="headerlink" title="方法流程"></a>方法流程</h3><ol>
<li>匹配初始帧；</li>
<li>位姿计算；</li>
<li>三角测量和地图创建；</li>
<li>BA优化。</li>
</ol>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><h4 id="1-匹配初始帧"><a href="#1-匹配初始帧" class="headerlink" title="1. 匹配初始帧"></a>1. 匹配初始帧</h4><p>​        该阶段工作是，根据连续两帧图片中能够匹配的特征点数量来判断其是否可以作为初始帧，即只有连续两帧中能够匹配的特征点的数量大于某个值时才认为该帧（前一帧）为初始帧；<br>​        在ORM-SLAM2中认为连续帧匹配点的数量大于100时可以将前一帧作为初始帧并记录两帧的匹配关系；<br>​        以下是在ORB-SLAM2中相关部分的代码，功能为对两帧图片进行ORB特征点提取并进行匹配，当匹配的点的数量大于100时认为前一帧可以作为初始帧；可以通过修改代码中的参数来调整判断是否能够作为初始帧的条件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nmatches = matcher.SearchForInitialization(mInitialFrame,mCurrentFrame,mvbPrevMatched,mvIniMatches,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>



<h4 id="2-位姿计算"><a href="#2-位姿计算" class="headerlink" title="2. 位姿计算"></a>2. 位姿计算</h4><p>​        得到超过100对匹配点后，ORB-SLAM2同时计算适用于平面场景的单应矩阵H和适用于普通场景的基础矩阵F;<br>方法是：首先由抽样点计算出单次抽样的H（四对点）和F矩阵（八点法）,通过若干次RANSAC抽样计算出最优的H和F矩阵；然后选择最合适的结果作为相机的初始位姿。</p>
<h5 id="2-1-八点法"><a href="#2-1-八点法" class="headerlink" title="2.1. 八点法"></a>2.1. 八点法</h5><p>相机位姿估计问题是为了求解本质矩阵E或者基础矩阵F，然后求解旋转R和平移t。<br> 对于E矩阵认为是一个3*3的矩阵，因为任意常数乘以E不变，所以E矩阵的自由度是8。实际上E矩阵的自由度是5（反对称），但是对于SLAM运算中八点法和五点法区别不大且会增加麻烦所以我们只考虑E矩阵的尺度等价性用八点法来计算），从上式可以看出一对点可以确定一个关于E矩阵的方程，8个自由度就需要8对点来求解E矩阵，这就是八点法。</p>
<h5 id="2-2-计算位姿"><a href="#2-2-计算位姿" class="headerlink" title="2.2 计算位姿"></a>2.2 计算位姿</h5><p>在同时计算单应矩阵和基础矩阵后对两个模型进行打分选择得分高的那个模型用来位姿计算，打分是用求得的E矩阵和F矩阵将前一帧上的特征点投影到下一帧并将下一帧的特征点投影到前一帧来计算重投影误差的和，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat Hn = ComputeH21(vPn1i,vPn2i); <span class="comment">//计算单应矩阵        </span></span><br><span class="line">currentScore = CheckHomography(H21i, H12i, vbCurrentInliers, mSigma); <span class="comment">//进行评分</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat Fn = ComputeF21(vPn1i,vPn2i);<span class="comment">//计算基础矩阵         </span></span><br><span class="line">currentScore = CheckFundamental(F21i, vbCurrentInliers, mSigma);<span class="comment">//   进行评分</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> RH = SH/(SH+SF);<span class="comment">//计算评分比,如果RH&gt;0.4，选择单应矩阵来恢复相机位姿，否则选择基础矩阵来恢复相机位姿。</span></span><br></pre></td></tr></table></figure>

<p>在计算完E矩阵和F矩阵并确定模型后，如果是本质矩阵E，进行SVD分解会得到4组可能的R，t，对这些解进行检查求出唯一真正的解；如果是单应矩阵进行分解（数值法、解析法）得到4组解，利用先验信息进行排除得到唯一解。</p>
<h4 id="3-三角测量和地图创建"><a href="#3-三角测量和地图创建" class="headerlink" title="3. 三角测量和地图创建"></a>3. 三角测量和地图创建</h4><p>已知位姿后通过三角测量可以计算出特征点对应的深度从而生成点云；并以第一帧为世界坐标系创建地图并进行数据关联。</p>
<p>三角测量是指通过在两处观察同一个点的夹角从而确定该点的距离。数学上可以从上式进行求解，设$x_1$,$x_2$是两个特征点的归一化坐标，那么存在<br>$$<br>s_1x_1=s_2Rx_2+t<br>$$<br>现在已知$R$,$t$要求解$s_1$,$s_2$,先求解$s_2$,对上式左乘$x_1$^:</p>
<p><img src="/2020/03/23/2020-03-24-SLAM%20Init/image-20200323214017168.png" alt="image-20200323214017168"></p>
<h5 id="数据关联"><a href="#数据关联" class="headerlink" title="数据关联"></a>数据关联</h5><ol>
<li><strong>地图点与关键帧关联</strong></li>
</ol>
<p>一个地图点可被多个关键帧观测到，将观测到这个地图点的关键帧与这个地图点进行关联，同时记录关键帧上哪一个特征点与这个地图点有关联。对于单目初始化来说，地图点需要关联第一步创建的两个关键帧；地图点与关键帧上的特征点关联后，计算最合适的描述子来描述该地图点，用于之后跟踪的匹配。</p>
<ol start="2">
<li><strong>关键帧与地图点关联</strong></li>
</ol>
<p>一个关键帧上的特征点由多个地图点投影而成，将关键帧与地图点关联。</p>
<ol start="3">
<li><strong>关键帧与关键帧关联</strong></li>
</ol>
<p>关键帧之间会共视一个地图点，如果共视的地图点个数越多，说明这两个关键帧之间的联系越紧密。对于某个关键帧，统计其与其他关键帧共视的特征点个数，如果大于某个阈值，那么将这两个关键帧进行关联。</p>
<ol start="4">
<li><strong>将关键帧和地图点加入到地图中</strong></li>
</ol>
<h4 id="4-BA优化。"><a href="#4-BA优化。" class="headerlink" title="4. BA优化。"></a>4. BA优化。</h4><p>初始化的最后一步将对只有两个关键帧的地图进行BA优化来优化位姿和路标点，以优化后的结果来重新生成点云地图。<br>同局部BA优化来最小化重投影误差不同，全局BA优化是在求解观测误差的最小二乘。由于观测误差的最小二乘是非线性的，利用了雅克比矩阵和H矩阵的稀疏性进行边缘化来简化运算，其中也使用了图优化理论。<br>实际上求解观测误差的最小二乘的过程是较复杂的，在这里就不多赘述了。<br>值得一提的是，由于单目没有尺度，因此在地图尺寸初始化时<strong>选择生成点深度的中位数作为单位尺寸1当作基准</strong>来进行地图的尺寸初始化。</p>
<h2 id="双目初始化"><a href="#双目初始化" class="headerlink" title="双目初始化"></a>双目初始化</h2><p>由于双目和RGB-D相机不需要通过两个相邻帧来恢复地图点深度，所以初始化过程极其相似。</p>
<p>只要得到两个满足条件的关键帧即可开始初始化。</p>
<p>双目/RGB-D相机已知若干个特征点的深度（通过双目匹配、结构光或者飞行时间等深度计算方法），可以求解二维点对应的世界坐标系下的空间点，即已知若干个3D空间点及其投影的位置；此时使用PnP来估计相机运动;PnP问题的求解方法有很多种，包括<code>P3P</code>, <code>DLT</code>,<code>EPnP</code>,<code>UPnP</code>, BA等，其中<code>ORM-SLAM2</code>使用的<code>PnP</code>方法是<code>EPnP</code>,具体计算方不作赘述。</p>
<h2 id="RGB-D初始化"><a href="#RGB-D初始化" class="headerlink" title="RGB-D初始化"></a>RGB-D初始化</h2><ol>
<li>初始化的目的是建立三维的空间点和地图并为之后的计算提供初始值；</li>
<li>同双目/RGB-D SLAM不同，单目SLAM无法从一帧图片中计算出深度，因此初始化需要两帧连续满足条件的图片来进行初始化；</li>
<li>单目SLAM初始化计算位姿是一个对极约束问题，而双目/RGB-D SLAM的初始化计算位姿是一个PnP问题；</li>
<li>在初始化成功后单目SLAM和双目SLAM一样是通过PnP来求解相机位姿的；</li>
<li>单目SLAM尺度不确定性的原因是因为在通过SVD分解E矩阵求解R，t时计算的t是没有单位的；</li>
<li>单目SLAM初始化的过程中对t进行了归一化来固定尺度，即以求解的初始帧的t为单位1，而后的轨迹和平移都将以这个t为单位；</li>
<li>单目SLAM的初始化一定要有一定程度的平移，纯旋转是无法完成初始化的。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>初始化</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 每日打卡3-23</title>
    <url>/2020/03/23/2020-03-23-LeetCode-CheckDaily/</url>
    <content><![CDATA[<p>今日打卡题目如下：</p>
<ol>
<li><p>876、链表的中间结点 【每日打卡23】</p>
</li>
<li><p>190、颠倒二进制位</p>
</li>
<li><p>191、位1的个数</p>
</li>
</ol>
<a id="more"></a>

<h2 id="876、链表的中间结点"><a href="#876、链表的中间结点" class="headerlink" title="876、链表的中间结点"></a>876、链表的中间结点</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</span><br></pre></td></tr></table></figure>

<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：此列表中的结点 <span class="number">4</span> (序列化形式：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">由于该列表有两个中间结点，值分别为 <span class="number">3</span> 和 <span class="number">4</span>，我们返回第二个结点。</span><br></pre></td></tr></table></figure>

<h3 id="方法一：数组"><a href="#方法一：数组" class="headerlink" title="方法一：数组"></a>方法一：数组</h3><p>思路和算法</p>
<p>链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; A = &#123;head&#125;;</span><br><span class="line">        <span class="keyword">while</span> (A.back()-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            A.push_back(A.back()-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> A[A.size() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度</strong>：<code>O(N)</code>，其中 <code>N</code> 是给定链表中的结点数目。</p>
<p><strong>空间复杂度</strong>：<code>O(N)</code>，即数组 <code>A</code> 用去的空间。</p>
<h4 id="方法二：单指针法"><a href="#方法二：单指针法" class="headerlink" title="方法二：单指针法"></a>方法二：单指针法</h4><p>我们可以对方法一进行空间优化，省去数组 A。</p>
<p>我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ++n;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><p>时间复杂度：O(N)，其中 N 是给定链表的结点数目。</p>
<p>空间复杂度：<code>O(1)</code>，只需要常数空间存放变量和指针。</p>
<h3 id="快慢指针解法"><a href="#快慢指针解法" class="headerlink" title="快慢指针解法"></a>快慢指针解法</h3><p>快慢指针，使用一个快的一个慢的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* back = head;</span><br><span class="line">        ListNode* front = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(back&amp;&amp;front)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( front &amp;&amp;front-&gt;next)</span><br><span class="line">                front=front-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!front)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> back;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!front-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> back-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            back=back-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> back;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：<code>O(n)</code></p>
<p><strong>空间复杂度</strong>：<code>O(1)</code></p>
<h2 id="190、颠倒二进制位"><a href="#190、颠倒二进制位" class="headerlink" title="190、颠倒二进制位"></a>190、颠倒二进制位</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<h4 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>

<h4 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>

<h4 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>

<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>本题考查位操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bit ++;</span><br><span class="line">            <span class="keyword">int</span> i=n&amp;<span class="number">1</span>;</span><br><span class="line">            n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            res=(res&lt;&lt;<span class="number">1</span>)|i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res=bit==<span class="number">0</span>?<span class="number">0</span>:res&lt;&lt;(<span class="number">32</span>-bit);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="191、位1的个数"><a href="#191、位1的个数" class="headerlink" title="191、位1的个数"></a>191、位1的个数</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量" target="_blank" rel="noopener">汉明重量</a>）。</p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000000001011</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000000001011</span> 中，共有三位为 <span class="string">'1'</span>。</span><br></pre></td></tr></table></figure>

<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000010000000</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000010000000</span> 中，共有一位为 <span class="string">'1'</span>。</span><br></pre></td></tr></table></figure>

<h4 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">31</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 中，共有 <span class="number">31</span> 位为 <span class="string">'1'</span>。</span><br></pre></td></tr></table></figure>

<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i+=n&amp;<span class="number">1</span>;</span><br><span class="line">            n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>每日打卡</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP-Algorithm</title>
    <url>/2020/03/22/2020-03-22-KMP-Algorithm/</url>
    <content><![CDATA[<p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？</p>
<h2 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h2><p>如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</p>
<ul>
<li>如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；</li>
<li>如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li>
</ul>
<p>回溯的方法使得算法复杂度上升。</p>
<p>因此需要优化回溯的步骤以简化算法。</p>
<p>源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 字符串下标始于 0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NaiveStringSearch</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">// S 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;    <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> s_len = S.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> p_len = P.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == P[j])  <span class="comment">// 若相等，都前进一步</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>               <span class="comment">// 不相等</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == p_len)        <span class="comment">// 匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(nm)$</p>
<p>当n和m很大的时候不好用。</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p><strong>引入概念</strong></p>
<ul>
<li>前缀：指的是字符串的子串中从原串最前面开始的子串</li>
<li>后缀：指的是字符串的子串中在原串结尾处结尾的子串</li>
</ul>
<p><strong>算法思想</strong></p>
<p>利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。</p>
<p>KMP算法引入了一个next数组，next[i]表示的是前i的字符组成的这个子串。</p>
<p><strong>next数组的意义</strong></p>
<p>next 数组里面的变量，存的是最有可能匹配的长度，也就是在模式串中，前缀和后缀相等的最大长度。</p>
<p>以”ABCDABD”为例</p>
<p>－”A”的前缀和后缀都为空集，共有元素的长度为0；</p>
<p>－”AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</p>
<p>－”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</p>
<p>－”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</p>
<p>－”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</p>
<p>－”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</p>
<p>－”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</p>
<p>next 数组中，第一个值，也就是next [0] = -1，而且，next [n]里面存的是 str[0] ~ str[n - 1]的前缀和后缀相等的最大长度。</p>
<p><strong>源代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p_len = P.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; p_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 S 中找到 P 第一次出现的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GetNext(P, next);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// S 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> s_len = S.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> p_len = P.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len) <span class="comment">// 因为末尾 '\0' 的存在，所以不会越界</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == P[j])  <span class="comment">// P 的第一个字符不匹配或 S[i] == P[j]</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];  <span class="comment">// 当前字符匹配失败，进行跳转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == p_len)  <span class="comment">// 匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; KMP(<span class="string">"bbc abcdab abcdabcdabde"</span>, <span class="string">"abcdabd"</span>, next) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：$O(m+n)$</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第181场周赛</title>
    <url>/2020/03/22/2020-03-20-LeetCode-Contest-181/</url>
    <content><![CDATA[<p>第 181 场周赛</p>
<p>题目列表如下：</p>
<ol>
<li>按既定顺序创建目标数组</li>
<li>四因数</li>
<li>检查网络中是否存在有效路径</li>
<li>最长快乐前缀</li>
</ol>
<a id="more"></a>

<h2 id="1-按既定顺序创建目标数组"><a href="#1-按既定顺序创建目标数组" class="headerlink" title="1. 按既定顺序创建目标数组"></a>1. 按既定顺序创建目标数组</h2><p><strong>题目</strong></p>
<p>给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组：</p>
<ul>
<li>目标数组 target 最初为空</li>
<li>按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] </li>
<li>重复上一步，直到在 nums 和 index 中都没有要读取的元素。<br>请你返回目标数组</li>
</ul>
<p>题目保证数字插入位置总是存在。</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,2,3,4], index &#x3D; [0,1,2,2,1]</span><br><span class="line">输出：[0,4,1,3,2]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">0            0        [0]</span><br><span class="line">1            1        [0,1]</span><br><span class="line">2            2        [0,1,2]</span><br><span class="line">3            2        [0,1,3,2]</span><br><span class="line">4            1        [0,4,1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,0], index &#x3D; [0,1,2,3,0]</span><br><span class="line">输出：[0,1,2,3,4]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">1            0        [1]</span><br><span class="line">2            1        [1,2]</span><br><span class="line">3            2        [1,2,3]</span><br><span class="line">4            3        [1,2,3,4]</span><br><span class="line">0            0        [0,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1], index &#x3D; [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; nums.length, index.length &lt;&#x3D; 100</span><br><span class="line">nums.length &#x3D;&#x3D; index.length</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</span><br><span class="line">0 &lt;&#x3D; index[i] &lt;&#x3D; i</span><br></pre></td></tr></table></figure>

<h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>用Vector容器存放结果,进行一次遍历,将取到的结果插入.</p>
<p><strong>源代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">createTargetArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; index)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.insert(res.<span class="built_in">begin</span>()+index[i],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>: $O(n^2)$</p>
<p><strong>空间复杂度</strong>:$O(1)$</p>
<h2 id="2-四因数"><a href="#2-四因数" class="headerlink" title="2. 四因数"></a>2. 四因数</h2><p>题目:给你一个整数数组 <code>nums</code>，请你返回该数组中恰有四个因数的这些整数的各因数之和。</p>
<p>如果数组中不存在满足题意的整数，则返回 <code>0</code> 。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [21,4,7]</span><br><span class="line">输出：32</span><br><span class="line">解释：</span><br><span class="line">21 有 4 个因数：1, 3, 7, 21</span><br><span class="line">4 有 3 个因数：1, 2, 4</span><br><span class="line">7 有 2 个因数：1, 7</span><br><span class="line">答案仅为 21 的所有因数的和。</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure>

<h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>这道题本身不难,但需要为了降低时间复杂度做出一些调整。比如，计算过的数就不要再计算一次可以使用hash表来存储键对。对每一个数进行计算因子的时候，出现了多于四个的因子就停止计算。我的方法通过了但是相信会有更快速的解法。</p>
<p><strong>源代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumFourDivisors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(num)==<span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">                <span class="built_in">map</span>.insert(make_pair(num,factors(num)));</span><br><span class="line">            sum+=<span class="built_in">map</span>[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">factors</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;=<span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count==<span class="number">3</span>?sum+n:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h3><p><strong>筛法</strong></p>
<ul>
<li>要注意完全四因数的情况</li>
</ul>
<h2 id="3-检查网格中是否存在有效路径"><a href="#3-检查网格中是否存在有效路径" class="headerlink" title="3. 检查网格中是否存在有效路径"></a>3. 检查网格中是否存在有效路径</h2><p><strong>题目</strong></p>
<p>给你一个 m x n 的网格 grid。网格里的每个单元都代表一条街道。grid[i][j] 的街道可以是：</p>
<p>1 表示连接左单元格和右单元格的街道。<br>2 表示连接上单元格和下单元格的街道。<br>3 表示连接左单元格和下单元格的街道。<br>4 表示连接右单元格和下单元格的街道。<br>5 表示连接左单元格和上单元格的街道。<br>6 表示连接右单元格和上单元格的街道。    </p>
<p><img src="/2020/03/22/2020-03-20-LeetCode-Contest-181/3.png" alt="lee"></p>
<h3 id="DFS解法"><a href="#DFS解法" class="headerlink" title="DFS解法"></a>DFS解法</h3><p>通过构建pipe数组，将每个拼图转化为四个方向上的移动限制图。<br>$pipe[3][2]=3$ ，代表三号拼图可以由向上的方向进入其中，并转向左方向继续前进。<br>$pipe[5][3]=-1$ ，代表五号拼图不可以由向左的方向进入其中。</p>
<p>其中0代表向下、1代表向右、2代表向上、3代表向左、-1代表不可走</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> row,col;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">//0下、1右、2上、3左</span></span><br><span class="line">    <span class="keyword">int</span> pipe[<span class="number">7</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//记录各个拼图块路径的方向，0、1、2、3代表方向，-1代表不可走。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> dir,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( x == row<span class="number">-1</span> &amp;&amp; y == col<span class="number">-1</span> ) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//到达终点</span></span><br><span class="line">        <span class="keyword">int</span> nextx = x + dx[dir] ,nexty = y + dy[dir];</span><br><span class="line">        <span class="keyword">if</span>(nextx&lt;<span class="number">0</span> || nexty&lt;<span class="number">0</span> || nextx &gt;= row || nexty&gt;=col)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//越界</span></span><br><span class="line">        <span class="keyword">int</span> nxt=grid[nextx][nexty]; <span class="comment">//得到下一块拼图的编号</span></span><br><span class="line">        <span class="keyword">if</span>( pipe[nxt][dir]!= <span class="number">-1</span> )</span><br><span class="line">            <span class="keyword">return</span> dfs(nextx,nexty,pipe[nxt][dir],grid); <span class="comment">//如果当前方向可走，则方向改变，继续走。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasValidPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;    </span><br><span class="line">        row=grid.<span class="built_in">size</span>();</span><br><span class="line">        col=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sta=grid[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//起点的拼图编号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)<span class="comment">//朝着四个方向都试一下</span></span><br><span class="line">            <span class="keyword">if</span>(pipe[sta][i]!=<span class="number">-1</span>)<span class="comment">//当前方向可以走</span></span><br><span class="line">                <span class="keyword">if</span>(dfs(<span class="number">0</span>,<span class="number">0</span>,pipe[sta][i],grid))<span class="comment">//沿着当前方向搜索</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//拼图都有两个方向可以走，只要沿着一个初始方向走通就可以。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="4-最长快乐前缀"><a href="#4-最长快乐前缀" class="headerlink" title="4. 最长快乐前缀"></a>4. 最长快乐前缀</h2><p>题目：「快乐前缀」是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串。</p>
<p>给你一个字符串 s，请你返回它的 最长快乐前缀。</p>
<p>如果不存在满足题意的前缀，则返回一个空字符串。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcodeleet&quot;</span><br><span class="line">输出：&quot;leet&quot;</span><br></pre></td></tr></table></figure>

<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPrefix</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j= i;j&lt;len;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[j-i]!=s[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    res = s.substr(i,len-i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果：超时</p>
<h3 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a><strong>Hash算法</strong></h3><p>可以使用 hash 算法，O(n)搞定该问题。</p>
<p>首先假设有一个足够大的数据类型可以装下我们所需要的数字。 后面会优化掉对该假设的依赖。</p>
<p>对于长度为 i 的前缀，我们可以计算其hash值，计算公式如下：<br>$$<br>prefix(i)=∑<em>{j=0}^{i−1}∗(s[i]−′a′)∗salt^j<br>$$<br>对于长度为 i 的后缀，我们可以计算其hash值，设字符串长度为 n，计算公式如下：<br>$$<br>suffix(i) =∑</em>{j=0}^{i−1}(s[n−i+j]−′a′)∗salt_j<br>$$<br>salt 是一个随机数，但最好是一个大的质数。<br>分析上述两个公式会发现，如果长度为 i 的前缀和后缀相等，那么必然有 prefix(i) == suffix(i)。而且在满足前述假设的前提下，不相等的前缀和后缀必然有 prefix(i) ≠ suffix(i)。</p>
<p>但是可惜的是，并没有在大多数编程语言中，并不存在这样的数据类型。从而导致了hash值冲突的问题，即不相等的前缀和后缀其hash值也有可能相同。那么如何解决该问题呢？</p>
<p>借鉴于通用的解决hash冲突的办法，我们可以增加 salt 的个数，以降低冲突的概率。当长度为 i 的前缀和后缀对于所有salt都相等时，我们才认为其真正的相等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; MAXN = <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">uint64_t</span> salt[MAXN] = &#123;<span class="number">1000007</span>, <span class="number">100000007</span>, <span class="number">1000000007</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; feature[<span class="number">2</span>][MAXN];</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPrefix</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">            feature[<span class="number">0</span>][i].resize(s.<span class="built_in">size</span>());</span><br><span class="line">            feature[<span class="number">1</span>][i].resize(s.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">uint64_t</span> mul = <span class="number">1</span>, k = <span class="number">0</span>, n = s.<span class="built_in">size</span>(); k &lt; n; k++, mul *= salt[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">                    feature[<span class="number">0</span>][i][k] = s[<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    feature[<span class="number">0</span>][i][k] = feature[<span class="number">0</span>][i][k<span class="number">-1</span>] + mul*(s[k]-<span class="string">'a'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = s.<span class="built_in">size</span>()<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k == s.<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">                    feature[<span class="number">1</span>][i][k] = s[k]-<span class="string">'a'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    feature[<span class="number">1</span>][i][k] = (s[k]-<span class="string">'a'</span>) + feature[<span class="number">1</span>][i][k+<span class="number">1</span>]*salt[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(feature[<span class="number">0</span>][<span class="number">0</span>][i] == feature[<span class="number">1</span>][<span class="number">0</span>][s.<span class="built_in">size</span>()-i<span class="number">-1</span>]</span><br><span class="line">              &amp;&amp; feature[<span class="number">0</span>][<span class="number">1</span>][i] == feature[<span class="number">1</span>][<span class="number">1</span>][s.<span class="built_in">size</span>()-i<span class="number">-1</span>]</span><br><span class="line">              &amp;&amp; feature[<span class="number">0</span>][<span class="number">2</span>][i] == feature[<span class="number">1</span>][<span class="number">2</span>][s.<span class="built_in">size</span>()-i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> s.substr(<span class="number">0</span>, i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">作者：Time-Limit</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/longest-happy-prefix/solution/c-on-de-hashsuan-fa-sui-ji-wen-ti-kan-lian-guo-by-/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>周赛</tag>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>粒子滤波器</title>
    <url>/2020/03/14/2020-03-15-Particle_Filter/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>粒子滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>高斯混合模型</title>
    <url>/2020/03/14/2020-03-14-GMM/</url>
    <content><![CDATA[<p>高斯混合模型</p>
<a id="more"></a>

<h2 id="高斯混合模型"><a href="#高斯混合模型" class="headerlink" title="高斯混合模型"></a>高斯混合模型</h2><p>概率图模型（ probabilistic graphical model）是一类用图来表达变量相关关系的概率模型。它以图为表示工具，最常见的是用一个结点表示一个或一组随机变量，结点之间的边表示变量间的概率相关关系，即“变量关系图”.根据边的性质不同，概率图模型可大致分为两类：</p>
<p>第一类是使用有向无环图表示变量间的依赖关系，称为有向图模型或贝叶斯网（ Bayesian network）；</p>
<p>第二类是使用无向图表示变量间的相关关系，称为无向图模型或马尔可夫网（ Markovnetwork）</p>
<p><strong>定义</strong></p>
<p>高斯混合模型是指具有如下形式的概率分布模型。<br>$$<br>P(y|\theta)=\sum^K_{k=1}\alpha_k\phi(y|\theta_k)<br>$$<br>其中，$\alpha_k$是系数，$\alpha_k\geq0$,$\sum^K_{k=1}\alpha_k=1$;$\phi(y|\theta_k)$是高斯分布密度，$\theta_k=(\mu_k,\delta^2_k)$;<br>$$<br>\phi(y|\theta_k)=\cfrac{1}{\sqrt{2\pi}\delta^2}exp(-\cfrac{(y-\mu_k)^2}{2\delta^2_k})<br>$$<br>称为第k个分模型。</p>
<p>一般混合模型可以由任意概率分布密度代替上式的高斯分布密度。</p>
<h3 id="高斯混合模型参数估计的EM算法"><a href="#高斯混合模型参数估计的EM算法" class="headerlink" title="高斯混合模型参数估计的EM算法"></a>高斯混合模型参数估计的EM算法</h3><p>概率模型有时既含有观测变量（ observable variable），又含有隐变量或潜在变量（ latent variable）.如果概率模型的变量都是观测变量，那么给定数据，可以直接用极大似然估计法，或贝叶斯估计法估计模型参数。但是，当模型含有隐变量时，就不能简单地使用这些估计方法。EM算法就是含有隐变量的概率模型参数的极大似然估计法，或极大后验概率估计法。我们仅讨论极大似然估计，极大后验概率估计与其类似。</p>
<p>假设观测数据$y_1,y_2,…,y_N$由高斯混合模型生成，<br>$$<br>P(y|\theta)=\sum^K_{k=1}\alpha_k\phi(y|\theta_k)<br>$$<br>其中，$\theta=(\alpha_1,\alpha_2,…,\alpha_k;\theta_1,\theta_2,\theta_k)$。我们用EM算法估计高斯混合模型的参数$\theta$。</p>
<p><strong>EM（期望最大化）算法</strong></p>
<p>输入：观测数据$y_1,y_2,…,y_N$，高斯混合模型；</p>
<p>输出：高斯混合模型参数。</p>
<ol>
<li><p>取参数的初始值开始迭代</p>
</li>
<li><p>求E步，根据当前模型参数，计算分模型k对观测数据$y_j$的相应度<br>$$<br>\hat{\gamma}<em>{jk}=\cfrac{\alpha_k\phi(y_j|\theta_k)}{\sum^K</em>{k=1}\alpha_k\phi(y_j|\theta_k)}，j=1,2,…N;k=1,2,..K<br>$$</p>
</li>
<li><p>求M步:计算新一轮的迭代的模型参数：<br>$$<br>\hat{\mu}<em>k=\cfrac{\sum^N</em>{j=1}\hat{\gamma}<em>{jk}y_j}{\sum^N</em>{j=1}\hat{\gamma}_{jk}},k=1,2,..,K<br>$$</p>
</li>
</ol>
<p>$$<br>\hat{\delta_k}^2=\cfrac{\sum^N_{j=1}\hat{gamma}<em>{jk}(y_j-\mu_k)^2}{\sum^N</em>{j=1}\hat{\gamma}_{jk}},k=1,2,…K<br>$$</p>
<p>$$<br>\hat{\alpha}<em>k=\cfrac{\sum^N_j=1\hat{\gamma</em>{jk}}}{N},k=1,2,…,K<br>$$</p>
<ol start="4">
<li>重复第二步和第三步，直至收敛。</li>
</ol>
<h2 id="GMM-HMM"><a href="#GMM-HMM" class="headerlink" title="GMM-HMM"></a>GMM-HMM</h2><p><img src="/2020/03/14/2020-03-14-GMM/20140528175313171.png" alt="20140528175313171"></p>
<p>语音识别系统主要由信号处理和特征提取、声学模型（AM）、语言模型（LM）和解码搜索部分。</p>
<ul>
<li>信号处理和特征提取部分以音频信号为输入，通过消除噪声和信道失真对语音进行增强，将信号从时域转化到频域，并为声学模型提取合适的特征向量。</li>
<li>声学模型将声学和发音学（phonetics）进行整合，以特征向量作为输入，并为可变长特征序列生成声学模型分数。</li>
<li>语言模型学习词与词间的相互关系，来评估序列的可能性。</li>
<li>解码搜索对给定特征向量序列和若干假设次序列计算声学模型和语言模型分数，并输出得分最高的结果</li>
</ul>
<p>语音识别系统中经常使用基于GMM-HMM的声学模型。</p>
<p><strong>GMM被整合进HMM中，用来拟合基于状态的输出分布。</strong></p>
<p>用GMM建模声学特征（Acoustic Feature）$O_1,O_2,…,O_n$，可以理解成：</p>
<ul>
<li>每一个特征是由一个音素确定的，即不同特征可以按音素来聚类。由于在HMM中音素被表示为隐变量（状态），故等价于：</li>
<li>每一个特征是由某几个状态确定的，即不同特征可以按状态来聚类。</li>
<li>则设$P(O|S_i)$符合正态分布，则根据GMM的知识，$O_1,O_2,…,O_n$实际上就是一个混合高斯模型下的采样值。</li>
</ul>
<p>若包含了语音顺序信息，GMM不再是一个好模型，因为它不包含任何顺序信息。当给定HMM的一个状态后，若要对属于该状态的语音特征向量的概率分布进行建模，GMM仍不失为一个好的模型。因此，GMM被整合进HMM中，用来拟合基于状态的输出分布。</p>
<p><strong>利用声学特征训练HMM</strong></p>
<p>确定状态转移矩阵，是执行解码问题的基础。</p>
<p>而状态转移矩阵的确定即等价于HMM的训练问题（即状态转移矩阵u=max(P(u|O))，从语音特征序列中利用EM算法学习得到状态转移矩阵。</p>
<h2 id="应用GMM-HMM模型识别语音"><a href="#应用GMM-HMM模型识别语音" class="headerlink" title="应用GMM-HMM模型识别语音"></a>应用GMM-HMM模型识别语音</h2><p><img src="/2020/03/14/2020-03-14-GMM/..%5Cimages%5CGMM%5C20160901093401467.png" alt></p>
<ul>
<li><strong>对待识别语音做信号预处理</strong></li>
<li><strong>对待识别语音提取声学特征</strong></li>
<li><strong>对声学特征利用Viterbi算法解码</strong></li>
</ul>
<p>对声学特征解码后得到的是状态序列，即音素序列。</p>
<p>如果把声学模型的结果表示为句子，往往效果不尽如意，所以还需要用语言模型把识别出的各个音素纠正为正确的句子</p>
<p><strong>其它应用</strong></p>
<p><img src="/2020/03/14/2020-03-14-GMM/D:%5CProject%5Cgrobenis.github.io%5Cimages%5CHMM%5CHMM_nlp.jpg" alt></p>
<p>将上图中的拼音换成语音，就成了语音识别问题，转移概率仍然是二元语言模型，其输出概率则是语音模型，即语音和汉字的对应模型。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>GMM</tag>
      </tags>
  </entry>
  <entry>
    <title>概率图模型</title>
    <url>/2020/03/14/2020-03-14-Probability_graph_model/</url>
    <content><![CDATA[<p>概率图模型（ probabilistic graphical model）是一类用图来表达变量相关关系的概率模型。它以图为表示工具，最常见的是用一个结点表示一个或一组随机变量，结点之间的边表示变量间的概率相关关系，即“变量关系图”.根据边的性质不同，概率图模型可大致分为两类：第一类是使用有向无环图表示变量间的依赖关系，称为有向图模型或贝叶斯网（ Bayesian network）；第二类是使用无向图表示变量间的相关关系，称为无向图模型或马尔可夫网（ Markovnetwork）</p>
<p>本节将用来介绍概率图模型。</p>
<a id="more"></a>

<h2 id="概率图模型"><a href="#概率图模型" class="headerlink" title="概率图模型"></a>概率图模型</h2><p>概率图模型（ probabilistic graphical model）是一类用图来表达变量相关关系的概率模型。它以图为表示工具，最常见的是用一个结点表示一个或一组随机变量，结点之间的边表示变量间的概率相关关系，即“变量关系图”.</p>
<p><strong>分类</strong></p>
<p>根据边的性质不同，概率图模型可大致分为两类：</p>
<p>第一类是使用有向无环图表示变量间的依赖关系，称为有向图模型或贝叶斯网（ Bayesian network）；</p>
<p>第二类是使用无向图表示变量间的相关关系，称为无向图模型或马尔可夫网（ Markovnetwork）；</p>
<p><strong>前提背景</strong></p>
<p>利用条件独立性可以降低概率模型的计算复杂度；</p>
<p>条件独立性要在图的结构上有所映射；</p>
<p><strong>图的构建方法</strong></p>
<p>拓扑排序;</p>
<p>根据拓扑排序构建的概率图能够得到联合概率的因子分解式；</p>
<p>性质：</p>
<p>如果父节点被观测，则其子节点独立；</p>
<h2 id="因子图"><a href="#因子图" class="headerlink" title="因子图"></a>因子图</h2><p>有向图：$P(x)=\Pi(x_i|x_{pa_i})$</p>
<p>无向图：$P(x)=\cfrac{1}{Z}\Pi^k_{i=1}\phi_{c_i}(x_{c_i})$</p>
<p>道德图：有向图 → 无向图</p>
<p>出发点：</p>
<ol>
<li>引入环</li>
<li>简便</li>
</ol>
<p>因子图把因子引入图里边。</p>
<p><img src="/2020/03/14/2020-03-14-Probability_graph_model/%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="factor_graph"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>概率图</tag>
      </tags>
  </entry>
  <entry>
    <title>Kalman滤波器学习</title>
    <url>/2020/03/14/2020-03-13-Kalman_Filter/</url>
    <content><![CDATA[<p>概率图+时间=动态系统</p>
<p>​    对概率图模型考虑其时间序列，可以得到动态系统。根据动态系统的隐状态的连续性和分布可以把系统大致分为三类：</p>
<ol>
<li>若隐状态离散，不要求分布，则为隐马尔可夫模型</li>
<li>如果隐状态连续、线性且服从高斯分布，则为Kalman滤波器（线性高斯模型）</li>
<li>如果隐状态连续且非线性，作为得到粒子滤波器</li>
</ol>
<p>本节主要来介绍kalman滤波器。</p>
<a id="more"></a>

<h2 id="Kalman滤波器"><a href="#Kalman滤波器" class="headerlink" title="Kalman滤波器"></a>Kalman滤波器</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>卡尔曼滤波器是由Swerling（1958）和Kalman（1960）作为线性高斯系统中的预测和滤波技术而发明的，使用矩来定义的。KF实现了对连续状态的置信度计算。KF用矩参数来表示置信度：在时刻k，置信度用均值$ \mu_k $（一阶矩）和方差$ \sum _{k-1} $（二阶矩）表达。</p>
<p>卡尔曼滤波建立在线性代数和隐马尔可夫模型上。其基本动态系统可以用一个马尔可夫链来表示，该马尔可夫链建立在一个线性高斯系统上。系统的状态可以用一个元素为实数的向量表示。随着离散时间的每一个增加，这个线性算子就会作用在当前状态上，产生一个新的状态，并也会带入一些噪声，同时系统的一些已知的控制器的控制信息也会被加入。同时，另一个受噪声干扰的线性算子产生出这些隐含状态的可见输出。</p>
<p>使后验为高斯分布的前提，同时也是KF的特性：<br>       （1）状态转移必须是带有随机高斯噪声的参数的线性函数。<br>       （2）测量也与带有高斯噪声的自变量呈线性关系。<br>       （3）初始置信度必须是正态分布的。</p>
<p>这三个假设足以确保后验在任何时刻<code>t</code>总符合高斯分布。</p>
<p>根据线性高斯系统可以得到<strong>卡尔曼滤波器</strong>。 </p>
<p>卡尔曼滤波器的状态由以下两个变量表示：</p>
<ol>
<li>$\hat{x}_k$，在时刻k的状态的估计；</li>
<li>$\Sigma_{k}$，后验估计误差协方差矩阵，度量估计值的精确程度。</li>
</ol>
<h3 id="线性高斯系统"><a href="#线性高斯系统" class="headerlink" title="线性高斯系统"></a>线性高斯系统</h3><p>线性高斯系统是说，运动方程和观测方程可以由线性方程来描述：<br>$$<br>\begin{cases}x_k=A_kx_{k-1}+u_k+w_k \quad k=1,…,N\<br>z_k=C_kx_k+v_k<br>\end{cases}<br>$$<br><img src="/2020/03/14/2020-03-13-Kalman_Filter/C:%5CUsers%5C%E9%83%AD%E7%8A%87%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200330234714941.png" alt="image-20200330234714941"></p>
<h4 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h4><p>$$<br>x_k=A_kx_{k-1}+u_k+w_k \quad k=1,…,N<br>$$</p>
<p>其中,$A_k$是作用在$x_{k-1}$的状态变换模型（矩阵/矢量）。</p>
<p>$w_k$是过程噪声,满足$w_k\sim N(0,Q)$</p>
<h4 id="观测模型"><a href="#观测模型" class="headerlink" title="观测模型"></a>观测模型</h4><p>$$<br>z_k = C_kx_k+v_k<br>$$</p>
<p>其中$C_k$是观测模型，能把真实状态空间映射成观测空间。并假设了所有的状态和噪声均满足高斯分布。</p>
<p>$v_k$观测噪声服从零均值高斯分布：即$.v_k\sim N(0,R)$。</p>
<p><strong>线性</strong></p>
<p>线性系统中的线性体现在以下两个方面:</p>
<ol>
<li>$X_k=A*X_{k-1}+B+\epsilon,\epsilon\sim N(0,Q)$</li>
<li>$Z_k=C*X_k+D+\delta,\epsilon \sim N(0,R)$</li>
</ol>
<p>两个条件服从高斯分布：<br>$$<br>P(X_k|X_{k-1})\sim N(A*X_{k-1}+B,Q)<br>$$</p>
<p>$$<br>P(Z_k|X_k)\sim N(C*X_k+D,R)<br>$$</p>
<p>可以系统的初始状态：<br>$$<br>X_1\sim N(\mu_1,\Sigma_1)<br>$$</p>
<p>$$<br>\begin{equation}<br>\left{<br>    \begin{array}{lr}<br>        P(X_k|X_{k-1})\sim N(A<em>X_{k-1}+B,Q)\<br>        P(Z_k|X_k)\sim N(C</em>X_k+D,R)\<br>        P(Z_1)=N(\mu_1,\Sigma_1)<br>    \end{array}<br>\right.<br>\end{equation}<br>$$<br>总共的参数表如下：</p>
<p>$$<br>\theta = (A,B,C,D,Q,R,\mu_1,\Sigma_1)<br>$$</p>
<p>卡尔曼滤波是一种递归的估计，即只要获知上一时刻状态的估计值以及当前状态的观测值就可以计算出当前状态的估计值，因此不需要记录观测或者估计的历史信息。卡尔曼滤波器与大多数滤波器不同之处，在于它是一种纯粹的时域滤波器，它不需要像低通滤波器等频域滤波器那样，需要在频域设计再转换到时域实现。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>卡尔曼滤波器的操作包括两个阶段：<strong>预测</strong>与<strong>更新</strong>。</p>
<ol>
<li>预测阶段，滤波器使用上一状态的估计，做出对当前状态的预测。</li>
<li>更新阶段，滤波器利用对当前状态的观测值优化在预测阶段获得的预测值，以获得一个更精确的新估计值。</li>
</ol>
<p><strong>输入：</strong>系统在<code>t-1</code>时刻状态的置信度（正态分布，均值和方差用$\mu_{t-1}$和$\Sigma_{t-1}$）; 输入的控制向量$u_t$和测量向量$z_t$。</p>
<p><strong>输出：</strong>系统t时刻的状态的置信度$bel(x_t)$，均值向量$\mu_t$，方差$\Sigma_t$。</p>
<p><strong>伪代码</strong></p>
<p><strong>Algorithm Kalman_filter</strong> ($\mu_{t-1}$,$\Sigma_{t-1}$,$\mu_t$,$z_t$)</p>
<ol>
<li>$\hat\mu_t = A_t\mu_{t-1}+B_tu_t$</li>
<li>$\hat\sum_t =A_t\sum_{t-1}A^T_t+R_t$</li>
<li>$K_t=\hat\sum_tC^T_t(C_t\hat\sum_tC^T_t+Q_t)^{-1}$</li>
<li>$\mu_t=\hat\mu_t+K_t(z_t-C_t\hat\mu_t)$</li>
<li>$\sum_t=(I-K_tC_t)\hat\sum_t$</li>
</ol>
<p><strong>return</strong> $\mu_t$, $ \sum_t$</p>
<h3 id="代码样例"><a href="#代码样例" class="headerlink" title="代码样例"></a>代码样例</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ predictx, predicty, state, param ]</span> = <span class="title">kalmanFilter</span><span class="params">( t, x, y, state, param, previous_t )</span></span></span><br><span class="line"><span class="comment">% 卡尔曼滤波器</span></span><br><span class="line"><span class="comment">% 输入：当前时间t，位置，状态，参数，前一帧的时间t-1</span></span><br><span class="line"><span class="comment">% UNTITLED Summary of this function goes here</span></span><br><span class="line"><span class="comment">%   假设状态为四维:[p_x,p_y,v_x,v_y]</span></span><br><span class="line"><span class="comment">%   Four dimensional state: position_x, position_y, velocity_x, velocity_y</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">%% Place parameters like covarainces, etc. here:</span></span><br><span class="line">    <span class="comment">% P = eye(4)</span></span><br><span class="line">    <span class="comment">% R = eye(2)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">% Check if the first time running this function</span></span><br><span class="line">    <span class="comment">% 初始化</span></span><br><span class="line">    <span class="keyword">if</span> previous_t&lt;<span class="number">0</span></span><br><span class="line">        state = [x, y, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">        param.P = <span class="number">0.1</span> * <span class="built_in">eye</span>(<span class="number">4</span>);</span><br><span class="line">        predictx = x;</span><br><span class="line">        predicty = y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%% Naive estimate 朴素估计</span></span><br><span class="line"><span class="comment">%     % As an example, here is a Naive estimate without a Kalman filter</span></span><br><span class="line"><span class="comment">%     % You should replace this code</span></span><br><span class="line"><span class="comment">%     vx = (x - state(1)) / (t - previous_t);</span></span><br><span class="line"><span class="comment">%     vy = (y - state(2)) / (t - previous_t);</span></span><br><span class="line"><span class="comment">%     % Predict 330ms into the future</span></span><br><span class="line"><span class="comment">%     predictx = x + vx * 0.330;</span></span><br><span class="line"><span class="comment">%     predicty = y + vy * 0.330;</span></span><br><span class="line"><span class="comment">%     % State is a four dimensional element</span></span><br><span class="line"><span class="comment">%     state = [x, y, vx, vy];</span></span><br><span class="line">    <span class="comment">%% <span class="doctag">TODO:</span> Add Kalman filter updates</span></span><br><span class="line">    <span class="comment">%% 当前目的：更新kalman滤波器</span></span><br><span class="line">    <span class="comment">% 1. 计算时间间隔</span></span><br><span class="line">    dt = t - previous_t; <span class="comment">% Time interval</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% PREDICT</span></span><br><span class="line">    <span class="comment">% 2. 预测</span></span><br><span class="line">    A = [<span class="number">1</span> <span class="number">0</span> dt <span class="number">0</span>; <span class="comment">% Transform matrix A</span></span><br><span class="line">         <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> dt;</span><br><span class="line">         <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>  <span class="number">0</span>;</span><br><span class="line">         <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>  <span class="number">1</span>];</span><br><span class="line">     </span><br><span class="line">    C = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; <span class="comment">% Observation matrix C</span></span><br><span class="line">         <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">     </span><br><span class="line">    z_t = [x, y]'; <span class="comment">% Measurement data</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Q = 0.005 * eye(4);</span></span><br><span class="line">    Q = [dt^<span class="number">2</span>  <span class="number">0</span>        <span class="number">0</span>       <span class="number">0</span>; <span class="comment">% System (Motion) noise covariance</span></span><br><span class="line">         <span class="number">0</span>        dt^<span class="number">2</span>  <span class="number">0</span>       <span class="number">0</span>;</span><br><span class="line">         <span class="number">0</span>        <span class="number">0</span>        <span class="number">1</span>       <span class="number">0</span>;</span><br><span class="line">         <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>       <span class="number">1</span>];</span><br><span class="line">           </span><br><span class="line">    R = <span class="number">0.005</span> * <span class="built_in">eye</span>(<span class="number">2</span>); <span class="comment">% Measurement noise covariance</span></span><br><span class="line">    </span><br><span class="line">    P = A * param.P * transpose(A) + Q; <span class="comment">% Prior estimation covariance</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% UPDATE</span></span><br><span class="line">    <span class="comment">% 3. 更新</span></span><br><span class="line">    K = P * transpose(C) * inv(R + C * P * transpose(C)); <span class="comment">% Kalman gain</span></span><br><span class="line">    state = (A * (state') + K * (z_t - C * A * (state')))'; <span class="comment">% Posterior state estimation</span></span><br><span class="line">    param.P = P - K * C * P; <span class="comment">% Posterior estimation covariance</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Predict 330ms into the future</span></span><br><span class="line">    predictx = state(<span class="number">1</span>) + state(<span class="number">3</span>) * <span class="number">0.330</span>;</span><br><span class="line">    predicty = state(<span class="number">2</span>) + state(<span class="number">4</span>) * <span class="number">0.330</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="基于后验概率推导Kalman滤波器·"><a href="#基于后验概率推导Kalman滤波器·" class="headerlink" title="基于后验概率推导Kalman滤波器·"></a>基于后验概率推导Kalman滤波器·</h3><p>可以看作是一个Filter问题的求解过程<br>$$<br>P(X_t|z_1,z_2,…z_t)\propto P(z_1,z_2,…z_t,X_t)\=P(z_t|z_1,z_2,…z_{t-1},X_t)*P(z_1,z_2,…z_{t-1},X_t)\<br>=P(z_t|X_t)P(z_1,…,z_{t-1},X_t)\<br>=P(z_t|X_t)P(X_t|z_1,…,z_{t-1})P(z_1,…,z_{t-1})\<br>\propto P(z_t|X_t)P(X_t|z_1,…,z_{t-1})\<br>$$</p>
<p>其中：<br>$$<br>P(X_t|z_1,…,z_{t-1})<br>=\int_{X_{t-1}}P(X_t,X_{t-1}|z_1,…,z_{t-1})dz_{t-1}\<br>=\int_{X_{t-1}}P(X_t|X_{t-1},z_1,…,z_{t-1})P(X_{t-1}|z_1,…,z_{t-1})dz_{t-1}<br>\=\int_{X_{t-1}}P(X_t|X_{t-1})P(X_{t-1}|z_1,…,z_{t-1})dz_{t-1}<br>$$</p>
<p> 基于概率的推导步骤：</p>
<ul>
<li><p>t=1,<br>$$<br>\begin{equation}<br>\left {</p>
<pre><code>\begin{array}{lr}
P(X_1|z_1)\rarr update\\
P(X_2|z_1)\rarr prediction
\end{array}</code></pre><p>\right.<br>\end{equation}<br>$$</p>
</li>
<li><p>t=2,<br>$$<br>\begin{equation}<br>\left {</p>
<pre><code>\begin{array}{lr}
P(X_2|z_1,z_2)\rarr update\\
P(X_3|z_1,z_2)\rarr prediction
\end{array}</code></pre><p>\right.<br>\end{equation}<br>$$</p>
</li>
<li><p>t=T,<br>$$<br>\begin{equation}<br>\left {</p>
<pre><code>\begin{array}{lr}
P(X_T|z_1,z_2...z_T)\rarr update\\
P(X_{T+1}|z_1,z_2,...,z_T)\rarr prediction
\end{array}</code></pre><p>\right.<br>\end{equation}<br>$$</p>
</li>
</ul>
<h3 id="Kalman滤波器与HMM之间的关系"><a href="#Kalman滤波器与HMM之间的关系" class="headerlink" title="Kalman滤波器与HMM之间的关系"></a>Kalman滤波器与HMM之间的关系</h3><p>本节<a href="https://www.cnblogs.com/pinking/p/9201405.html" target="_blank" rel="noopener">出处</a>。</p>
<p>Kalman与HMM的关系，事实上，他们解决的问题模型都是如上图所示，只不过一个是利用最小均方误差准则进行估计，一个是利用最大后验进行估计。事实上，HMM的预测问题中，就是一个最大的后验概率作为其似然函数，然后通过viterbi算法解的这个似然函数。</p>
<h2 id="拓展Kalman滤波器"><a href="#拓展Kalman滤波器" class="headerlink" title="拓展Kalman滤波器"></a>拓展Kalman滤波器</h2><p>核心思想：把卡尔曼滤波器的结果拓展到非线性系统中</p>
<p>做法：在某个点附近考虑运动方程以及观测方程的一阶泰勒展开，只保留一阶项，即闲下来部分，然后按照线性系统进行推导。</p>
<p>卡尔曼滤波器给出了在线性化之后，状态变量分布的变化过程。在线性系统和高斯噪声下，卡尔曼滤波器给出了无偏最优估计。而在SLAM 这种非线性的情况下，它给出了单次线性近似下最大后验估计（MAP）。</p>
<h3 id="EKF的应用"><a href="#EKF的应用" class="headerlink" title="EKF的应用"></a>EKF的应用</h3><p>EKF在SLAM中有着广泛的应用</p>
<h3 id="EKF的局限性"><a href="#EKF的局限性" class="headerlink" title="EKF的局限性"></a>EKF的局限性</h3><ol>
<li>EKF假设了马尔可夫性，即k时刻的状态只与k-1时刻相关，而与k-1之前的状态和观测都无关。但在视觉里程计中，只考虑相邻两帧的关系会累积误差。如果有回环检测的，滤波器就很难处理这种情况。</li>
<li>与非线性优化方法相比，EKF滤波器仅在$\hat{x}_{k-1}$处做了一次线性化，然后直接根据这次线性化结果计算后验概率。。这相当于在说，我们认为该点处的线性化近似，在后验概率处仍然是有效的。而实际上，当我们离开工作点较远的时候，一阶泰勒展开并不一定能够近似整个函数，这取决于运动模型和观测模型的非线性情况。如果它们有强烈的非线性，那线性近似就只在很小范围内成立，不能认为在<br>很远的地方仍能用线性来近似。这就是EKF 的非线性误差，是它的主要问题所在。在优化问题中，尽管我们也做一阶（最速下降）或二阶（G-N 或L-M）的近似，但每迭代一次，状态估计发生改变之后，我们会重新对新的估计点做泰勒展开，而不像EKF 那样只在固定点上做一次泰勒展开。这就导致优化方法适用范围更广，则在状态变化较大时亦能适用。</li>
<li>从程序实现上来说，EKF 需要存储状态量的均值和方差，并对它们进行维护和更新。如果把路标也放进状态的话，由于视觉SLAM 中路标数量很大，这个存储量是相当可观的，且与状态量呈平方增长（因为要存储协方差矩阵）。因此，EKF-SLAM 普遍被认为不可适用于大型场景。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Kalman滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>运动一致性判断</title>
    <url>/2020/03/14/2020-03-15-Motion_consistency/</url>
    <content><![CDATA[<p>直至以来，SLAM的研究共朝着三个方向努力：精度、速度、鲁棒性。尤以鲁棒性居多。通常动态场景中，根据IMU测量值与视觉测量值分别进行计算得到的结果会有所不同。因此需要进行一致性的检测，以得到真值。本文将主要讲运动一致性检测。</p>
<a id="more"></a>

<h1 id="运动一致性判断"><a href="#运动一致性判断" class="headerlink" title="运动一致性判断"></a>运动一致性判断</h1><p>基于聚类将图片分割之后获得的区域需要判断其运动一致性以分离动态物体和静态背景。</p>
<p>目的：对图片中各部分进行运动一致性判断以分离出目标和背景。</p>
<p>下面介绍各个论文中的判断方法</p>
<h2 id="Nonparametric-Statistical-and-Clustering-Based-RGB-D-Dense-Visual-Odometry-in-a-Dynamic-Environment"><a href="#Nonparametric-Statistical-and-Clustering-Based-RGB-D-Dense-Visual-Odometry-in-a-Dynamic-Environment" class="headerlink" title="Nonparametric Statistical and Clustering Based RGB-D Dense Visual Odometry in a Dynamic Environment"></a>Nonparametric Statistical and Clustering Based RGB-D Dense Visual Odometry in a Dynamic Environment</h2><p>该论文将RGB图片与深度图结合后进行k均值聚类以实现图片分割</p>
<p>过程：</p>
<ol>
<li>进行k-means聚类</li>
<li>计算每一个簇的残差</li>
<li>根据计算出的残差建立非参数统计模型</li>
</ol>
<p>聚类的好处有两点：</p>
<ol>
<li>能够将非刚体场景表示基于聚类的刚体场景</li>
<li>可有效增强密集运动的分割效果，从而支持场景流估计和避障。</li>
</ol>
<p>本文使用了一个残差模型。该模型基于一个假设：</p>
<p>若图片对齐，则基于静态背景的聚类将会有一个很小的残差。</p>
<p>光照强度残差：<br>$$<br>r^p_I(\xi）= I_k(W(x^p_{k-n},\xi^k_{k-n}))-I_{k-n}(x^p_{k-n})<br>$$<br>图像扭曲，Warp函数：<br>$$<br>W(x^p_{k-n},\xi^k_{k-n})=\pi(T^k_{k-n}\pi^{-1}(x^p_{k-n},Z_{k-n}(x^p_{k-n})))<br>$$</p>
<p>第i个聚类的残差计算方法如下所示：<br>$$<br>\delta^{k,i}<em>{k-n}=\cfrac{\sum^{S_i-O_i}</em>{p=1}\alpha_Ir^p_I+r^P_Z/\hat Z_i}{S_i-O_i}<br>$$<br>其中，$S_i$是第i类的像素大小。$O_i$是第i类遮挡的区域大小。</p>
<p>$\hat Z_i$是第i类的平均深度，$\alpha_I$是平衡深度和广度的权重。<br>$$<br>r_Z^P(\Chi)=Z_k(W(x^p_{k-n},\Chi^k_{k-n}))-|T^k_{k-n}|_Z<br>$$</p>
<p><strong>非参数统计模型</strong></p>
<p>该模型的用途是为了你和实际实验残差的直方图，为每个聚类提供权重以估计相机运动</p>
<p>静态背景部分的运动始终与相机运动具有双重关系。因此，静态簇的残差通常会很小或接近零，因为它们会完美对齐，而这些动态簇的残差通常是较大的值，由于动态对象的独立运动，它们的值会很明显的偏移于零。</p>
<p>对于不同的场景，残差分布并不总是相同的。应该探索聚类残差的分布特征。图2是高动态场景的统计残差直方图示例。</p>
<p><img src="/2020/03/14/2020-03-15-Motion_consistency/Motion_consistency.png" alt="image-20200316123237971"></p>
<p>在概率论和统计学中，t-分布（t-distribution）用于根据小样本来估计呈正态分布且方差未知的总体的均值。</p>
<p>受[14，23]的启发，基于t分布的非参数统计模型构造如下：<br>$$<br>w_i = \cfrac{v_0+1}{v_0+((\delta’_i-\mu))^2}<br>$$</p>
<p>$$<br>\delta = 1.4826 Median {|\delta’_i-\mu|}<br>$$</p>
<p>其中，$v_0$是t分布的自由度，决定了分布曲线的陡峭程度。</p>
<p>实验中，$v_0$被设置为10，$\mu$是样本均值，设为0；</p>
<p>$\delta$是样本方差，即基于中位数绝对偏差的非参数统计。</p>
<p>由于统计模型的概率表示簇的运动可能性，因此它可以指导场景运动分割，并为每个聚类提供权重以估计自我运动。</p>
<p>聚类标签根据如下给出：<br>$$<br>\Beta_i=\left{<br>\begin{array}{l}<br>1,&amp;\delta’_i\leq1/(\min(10,\max(3.\alpha_Bv_c\delta)))<br>\0,&amp;\delta’_i\geq1/(\min(10,\max(3,\alpha_Bv_c\delta)))<br>\end{array}<br>\right.<br>$$<br>Bi表示第i个簇的聚类标签。1表示该类属于静态背景。</p>
<p>0表示该类属于动态部分。$\alpha_B$是一个用来调节独立变量和残差的维度协方差，计算方法为：<br>$$<br>\alpha_B=10^3\times\min(10^3,10^{N_d})<br>$$<br>$N_d$是标记为移动部分的聚类数。</p>
<p>聚类权重参考聚类的残差来给出，如下所示：<br>$$<br>w_i^p=\left{<br>\begin{array}{}<br> w_i, &amp;Meadian(\delta’_i)&gt;0.02\or N_d&gt;5\<br>1-\delta’_i,&amp;Others<br>\end{array}<br>\right.<br>$$<br>其中，$w_i$是第i类的权重。Median($\delta’_i$)是聚类残差的中位数。</p>
<p>最后将运动标记和权重模型添加到稠密视觉里程计的能量优化函数中。优化函数是根据Kerl的工作[9]基于深度和强度构建的，具有很高的稳定性，而Jaimez的工作[15]的方法表明优化过程可以在Cauchy M估计器中获得良好的结果。自运动通过以下等式估算：<br>$$<br>\Chi = \arg \min_{\Chi}{\sum^M_{m=1}\Beta_i[F(w^P_i)r^P_Z(\Chi)+F(\alpha_I)w^p_ir^p_I(\Chi)]<br>$$</p>
<p>$$<br>F(r)=\cfrac{c^2}{2}\log(1+(\cfrac{r}{c})^2)<br>$$</p>
<p>此外，基于能量函数的视觉里程计方法只有在运动较小时才能收敛到真实值，而较大的运动通常会将收敛收敛到局部最小值。因此，我们使用金字塔模型来解决此优化问题，以获得更准确的自我运动估计。</p>
<h2 id="Dection-and-Resolution-of-Motion-Conflict-Inertial-Odometry"><a href="#Dection-and-Resolution-of-Motion-Conflict-Inertial-Odometry" class="headerlink" title="Dection and Resolution of Motion Conflict Inertial Odometry"></a>Dection and Resolution of Motion Conflict Inertial Odometry</h2><p>判断路标点间一致性的策略：</p>
<ol>
<li><p>基于IMU判断的运动对每一个特征点计算重投影残差<br>$$<br>\delta_{l_j}=\sum_{i\in S}(z_ij-h(\hat X^I_j,l_j))<br>$$</p>
</li>
<li><p>计算当前帧中特征点的残差不一致点的个数，如果不一致点的个数超过了一定比例，则判断发生了运动冲突。<br>$$<br>Mr:=\cfrac{landmarks<del>wihtout</del>confilt}{landmarks}<br>$$</p>
</li>
<li><p>另一方面，分别根据基于IMU和视觉的运动计算重投影误差，再计算二者的分歧度，再根据分歧度计算当前帧是否发生了冲突。<br>$$<br>\delta_{MC}=||{\hat p_k^V-\hat p_k^I}||_{\sum}<br>$$</p>
</li>
</ol>
<h2 id="On-Exploting-Per-Pixel-Conflict-to-Extract-Secondary-Motions"><a href="#On-Exploting-Per-Pixel-Conflict-to-Extract-Secondary-Motions" class="headerlink" title="On Exploting Per-Pixel Conflict to Extract Secondary Motions"></a>On Exploting Per-Pixel Conflict to Extract Secondary Motions</h2><p>基于DNN训练一个概率图，提取出概率图（Mask）</p>
<p>然后基于该概率图分别计算主要运动和次要运动。</p>
<h2 id="A-Compatible-Framework-for-RGB-D-in-Dynamic-Scenes"><a href="#A-Compatible-Framework-for-RGB-D-in-Dynamic-Scenes" class="headerlink" title="A Compatible Framework for RGB-D in Dynamic Scenes"></a>A Compatible Framework for RGB-D in Dynamic Scenes</h2><ol>
<li><p>首先利用CNN提取出图像中潜在的动态区域</p>
</li>
<li><p><strong>运动检测方法</strong></p>
<p>​    本文采用基于光学流的方法来检查潜在动态区域和背景区域的一致性。光学流算法[30]在该领域已被广泛研究，该算法在运动检测中表现出色。该算法的总体思想是在两个图像的时空一致性假设下，从两个连续的图像中确定点的对应关系。提出了两种针对光流问题的解决方法，分别称为稀疏法和稠密法。稠密解决方案逐像素计算图像中的光学流值。但稀疏解决方案仅在这些兴趣点上计算流量矢量。可以通过以下公式获得一个像素的光学流值：<br>$$<br>\tau(\Chi,u)=\sum_{\Chi_i\in S}[I_{l-1}(X_i)-I_l(X_i+u(X_i))]^2<br>$$<br>​    对于每一个2D再集合$S\subset R^2$的点$X_i$，$I_{l-1}(X_i)$是第l-1帧的$X_i$的雄塑强度。$I_l(X_i+u(X_I))$表示相应的第l帧中的光照强度。</p>
<p>$u(X_i)$是第l-1和第l帧的相应点的变化，该项根据局部窗口中基于重心$X_i$的变化而来，是使函数达到最小的变量。</p>
<p>为了减少上面所说的损失函数，$X_i$点的光流向量$(\frac{u_x(X_i)}{dt},\frac{u_y(X_i)}{dt})$。$\frac{u_x(X_i)}{dt}$是其沿x轴的时间随时间变化的导数，$\frac{u_y(X_i)}{dt}$是其沿y轴方向变化的倒数。沿y轴的时间。利用广泛使用的Lucas-Kanade光流法用于跟踪潜在动态对象内部和外部的稀疏点。</p>
<p>对于光学流向量$p =（u，v）$，其方向$\Phi$和大小$ρ$表示如下：<br>$$<br>\phi=\left{<br>\begin{array}{}<br>atan2(\frac{v}{u})<em>180/\pi,&amp;if~atan2(\frac{v}{u})&gt;0\<br>(360+atan2(\frac{v}{u}))</em>180/\pi,&amp;otherwise<br>\end{array}<br>\right.<br>$$</p>
<p>$$<br>\rho = \sqrt2{u^2+v^2}<br>$$</p>
<p>然后，类似于[15]，将为潜在的动态区域和背景区域构建标准化的直方图，其中每个单元格的范围将由如下所示的公式确定：<br>$$<br>2\pi<em>\frac{r-1}{R}&lt;\psi&lt;2\pi</em>{\frac{r}{R}}<br>$$<br>其中，$\R$是bins的数目，r是从左到右的系列字母。所有的流向量将根据它们与水平轴的夹角划分为每个容器。此外，所有流向量将分配给不同的簇。每个bin的高度将如下计算：<br>$$<br>H=\frac{\sum_{\xi\in bin}\rho_\xi}{\sum_{\mu\in area}\rho_\mu}<br>$$</p>
</li>
</ol>
<p>   其中$ρ_ξ$表示一个箱中流量矢量的大小，而$ρ_\mu$是势能动态区域或背景区域中流量矢量的大小。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS-Fusion代码阅读</title>
    <url>/2020/03/10/2020-03-10-Read-VINS-Fusion/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Loop-Fusion"><a href="#Loop-Fusion" class="headerlink" title="Loop Fusion"></a>Loop Fusion</h2><p>Loop Fusion结点包括：</p>
<h2 id="VINS-estimator"><a href="#VINS-estimator" class="headerlink" title="VINS_estimator"></a>VINS_estimator</h2><p>VINS_estimator是VINS_Fusion的节点，其不包含回环检测部分，该节点可以单独对相机进行位姿估计。</p>
<h3 id="rosNodeTest-cpp"><a href="#rosNodeTest-cpp" class="headerlink" title="rosNodeTest.cpp"></a>rosNodeTest.cpp</h3><p>rosNodeTest.cpp是vins_estimator节点的程序入口。主要实现以下函数。</p>
<p>主程序包含以下流程：</p>
<ol>
<li><p>读取配置文件参数 readParameter()</p>
</li>
<li><p>订阅了四个话题，分别是imu、双目相机图像以及feature_tracker所提供的跟踪光流点，收到各个话题的消息后执行回调函数，对各个数据进行相应的处理</p>
</li>
<li><p>开启一个新线程sync_process。</p>
<p>该线程的作用：若图像buffer里面有数据,读入数据并且添加到estimator中。利用图片携带的时间戳信息能够检测两图片是否同步，若两图片的时间戳差距在一定范围内，则添加到estimator中中，否则丢弃两帧图片。</p>
</li>
</ol>
<h3 id="estimator"><a href="#estimator" class="headerlink" title="estimator"></a>estimator</h3><p>VIO系统的整个程序从Estimator estimator开启。</p>
<p>estimator类的定义由estimator.h和estimator.cpp两个文件完成。</p>
<p>包含以下重要的自定义成员：</p>
<table>
<thead>
<tr>
<th align="center">成员</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Feature_Tracker featureTracker</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">FeatureManager f_manager</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>estimator类中包含两类成员函数：</p>
<ol>
<li><p>接口函数</p>
<p>包括以下8个函数：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">initFirstPose()</td>
<td align="left">初始化初始位姿</td>
</tr>
<tr>
<td align="center">inputIMU()</td>
<td align="left">输入IMU数据</td>
</tr>
<tr>
<td align="center">inputImage()</td>
<td align="left">输入图片数据</td>
</tr>
<tr>
<td align="center">inputFeature()</td>
<td align="left">输入特征</td>
</tr>
<tr>
<td align="center">ProcessIMU()</td>
<td align="left">处理IMU数据，对IMU进行预积分；</td>
</tr>
<tr>
<td align="center">ProcessImage()</td>
<td align="left">处理相机数据；<br>1. 基于特征点的视差来判断当前帧是否属于关键帧；<br>2. 判断相机到IMU的外参是否有校正，若无则用手眼标定法进行标定,具体在CalibrationExRotation里，此处只标定旋转矩阵，未标定平移矩阵，原因是系统对旋转矩阵较敏感，系统易因为小幅度的角度偏差而崩溃；<br>3. 判断是否有进行初始化;若已完成初始化，则调用optimization( )，用ceres_solver对滑窗进行非线性优化的求解，优化项主要有四项：边缘化残差、 imu残差、相机重投影残差以及相机与Imu间同步时间差的残差项。否则进行相应的初始化过程。<br>4. 本函数中包含一个failureDetection()函数,用于判断系统在一定条件下是否崩溃，比如非线性求解器中的解有大跳动，求解出相机IMU的外参矩阵或IMU偏移等等，系统挂掉就清空状态，重新初始化。</td>
</tr>
<tr>
<td align="center">ProcessMeasurements()</td>
<td align="left">处理测量值；处理各buffer里的数据，当featureBuf不等于空时，开始进行以下处理（为什么是featureBuf，因为当有图像buffer数据的时候，才会有featuretracker.push(make_pair(t,featureFrame))，即有图像数据后，程序才发给跟踪器叫他产生feature，因此当featureBuf不等于空，所有的buffer，包括imu,图像，都不为空）：</td>
</tr>
<tr>
<td align="center">changeSensrType</td>
<td align="left">改变传感器类型，用于确定是否使用IMU，使用单目相机还是双目相机</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="2">
<li>内部函数</li>
</ol>
<p>类的初始化函数Estimator()，由于Estimator类成员内部有两个比较重要的自定义类成员：<br>（1）Feature_Tracker featuretracker;（以前vins-mono这部分是作为一个独立的Node存在）:<br>用来对原始图像进行畸变校正，特征点采集，光流跟踪<br>（2）FeatureManager f_manager;<br>用来对滑动窗口内所有特征点的管理。<br>简单设置了一些参数后，系统进入main()。</p>
<p>接着main()与Estimator estimator两者开始发生联系：<br>main()中estimator.setParameter()开启了滑动窗口估计的一个新线程<br>由于我们在配置文件中 多线程MULTIPLE_THREAD设置为1，因此当setParameter()时候，就开启了一个Estimator类内的新线程：processMeasurements();</p>
<p>pub VIO的各种话题，包括里程计信息，tf变换，相机姿态，点云信息，并且发布关键帧。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>VINS</tag>
        <tag>代码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>经典聚类算法调研</title>
    <url>/2020/03/10/2020-03-12-Clustering_Survey/</url>
    <content><![CDATA[<p>本文将盘点六个经典的聚类算法，以便于后续研究。经典的聚类算法主要包括以下六种：</p>
<ol>
<li>Means-shift聚类</li>
<li>k-means聚类</li>
<li>Fuzzy C means聚类</li>
<li>Medoid shift算法</li>
<li>Turbopixel算法</li>
<li>SLIC算法</li>
</ol>
<a id="more"></a>

<h2 id="Means-shift聚类（均值漂移）"><a href="#Means-shift聚类（均值漂移）" class="headerlink" title="Means-shift聚类（均值漂移）"></a>Means-shift聚类（均值漂移）</h2><p><strong>核心思想</strong></p>
<p>均值漂移聚类是基于滑动窗口的算法，用来寻找到数据最密集的区域。这是一个基于质心的算法，通过将中心点的候选点更新为滑动窗口内点的均值来完成，来定位每个组/类的中心点。</p>
<p>然后对这些候选窗口进行相似窗口进行去除，最终形成中心点集及相应的分组。</p>
<p><strong>算法步骤</strong></p>
<ol>
<li><p>确定滑动窗口半径r，以随机选取的中心点C半径为r的圆形滑动窗口开始滑动。均值漂移类似一种爬山算法，在每一次迭代中向密度更高的区域移动，直到收敛。</p>
</li>
<li><p>每一次滑动到新的区域，计算滑动窗口内的均值来作为中心点，滑动窗口内的点的数量为窗口内的密度。在每一次移动中，窗口会想密度更高的区域移动。</p>
</li>
<li><p>移动窗口，计算窗口内的中心点以及窗口内的密度，知道没有方向在窗口内可以容纳更多的点，即一直移动到圆内密度不再增加为止。</p>
</li>
<li><p>步骤一到三会产生很多个滑动窗口，当多个滑动窗口重叠时，保留包含最多点的窗口，然后根据数据点所在的滑动窗口进行聚类。</p>
<p>下图演示了均值漂移聚类的计算步骤：</p>
<p><img src="/2020/03/10/2020-03-12-Clustering_Survey/..%5Cimages%5C%E8%81%9A%E7%B1%BB%5CMeanshift%E7%AE%97%E6%B3%95.gif" alt="Meanshift算法"></p>
</li>
</ol>
<p><strong>算法评价</strong></p>
<p>优点：1.稳定性和鲁棒性较好，基于密度的算法相比于K-Means受均值影响较小。 2.不需要选择簇的数量</p>
<p>缺点：1.给定的图像语义信息较少；2.进行分割时效果较差；3.时间复杂度较高，导致分割速度慢；4.图像分割块数量不可控；5.固定了窗口大小/半径</p>
<h2 id="K-means聚类"><a href="#K-means聚类" class="headerlink" title="K-means聚类"></a>K-means聚类</h2><p><strong>核心思想</strong></p>
<p>输入参数 K，将给定的 N 个数据样本点平均分成 K 个组，把输入的 K 个点作为聚类起始点。计算簇中其他采样点到 K 个起始点的欧氏距离，并对比全部采样点和收敛中心点之间的距离。通过对比最小的欧氏距离进行归类，然后经重复迭代，逐次得计算K 个簇的均值。直到聚类的性能准则函数最优</p>
<p><strong>算法步骤</strong></p>
<ol>
<li>选择一些类/组，随机初始化各自的中心点。中心点是与每个数据点向量长度相同的位置。这需要我们提前预知类的数量(即中心点的数量)。</li>
<li>计算每个数据点到中心点的距离，数据点距离哪个中心点最近就划分到哪一类中。</li>
<li>计算每一类中中心点作为新的中心点。</li>
<li>重复以上步骤，直至聚类中心变化在一定范围内为止</li>
</ol>
<p><strong>算法评价</strong></p>
<p>优点：简单快速高效；对异常值不太敏感</p>
<p>缺点：聚类数目 K 值是必须事先给出；不适合处理不规则形状；距离函数对结果有影响。</p>
<p>下图演示了k均值聚类的过程：</p>
<p><img src="/2020/03/10/2020-03-12-Clustering_Survey/..%5Cimages%5C%E8%81%9A%E7%B1%BB%5Ck%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB.gif" alt></p>
<h2 id="Fuzzy-C-means算法"><a href="#Fuzzy-C-means算法" class="headerlink" title="Fuzzy C-means算法"></a>Fuzzy C-means算法</h2><p><strong>核心思想</strong></p>
<p>Fuzzy C-means又名模糊C均值聚类，模糊C均值聚类融合了模糊理论的精髓，相较于k-means的硬聚类，模糊C提供了更加灵活的聚类结果。因为在大部分情况下，数据集中的对象不能划分成为明显分离的簇，指派一个对象到一个特定的簇有些生硬，也可能会出错。故，对每个对象和每个簇赋予一个权值，指明对象属于该簇的程度。当然，基于概率的方法也可以给出这样的权值，但是有时候我们很难确定一个合适的统计模型，因此使用具有自然地、非概率特性的模糊c均值就是一个比较好的选择。</p>
<p>简单地说，就是要最小化目标函数（即误差的平方和）：<br>$$<br>J_m = \sum^N_{i=1}\sum^C_{j=1}U^m_{ij}||x_i-c_j||^2 ,1&lt;=m&lt;∞<br>$$<br>其中，m是聚类的簇数；i,j是类标号；$u_{ij}$ 表示样本$x_i$ 属于j类的隶属度。i表示第i个样本，x是具有d维特征的一个样本。$c_j$是j簇的中心，也具有d维度。$||*||$是表示距离的度量。</p>
<p>模糊C聚类是一个不断得带隶属度$u_{ij}$ 和簇中心$c_j$ 的过程，直到达到最优。</p>
<p><strong>算法思路</strong></p>
<p>将提供的 n 个样本分为 C 组，通过迭代寻找各个组的聚类中心与隶属度值 Uij ，使非相似性指标的目标函数 J( U，V) 取最小值。该算法将隶属度 0 至 1 分别分派给每个数据对象，数据对象所属于哪类的问题是由隶属度值来决定。且规定每一个样本的隶属度值的总和是 1。</p>
<p><strong>算法步骤</strong></p>
<ol>
<li><p>初始化。通常采用随机初始化。即权值随机地选取。簇数需要人为选定。</p>
</li>
<li><p>计算质心。FCM中的质心有别于传统质心的地方在于，它是以隶属度为权重做一个加权平均。</p>
</li>
<li><p>更新模糊伪划分。即更新权重（隶属度）。简单地说，如果x越靠近质心c，则隶属度越高，反之越低。</p>
</li>
</ol>
<p><strong>算法评价</strong></p>
<p>优点：当聚类数量较多且类间差异明显时，简单高效效果较好</p>
<p>缺点：1.需要接收参数 C，若给定的参数不恰当，会对聚类结果产生负面影响。2. 当待检测数据样本总数过大并特征点过多，聚类效果不好。算法没有分析图像中各个像素间的领域关系，导致分割后的样本点易受噪声点的影响。</p>
<h2 id="Medoid-shift-算法"><a href="#Medoid-shift-算法" class="headerlink" title="Medoid shift 算法"></a>Medoid shift 算法</h2><p><strong>核心思想</strong></p>
<p>基于Means shift算法进行的改进，不同之处，MeanShift 算法经过多次迭代计算出的均值，即偏移值。相比较 Medoidshift 算法不要求求出平均值，而是从数据中将偏移值取出，但仍然需要确定两点之间距离。Medoidshift 算法每次迭代会计算出新的中心点，并非新位置，中心点可以被定义如下:</p>
<p><strong>算法步骤</strong></p>
<p><strong>算法评价</strong></p>
<p>优点：比Mean shift更高效</p>
<p>缺点：不能控制图像块数量和大小</p>
<h2 id="Turbo-Pixel算法"><a href="#Turbo-Pixel算法" class="headerlink" title="Turbo Pixel算法"></a>Turbo Pixel算法</h2><p><strong>核心思想</strong></p>
<p>该算法是一种基于几何流的超像素快速分割算法。首先，像素块应先满足以下几个条件：</p>
<p>①每个图像块尺寸大小尽可能均匀：</p>
<p>②各个图像块之间紧凑连接且保持连通</p>
<p>③各图像块彼此不覆盖且每块边界光滑无特殊棱角。</p>
<p><strong>算法步骤</strong></p>
<ol>
<li><p>首先为避免在给种子点定义时被噪声污染，特添加扰动。</p>
</li>
<li><p>对图像中的像素点进行标记</p>
</li>
<li><p>初始化水平集函数。</p>
</li>
<li><p>执行以下步骤，通过反复迭代并检验种子点膨胀边缘的演化速度是否为0，若达到则停止，反之继续，一是首先水平集曲线函数演化二是开始对未分配区域进行比较冫三是边界上的所有像素点的演化速度是由根据比较的结果进行更新</p>
</li>
</ol>
<p>⑤返回边界。</p>
<p><strong>算法评价</strong></p>
<p>超像素分割算法利用图像相似度将图像分割成几个同质超像素子区域。对于基于像素的处理方法，用来处理超像素的图像，可以更有助于获取的特定部分特征，从而保留更有效的信息的图像</p>
<h2 id="SLIC算法"><a href="#SLIC算法" class="headerlink" title="SLIC算法"></a>SLIC算法</h2><p><strong>核心思想</strong></p>
<p> 利用CIE-Lab 颜色空间来表示图像颜色信息，需要颜色空间转换，对应着图像中的每个像素，将其用一个由CIE-Lab 颜色空间和像素坐标 组成的 5 维向量{ L,a,b,x,y} 表示。通过向量距离来度量两个像素的相似性.</p>
<p>像素相似性与向量距离成反比。</p>
<p><strong>算法步骤</strong></p>
<p>1.初始化图像分割块。根据超参数生成K个种子点，计算种子点到所有像素的梯度值，搜索每个种子点周围空间里距离该点的最近的像素点。将各个像素分类。</p>
<p>步距设置为：$S=\sqrt{\frac{N}{K}}$ 。N是像素边，K是种子点个数</p>
<p>2.初始化聚类中心。将所有像素归类，计算领域内像素与种子间的距离，取最小距离作为聚类中心。</p>
<p>距离计算公式如下：<br>$$<br>d_c=\sqrt{(l_j-l_i)^2+(a_j-a_i)^2+(b_j-b_i)^2}<br>$$</p>
<p>$$<br>d_s=\sqrt{(x_j-x_i)^2+(y_j-y_i)^2}<br>$$</p>
<p>$$<br>D’=\sqrt{(\frac{d_c}{N_c})^2+(\frac{d_s}{N_s})^2}<br>$$</p>
<p>其中，$N_S=S=\sqrt{\frac{N}{K}}$</p>
<p>3.计算聚类中心到领域内所有像素点的距离。刷新原有的K个聚类重心点，再以刷新后的收敛中心点去搜索其周围与其相似度最高的点。</p>
<p>4.重新聚类，更新每个像素点所属的图像块，将同一个图像块的像素点取平均，得到新的聚类中心。</p>
<p>5.重复前面的步骤，直到两次聚类中心的距离小于某个阈值。</p>
<p><strong>算法评价</strong></p>
<p>优点：</p>
<p>1.聚类结果紧凑整齐且邻域特征明显。</p>
<p>2.可处理彩色图和灰度图</p>
<p>3.只需一个超参数。</p>
<p>4.运行速度较快。</p>
<p>缺点：因为对边缘的保持使用位置限制，导致超像素和图像边缘的契合度变差。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>聚类</tag>
        <tag>图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title>回环检测与DBoW2库</title>
    <url>/2020/03/10/2020-03-10-Use_DBoW2_to_Loop_Detection/</url>
    <content><![CDATA[<p>本文目的是为了更加详细的学习通用的回环检测算法 中的DBoW2库，了解其代码构成。</p>
<ol>
<li>回环检测</li>
<li>DBOW2介绍</li>
<li>DBOW3介绍</li>
</ol>
<a id="more"></a>

<h2 id="回环的评价指标"><a href="#回环的评价指标" class="headerlink" title="回环的评价指标"></a>回环的评价指标</h2><p>一个回环的结果，可能有以下四种情况出现：</p>
<table>
<thead>
<tr>
<th align="center">算法结果事实</th>
<th align="center">是回环</th>
<th align="center">不是回环</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是回环</td>
<td align="center">真阳性</td>
<td align="center">假阳性</td>
</tr>
<tr>
<td align="center">不是回环</td>
<td align="center">假阴性</td>
<td align="center">真阴性</td>
</tr>
</tbody></table>
<p>回环检测算法可以输出以下结果：四种结果的数量分别为<br>$$<br>准确率=N_{TP}/{N_{TP}+N_{FP}}<br>$$</p>
<p>$$<br>Recall = N_{TP}/{N_{TP}+N_{FN}}<br>$$</p>
<p>准确率描述了检测到的回环中真回环的个数。</p>
<p>Recall描述了真回环中有多少个被检测出来了。</p>
<p>根据准确率和召回率可以得到ROC曲线.</p>
<p>ROC曲线越靠右上方越好，但是通常这两者是矛盾的。</p>
<h2 id="回环检测"><a href="#回环检测" class="headerlink" title="回环检测"></a>回环检测</h2><p>闭环检测算法指的是通过检测算法检测出之前访问过的场景。</p>
<p><img src="/2020/03/10/2020-03-10-Use_DBoW2_to_Loop_Detection/%E5%9B%9E%E7%8E%AF%E6%A3%80%E6%B5%8B.jpg" alt="img"></p>
<p>如图1所示，当机器人在移动过程中，特别是在探索大面积的场景时，由于模型的不确定性以及设备的噪声，不确定性会逐渐增长。通过引入闭环检测技术，识别出历史访问过的场景以增加位姿之间的约束，可以很好的减少这种不确定性。</p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><h4 id="一、关键帧匹配"><a href="#一、关键帧匹配" class="headerlink" title="一、关键帧匹配"></a>一、关键帧匹配</h4><p>最简单的闭环检测算法是将新检测出来的关键帧和过去所有的关键帧一一进行比较，虽然这种方法能比较好的检测出当前场景是否在之前出现过，但是在大规模场景下，机器人往往有成千上万个关键帧，这种方法检测效率及其底下，不能再实际场景中使用。</p>
<h4 id="二、将特征与路标对应"><a href="#二、将特征与路标对应" class="headerlink" title="二、将特征与路标对应"></a>二、将特征与路标对应</h4><p>通过将图像中的特征和整个地图中的路标对应起来，然后建立一个所有路标的数据库，通过使用路标分类器来加快场景识别速度。比如讲所有路标构建成一棵KD-Tree，当新添加一帧关键帧时，将关键帧在KD-Tree中进行检索，从中检索之前出现过的场景。</p>
<h4 id="三、视觉词袋方法"><a href="#三、视觉词袋方法" class="headerlink" title="三、视觉词袋方法"></a>三、视觉词袋方法</h4><p>基于视觉词袋的闭环检测方法，这种方法通过将特征描述子抽象成词汇，通过TF-IDF方法识别出现过的场景。如图2所示，是闭环检测中基于词袋模型流程图。使用视觉词袋的方法效率很高，可用在大规模地图的创建上。</p>
<h2 id="DBoW2视觉词袋库"><a href="#DBoW2视觉词袋库" class="headerlink" title="DBoW2视觉词袋库"></a>DBoW2视觉词袋库</h2><p><a href="https://github.com/rmsalinas/DBow3" target="_blank" rel="noopener">Github地址</a></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​        DBoW2是DBow库的改进版本，DBow库是一个开放源代码的C ++库，用于根据图像建立索引，并将其转换成词袋表示。它实现了一个层次树，用于近似图像特征空间中的最近邻居并创建视觉词汇。 DBoW2还使用反向和直接文件来实现图像数据库，以索引图像并支持快速查询和功能比较。与以前的DBow库的主要区别在于：</p>
<ul>
<li>DBoW2类是模板化的，因此它可以与任何类型的描述符一起使用。</li>
<li>DBoW2附带了可直接与ORB或Brief描述符一起使用的类。</li>
<li>DBoW2将直接文件添加到图像数据库以进行快速功能比较。 DLoopDetector使用它。</li>
<li>DBoW2不再使用二进制格式。另一方面，它使用OpenCV存储系统来保存词汇表和数据库。这意味着这些文件可以YAML格式存储为纯文本，从而使兼容性更容易，也可以将其压缩为gunzip格式（.gz）以减少磁盘使用。</li>
<li>一些代码已被重写以优化速度。 DBoW2的界面已简化。</li>
<li>出于性能原因，DBoW2不支持停用词。</li>
</ul>
<p>DBoW2需要OpenCV和Boost :: dynamic_bitset类才能使用Brief版本。<br>DBoW2与DLoopDetector一起在多个真实数据集上进行了测试，执行时间为3毫秒，将图像的Brief特征转换为词袋矢量，执行时间为5毫秒，以在数据库中查找图像匹配项。超过19000张图像。</p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><h4 id="加权和计分"><a href="#加权和计分" class="headerlink" title="加权和计分"></a>加权和计分</h4><p>DBoW2实现与DBow相同的加权和计分机制。在这里检查。唯一的区别是DBoW2将所有分数缩放到[0..1]，因此不再使用缩放标志。</p>
<h4 id="保存并加载"><a href="#保存并加载" class="headerlink" title="保存并加载"></a>保存并加载</h4><p>可以使用保存和加载成员功能将所有词汇表和数据库保存到磁盘或从磁盘加载。保存数据库时，与之关联的词汇表也嵌入到文件中，因此词汇表和数据库文件是完全独立的。<br>您还可以将词汇表或数据库数据添加到使用cv :: FileStorage结构打开的任何文件中。<br>您可以使用任何文件扩展名保存词汇表或数据库。如果使用.gz，则文件将自动压缩（OpenCV行为）。</p>
<h3 id="应用说明"><a href="#应用说明" class="headerlink" title="应用说明"></a>应用说明</h3><h4 id="类参数"><a href="#类参数" class="headerlink" title="类参数"></a>类参数</h4><p>DBoW2有两个主要的类：<code>TemplatedVocabulary</code>和<code>TemplatedDatabase</code>。这些工具实现了视觉词汇，可将图像转换成词袋矢量，并将数据库转换成索引图像。这些类是模板化的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">TDescriptor</span>, <span class="title">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">TemplatedVocabulary</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">TDescriptor</span>, <span class="title">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">TemplatedDatabase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>两个类必须被提供：<code>TDescriptor</code>是单个描述符向量的数据类型，而<code>F</code>是具有从<code>FClass</code>派生的具有操作描述符功能的类。<br>例如，要使用<code>ORB</code>描述符，<code>TDescriptor</code>定义为<code>cv :: Mat</code>（类型为<code>CV_8UC1</code>），它是包含32个8位值的单行。从图像中提取特征时，必须获取<code>std :: vector &lt;TDescriptor&gt;</code>。对于<code>BRIEF</code>描述子，<code>TDescriptor</code>被定义为<code>boost :: dynamic_bitset &lt;&gt;</code>。<br><code>F</code>参数是实现<code>FClass</code>中定义的函数的类的名称。这些函数获取<code>TDescriptor</code>数据并计算一些结果。 <code>DBoW2</code>中已经包含了处理<code>ORB</code>和<code>Brief</code>描述符的类。 （<code>FORB</code>，<code>FBrief</code>）。</p>
<h4 id="预定义的词汇表和数据库"><a href="#预定义的词汇表和数据库" class="headerlink" title="预定义的词汇表和数据库"></a>预定义的词汇表和数据库</h4><p>为了便于使用，<code>DBoW2</code>定义了两种词汇表和数据库：<code>OrbVocabulary</code>，<code>OrbDatabase</code>，<code>BriefVocabulary</code>，<code>BriefDatabase</code>。请检查演示应用程序，以了解如何创建和使用它们。</p>
<h2 id="DBoW3视觉词袋库"><a href="#DBoW3视觉词袋库" class="headerlink" title="DBoW3视觉词袋库"></a>DBoW3视觉词袋库</h2><p><a href="https://github.com/rmsalinas/DBow3" target="_blank" rel="noopener"><strong>Github地址</strong></a></p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>​        DBoW3是DBow2库的改进版本，DBow2库是一个开放源C ++库，用于将图像索引并将其转换为词袋表示。它实现了一个层次树，用于近似图像特征空间中的最近邻居并创建视觉词汇。 DBoW3还使用反向和直接文件来实现图像数据库，以索引图像并支持快速查询和功能比较。与以前的DBow2库的主要区别是：</p>
<ul>
<li>DBoW3仅需要OpenCV。 DLIB的DBoW2依赖性已删除。</li>
<li>DBoW3可以立即使用二进制和浮点描述符。无需为任何描述符重新实现任何类。</li>
<li>DBoW3可以在linux和Windows中进行编译。</li>
<li>一些代码已被重写以优化速度。 DBoW3的界面已简化。</li>
<li>使用二进制文件的可能性。二进制文件的加载/保存速度比yml快4-5倍。同样，它们可以被压缩。</li>
<li>兼容DBoW2 yml文件</li>
</ul>
<h3 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h3><p><code>DBoW3</code>仅需要<code>OpenCV</code>。<br>要编译<code>utils / demo_general.cpp</code>，必须针对<code>OpenCV 3</code>进行编译。如果已安装<code>contrib_modules</code>，请使用<code>cmake</code>选项<code>-DUSE_CONTRIB = ON</code>启用<code>SURF</code>。</p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>检查<code>utils/demo_general.cpp</code></p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>DBoW3主要有两个类： <code>Vocabulary</code> 和<code>Database</code>。这些工具实现了视觉词汇，可将图像转换成词袋矢量，并将数据库转换成索引图像。有关示例，请参见<code>utils / demo_general.cpp</code>。</p>
<h4 id="读取-存储-词汇"><a href="#读取-存储-词汇" class="headerlink" title="读取/存储 词汇"></a>读取/存储 词汇</h4><p>文件<code>orbvoc.dbow3</code>是<code>ORBSLAM2</code>中的<code>ORB</code>词汇，但采用<code>DBoW3</code>的二进制格式：</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>DBoW2</tag>
        <tag>回环检测</tag>
      </tags>
  </entry>
  <entry>
    <title>隐马尔可夫模型</title>
    <url>/2020/03/10/2020-03-13-HMM_model/</url>
    <content><![CDATA[<p>隐马尔可夫模型是关于时序的概率模型，描述由一个隐藏的马尔可夫链随机生成不可观测的状态的序列，再由各个状态随机生成一个观测而产生观测的序列的过程。</p>
<p>隐马尔可夫模型是可用于标注问题的统计学习模型，描述有隐藏的马尔科夫链随机生成观测序列的过程，属于生成模型。本文将学习隐马尔可夫模型，着重介绍掌握HMM的模型、应用、及理论推导过程。</p>
<p>来源：李航的《统计学习方法》</p>
<a id="more"></a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>隐马尔可夫模型是关于时序的概率模型，描述了由一个隐藏的马尔可夫链随机生成不可观测的状态随机序列，再有各个状态生成一个观测而产生随机序列的过程。隐藏的马尔可夫链随机生成的状态的序列成为状态序列；每个状态生成一个观测得到的观测随机序列成为观测序列。序列得每一个位置都可以看作是一个时刻。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>机器学习中的步骤优化：</p>
<ol>
<li>确定模型</li>
<li>确定策略 即准则（损失函数）</li>
<li>算法：GN</li>
</ol>
<h3 id="概率图模型"><a href="#概率图模型" class="headerlink" title="概率图模型"></a>概率图模型</h3><p>概率图模型（ probabilistic graphical model）是一类用图来表达变量相关关系的概率模型。它以图为表示工具，最常见的是用一个结点表示一个或一组随机变量，结点之间的边表示变量间的概率相关关系，即“变量关系图”.根据边的性质不同，概率图模型可大致分为两类：</p>
<p>第一类是使用有向无环图表示变量间的依赖关系，称为有向图模型或贝叶斯网（ Bayesian network）；</p>
<p>第二类是使用无向图表示变量间的相关关系，称为无向图模型或马尔可夫网（ Markov network）;</p>
<p>概率图模型可以分为有向图(贝叶斯网络)、无向图（马尔可夫随机场）；</p>
<p>概率图模型+时间序列=动态模型；</p>
<p>动态模型主要有：HMM、卡尔曼滤波器、粒子滤波器；</p>
<ol>
<li>HMM：系统状态离散</li>
<li>Kalman滤波器：系统状态连续且线性分布</li>
<li>Particle滤波器：系统状态连续且非线性分布</li>
</ol>
<h3 id="HMM定义"><a href="#HMM定义" class="headerlink" title="HMM定义"></a>HMM定义</h3><p>​        隐马尔可夫模型由初始概率分布、状态转移概率分布以及观测概率分布确定。形式定义如下：</p>
<p>设Q是所有可能的状态集合，V是所有可能的观测的集合。<br>$$<br>Q = {q_1,q_2,…,q_N},V={v_1,v_2,…v_M}<br>$$<br>其中，N是可能的状态数，M是可能的观测数。</p>
<p>I是长度为T的状态序列，O是对应的观测序列<br>$$<br>I={i_1,i_2,…,i_N},O={v_1,v_2,…,v_M}<br>$$<br>A是状态转移概率矩阵：<br>$$<br>A=[a_ij]<em>{N\times N}<br>$$<br>其中，<br>$$<br>a</em>{ij}=P(i_{t+1}=i_t|q_j),i=1,2,..N;j=1,2,…,N<br>$$<br>表示在时刻t处于状态$q_i$的条件下在时刻t+1转移到状态$q_j$的概率。</p>
<p>B是观测概率矩阵：<br>$$<br>B=[b_j(k)]_{N\times M}<br>$$<br>其中，<br>$$<br>b_j(k)=P(o_t=v_k|i_t=q_j)，i=1,2,…N;j=1,2,…,N<br>$$<br>是在时刻t处于状态$q_j$的条件下生成观测$v_k$的概率。</p>
<p>$\pi$是初始状态概率向量：<br>$$<br>\pi=(\pi_i)<br>$$<br>其中，<br>$$<br>\pi=P(i_1=q_i),i=1,2,…N<br>$$<br>是时刻t=1处于状态$t=1$处于状态$q_i$的概率。</p>
<p>​    因此，隐马尔勒夫模型由初始状态向量$\pi$、状态转移概率矩阵Ahead观测概率矩阵B决定。$\pi$和A决定状态序列，B决定观测序列。因此，隐马尔可夫模型$\lambda$可以用三元符号表示，即<br>$$<br>\lambda=(A,B,\pi)<br>$$<br>$A,B,\pi$称为隐马尔可夫模型的三要素。</p>
<p>​    状态转移概率矩阵A与初始状态概率向量π确定了隐藏的马尔可夫链，生成不可观测的状态序列。观测概率矩阵B确定了如何从状态生成观测，与状态序列综合确定了如何产生观测序列</p>
<h3 id="两个基本假设"><a href="#两个基本假设" class="headerlink" title="两个基本假设"></a>两个基本假设</h3><ol>
<li><p><strong>齐次马尔可夫性假设</strong>，即假设隐藏的马尔可夫链在任意时刻t的状态只依赖于其前一其前一时刻的状态，于其它时刻的状态及观测无关，也与时刻t无关。<br>$$<br>P(i_t|i_t-1,o_{t-1},…,i_1,o_1)=P(i_t|i_t-1),t=1,2,…,T<br>$$</p>
</li>
<li><p><strong>观测独立性假设</strong>，即假设任意时刻的观测只依赖于该时刻的马尔可夫链的状态，与其他观测及状态无关。<br>$$<br>P(o_T|i_T,o_T,i_{T-1},o_{T-1}，…i_{t+1},o_{t+1},i_t,i_{t-1},o_{t-1},…,i_1,o_1)=P(o_t|i_t)<br>$$</p>
</li>
</ol>
<h3 id="观测序列的生成过程"><a href="#观测序列的生成过程" class="headerlink" title="观测序列的生成过程"></a>观测序列的生成过程</h3><p>根据HMM模型定义，可以将一个长度为T的观测序列$O=(o_1,o_2,…o_T)$的生成过程描述如下：</p>
<p>算法：观测序列的生成</p>
<p>输入：隐马尔可夫模型$\lambda=(A,B,\pi)$,观测序列长度；</p>
<p>输出：观测序列$O=(o_1,o_2,…,o_T)$</p>
<ol>
<li>按照初始状态分布$\pi$产生状态$i_1$</li>
<li>令t=1</li>
<li>按照状态$i_t$的观测概率分布$b_{i_t(k)}$生成$o_t$</li>
<li>按照状态$i_t$的状态转移概率分布${a_{i_ti_{t+1}}}$产生状态$i_{t+1},i_{t+2}=1,2,…N$ </li>
<li>令t=t+1,如果t&lt;T，转步（3），否则，终止</li>
</ol>
<h2 id="算法推导"><a href="#算法推导" class="headerlink" title="算法推导"></a>算法推导</h2><p>隐马尔可夫模型有三个<strong>基本问题</strong>：</p>
<ol>
<li><strong>概率计算问题</strong>。给的模型$\lambda=(A,B,\pi)$和观测序列$O=(o_1,o_2,…,o_T)$，计算在模型$\lambda$下观测序列O出现的概率$P(O|\lambda)$。</li>
<li><strong>学习问题</strong>。阈值观测序列$O=(o_1,o_2,…,o_T)$，估计模型参数$\lambda=(A,B,\pi)$参数，使得在该模型下观测序列序列概率$P(O|\lambda)$最大，即用极大似然估计的方法估计参数</li>
<li><strong>预测问题</strong>，（解码（decoding）问题）。一致模型$\lambda=(A,B,\pi)$和观测序列$O=(o_1,o_2,…,o_T)$,求对给定观测序列条件概率$P(I|O)$最大的状态序列$I=(i_1,i_2,…,i_T)$，即<strong>给定观测序列，求最有可能的对应的状态序列。</strong></li>
</ol>
<p>本节将介绍HMM模型的概率计算算法、学习算法以及预测算法</p>
<h3 id="概率计算算法"><a href="#概率计算算法" class="headerlink" title="概率计算算法"></a>概率计算算法</h3><p><strong>目的</strong>：给定模型$\lambda=(A,B,\pi)$和观测序列$O=(o_1,o_2,…,o_T)$，计算在模型$\lambda$下观测序列O出现的概率$P(O|\lambda)$。</p>
<h4 id="直接计算法"><a href="#直接计算法" class="headerlink" title="直接计算法"></a>直接计算法</h4><p>最直接的方法是按照概率公式直接计算。通过列举所有可能的长度为T的状态序列$I=(i_1,i_2,…i_T)$，求各个状态序列I与观测序列$O=(o_1,o_2,…,o_T)$的联合概率$P(O,I|\lambda)$，然后对所有可能的状态序列求和，得到$P(O|\lambda)$。</p>
<p>状态序列$I=(i_1,i_2,…i_T)$的概率是<br>$$<br>P(I|\lambda)=\pi_{i_1}a_{i_1i_2}a_{i_2i_3}…a_{i_{T-1}i_T}<br>$$<br>对固定的状态序列$I=(i_1,i_2,…i_T)$,观测序列$O=(o_1,o_2,…,o_T)$的概率是$P(O|I,\lambda)$，<br>$$<br>P(O|I,\lambda)=b_{i_1}(o_1)b_{i_2}(o_2)…b_{i_T}(o_T)<br>$$<br>O和I同时出现的概率为：<br>$$<br>P(O,I|\lambda)=P(O|I,\lambda)P(I,\lambda)=\pi_{i_i}b_{i_1}(o_1)a_{i_1i_2}b_{i_2}(o_2)…a_{i_{T-1}i_T}b(o_T)<br>$$<br>对所有可能的状态序列I球壳，得到观测序列O的概率$P(P|\lambda)$，即<br>$$<br>P(O|\lambda)=\sum_IP(O|I,\lambda)P(I|\lambda)=\sum_{i_1,i_2,…,i_T}\pi_{i_1}b_{i_1}(o_1)a_{i_1I_2}b_{i_2}(o_2)…a_{i_{T-1}i_T}b_{i_T}(o_T)<br>$$<br>这种方法很容易理解，但是计算量很大，是$O(TN^T)$阶的。不可行</p>
<h4 id="前向算法（forward-backward-algorithm）"><a href="#前向算法（forward-backward-algorithm）" class="headerlink" title="前向算法（forward-backward algorithm）"></a>前向算法（forward-backward algorithm）</h4><p><strong>前向概率</strong> 给定隐马尔可夫模型$\lambda$，定义时刻t部分观测序列为$O=(o_1,o_2,…,o_T)$且状态为$q_i$的概率为前向概率，记作<br>$$<br>\alpha_t(i)=P(o_1,o_2,…,o_t,i_t=q_i|\lambda)<br>$$<br><strong>观测序列概率的前向算法</strong></p>
<p>输入：隐马尔可夫模型$\lambda$，观测序列O;</p>
<p>输出：观测序列概率$P(O|\lambda)$</p>
<ol>
<li><p>初值<br>$$<br>\alpha_1(i)=\pi_ib_i(o_1),i=1,2,…N<br>$$</p>
</li>
<li><p>递推 对 $t=1,2,..,T-1$<br>$$<br>\alpha_{t+1}(i)=[\sum^N_{j=1}\alpha_t(j)a_{ji}]b_t(o_{t+1}),i=1,2,…N<br>$$</p>
</li>
<li><p>终止<br>$$<br>P(O|\lambda)=\sum^N_{j=1}\alpha_T(i)<br>$$</p>
</li>
</ol>
<p>算法解读，步骤（1）初始化前向概率是初始时刻状态和观测的联合概率，步骤（2）是前向概率的递推公式，计算到时刻t+1部分观测序列在时刻t+1且初始状态$q_i$的的前向概率。</p>
<p>所以：<br>$$<br>P(O|\lambda)=\sum^N_{j=1}\alpha_T(i)<br>$$<br>下图表示了前向概率的递推公式：</p>
<p><img src="/2020/03/10/2020-03-13-HMM_model/..%5Cimages%5CHMM%5C%E5%89%8D%E5%90%91%E6%A6%82%E7%8E%87%E7%9A%84%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F.png" alt="递推公式"></p>
<h4 id="后向算法"><a href="#后向算法" class="headerlink" title="后向算法"></a>后向算法</h4><p><strong>后向概率</strong>：给定隐马尔可夫模型$\lambda$ ，定义在时刻t状态为$q_i$的条件下，从t+1到T的部分观测序列为$o_{t+1},o_{t+2},…o_T$的概率为后向概率，记作：<br>$$<br>\beta_t(i)=P(o_{t+1},o_{t+2},…,o_T|i_t=q_i,\lambda)<br>$$<br>可以也递推的方法求得后向概率$\beta_t(i)$及观测序列概率$P(O|\lambda)$.</p>
<p><strong>算法步骤</strong></p>
<p><strong>输入</strong>：隐马尔可夫模型$\lambda$,观测序列O;</p>
<p><strong>输出</strong>：观测序列$P(O|\lambda)$;</p>
<ol>
<li><p>$\beta_T(i)=1,i=1,2,…N$</p>
</li>
<li><p>对$t=T-1,T-2,…1$<br>$$<br>\beta_t(i)=\sum^N_{j=1}a_{ij}b_j(a_{t+1})\beta_{t+1}(j),i=1,2,…,N<br>$$</p>
</li>
</ol>
<p>算法（1）初始化后向概率，对最终时刻的所有状态$q_i$规定$\beta_T(i)=1$ ；步骤（2）是后向概率的递推公式。</p>
<p><img src="/2020/03/10/2020-03-13-HMM_model/..%5Cimages%5CHMM%5C%E5%90%8E%E5%90%91%E6%A6%82%E7%8E%87%E7%9A%84%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F.png" alt="后向概率的递推公式"></p>
<h3 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h3><h4 id="监督学习方法"><a href="#监督学习方法" class="headerlink" title="监督学习方法"></a>监督学习方法</h4><h4 id="Baum-welch算法"><a href="#Baum-welch算法" class="headerlink" title="Baum-welch算法"></a>Baum-welch算法</h4><h3 id="预测算法（Decoding算法"><a href="#预测算法（Decoding算法" class="headerlink" title="预测算法（Decoding算法)"></a>预测算法（Decoding算法)</h3><h4 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h4><h4 id="维特比算法"><a href="#维特比算法" class="headerlink" title="维特比算法"></a>维特比算法</h4><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>隐马尔可夫模型在语音识别、自然语言处理、生物信息、模式识别等领域有着广泛的应用。</p>
<p>HMM的主要应用是解码</p>
<p>两种解码方法：</p>
<ol>
<li>Viterbi算法解码</li>
<li>前向后向算法+贝叶斯后验概率</li>
</ol>
<h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><h3 id="词性标注"><a href="#词性标注" class="headerlink" title="词性标注"></a>词性标注</h3><p>词性是隐藏状态，词出现时观察序列。</p>
<p>首先我们要知道模型的参数，如果又标注数据，直接用比例代替概率，如果没有用前向后向算法求除</p>
<p>知道模型参数吧，使用Viterbi算法来计算某个标注序列（隐含状态）的概率</p>
<h3 id="实际建模过程"><a href="#实际建模过程" class="headerlink" title="实际建模过程"></a>实际建模过程</h3><ul>
<li>根据实际问题确定状态个数及观察序列</li>
<li>用若干已知序列，采用B-W算法估计参数（转移概率和输出概率的值）</li>
<li>输入位置序列用Viterbi算法或者贝叶斯概率解码</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>HMM</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Kalibr标定双目相机与IMU</title>
    <url>/2020/02/15/2020-02-15-Calibrate_IMU_Camera_by_Kalibr/</url>
    <content><![CDATA[<p>本文介绍如何利用Kalibr标定工具进行双目相机与IMU的联合标定。主要过程包括以下四步：</p>
<ol>
<li>生成标定板</li>
<li>标定双目相机</li>
<li>标定IMU</li>
<li>联合标定</li>
</ol>
<a id="more"></a>

<h2 id="1-生成标定板"><a href="#1-生成标定板" class="headerlink" title="1. 生成标定板"></a>1. 生成标定板</h2><p>使用AprilTag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosrun kalibr kalibr_create_target_pdf --type apriltag --nx 6 --ny 6 --tsize 0.002 --tspace 0.3</span><br></pre></td></tr></table></figure>



<h2 id="2-标定双目相机"><a href="#2-标定双目相机" class="headerlink" title="2. 标定双目相机"></a>2. 标定双目相机</h2><p>降低帧率</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosrun topic_tools throttle messages &#x2F;l_cam&#x2F;image_raw 4 &#x2F;left</span><br><span class="line">rosrun topic_tools throttle messages &#x2F;r_cam&#x2F;image_raw 4 &#x2F;right</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">advertised as &#x2F;left &#x2F;&#x2F;出现时说明将帧成功</span><br></pre></td></tr></table></figure>

<p>录制bag包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosbag record &#x2F;left &#x2F;right &gt;mycamera.bag</span><br></pre></td></tr></table></figure>

<h3 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h3><h4 id="ImportError-cannot-import-name-NavigationToolbar2Wx"><a href="#ImportError-cannot-import-name-NavigationToolbar2Wx" class="headerlink" title="ImportError: cannot import name NavigationToolbar2Wx"></a>ImportError: cannot import name NavigationToolbar2Wx</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;cjn&#x2F;kalibr&#x2F;src&#x2F;kalibr&#x2F;Schweizer-Messer&#x2F;sm_python&#x2F;python&#x2F;sm&#x2F;PlotCollection.py</span><br><span class="line">解决：将 PlotCollection.py 中的NavigationToolbar2Wx 改为 NavigationToolbar2WxAgg</span><br></pre></td></tr></table></figure>

<h4 id="ImportError-No-module-named-igraph"><a href="#ImportError-No-module-named-igraph" class="headerlink" title="ImportError: No module named igraph"></a>ImportError: No module named igraph</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python2.7-igraph</span><br></pre></td></tr></table></figure>



<h4 id="kalibr标定时出现：ImportError-No-module-named-Image"><a href="#kalibr标定时出现：ImportError-No-module-named-Image" class="headerlink" title="kalibr标定时出现：ImportError: No module named Image."></a>kalibr标定时出现：ImportError: No module named Image.</h4><p>解决方法： 在kalibr_workspace/aslam_offline_calibration/kalibr/python/kalibr_camera_calibration/MulticamGraph.py中<br>将import Image改为from PIL import Image</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosrun kalibr kalibr_calibrate_cameras --bag &#39;&#x2F;home&#x2F;guoben&#x2F;stereocam.bag&#39; --topics &#x2F;left &#x2F;right --models pinhole-radtan pinhole-radtan --target &#39;&#x2F;home&#x2F;guoben&#x2F;Project&#x2F;Kalibr_ws&#x2F;april_6x6_80x80cm.yaml&#39; --show-extraction --approx-sync 0.1</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>标定的时候图中不能存在两个标定板</li>
<li>起始画面和终止画面要稳定</li>
</ul>
<h2 id="3-标定IMU"><a href="#3-标定IMU" class="headerlink" title="3. 标定IMU"></a>3. 标定IMU</h2><p>参考：<a href="https://blog.csdn.net/learning_tortosie/article/details/89878769" target="_blank" rel="noopener">IMU噪声标定——加速度计和陀螺仪的白噪声和零偏不稳定性</a></p>
<p>//录制bag文件</p>
<ol>
<li>collect the data while the IMU is Stationary, with a two hours duration;</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosbag	record &#x2F;imu0</span><br></pre></td></tr></table></figure>

<p>有Code_utils和imu_utils两个包 先编译code_utils再编译imu_tils</p>
<p>得到的imu.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">IMU</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">ICM20602</span></span><br><span class="line"><span class="attr">Gyr:</span></span><br><span class="line">   <span class="attr">unit:</span> <span class="string">" rad/s"</span></span><br><span class="line">   <span class="attr">avg-axis:</span></span><br><span class="line">      <span class="attr">gyr_n:</span> <span class="number">1.4127871720120859e+02</span></span><br><span class="line">      <span class="attr">gyr_w:</span> <span class="number">4.8477797168896648e-03</span></span><br><span class="line">   <span class="attr">x-axis:</span></span><br><span class="line">      <span class="attr">gyr_n:</span> <span class="number">3.9615886574940606e+02</span></span><br><span class="line">      <span class="attr">gyr_w:</span> <span class="number">4.8477797168896648e-03</span></span><br><span class="line">   <span class="attr">y-axis:</span></span><br><span class="line">      <span class="attr">gyr_n:</span> <span class="number">1.5284722859858114e+01</span></span><br><span class="line">      <span class="attr">gyr_w:</span> <span class="number">4.8477797168896648e-03</span></span><br><span class="line">   <span class="attr">z-axis:</span></span><br><span class="line">      <span class="attr">gyr_n:</span> <span class="number">1.2392562994361640e+01</span></span><br><span class="line">      <span class="attr">gyr_w:</span> <span class="number">4.8477797168896648e-03</span></span><br><span class="line"><span class="attr">Acc:</span></span><br><span class="line">   <span class="attr">unit:</span> <span class="string">" m/s^2"</span></span><br><span class="line">   <span class="attr">avg-axis:</span></span><br><span class="line">      <span class="attr">acc_n:</span> <span class="number">3.8264508828802807e-01</span></span><br><span class="line">      <span class="attr">acc_w:</span> <span class="number">1.0613073078261251e-02</span></span><br><span class="line">   <span class="attr">x-axis:</span></span><br><span class="line">      <span class="attr">acc_n:</span> <span class="number">3.6962189636668691e-01</span></span><br><span class="line">      <span class="attr">acc_w:</span> <span class="number">1.0916554449621266e-02</span></span><br><span class="line">   <span class="attr">y-axis:</span></span><br><span class="line">      <span class="attr">acc_n:</span> <span class="number">4.6707198750779616e-01</span></span><br><span class="line">      <span class="attr">acc_w:</span> <span class="number">1.0721472803944067e-02</span></span><br><span class="line">   <span class="attr">z-axis:</span></span><br><span class="line">      <span class="attr">acc_n:</span> <span class="number">3.1124138098960102e-01</span></span><br><span class="line">      <span class="attr">acc_w:</span> <span class="number">1.0201191981218414e-02</span></span><br></pre></td></tr></table></figure>

<p>修改为如下样式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rostopic:</span> <span class="string">/imu0</span></span><br><span class="line"><span class="attr">update_rate:</span> <span class="number">100.0</span> <span class="comment">#Hz</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">accelerometer_noise_density:</span> <span class="number">3.8264508828802807e-01</span> <span class="comment">#continous</span></span><br><span class="line"><span class="attr">accelerometer_random_walk:</span> <span class="number">1.0613073078261251e-02</span> </span><br><span class="line"><span class="attr">gyroscope_noise_density:</span> <span class="number">1.4127871720120859e+02</span> <span class="comment">#continous</span></span><br><span class="line"><span class="attr">gyroscope_random_walk:</span> <span class="number">4.8477797168896648e-03</span></span><br></pre></td></tr></table></figure>



<h2 id="4-录制数据包"><a href="#4-录制数据包" class="headerlink" title="4. 录制数据包"></a>4. 录制数据包</h2><p>沿着3个轴旋转平移三次</p>
<h2 id="5-联合标定"><a href="#5-联合标定" class="headerlink" title="5. 联合标定"></a>5. 联合标定</h2><p>准备好四个文件</p>
<ol>
<li>标定半文件</li>
<li>相机参数文件</li>
<li>imu参数文件</li>
<li>数据bag文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosrun kalibr kalibr_calibrate_imu_camera --target april_6x6_80x80cm.yaml --cam stereocam.yaml --imu ICM20602.yaml --bag camera_imu.bag --timeoffset-padding 0.1</span><br></pre></td></tr></table></figure>

<h2 id="6-标定结果"><a href="#6-标定结果" class="headerlink" title="6. 标定结果"></a>6. 标定结果</h2><p>得到结果为camchain.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cam0:</span></span><br><span class="line">  <span class="attr">T_cam_imu:</span> <span class="comment"># 从IMU到相机坐标的转换</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.08233179976406399,</span> <span class="number">-0.9949127683235393</span><span class="string">,</span> <span class="number">-0.05805220214946505</span><span class="string">,</span> <span class="number">-0.008744023342066004</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[-0.9959106050536686,</span> <span class="number">-0.08430878258416843</span><span class="string">,</span> <span class="number">0.032466843406961834</span><span class="string">,</span> <span class="number">0.07000917129335886</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[-0.03719598754229868,</span> <span class="number">0.055141750117018384</span><span class="string">,</span> <span class="number">-0.9977854708827878</span><span class="string">,</span> <span class="number">-0.11902680705823296</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.0,</span> <span class="number">0.0</span><span class="string">,</span> <span class="number">0.0</span><span class="string">,</span> <span class="number">1.0</span><span class="string">]</span></span><br><span class="line">  <span class="attr">cam_overlaps:</span> <span class="string">[1]</span></span><br><span class="line">  <span class="attr">camera_model:</span> <span class="string">pinhole</span></span><br><span class="line">  <span class="attr">distortion_coeffs:</span> <span class="string">[-0.4274960254764774,</span> <span class="number">0.1522753401860188</span><span class="string">,</span> <span class="number">0.022086313718892994</span><span class="string">,</span></span><br><span class="line">    <span class="number">-0.0007250205609533983</span><span class="string">]</span> <span class="comment">#失真模型的参数向量</span></span><br><span class="line">  <span class="attr">distortion_model:</span> <span class="string">radtan</span> </span><br><span class="line">  <span class="attr">intrinsics:</span> <span class="string">[576.2948258096362,</span> <span class="number">570.5120047531799</span><span class="string">,</span> <span class="number">290.9276492936449</span><span class="string">,</span> <span class="number">165.99488000803987</span><span class="string">]</span> <span class="comment">#相机内参 之前标好的</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">[640,</span> <span class="number">480</span><span class="string">]</span> <span class="comment">#分辨率</span></span><br><span class="line">  <span class="attr">rostopic:</span> <span class="string">/l_cam/image_raw</span> <span class="comment">#话题</span></span><br><span class="line">  <span class="attr">timeshift_cam_imu:</span> <span class="number">-0.04319840825131607</span> <span class="comment">#漂移</span></span><br><span class="line"><span class="attr">cam1:</span> </span><br><span class="line">  <span class="attr">T_cam_imu:</span> <span class="comment"># 从IMU到相机坐标的转换</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.0894795247331801,</span> <span class="number">-0.9911722483784674</span><span class="string">,</span> <span class="number">0.0978314300104943</span><span class="string">,</span> <span class="number">-0.06676213145949367</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[-0.995095690056223,</span> <span class="number">-0.08480851440432002</span><span class="string">,</span> <span class="number">0.05091250844401363</span><span class="string">,</span> <span class="number">0.06960856622513922</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[-0.04216612722380045,</span> <span class="number">-0.10190726141402426</span><span class="string">,</span> <span class="number">-0.9938998580269747</span><span class="string">,</span> <span class="number">-0.12389393733183268</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.0,</span> <span class="number">0.0</span><span class="string">,</span> <span class="number">0.0</span><span class="string">,</span> <span class="number">1.0</span><span class="string">]</span></span><br><span class="line">  <span class="attr">T_cn_cnm1:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.9878176058814627,</span> <span class="number">-0.002372804306504643</span><span class="string">,</span> <span class="number">-0.1555980311904324</span><span class="string">,</span> <span class="number">-0.07647885002996721</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[-0.000506528488511444,</span> <span class="number">0.9998294218114983</span><span class="string">,</span> <span class="number">-0.01846268422998622</span><span class="string">,</span> <span class="number">-0.0025906464811484946</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.155615297896788,</span> <span class="number">0.018316579369764666</span><span class="string">,</span> <span class="number">0.9876479038507021</span><span class="string">,</span> <span class="number">-0.0062589855841411746</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">[0.0,</span> <span class="number">0.0</span><span class="string">,</span> <span class="number">0.0</span><span class="string">,</span> <span class="number">1.0</span><span class="string">]</span></span><br><span class="line">  <span class="attr">cam_overlaps:</span> <span class="string">[0]</span></span><br><span class="line">  <span class="attr">camera_model:</span> <span class="string">pinhole</span></span><br><span class="line">  <span class="attr">distortion_coeffs:</span> <span class="string">[-0.4358292770104687,</span> <span class="number">0.13856343257725542</span><span class="string">,</span> <span class="number">0.01867787729653694</span><span class="string">,</span></span><br><span class="line">    <span class="number">-0.011189753016360725</span><span class="string">]</span></span><br><span class="line">  <span class="attr">distortion_model:</span> <span class="string">radtan</span></span><br><span class="line">  <span class="attr">intrinsics:</span> <span class="string">[572.0873971077864,</span> <span class="number">571.5888157262697</span><span class="string">,</span> <span class="number">349.04660762135626</span><span class="string">,</span> <span class="number">174.35778659111406</span><span class="string">]</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">[640,</span> <span class="number">480</span><span class="string">]</span></span><br><span class="line">  <span class="attr">rostopic:</span> <span class="string">/r_cam/image_raw</span></span><br><span class="line">  <span class="attr">timeshift_cam_imu:</span> <span class="number">-0.002440062477866302</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>IMU</tag>
        <tag>Kalibr</tag>
      </tags>
  </entry>
  <entry>
    <title>利用ROS标定相机步骤与方法</title>
    <url>/2020/02/15/2020-02-15-Calibrate_Camera_by_ROS/</url>
    <content><![CDATA[<p>本文讲解利用ROS框架下的工具标定USB相机的过程。</p>
<a id="more"></a>

<h2 id="利用IMU标定相机流程"><a href="#利用IMU标定相机流程" class="headerlink" title="利用IMU标定相机流程"></a>利用IMU标定相机流程</h2><ol>
<li>驱动USB摄像头</li>
<li>利用camera_calibration标定相机</li>
</ol>
<p>执行命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosrun camera_calibration cameracalibrator.py --approximate 0.1 --size 9x6 --square 0.03 right:&#x3D;&#x2F;r_cam&#x2F;image_raw left:&#x3D;&#x2F;l_cam&#x2F;image_raw right_camera:&#x3D;&#x2F;r_cam left_camera:&#x3D;&#x2F;l_cam</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image_width: 320</span><br><span class="line">image_height: 240</span><br><span class="line">camera_matrix:</span><br><span class="line">  rows: 3</span><br><span class="line">  cols: 3</span><br><span class="line">  data: [247.284755, 0.000000, 160.857882, 0.000000, 246.200449, 111.816057, 0.000000, 0.000000, 1.000000]</span><br><span class="line"></span><br><span class="line">distortion_coefficients:</span><br><span class="line">  rows: 1</span><br><span class="line">  cols: 5</span><br><span class="line">  data: [-0.405110, 0.167545, -0.000400, -0.002129, 0.000000]</span><br><span class="line"></span><br><span class="line">rectification_matrix:</span><br><span class="line">  rows: 3</span><br><span class="line">  cols: 3</span><br><span class="line">  data: [0.999530, -0.021547, 0.021827, 0.021830, 0.999680, -0.012768, -0.021545, 0.013239, 0.999680]</span><br><span class="line">  </span><br><span class="line">projection_matrix:</span><br><span class="line">  rows: 3</span><br><span class="line">  cols: 4</span><br><span class="line">  data: [227.343911, 0.000000, 160.318575, 0.000000, 0.000000, 227.343911, 109.066130, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>内参矩阵A：(cx,cy)为主光轴点,一般为图像的中心；fx和fy为焦距</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9565709-72d7a6aeb3e0826d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/127/format/webp" alt="img"></p>
</li>
<li><p>畸变参数向量：[k1,k2,p1,p2]</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">camera matrix &#x3D;</span><br><span class="line"></span><br><span class="line">[fx 0.0 cx</span><br><span class="line"></span><br><span class="line">0.0 fy cy</span><br><span class="line"></span><br><span class="line">0.0 0.0 1.0]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>相机标定</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu1604连接蓝牙鼠标</title>
    <url>/2020/02/15/2020-02-15-UbuntuBluetooth/</url>
    <content><![CDATA[<p>打开命令行<br>$ sudo -i</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[bluetooth]# power off</span><br><span class="line">[bluetooth]# power on</span><br><span class="line">[bluetooth]# scan on</span><br><span class="line">[bluetooth]# connect XX:XX:XX:XX:XX:XX</span><br><span class="line">[Arc Touch Mouse SE]# trust</span><br><span class="line">[Arc Touch Mouse SE]# pair</span><br><span class="line">[Arc Touch Mouse SE]# unblock</span><br><span class="line">[Arc Touch Mouse SE]# power off</span><br><span class="line">[bluetooth]# power on</span><br></pre></td></tr></table></figure>

<p>注意先从系统设置的蓝牙里，把之前配对的设备删掉，我还把 /var/lib/bluetooth/…./XX:XX:XX:XX:XX 的老的配对文件也给删了。<br>重新配对后，info 文件里的内容比1楼里的内容多了 ConnectionParameters、IdentityResolvingKey、LocalSignatureKey、LongTermKey 等好几段数据</p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS系统解析</title>
    <url>/2020/02/15/2020-02-15-VINS_Mono_System/</url>
    <content><![CDATA[<h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>基本框架如下图所示<br><img src="/images/VINS%E8%A7%A3%E6%9E%90/VINS%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="image-20191202164309191"></p>
<a id="more"></a>

<p><img src="/images/VINS%E8%A7%A3%E6%9E%90/VINS%E5%B8%A7%E9%97%B4%E7%BA%A6%E6%9D%9F.png" alt="image-20191202163857217"></p>
<blockquote>
<ol>
<li>黄色的是IMU的帧间约束（PVQBaBg 15*1）</li>
<li>蓝色为视觉重投影误差约束（2*1）</li>
<li>绿色为闭环帧，用来计算相对位资，用于闭环优化时使用</li>
<li>红色的是IMU预计分步骤</li>
</ol>
</blockquote>
<p>本文重点看IMU约束与视觉约束</p>
<h4 id="前端使用光流跟踪"><a href="#前端使用光流跟踪" class="headerlink" title="前端使用光流跟踪"></a>前端使用光流跟踪</h4><ol>
<li>cv::goodfeaturesToTrack检测Harris角点</li>
<li>cv::CalcOpticalFlowPyrLK跟踪相邻帧的角点</li>
<li>cv::findFundamentalMat 去除异常点</li>
<li>统一的球面模型</li>
</ol>
<h4 id="关键帧选择机制"><a href="#关键帧选择机制" class="headerlink" title="关键帧选择机制"></a>关键帧选择机制</h4><ol>
<li>平均视差大于某个阈值</li>
<li>跟踪的特征点数量小于某个阈值</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>VINS</tag>
      </tags>
  </entry>
  <entry>
    <title>发布IMU信息到ROS系统中</title>
    <url>/2020/02/15/2020-02-15-Pub_IMU_Message_To_ROS/</url>
    <content><![CDATA[<p>以下记录是在调试树莓派3b中得到的经验</p>
<p>​    本文记录调试树莓派3b中得到的经验，如何把IMU信息发布到ROS系统中。</p>
<a id="more"></a>

<h2 id="发布IMU信息到ROS"><a href="#发布IMU信息到ROS" class="headerlink" title="发布IMU信息到ROS"></a>发布IMU信息到ROS</h2><h2 id="sensor-msgs-Imu-msg"><a href="#sensor-msgs-Imu-msg" class="headerlink" title="sensor_msgs/Imu.msg"></a>sensor_msgs/Imu.msg</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Header header</span><br><span class="line"> </span><br><span class="line">geometry_msgs&#x2F;Quaternion orientation</span><br><span class="line">float64[9] orientation_covariance # Row major about x, y, z axes</span><br><span class="line"> </span><br><span class="line">geometry_msgs&#x2F;Vector3 angular_velocity</span><br><span class="line">float64[9] angular_velocity_covariance # Row major about x, y, z axes</span><br><span class="line"> </span><br><span class="line">geometry_msgs&#x2F;Vector3 linear_acceleration</span><br><span class="line">float64[9] linear_acceleration_covariance # Row major x, y z</span><br></pre></td></tr></table></figure>

<p>其中，文档描述了Imu的消息结构，其中姿态（orientation）类型为四元数（geometry_msgs/Quaternion）；角速度（angular_velocity）和线加速度（linear_acceleration）的类型为三维向量（geometry_msgs/Vector3）。</p>
<h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><ol>
<li><p>WiringPi未安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone WiringPi</span><br><span class="line">cd WiringPi</span><br><span class="line">sudo chmod 771 .&#x2F;build</span><br><span class="line">sudo .&#x2F;build</span><br></pre></td></tr></table></figure>
</li>
<li><p>I2C device</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建ros包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">catkin_create_pkg beginner_tutorials std_msgs rospy roscpp</span><br></pre></td></tr></table></figure>

<p>然后修改XML和CMakeLists.txt</p>
</li>
</ol>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>IMU</tag>
      </tags>
  </entry>
  <entry>
    <title>VIO主流框架</title>
    <url>/2020/02/15/2020-02-15-VIO_Framework/</url>
    <content><![CDATA[<p>本节主要说明当前主流的VIO算法流程。课程来源于<a href="https://www.bilibili.com/video/av44472237?t=297" target="_blank" rel="noopener">B站</a>。</p>
<a id="more"></a>

<h2 id="高斯牛顿法"><a href="#高斯牛顿法" class="headerlink" title="高斯牛顿法"></a>高斯牛顿法</h2><p>误差项:<br>$$<br>e(x+\Delta x)=e(x)+J(x)\Delta x<br>$$</p>
<ol>
<li>一次观测</li>
<li>多次观测</li>
<li>逆深度 + VIO</li>
</ol>
<h2 id="EKF滤波和优化"><a href="#EKF滤波和优化" class="headerlink" title="EKF滤波和优化"></a>EKF滤波和优化</h2><ol>
<li>EKF铝箔相当于之迭代一次的优化，区别是滤波仅考虑上一帧的影响，而优化则考虑所有帧的影响</li>
<li>多次优化精度比滤波高，但效率低于滤波，因优化可以迭代多次，不断优化线性化点，是误差最小</li>
</ol>
<h2 id="IMU预积分"><a href="#IMU预积分" class="headerlink" title="IMU预积分"></a>IMU预积分</h2><ol>
<li>积分下一个时刻的PVQ作为视觉初始值</li>
<li>预计分相邻帧的PVQ变化量，作为IMU的约束</li>
<li>计算IMU误差的协方差和jacobian</li>
</ol>
<p><img src="/images/photo/image-20191202112248399.png" alt="image-20191202112248399"></p>
<h2 id="VIO分类"><a href="#VIO分类" class="headerlink" title="VIO分类"></a>VIO分类</h2><ol>
<li><p>将视觉约束就加到联合优化是紧耦合</p>
</li>
<li><p>将视觉约束后的位姿加入到联合优化是松耦合</p>
</li>
</ol>
<p><img src="/image/image-20191202135710367.png" alt="image-20191202135710367"></p>
<h3 id="MSCKF"><a href="#MSCKF" class="headerlink" title="MSCKF"></a>MSCKF</h3><p>具体流程如下所示:</p>
<ol>
<li>初始化</li>
<li>IMU预测</li>
<li>视觉跟踪</li>
<li>视觉增广</li>
<li>视觉更新—选老点或者看不见的点</li>
<li>视觉更新—边缘化</li>
<li>剔除老帧</li>
</ol>
<p><img src="/images/SLAM/image-20191202142230678.png" alt="image-20191202142230678"></p>
<p>误差状态向量<br>$$<br>\hat{X_k}^{(15+6N)\times1} = [\hat{X_{IMU_k}} \delta \theta_{C_1} \ce{G}\hat{p}<em>{C_1} …\ce{^{G}\hat{p}</em>{c_N} \ce{G}\hat{p}_{C_N}}]<br>$$</p>
<p>$$<br>\hat{X}_{IMU}_k^{15\times1}=[\delta\theta_I  \hat{b_g}\space\ce{G}\hat{v}_I\hat{b}_a\space \ce{G}\hat{p}_I ]^T<br>$$</p>
<blockquote>
<p>每得到一个新图像以后需要对协方差矩阵做一个增广</p>
</blockquote>
<p><img src="/images/SLAM/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E6%8E%A8%E5%AF%BC/MSCKF%E5%AF%B9%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%E7%9A%84%E5%A2%9E%E5%B9%BF.png" alt="MSCKF对协方差矩阵的增广"></p>
<p><img src="/images/SLAM/MSCKF%E6%BB%A4%E6%B3%A2.png" alt="image-20191202144228268"></p>
<blockquote>
<p>成熟的路标点 表示窗口内各帧都看得到的点</p>
</blockquote>
<p><strong>因子图</strong></p>
<p><img src="/images/SLAM/MSCKF%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="image-20191202145520572"></p>
<blockquote>
<p>Tbc表示IMU与相机间的转换矩阵</p>
</blockquote>
<p><img src="/images/SLAM/%E8%BE%B9%E7%BC%98%E5%8C%961.png" alt="image-20191202145642717"></p>
<p><img src="/images/SLAM/%E8%BE%B9%E7%BC%98%E5%8C%962.png" alt="image-20191202145714060"></p>
<p>路标点边缘化完后就可以了</p>
<p><strong>第j个路标点的所有视觉误差为</strong><br>$$<br>r^{2M\times1}\cong H_x^{2M\times(15+6N)\tilde{X}^{(15+N)\times1}}+H_f^{2M\times3}\ce{G}\hat{p}_{f_j}^{3\times1}+n^{2M\times1}<br>$$<br><img src="/images/SLAM/MSCKF%E5%9B%A0%E5%AD%90%E5%9B%BE3.png" alt="image-20191202150951897"></p>
<p>将r投影到Hf的左零空间，想党羽对路标点进行边缘化，将边缘化约束来优化共视帧。<br>$$<br>r_0^(2M-3M_L)\times1=A^Tr^2M\times1\cong A^TH_{x}^{2M\times(15+6N)}\tilde{X}^{(15+6N)\times1}+A^Tn^(2M\times1)<br>$$</p>
<h3 id="ROVIO"><a href="#ROVIO" class="headerlink" title="ROVIO"></a>ROVIO</h3><blockquote>
<p>复杂 不常用</p>
</blockquote>
<p>流程</p>
<ol>
<li>IMU预测</li>
<li>视觉更新</li>
<li>IEKF</li>
<li>相机模型</li>
<li>像素坐标校正</li>
<li>光度误差</li>
<li>QR分解</li>
<li>Paych提取及Warp计算</li>
<li>路标点质量评价及维护</li>
</ol>
<p><img src="/images/SLAM/ROVIO%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image-20191202152338738"></p>
<blockquote>
<p>ROVIO使用光度误差</p>
<p><img src="/images/SLAM/ROVIO%E7%8A%B6%E6%80%81%E5%90%91%E9%87%8F.png" alt="image-20191202152951499"></p>
</blockquote>
<blockquote>
<blockquote>
<p>ROVIO将路标点包含到状态向量中。有因将路标点表征在当前帧的坐标系下，有范围限制，因此对其进行归一化得到无约束的状态量—方向向量Bearing Vector</p>
</blockquote>
</blockquote>
<p>ROVIO的创新点如下所示：</p>
<p>ROVIO中，路标点使用当前帧下的归一化相机系坐标Pc和你深度表示，并作为状态向量进行预测和更新。参数化不同导致预测和更新的细节不同，但总体还是EKF五大公式。又因Pc有边界约束，因此引入了Bearing  Vector老了使得Pc平滑可导</p>
<p><img src="/images/SLAM/ROVIO%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png" alt="image-20191202153359978"></p>
<p>状态向量：当前帧的PVQB和路标点( mu,p)</p>
<p><img src="/images/SLAM/ROVIO%E7%8A%B6%E6%80%81%E5%90%91%E9%87%8F.png" alt="image-20191202154121085"></p>
<p>因子图如下</p>
<p><img src="/images/SLAM/ROVIO%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="image-20191202154600998"></p>
<h3 id="VINS"><a href="#VINS" class="headerlink" title="VINS"></a>VINS</h3><h4 id="优化向量"><a href="#优化向量" class="headerlink" title="优化向量"></a>优化向量</h4><blockquote>
<p>包括滑动窗口内的n个相机状态PVQB、Camera到IMU的外参、m个3D点的逆深度：</p>
</blockquote>
<p>$$<br>X=[x_0,x_1,…x_n,x_c^b,\lambda_0,\lambda_1,…\lambda_m]<br>$$</p>
<p><img src="/images/SLAM/VINS%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="image-20191202155816170"></p>
<blockquote>
<p>框表示滑动窗口，T中的R、t表示P、Q ；M中的是v和b；lambda表示路标的逆深度；（外参没有考虑）</p>
</blockquote>
<h3 id="VI-ORB"><a href="#VI-ORB" class="headerlink" title="VI-ORB"></a>VI-ORB</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="/images/SLAM/VIORB%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image-20191202160942722"></p>
<p>Tracklocal map：仅优化当前帧</p>
<p><img src="/images/SLAM/VIORB%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="image-20191202160729305"></p>
<p>Local Map：优化华创内的所有帧的PVQB和路标点</p>
<p><img src="/images/SLAM/VIORB_LocalBA%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="image-20191202161217237"></p>
<h3 id="ICE-BA"><a href="#ICE-BA" class="headerlink" title="ICE-BA"></a>ICE-BA</h3><p><strong>增量式BA</strong>，误差为IMU和视觉，LBA为滑窗优化，GBA为所有KF优化，速度很快。</p>
<p><img src="/home/guoben/ICE-BA%E5%9B%A0%E5%AD%90%E5%9B%BE.png" alt="image-20191202161618980"></p>
<p>ICE-BA认为在建立增量方程时，对之前已经算过的且不变的那些状态向量没必要重新线性化（线性化及计算Jacobian），因为即使重新计算Jacobian也没什么变化。另外，也没必要对整体[H|b]矩阵进行消元，而是只对变化的进行更新。最后只计算变化的路标点即可。对于没有变化的状态向量的临时值则一直保存下来，避免重新计算。</p>
<p>总结而言，在ICE-BA中更新Factor有三种情况：</p>
<ol>
<li>该Factor在本次迭代中没有变化，则不更新；</li>
<li>该Factor是新Factor，则在原来基础上+=新Factor。如新观察到一个新的路标点，则对此新路标点的观测约束就是一个新的Factor；</li>
<li>该Factor已存在但需要更新，则先减去旧Factor，再架上新Factor。</li>
</ol>
<p><img src="/images/SLAM/ICEBA_LocalBA%E4%B8%8EGlobalBA.png" alt="image-20191202162754352"></p>
]]></content>
      <tags>
        <tag>VINS</tag>
        <tag>VIO</tag>
      </tags>
  </entry>
  <entry>
    <title>使用evo工具评测SLAM</title>
    <url>/2020/02/15/2020-02-19-How_to_use_evo/</url>
    <content><![CDATA[<p>evo是一款用于视觉里程计和slam问题的轨迹评估工具。核心功能是能够绘制相机的轨迹，或评估估计轨迹与真值的误差。支持多种数据集的轨迹格式（TUM、KITTI、EuRoC MAV、ROS的bag），同时支持这些数据格式之间进行相互转换。在此仅对其基本功能做简要介绍。并且介绍如何修改经典的SLAM算法以输出可使用evo评测的轨迹。</p>
<p><a href="https://github.com/MichaelGrupp/evo" target="_blank" rel="noopener">github地址</a></p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>使用pypi直接安装：</li>
</ol>
<figure class="highlight plain"><figcaption><span>install evo --upgrade --no-binary evo ```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 本地编译安装</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; pip install --editable . --upgrade --no-binary evo</span><br></pre></td></tr></table></figure>
<p>安装完毕后，在命令行输入evo，若显示了相关信息，则表明安装成功。若提示”command not found”也不用惊慌，很多人遇到这种问题，重启电脑即可找到evo相应指令。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>指标</strong></p>
<ul>
<li><code>evo_ape</code> - absolute pose error - 绝对误差计算绝对位姿误差(absolute pose error)，用于整体评估整条轨迹的全局一致性；<br>evo_rpe：计算相对位姿误差(relative pose error)，用于评价轨迹局部的准确性。</li>
<li><code>evo_rpe</code>  - relative pose error - 相对误差 （相对误差=绝对误差/真值）</li>
</ul>
<p><strong>工具命令</strong></p>
<ul>
<li><p><code>evo_traj</code> - tool for analyzing, plotting or exporting one or more trajectories 对轨迹进行分析、画图</p>
</li>
<li><p><code>evo_res</code> - tool for comparing one or multiple result files from <code>evo_ape</code> or <code>evo_rpe</code> 对比多个结果</p>
</li>
<li><p><code>evo_fig</code> - (experimental) tool for re-opening serialized plots (saved with <code>--serialize_plot</code>) </p>
</li>
<li><p><code>evo_config</code> - tool for global settings and config file manipulation -设置参数</p>
</li>
<li><p><code>-va</code> a 对齐轨迹</p>
</li>
</ul>
<p>evo绘制轨迹的指令为：evo_traj，后跟必要参数有：数据的格式（tum/kitti/bag/euroc等），轨迹文件。轨迹文件可以有多个，例如：<br>evo_traj tum traj1.txt traj2.txt<br>这个指令只是显示轨迹的基本信息，若要绘制轨迹，则增加可选参数 -p 或 –plot<br>evo_traj tum traj1.txt –p</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>对比/绘制VINS-mono/fusion的轨迹时需要对其代码进行修改，具体参考<a href="https://blog.rneko.com/posts/3937502838.html" target="_blank" rel="noopener">该博客</a>.</li>
</ul>
<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><h3 id="EuRoC"><a href="#EuRoC" class="headerlink" title="EuRoC"></a>EuRoC</h3><p>画groundtruth的轨迹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evo_traj euroc .&#x2F;groundtruth&#x2F;MH_01_data.csv -p --plot_mode&#x3D;xyz</span><br></pre></td></tr></table></figure>

<p>画某一次结果的轨迹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evo_traj tum .&#x2F;result&#x2F;MH_01&#x2F;loop_result.csv -p --plot_mode&#x3D;xyz</span><br></pre></td></tr></table></figure>

<h3 id="TUM"><a href="#TUM" class="headerlink" title="TUM"></a>TUM</h3><p>groundtruth.txt 为外部运动捕捉系统采集到的相机位姿,格式为(time, t x , t y , t z , q x , q y , q z , q w ),</p>
<h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><h3 id="VINS-Mono"><a href="#VINS-Mono" class="headerlink" title="VINS-Mono"></a>VINS-Mono</h3><p>VINS-mono的估计结果需要按照TUM格式输出 因此要对代码做一些调整。在一下两个文件中修改即可。</p>
<ul>
<li><p>“vins_result_loop” : defined in [path to Vins folder]/pose_graph/src/pose_graph.cpp ; line 156 or 630. The format is timestamp + position(x,y, z) + quaternion(qw, qx, qy, qz).</p>
</li>
<li><p>“vins_result_no_loop”: defined in [path to Vins folder]/vins_estimator/src/utility/visualization.cpp in function pubOdometry(). </p>
<p>The format is timestamp + position(x,y, z) + quaternion(qw, qx, qy, qz) + velocity(x,y,z).</p>
</li>
</ul>
<p>代码修改过程：</p>
<p><strong>visualization.cpp -&gt; Pubodometry ()</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// write result to file 为了按照TUM格式输出 调换了位置</span></span><br><span class="line"><span class="keyword">double</span> turetime = header.stamp.toSec();</span><br><span class="line"><span class="function">ofstream <span class="title">foutC</span><span class="params">(VINS_RESULT_PATH, ios::app)</span></span>;</span><br><span class="line">foutC.setf(ios::fixed, ios::floatfield);</span><br><span class="line">foutC &lt;&lt; turetime &lt;&lt;<span class="string">" "</span></span><br><span class="line">      &lt;&lt; estimator.Ps[WINDOW_SIZE].x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; estimator.Ps[WINDOW_SIZE].y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; estimator.Ps[WINDOW_SIZE].z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; tmp_Q.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; tmp_Q.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; tmp_Q.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; tmp_Q.w() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>*<em>pose_graph.cpp *</em></p>
<p>updatePath()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (SAVE_LOOP_PATH)</span><br><span class="line">   &#123;        </span><br><span class="line">       <span class="function">ofstream <span class="title">loop_path_file</span><span class="params">(<span class="string">"/home/guoben/Documents/output/loop_result.csv"</span>, ios::app)</span></span>;</span><br><span class="line">       <span class="keyword">double</span> turetime = cur_kf-&gt;time_stamp;</span><br><span class="line">       loop_path_file.setf(ios::fixed, ios::floatfield);</span><br><span class="line">       loop_path_file  &lt;&lt; turetime &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; P.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; P.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; P.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; Q.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; Q.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; Q.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; Q.w() &lt;&lt; <span class="built_in">endl</span>;           </span><br><span class="line">      loop_path_file.<span class="built_in">close</span>();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//一共有两处</span></span><br><span class="line">       <span class="keyword">if</span> (SAVE_LOOP_PATH)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="function">ofstream <span class="title">loop_path_file</span><span class="params">(VINS_RESULT_PATH, ios::app)</span></span>;</span><br><span class="line">           loop_path_file.setf(ios::fixed, ios::floatfield);</span><br><span class="line">           loop_path_file &lt;&lt; (*it)-&gt;time_stamp &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">           loop_path_file  &lt;&lt; P.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; P.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; P.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; Q.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; Q.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; Q.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; Q.w() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">           loop_path_file.<span class="built_in">close</span>();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<p>画某一个结果的轨迹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evo_traj tum .&#x2F;loop_result.csv -p --plot_mode&#x3D;xyz</span><br></pre></td></tr></table></figure>

<p>对比结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evo_rpe euroc .&#x2F;groundtruth&#x2F;MH_01_data.csv .&#x2F;result&#x2F;MH_01&#x2F;vins_result_loop.csv -va -r full --plot</span><br></pre></td></tr></table></figure>

<p>MSCKF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ofstream foutC(&quot;&#x2F;home&#x2F;guoben&#x2F;Documents&#x2F;output&#x2F;result_vio.csv&quot;, ios::app);</span><br><span class="line">&#x2F;&#x2F; foutC.setf(ios::fixed, ios::floatfield);</span><br><span class="line">&#x2F;&#x2F; foutC &lt;&lt; odom_msg.header.stamp.toSec() &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.position.x &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.position.y &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.position.z &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.orientation.x &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.orientation.y &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.orientation.z &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.orientation.w &lt;&lt; endl;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>VIO</tag>
        <tag>evo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用evo工具评测SLAM</title>
    <url>/2020/02/15/EVO%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>evo是一款用于视觉里程计和slam问题的轨迹评估工具。核心功能是能够绘制相机的轨迹，或评估估计轨迹与真值的误差。支持多种数据集的轨迹格式（TUM、KITTI、EuRoC MAV、ROS的bag），同时支持这些数据格式之间进行相互转换。在此仅对其基本功能做简要介绍。并且介绍如何修改经典的SLAM算法以输出可使用evo评测的轨迹。</p>
<p><a href="https://github.com/MichaelGrupp/evo" target="_blank" rel="noopener">github地址</a></p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>使用pypi直接安装：</li>
</ol>
<figure class="highlight plain"><figcaption><span>install evo --upgrade --no-binary evo ```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 本地编译安装</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; pip install --editable . --upgrade --no-binary evo</span><br></pre></td></tr></table></figure>
<p>安装完毕后，在命令行输入evo，若显示了相关信息，则表明安装成功。若提示”command not found”也不用惊慌，很多人遇到这种问题，重启电脑即可找到evo相应指令。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>指标</strong></p>
<ul>
<li><code>evo_ape</code> - absolute pose error - 绝对误差计算绝对位姿误差(absolute pose error)，用于整体评估整条轨迹的全局一致性；<br>evo_rpe：计算相对位姿误差(relative pose error)，用于评价轨迹局部的准确性。</li>
<li><code>evo_rpe</code>  - relative pose error - 相对误差 （相对误差=绝对误差/真值）</li>
</ul>
<p><strong>工具命令</strong></p>
<ul>
<li><p><code>evo_traj</code> - tool for analyzing, plotting or exporting one or more trajectories 对轨迹进行分析、画图</p>
</li>
<li><p><code>evo_res</code> - tool for comparing one or multiple result files from <code>evo_ape</code> or <code>evo_rpe</code> 对比多个结果</p>
</li>
<li><p><code>evo_fig</code> - (experimental) tool for re-opening serialized plots (saved with <code>--serialize_plot</code>) </p>
</li>
<li><p><code>evo_config</code> - tool for global settings and config file manipulation -设置参数</p>
</li>
<li><p><code>-va</code> a 对齐轨迹</p>
</li>
</ul>
<p>evo绘制轨迹的指令为：evo_traj，后跟必要参数有：数据的格式（tum/kitti/bag/euroc等），轨迹文件。轨迹文件可以有多个，例如：<br>evo_traj tum traj1.txt traj2.txt<br>这个指令只是显示轨迹的基本信息，若要绘制轨迹，则增加可选参数 -p 或 –plot<br>evo_traj tum traj1.txt –p</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>对比/绘制VINS-mono/fusion的轨迹时需要对其代码进行修改，具体参考<a href="https://blog.rneko.com/posts/3937502838.html" target="_blank" rel="noopener">该博客</a>.</li>
</ul>
<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><h3 id="EuRoC"><a href="#EuRoC" class="headerlink" title="EuRoC"></a>EuRoC</h3><p>画groundtruth的轨迹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evo_traj euroc .&#x2F;groundtruth&#x2F;MH_01_data.csv -p --plot_mode&#x3D;xyz</span><br></pre></td></tr></table></figure>

<p>画某一次结果的轨迹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evo_traj tum .&#x2F;result&#x2F;MH_01&#x2F;loop_result.csv -p --plot_mode&#x3D;xyz</span><br></pre></td></tr></table></figure>

<h3 id="TUM"><a href="#TUM" class="headerlink" title="TUM"></a>TUM</h3><p>groundtruth.txt 为外部运动捕捉系统采集到的相机位姿,格式为(time, t x , t y , t z , q x , q y , q z , q w ),</p>
<h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><h3 id="VINS-Mono"><a href="#VINS-Mono" class="headerlink" title="VINS-Mono"></a>VINS-Mono</h3><p>VINS-mono的估计结果需要按照TUM格式输出 因此要对代码做一些调整。在一下两个文件中修改即可。</p>
<ul>
<li><p>“vins_result_loop” : defined in [path to Vins folder]/pose_graph/src/pose_graph.cpp ; line 156 or 630. The format is timestamp + position(x,y, z) + quaternion(qw, qx, qy, qz).</p>
</li>
<li><p>“vins_result_no_loop”: defined in [path to Vins folder]/vins_estimator/src/utility/visualization.cpp in function pubOdometry(). </p>
<p>The format is timestamp + position(x,y, z) + quaternion(qw, qx, qy, qz) + velocity(x,y,z).</p>
</li>
</ul>
<p>代码修改过程：</p>
<p><strong>visualization.cpp -&gt; Pubodometry ()</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// write result to file 为了按照TUM格式输出 调换了位置</span></span><br><span class="line"><span class="keyword">double</span> turetime = header.stamp.toSec();</span><br><span class="line"><span class="function">ofstream <span class="title">foutC</span><span class="params">(VINS_RESULT_PATH, ios::app)</span></span>;</span><br><span class="line">foutC.setf(ios::fixed, ios::floatfield);</span><br><span class="line">foutC &lt;&lt; turetime &lt;&lt;<span class="string">" "</span></span><br><span class="line">      &lt;&lt; estimator.Ps[WINDOW_SIZE].x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; estimator.Ps[WINDOW_SIZE].y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; estimator.Ps[WINDOW_SIZE].z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; tmp_Q.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; tmp_Q.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; tmp_Q.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">      &lt;&lt; tmp_Q.w() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>*<em>pose_graph.cpp *</em></p>
<p>updatePath()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (SAVE_LOOP_PATH)</span><br><span class="line">   &#123;        </span><br><span class="line">       <span class="function">ofstream <span class="title">loop_path_file</span><span class="params">(<span class="string">"/home/guoben/Documents/output/loop_result.csv"</span>, ios::app)</span></span>;</span><br><span class="line">       <span class="keyword">double</span> turetime = cur_kf-&gt;time_stamp;</span><br><span class="line">       loop_path_file.setf(ios::fixed, ios::floatfield);</span><br><span class="line">       loop_path_file  &lt;&lt; turetime &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; P.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; P.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; P.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; Q.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; Q.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; Q.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; Q.w() &lt;&lt; <span class="built_in">endl</span>;           </span><br><span class="line">      loop_path_file.<span class="built_in">close</span>();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//一共有两处</span></span><br><span class="line">       <span class="keyword">if</span> (SAVE_LOOP_PATH)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="function">ofstream <span class="title">loop_path_file</span><span class="params">(VINS_RESULT_PATH, ios::app)</span></span>;</span><br><span class="line">           loop_path_file.setf(ios::fixed, ios::floatfield);</span><br><span class="line">           loop_path_file &lt;&lt; (*it)-&gt;time_stamp &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">           loop_path_file  &lt;&lt; P.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; P.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; P.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; Q.x() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; Q.y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; Q.z() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                 &lt;&lt; Q.w() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">           loop_path_file.<span class="built_in">close</span>();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<p>画某一个结果的轨迹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evo_traj tum .&#x2F;loop_result.csv -p --plot_mode&#x3D;xyz</span><br></pre></td></tr></table></figure>

<p>对比结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evo_rpe euroc .&#x2F;groundtruth&#x2F;MH_01_data.csv .&#x2F;result&#x2F;MH_01&#x2F;vins_result_loop.csv -va -r full --plot</span><br></pre></td></tr></table></figure>

<p>MSCKF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ofstream foutC(&quot;&#x2F;home&#x2F;guoben&#x2F;Documents&#x2F;output&#x2F;result_vio.csv&quot;, ios::app);</span><br><span class="line">&#x2F;&#x2F; foutC.setf(ios::fixed, ios::floatfield);</span><br><span class="line">&#x2F;&#x2F; foutC &lt;&lt; odom_msg.header.stamp.toSec() &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.position.x &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.position.y &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.position.z &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.orientation.x &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.orientation.y &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.orientation.z &lt;&lt; &quot; &quot;</span><br><span class="line">&#x2F;&#x2F;       &lt;&lt; odom_msg.pose.pose.orientation.w &lt;&lt; endl;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>VIO</tag>
        <tag>evo</tag>
      </tags>
  </entry>
  <entry>
    <title>利用ROS标定相机步骤与方法</title>
    <url>/2020/02/15/%E4%BD%BF%E7%94%A8ROS%E5%B7%A5%E5%85%B7%E6%A0%87%E5%AE%9AUSB%E7%9B%B8%E6%9C%BA/</url>
    <content><![CDATA[<p>本文讲解利用ROS框架下的工具标定USB相机的过程。</p>
<a id="more"></a>

<h2 id="利用IMU标定相机流程"><a href="#利用IMU标定相机流程" class="headerlink" title="利用IMU标定相机流程"></a>利用IMU标定相机流程</h2><ol>
<li>驱动USB摄像头</li>
<li>利用camera_calibration标定相机</li>
</ol>
<p>执行命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rosrun camera_calibration cameracalibrator.py --approximate 0.1 --size 9x6 --square 0.03 right:&#x3D;&#x2F;r_cam&#x2F;image_raw left:&#x3D;&#x2F;l_cam&#x2F;image_raw right_camera:&#x3D;&#x2F;r_cam left_camera:&#x3D;&#x2F;l_cam</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image_width: 320</span><br><span class="line">image_height: 240</span><br><span class="line">camera_matrix:</span><br><span class="line">  rows: 3</span><br><span class="line">  cols: 3</span><br><span class="line">  data: [247.284755, 0.000000, 160.857882, 0.000000, 246.200449, 111.816057, 0.000000, 0.000000, 1.000000]</span><br><span class="line"></span><br><span class="line">distortion_coefficients:</span><br><span class="line">  rows: 1</span><br><span class="line">  cols: 5</span><br><span class="line">  data: [-0.405110, 0.167545, -0.000400, -0.002129, 0.000000]</span><br><span class="line"></span><br><span class="line">rectification_matrix:</span><br><span class="line">  rows: 3</span><br><span class="line">  cols: 3</span><br><span class="line">  data: [0.999530, -0.021547, 0.021827, 0.021830, 0.999680, -0.012768, -0.021545, 0.013239, 0.999680]</span><br><span class="line">  </span><br><span class="line">projection_matrix:</span><br><span class="line">  rows: 3</span><br><span class="line">  cols: 4</span><br><span class="line">  data: [227.343911, 0.000000, 160.318575, 0.000000, 0.000000, 227.343911, 109.066130, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>内参矩阵A：(cx,cy)为主光轴点,一般为图像的中心；fx和fy为焦距</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9565709-72d7a6aeb3e0826d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/127/format/webp" alt="img"></p>
</li>
<li><p>畸变参数向量：[k1,k2,p1,p2]</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">camera matrix &#x3D;</span><br><span class="line"></span><br><span class="line">[fx 0.0 cx</span><br><span class="line"></span><br><span class="line">0.0 fy cy</span><br><span class="line"></span><br><span class="line">0.0 0.0 1.0]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>相机标定</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法简介</title>
    <url>/2020/01/15/2020-01-15-chinese-markdown-cheatsheet/</url>
    <content><![CDATA[<h2 id="分段与分行"><a href="#分段与分行" class="headerlink" title="分段与分行"></a>分段与分行</h2><p>以一个或多个空行来隔开段落；以两个或多个空格来段内换行。</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is an H1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">This is an H2</span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line"># This is an H1</span><br><span class="line"></span><br><span class="line">##  This is an H2</span><br><span class="line"></span><br><span class="line">######  This is an H6</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在每一行前面写一个<code>&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class="line">&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line">&gt;</span><br><span class="line">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class="line">&gt; id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
<p>或者在每一段前面写一个<code>&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class="line">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line"></span><br><span class="line">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class="line">id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>

<h2 id="多重引用"><a href="#多重引用" class="headerlink" title="多重引用"></a>多重引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; This is the first level of quoting.</span><br><span class="line">&gt;</span><br><span class="line">&gt; &gt; This is nested blockquote.</span><br><span class="line">&gt;</span><br><span class="line">&gt; Back to the first level.</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表项占一行，以*、+、-开头即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>有序列表只需要将上述标记符换成数字加句点。而且顺序由书写顺序决定，与数字无关，但数字需要从1开始。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1\.  Bird</span><br><span class="line">3.  McHale</span><br><span class="line">2.  Parish</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<p>每一个列表项可以多行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line">Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class="line">viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class="line">Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</li>
<li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</li>
</ul>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>每一行前面缩进四个或以上个空格，就认为是开始了一段代码块。代码块内原样输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is a normal paragraph:</span><br><span class="line"></span><br><span class="line">    This is a code block.</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p>This is a normal paragraph:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is a code block.</span><br></pre></td></tr></table></figure>

<h2 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h2><p>三个或更多个<code>*</code>、<code>-</code>（它们之间可以有空格）会产生横线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * *</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<hr>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>内嵌链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I get 10 times more traffic from [Google](http:&#x2F;&#x2F;google.com&#x2F; &quot;Google&quot;)</span><br><span class="line">than from [Yahoo](http:&#x2F;&#x2F;search.yahoo.com&#x2F; &quot;Yahoo Search&quot;) or</span><br><span class="line">[MSN](http:&#x2F;&#x2F;search.msn.com&#x2F; &quot;MSN Search&quot;).</span><br></pre></td></tr></table></figure>

<p>或参考文献式链接（缺省的链接标记认为与文本一致）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I get 10 times more traffic from [Google] [1] than from</span><br><span class="line">[Yahoo] [2] or [MSN] [3].</span><br><span class="line"></span><br><span class="line">  [1]: http:&#x2F;&#x2F;google.com&#x2F;        &quot;Google&quot;</span><br><span class="line">  [2]: http:&#x2F;&#x2F;search.yahoo.com&#x2F;  &quot;Yahoo Search&quot;</span><br><span class="line">  [3]: http:&#x2F;&#x2F;search.msn.com&#x2F;    &quot;MSN Search&quot;</span><br><span class="line"></span><br><span class="line">I get 10 times more traffic from [Google][] than from</span><br><span class="line">[Yahoo][] or [MSN][].</span><br><span class="line"></span><br><span class="line">  [google]: http:&#x2F;&#x2F;google.com&#x2F;        &quot;Google&quot;</span><br><span class="line">  [yahoo]:  http:&#x2F;&#x2F;search.yahoo.com&#x2F;  &quot;Yahoo Search&quot;</span><br><span class="line">  [msn]:    http:&#x2F;&#x2F;search.msn.com&#x2F;    &quot;MSN Search&quot;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p>I get 10 times more traffic from <a href="http://google.com/" target="_blank" rel="noopener" title="Google">Google</a> than from <a href="http://search.yahoo.com/" target="_blank" rel="noopener" title="Yahoo Search">Yahoo</a> or <a href="http://search.msn.com/" target="_blank" rel="noopener" title="MSN Search">MSN</a>.</p>
<p>如果直接以链接地址作为链接文本，可以用如下快捷写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;http:&#x2F;&#x2F;www.shengbin.me&gt; 效果：</span><br></pre></td></tr></table></figure>

<p><a href="http://www.shengbin.me/" target="_blank" rel="noopener">http://www.shengbin.me</a></p>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>单个<code>*</code>或<code>_</code>产生斜体，两个（<code>**</code>、<code>__</code>）则产生粗体。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*like* _this_</span><br><span class="line"></span><br><span class="line">**like** **this**</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><em>like</em> <em>this</em></p>
<p><strong>like</strong> <strong>this</strong></p>
<h2 id="内嵌代码"><a href="#内嵌代码" class="headerlink" title="内嵌代码"></a>内嵌代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code: &#96;echo hello&#96;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p>code: <code>echo hello</code></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片与链接类似，只需在文本前面加上感叹号<code>!</code>即可。图片位置和大小无法通过Markdown来指定。</p>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>以下特殊字符需要用<code>\</code>转义得到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\   backslash</span><br><span class="line">&#96;   backtick</span><br><span class="line">*   asterisk</span><br><span class="line">_   underscore</span><br><span class="line">&#123;&#125;  curly braces</span><br><span class="line">[]  square brackets</span><br><span class="line">()  parentheses</span><br><span class="line">#   hash mark</span><br><span class="line">+   plus sign</span><br><span class="line">-   minus sign (hyphen)</span><br><span class="line">.   dot</span><br><span class="line">!   exclamation mark</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM各算法运行方法与过程</title>
    <url>/2020/01/15/2020-01-15-SLAM_Alg_Indirect/</url>
    <content><![CDATA[<p>本文介绍本人在实践过程中遇到的各个间接法的运行和配置过程。</p>
<p>主要包括以下五种算法:</p>
<ol>
<li>VINS_mono/fusion</li>
<li>OKVIS</li>
<li>ROVIO</li>
<li>VI_ORB-SLAM</li>
<li>MSCKF</li>
</ol>
<a id="more"></a>

<h2 id="VINS-mono"><a href="#VINS-mono" class="headerlink" title="VINS_mono"></a>VINS_mono</h2><hr>
<h2 id="OKVIS"><a href="#OKVIS" class="headerlink" title="OKVIS"></a>OKVIS</h2><h3 id="Run-OKVIS"><a href="#Run-OKVIS" class="headerlink" title="Run OKVIS"></a>Run OKVIS</h3><p>可能需要加入std::ftream<br>Opencv需要3.4.2或以下版本，需要opencvv模块<br>Opencv3.4.7没有这个模块</p>
<hr>
<h2 id="ROVIO"><a href="#ROVIO" class="headerlink" title="ROVIO"></a>ROVIO</h2><p>可参考：[该博客]<a href="https://www.cnblogs.com/Jessica-jie/p/6607719.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jessica-jie/p/6607719.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">catkin build rovio --cmake-args -DCMAKE_BUILD_TYPE&#x3D;Release -DMAKE_SCENE&#x3D;ON</span><br></pre></td></tr></table></figure>

<h3 id="运行ROVIO"><a href="#运行ROVIO" class="headerlink" title="运行ROVIO"></a>运行ROVIO</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ source devel&#x2F;setup.bash </span><br><span class="line">$ roslaunch rovio rovio_node.launch</span><br></pre></td></tr></table></figure>

<h3 id="修改代码以输出路径"><a href="#修改代码以输出路径" class="headerlink" title="修改代码以输出路径"></a>修改代码以输出路径</h3><p>在发送IMU数据下边添加输出到文件的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;把数据写到文档里</span><br><span class="line"> std::ofstream vio_result_file(&quot;&#x2F;home&#x2F;guoben&#x2F;Documents&#x2F;output&#x2F;vio_result.csv&quot;, ios::app);</span><br><span class="line"> vio_result_file &lt;&lt; ros::Time(mpFilter_-&gt;safe_.t_) &lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; imuOutput_.WrWB()(0) &lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; imuOutput_.WrWB()(1) &lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; imuOutput_.WrWB()(2)  &lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; imuOutput_.qBW().x()  &lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; imuOutput_.qBW().y()&lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; imuOutput_.qBW().z() &lt;&lt; &quot; &quot; </span><br><span class="line"> &lt;&lt; -imuOutput_.qBW().w() &lt;&lt; std::endl;</span><br><span class="line"> vio_result_file.close();</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="VI-ORB-SLAM"><a href="#VI-ORB-SLAM" class="headerlink" title="VI-ORB_SLAM"></a>VI-ORB_SLAM</h2><p><a href="https://github.com/jingpang/LearnVIORB" target="_blank" rel="noopener"> LearnVIORB 的代码地址</a><br>代码运行方法<br>轨迹生成<br>输出位置位于 System.cc    </p>
<hr>
<h2 id="MSCKF"><a href="#MSCKF" class="headerlink" title="MSCKF"></a>MSCKF</h2><h3 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">roslaunch msckf_vio msckf_vio_euroc.launch </span><br><span class="line">rosrun rviz rviz -d ~&#x2F;Project&#x2F;msckf_vio_workspace&#x2F;src&#x2F;msckf_vio&#x2F;rviz&#x2F;rviz_euroc_config.rviz   &#x2F;&#x2F;rviz显示模型</span><br><span class="line">  rosbag play &#x2F;home&#x2F;wj&#x2F;Downloads&#x2F;dataset&#x2F;EuRoC&#x2F;ROS_bag&#x2F;MH_05_difficult.bag</span><br></pre></td></tr></table></figure>

<p><strong>NOTE</strong><br>The software does not run on EuRoC <code>MH_01_easy.bag</code> and <code>MH_02_easy.bag</code>. As explained in the README, the algorithm requires the sensor to start from staic in order to initialize the orientation and IMU bias. unfortunately, <code>MH_01_easy.bag</code> and <code>MH_02_easy.bag</code> do not have the initial static period.</p>
]]></content>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World!</title>
    <url>/2020/01/14/2020-01-14_hello_world/</url>
    <content><![CDATA[<p>今天是我生平的第一个博客空间！</p>
<p>以后把好玩的东西、学习过程都写在这里！</p>
<p>愿世界和平！</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>Hello</tag>
        <tag>me</tag>
      </tags>
  </entry>
</search>
