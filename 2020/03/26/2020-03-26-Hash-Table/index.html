<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="曾梦想仗剑走天涯" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    哈希表与C++ |  曾是少年
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/images/cat.ico" />
  
  
<link rel="stylesheet" href="/css/main.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-2020-03-26-Hash-Table" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  哈希表与C++
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/26/2020-03-26-Hash-Table/" class="article-date">
  <time datetime="2020-03-26T03:32:17.000Z" itemprop="datePublished">2020-03-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.2k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">16分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<p>本节将介绍哈希表的基本概念，与C++实现方法。</p>
<a id="more"></a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>若关键字为<strong>k</strong>，则其值存放在<strong>f(k)</strong>的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系<strong>f</strong>为散列函数，按这个思想建立的表为散列表。</p>
</li>
<li><p>对不同的关键字可能得到同一散列地址，即<code>k1≠k2</code>，而<code>f(k1)=f(k2)</code>，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数<code>f(k)</code>和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。</p>
</li>
<li><p>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</p>
</li>
</ol>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。</p>
<p>实际工作中需视不同的情况采用不同的哈希函数，通常考虑的因素有：</p>
<ol>
<li><p>计算哈希函数所需时间</p>
</li>
<li><p>关键字的长度</p>
</li>
<li><p>哈希表的大小</p>
</li>
<li><p>关键字的分布情况</p>
</li>
<li><p>记录的查找频率</p>
</li>
</ol>
<h3 id="1-直接寻址法"><a href="#1-直接寻址法" class="headerlink" title="1. 直接寻址法"></a>1. 直接寻址法</h3><p>取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种<a href="https://baike.baidu.com/item/散列函数" target="_blank" rel="noopener">散列函数</a>叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。</p>
<h3 id="2-数字分析法"><a href="#2-数字分析法" class="headerlink" title="2. 数字分析法"></a>2. 数字分析法</h3><p>分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p>
<h3 id="3-平方取中法"><a href="#3-平方取中法" class="headerlink" title="3. 平方取中法"></a>3. 平方取中法</h3><p>当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。 [1] </p>
<p>例：我们把英文字母在字母表中的位置序号作为该英文字母的内部编码。例如K的内部编码为11，E的内部编码为05，Y的内部编码为25，A的内部编码为01, B的内部编码为02。由此组成关键字“KEYA”的内部代码为11052501，同理我们可以得到关键字“KYAB”、“AKEY”、“BKEY”的内部编码。之后对关键字进行平方运算后，取出第7到第9位作为该关键字哈希地址，如下图所示</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>内部编码</th>
<th>内部编码的平方值</th>
<th>H(k)关键字的哈希地址</th>
</tr>
</thead>
<tbody><tr>
<td>KEYA</td>
<td>11052501</td>
<td>122157778355001</td>
<td>778</td>
</tr>
<tr>
<td>KYAB</td>
<td>11250102</td>
<td>126564795010404</td>
<td>795</td>
</tr>
<tr>
<td>AKEY</td>
<td>01110525</td>
<td>001233265775625</td>
<td>265</td>
</tr>
<tr>
<td>BKEY</td>
<td>02110525</td>
<td>004454315775625</td>
<td>315</td>
</tr>
</tbody></table>
<h3 id="4-折叠法"><a href="#4-折叠法" class="headerlink" title="4. 折叠法"></a>4. 折叠法</h3><p>将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。</p>
<h3 id="5-随机数法"><a href="#5-随机数法" class="headerlink" title="5. 随机数法"></a>5. 随机数法</h3><p>选择一随机函数，取关键字的随机值作为散列地址，即$H(key)=random(key)$其中random为随机函数,通常用于关键字长度不等的场合。</p>
<h3 id="6-除留余数法"><a href="#6-除留余数法" class="headerlink" title="6. 除留余数法"></a>6. 除留余数法</h3><p>取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即$H(key) = key \mod p,p&lt;=m$。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。</p>
<h2 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h2><h3 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1. 开放寻址法"></a>1. 开放寻址法</h3><p>$H_i=(H(key) + d_i) MOD m,i=1,2，…，k(k&lt;=m-1）$，其中<code>H(key）</code>为散列函数，<code>m</code>为散列表长，$d_i$为增量序列，可有下列三种取法：<br>1.1. di=1,2,3，…，m-1，称线性探测再散列；<br>1.2. di=1^2,-1^2,2^2,-2^2，⑶^2，…，±（k)^2,(k&lt;=m/2）称二次探测再散列；<br>1.3. di=伪随机数序列，称伪随机探测再散列。</p>
<h3 id="2-再散列法"><a href="#2-再散列法" class="headerlink" title="2. 再散列法"></a>2. 再散列法</h3><p>$H_i=RH_i(key), i=1,2，…，k$ ,$RH_i$均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。</p>
<h3 id="3-链地址法（拉链法）"><a href="#3-链地址法（拉链法）" class="headerlink" title="3. 链地址法（拉链法）"></a>3. 链地址法（拉链法）</h3><h3 id="4-建立一个公共溢出区"><a href="#4-建立一个公共溢出区" class="headerlink" title="4. 建立一个公共溢出区"></a>4. 建立一个公共溢出区</h3><h2 id="查找性能"><a href="#查找性能" class="headerlink" title="查找性能"></a>查找性能</h2><p>​        散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平均查找长度来衡量。<br>​        查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素：</p>
<ol>
<li>散列函数是否均匀；</li>
<li>处理冲突的方法；</li>
<li>散列表的装填因子。<br>散列表的装填因子定义为：α= 填入表中的元素个数 / 散列表的长度<br>α是散列表装满程度的标志因子。由于表长是定值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。<br>实际上，散列表的平均查找长度是装填因子α的函数，只是不同处理冲突的方法有不同的函数。</li>
</ol>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>C++中的STL提供了hash_map来实现哈希表功能，但在C++11中，<code>unordered_map</code>作为一种关联容器，替代了<code>hash_map</code>，<code>unordered_map</code>的底层实现是<code>hash</code>表，所以被称为无序关联容器。<br>不管是map还是unordered_map都是一种 key-map(value) 映射的容器，提供非常高的查找效率，下面我们来了解<code>unordered_map</code>的用法。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>在讲解<code>unordered_map</code>之前，我们先得了解一些预备知识：</p>
<h4 id="元素类型"><a href="#元素类型" class="headerlink" title="元素类型"></a>元素类型</h4><p>除常用的语言内置类型以外，<code>unordered_map</code>的元素类型大致有以下几种：</p>
<ul>
<li>value_type : unordered_map元素类型，这种类型的形式为 key-map类型，key和map的类型都是模板类型。</li>
<li>key_type : key，模板类型</li>
<li>mapped_type ：map，即我们常说的value，模板类型</li>
<li>pair类型 ：pair类型也是STL中的常用类型，原型为template &lt;class T1, class T2&gt; struct pair;由于unordered_map使用的就是Key-Map匹配对，所以在这里使用比较多。</li>
</ul>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>插槽：英文为bucket，又可以翻译成桶。在hash表中，hash函数通常返回一个整型(或无符号整型)元素，对应hash表的数组下标，但是数组类型通常为指针指向一片内存或者是一个链表头，对应许多元素，就像一个桶可以装很多元素，这里称为插槽。</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">unordered_map</span> <span class="params">( size_type n = N,<span class="keyword">const</span> hasher&amp; hf = hasher(),<span class="keyword">const</span> key_equal&amp; eql = key_equal(),<span class="keyword">const</span> allocator_type&amp; alloc = allocator_type() )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个构造函数接受无参数构造</p>
<ul>
<li>n：为hash表的最小插槽数，如果未指定，将会被自动确定(取决于特定的库实现，并不固定)</li>
<li>hf: hash函数，因为底层实现是hash表，必然就有hash函数，STL提供了非常全面的不同类型的hash函数实现，也可以自己实现hash函数。</li>
<li>key_equal:判断两个key对象的hash值相等以确定查找的命中，STL提供了大部分的不同类型的key_equal实现，同样也可以实现hash函数</li>
<li>alloc：容易使用的内存构造器，可选择不同的内存构建方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explicit unordered_map ( const allocator_type&amp; alloc );</span><br></pre></td></tr></table></figure>

<p>指定unordered_map的构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class InputIterator&gt;</span><br><span class="line">unordered_map ( InputIterator first, InputIterator last,size_type n &#x3D; N,const hasher&amp; hf &#x3D; hasher(),const key_equal&amp; eql &#x3D; key_equal(),const allocator_type&amp; alloc &#x3D; allocator_type() );</span><br></pre></td></tr></table></figure>

<p>接收输入迭代器构造方式，将迭代器指向的元素区间进行复制构造</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map ( const unordered_map&amp; ump );</span><br><span class="line">unordered_map ( const unordered_map&amp; ump, const allocator_type&amp; alloc );</span><br></pre></td></tr></table></figure>

<p>复制构造，第二个可指定构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map ( unordered_map&amp;&amp; ump );</span><br><span class="line">unordered_map ( unordered_map&amp;&amp; ump, const allocator_type&amp; alloc );</span><br></pre></td></tr></table></figure>

<p>移动构造方式，这个C++11中新支持的特性，移动构造方式提供临时变量的引用，即右值引用的功能,&amp;表示左值引用，&amp;&amp;表示右值引用。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map ( initializer_list&lt;value_type&gt; il,size_type n &#x3D; N,const hasher&amp; hf &#x3D; hasher(),const key_equal&amp; eql &#x3D; key_equal(),const allocator_type&amp; alloc &#x3D; allocator_type() );</span><br></pre></td></tr></table></figure>

<p>以传入列表的形式构造</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>[<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>](<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>) strmap( &#123;&#123;<span class="string">"name"</span>,<span class="string">"downey"</span>&#125;,&#123;<span class="string">"age"</span>,<span class="string">"500"</span>&#125;&#125; );</span><br></pre></td></tr></table></figure>

<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h5 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mapped_type&amp; <span class="title">at</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> mapped_type&amp; <span class="title">at</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>根据Key值查找容器内元素，并返回map元素的引用。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mymap=&#123;<span class="string">"key"</span>,<span class="number">111</span>&#125;;</span><br><span class="line"><span class="built_in">map</span>.at(<span class="string">"key"</span>)=<span class="number">123</span>;</span><br><span class="line"><span class="built_in">map</span>.at(<span class="string">"key"</span>)+=<span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<h5 id="begin"><a href="#begin" class="headerlink" title="begin()"></a>begin()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">local_iterator <span class="title">begin</span> <span class="params">( size_type n )</span></span>;</span><br><span class="line"><span class="function">const_local_iterator <span class="title">begin</span> <span class="params">( size_type n )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>指向容器内第一个元素的迭代器。迭代器访问元素时，it-&gt;first对应key，it-&gt;second对应map(value).</p>
<h5 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">local_iterator <span class="title">end</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function">const_local_iterator <span class="title">end</span> <span class="params">(size_type n)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>指向容器内最后一个元素的后一个位置的迭代器。</p>
<h5 id="cbegin"><a href="#cbegin" class="headerlink" title="cbegin()"></a>cbegin()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const_iterator cbegin() const noexcept;</span><br><span class="line">const_local_iterator cbegin ( size_type n ) const;</span><br></pre></td></tr></table></figure>

<p>返回const类型的第一位置迭代器</p>
<h5 id="cend"><a href="#cend" class="headerlink" title="cend()"></a>cend()</h5><p>返回const类型的最后一个位置的下一位置的迭代器。</p>
<h4 id="清空：clear"><a href="#清空：clear" class="headerlink" title="清空：clear()"></a>清空：clear()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void clear() noexcept;</span><br></pre></td></tr></table></figure>

<p>删除容器内所有元素。</p>
<h4 id="计数：count"><a href="#计数：count" class="headerlink" title="计数：count()"></a>计数：count()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_type count ( const key_type&amp; k ) const;</span><br></pre></td></tr></table></figure>

<p>某个key值对应的map(value)值的数量，因为unordered_map不允许重复元素，所以返回值总是0或1</p>
<h4 id="emplace"><a href="#emplace" class="headerlink" title="emplace()"></a>emplace()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class... Args&gt;</span><br><span class="line">pair&lt;iterator, bool&gt; emplace ( Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure>

<p>如果key元素是唯一的，在unordered_map中插入新元素，使用Args作为元素构造函数的参数来构造这个新元素。参数为右值引用。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mymap.emplace (&quot;NCC-1701&quot;, &quot;J.T. Kirk&quot;);</span><br></pre></td></tr></table></figure>

<p>即可插入相应的map元素</p>
<h4 id="emplace-hint"><a href="#emplace-hint" class="headerlink" title="emplace_hint()"></a>emplace_hint()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class... Args&gt;</span><br><span class="line">iterator emplace_hint ( const_iterator position, Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure>

<p>与emplace()操作一致，position参数则是提供一个建议搜索位置的起点的提示，可以优化执行时间。</p>
<h4 id="判断是否为空：empty"><a href="#判断是否为空：empty" class="headerlink" title="判断是否为空：empty()"></a>判断是否为空：empty()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool empty() const noexcept;</span><br></pre></td></tr></table></figure>

<p>判断容器是否为空，返回bool值</p>
<h4 id="擦除：erase"><a href="#擦除：erase" class="headerlink" title="擦除：erase()"></a>擦除：erase()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iterator erase ( const_iterator position );</span><br><span class="line">size_type erase ( const key_type&amp; k );</span><br><span class="line">iterator erase ( const_iterator first, const_iterator last );</span><br></pre></td></tr></table></figure>

<p>根据不同的索引擦除插槽中的元素.</p>
<h4 id="查找：find"><a href="#查找：find" class="headerlink" title="查找：find()"></a>查找：find()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iterator find ( const key_type&amp; k );</span><br><span class="line">const_iterator find ( const key_type&amp; k ) const;</span><br></pre></td></tr></table></figure>

<p>查找函数，通过key查找一个元素，返回迭代器类型。</p>
<h4 id="查找：bucket"><a href="#查找：bucket" class="headerlink" title="查找：bucket()"></a>查找：bucket()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">bucket</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>以key值寻找元素在容器中的位置。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str_map map1;</span><br><span class="line">map1.insert(&#123;<span class="string">"downey"</span>,<span class="string">"hello"</span>&#125;);   </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;map1.bucket (it-&gt;first)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">output:</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>从返回值可以看出，即使是插入的第一个元素，位置也不一定是1，这跟容器的hash实现相关。</p>
<h4 id="插入：insert"><a href="#插入：insert" class="headerlink" title="插入：insert()"></a>插入：insert()</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;iterator,bool&gt; insert ( const value_type&amp; val );</span><br></pre></td></tr></table></figure>

<p>直接插入元素类型，返回pair类型，返回值pair第一元素是插入元素迭代器，第二元素表示操作是否成功</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator,bool&gt; <span class="title">insert</span> ( <span class="title">P</span>&amp;&amp; <span class="title">val</span> );</span></span><br></pre></td></tr></table></figure>

<p>移动插入方式，可以传入右值插入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">( const_iterator hint, <span class="keyword">const</span> value_type&amp; val )</span></span>;</span><br></pre></td></tr></table></figure>

<p>用户给出一个插入起点以优化查找时间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">( const_iterator hint, P&amp;&amp; val )</span></span>;</span><br><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( InputIterator first, InputIterator last )</span></span>;</span><br></pre></td></tr></table></figure>

<p>复制型插入，将(first,last]所包含的内容全部复制插入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( <span class="built_in">initializer_list</span>&lt;value_type&gt; il )</span></span>;</span><br></pre></td></tr></table></figure>

<p>插入一个列表形式的元素</p>
<h4 id="比较：key-eq"><a href="#比较：key-eq" class="headerlink" title="比较：key_eq()"></a>比较：key_eq()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回比较关键相等性的函数。获取key equal函数，key_equal函数为判断key值是否匹配，在一般情况下，hash函数并不能保证每一个输入对应一个独一无二的输出，可能多个输入会对应同一个输出，这就是hash冲突。可能一个槽内同时由多个元素，这时候就需要使用key_equal来进行进一步判断。</p>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><h5 id="‘-’-运算符重载"><a href="#‘-’-运算符重载" class="headerlink" title="‘=’ 运算符重载"></a>‘=’ 运算符重载</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&amp; <span class="keyword">operator</span>= ( <span class="keyword">const</span> <span class="built_in">unordered_map</span>&amp; ump );</span><br><span class="line"><span class="built_in">unordered_map</span>&amp; <span class="keyword">operator</span>= ( <span class="built_in">unordered_map</span>&amp;&amp; ump );</span><br><span class="line"><span class="built_in">unordered_map</span>&amp; <span class="keyword">operator</span>= ( intitializer_list&lt;value_type&gt; il );</span><br></pre></td></tr></table></figure>

<p>以不同方式对容器进行赋值。</p>
<h5 id="‘-’-操作符重载"><a href="#‘-’-操作符重载" class="headerlink" title="‘[]’ 操作符重载"></a>‘[]’ 操作符重载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapped_type&amp; operator[] ( const key_type&amp; k );</span><br><span class="line">mapped_type&amp; operator[] ( key_type&amp;&amp; k );</span><br></pre></td></tr></table></figure>

<p>[]操作符重载，使得容易可以通过map[Key]的方式进行索引。</p>
<h4 id="重建：rehash"><a href="#重建：rehash" class="headerlink" title="重建：rehash()"></a>重建：rehash()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void rehash( size_type n );</span><br></pre></td></tr></table></figure>

<p>重建hash表，将插槽的数量扩展的n，如果n小于目前插槽数量，这个函数并不起作用。</p>
<h4 id="翻转：reserve"><a href="#翻转：reserve" class="headerlink" title="翻转：reserve()"></a>翻转：reserve()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void reserve ( size_type n );</span><br></pre></td></tr></table></figure>

<p>将容器的插槽数设置成最适合n个元素的情况，这样可以避免多次rehash和直接rehash空间的浪费。</p>
<p>与rehash相比，这个函数由用户给一个插槽数量建议值，由系统去分配空间，而rehash则是指定容器的插槽值</p>
<h4 id="大小：size"><a href="#大小：size" class="headerlink" title="大小：size()"></a>大小：size()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_type size() const noexcept;</span><br></pre></td></tr></table></figure>

<p>返回当前容器中元素的个数</p>
<h4 id="交换：swap"><a href="#交换：swap" class="headerlink" title="交换：swap()"></a>交换：swap()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void swap ( unordered_map&amp; ump )</span><br></pre></td></tr></table></figure>

<p>交换两个容器的内容，两个容器的类型必须一致，但大小可以不同。</p>
<h4 id="内部信息获取"><a href="#内部信息获取" class="headerlink" title="内部信息获取"></a>内部信息获取</h4><h5 id="get-allocator"><a href="#get-allocator" class="headerlink" title="get_allocator()"></a>get_allocator()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocator_type get_allocator() const noexcept;</span><br></pre></td></tr></table></figure>

<p>返回容器目前使用的内存构造器。</p>
<h5 id="hash-function"><a href="#hash-function" class="headerlink" title="hash_function()"></a>hash_function()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasher hash_function() const;</span><br></pre></td></tr></table></figure>

<p>获取hash容器当前使用的hash函数</p>
<h5 id="bucket-count"><a href="#bucket-count" class="headerlink" title="bucket_count()"></a>bucket_count()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回hash表的插槽值个数，这个函数的值对应构造函数中的n(最小插槽数)参数。</p>
<h5 id="max-bucket-count"><a href="#max-bucket-count" class="headerlink" title="max_bucket_count()"></a>max_bucket_count()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_type max_bucket_count() const noexcept;</span><br></pre></td></tr></table></figure>

<p>返回容器所能支持的最大插槽数，根据平台不同而不同，一般是一个非常大的数字。</p>
<h5 id="bucket-size"><a href="#bucket-size" class="headerlink" title="bucket_size()"></a>bucket_size()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_type bucket_size ( size_type n ) const;</span><br></pre></td></tr></table></figure>

<p>这个函数返回每个插槽中的元素数量。</p>
<h5 id="max-load-factor"><a href="#max-load-factor" class="headerlink" title="max_load_factor()"></a>max_load_factor()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float max_load_factor() const noexcept;</span><br><span class="line">void max_load_factor ( float z );</span><br></pre></td></tr></table></figure>

<p>第一个函数是查询目前容器最大的负载因子，默认为1。</p>
<p>第二个函数是进行最大的负载因子的设置。</p>
<h5 id="max-size"><a href="#max-size" class="headerlink" title="max_size()"></a>max_size()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_type max_size() const noexcept;</span><br></pre></td></tr></table></figure>

<p>容器可支持的元素最大数量，linux平台下，使用4.8.5的STL库中这个值是：268435455</p>
<h5 id="load-factor"><a href="#load-factor" class="headerlink" title="load_factor()"></a>load_factor()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float load_factor() const noexcept;</span><br></pre></td></tr></table></figure>

<p>load factor在中文中被翻译成负载因子，负载因子是容器中元素数量与插槽数量之间的比例。即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor &#x3D; size &#x2F; bucket_count</span><br></pre></td></tr></table></figure>

<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><h5 id="使用迭代器遍历"><a href="#使用迭代器遍历" class="headerlink" title="使用迭代器遍历"></a>使用迭代器遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> n:deck)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">map</span>[n]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=<span class="built_in">map</span>[deck[<span class="number">0</span>]];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator  iter;</span><br><span class="line"><span class="keyword">for</span>(iter = <span class="built_in">map</span>.<span class="built_in">begin</span>(); iter != <span class="built_in">map</span>.<span class="built_in">end</span>(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">    res = gcd(res,iter-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res&gt;=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://grobenis.github.io/2020/03/26/2020-03-26-Hash-Table/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="tag">哈希表</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/03/26/2020-03-26-Epipolar-constraint/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            对极约束
          
        </div>
      </a>
    
    
      <a href="/2020/03/26/2020-03-26-LeetCode-CheckDaily/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">LeetCode 每日打卡3-26</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2020
        guoben
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/cat.ico" alt="曾是少年"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://www.cnblogs.com/guoben/" target="_blank" rel="noopener">博客</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://cengshishaonian37279.lofter.com/" target="_blank" rel="noopener">生活</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/pay/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/share.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['曾梦想仗剑走天涯', '愿你出走半生，归来仍是少年', '一杯敬朝阳，一杯敬月光'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>




<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/js/ayer.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>