<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="曾梦想仗剑走天涯" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    C++开发面试题汇总 |  曾是少年
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/images/cat.ico" />
  
  
<link rel="stylesheet" href="/css/main.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-C-开发面试题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  C++开发面试题汇总
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2020-08-18T14:13:56.000Z" itemprop="datePublished">2020-08-18</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E4%BD%9C/">工作</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">102.2k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">367分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>本文整理自网络：</p>
<ol>
<li><a href="https://www.nowcoder.com/tutorial/93/8f140fa03c084299a77459dc4be31c95" target="_blank" rel="noopener">C++面经宝典</a></li>
<li>现代操作系统</li>
<li>计算机网络</li>
<li>数据库系统概论</li>
<li>设计模式</li>
</ol>
<a id="more"></a>

<h1 id="一-C-基础"><a href="#一-C-基础" class="headerlink" title="一 C++基础"></a>一 C++基础</h1><h2 id="一-基本语言"><a href="#一-基本语言" class="headerlink" title="一 基本语言"></a>一 基本语言</h2><h3 id="零-编译过程"><a href="#零-编译过程" class="headerlink" title="零 编译过程"></a>零 编译过程</h3><h4 id="1-源文件从文本到可执行文件经历的过程"><a href="#1-源文件从文本到可执行文件经历的过程" class="headerlink" title="1. 源文件从文本到可执行文件经历的过程"></a>1. 源文件从文本到可执行文件经历的过程</h4><p><strong>简单版本</strong></p>
<p>对于C++源文件，从文本到可执行文件一般需要<strong>四个过程</strong></p>
<blockquote>
<p>1、<strong>预处理阶段</strong>：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</p>
<p>2、<strong>编译阶段</strong>：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</p>
<p>3、<strong>汇编阶段</strong>：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</p>
<p>4、<strong>链接阶段</strong>：将多个目标文件及所需要的库连接成最终的可执行目标文件</p>
</blockquote>
<p><strong>详细版本</strong></p>
<p><strong>1 预编译：主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</strong></p>
<blockquote>
<p>1、删除所有的#define，展开所有的<strong>宏定义</strong>。</p>
<p>2、处理所有的<strong>条件预编译指令</strong>，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p>
<p>3、处理“<strong>#include”预编译指令</strong>，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</p>
<p>4、删除所有的<strong>注释</strong>，“//”和“/**/”。</p>
<p>5、保留所有的<strong>#pragma 编译器指令</strong>，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</p>
<p>6、添加<strong>行号和文件标识</strong>，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</p>
</blockquote>
<p><strong>2 编译：把预编译之后生成的<code>xxx.i</code>或<code>xxx.ii</code>文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</strong></p>
<blockquote>
<p>1、<strong>词法分析</strong>：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p>
<p>2、<strong>语法分析</strong>：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</p>
<p>3、<strong>语义分析</strong>：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p>
<p>4、<strong>优化</strong>：源代码级别的一个优化过程。</p>
<p>5、<strong>目标代码生成</strong>：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p>
<p>6、<strong>目标代码优化</strong>：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p>
</blockquote>
<p><strong>3）汇编</strong></p>
<blockquote>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 </p>
<p>汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是<strong>根据汇编指令和机器指令的对照表一一翻译</strong>过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。</p>
</blockquote>
<p><strong>4）链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接</strong></p>
<blockquote>
<ul>
<li><p>静态库（.a 、.lib）：（Windows 下的 .lib，Linux 和 Mac 下的 .a）一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。</p>
</li>
<li><p>动态库（.so 、.dll ）：（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib）</p>
</li>
</ul>
<p>1、<strong>静态链接</strong></p>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p>
<ul>
<li>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</li>
<li>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</li>
<li>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</li>
</ul>
<p>2、<strong>动态链接</strong></p>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<ul>
<li>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</li>
<li>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</li>
<li>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</li>
</ul>
</blockquote>
<h4 id="2-include头文件的顺序，双引号””和尖括号-lt-gt-的区别？"><a href="#2-include头文件的顺序，双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="2. include头文件的顺序，双引号””和尖括号&lt;&gt;的区别？"></a>2. include头文件的顺序，双引号””和尖括号&lt;&gt;的区别？</h4><blockquote>
<p>Include头文件的顺序：对于include的头文件来说，如果在文件<code>a.h</code>中声明一个在文件<code>b.h</code>中定义的变量，而不引用<code>b.h</code>。那么要在<code>a.c</code>文件中引用<code>b.h</code>文件，并且要先引用<code>b.h</code>，后引用<code>a.h</code>,否则汇报变量类型未声明错误。</p>
<p><strong>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。</strong></p>
<p>对于使用双引号包含的头文件，查找头文件路径的顺序为</p>
<ol>
<li>当前头文件目录</li>
<li>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</li>
<li>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</li>
</ol>
<p>对于使用尖括号包含的头文件，查找头文件的路径顺序为：</p>
<ol>
<li>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</li>
<li>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</li>
</ol>
</blockquote>
<h3 id="一-变量和基本类型"><a href="#一-变量和基本类型" class="headerlink" title="一 变量和基本类型"></a>一 变量和基本类型</h3><h4 id="1-static"><a href="#1-static" class="headerlink" title="1. static"></a>1. static</h4><p><strong>简短回答</strong></p>
<blockquote>
<ol>
<li>对于函数定义和代码块之外的<strong>全局变量</strong>声明，static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。</li>
<li>对于代码块<strong>内部的变量</strong>声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。</li>
<li>对于被static修饰的<strong>普通函数</strong>，其只能在定义它的源文件中使用，不能在其他源文件中被引用</li>
<li>对于被static修饰的<strong>类成员变量和成员函数</strong>，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。</li>
</ol>
</blockquote>
<p><strong>其它解答</strong></p>
<blockquote>
<ol>
<li><p>加了static关键字的全局变量只能在本文件中使用。例如在a.c中定义了static int a=10;那么在b.c中用extern int a是拿不到a的，a的作用域只在a.c中。 </p>
</li>
<li><p>static定义的静态局部变量分配在数据段上，普通的局部变量分配在栈上，会因为函数栈的释放而被释放掉。</p>
</li>
<li><p>对一个类中成员变量和成员函数来说，加了static关键字，则此变量/函数就没有了this指针了，必须通过类名才能访问</p>
</li>
</ol>
</blockquote>
<p><strong>详细说明</strong></p>
<blockquote>
<ol>
<li><strong>全局静态变量</strong></li>
</ol>
<blockquote>
<p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.</p>
<p>静态存储区，在整个程序运行期间一直存在。</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
</blockquote>
<ol start="2">
<li><strong>局部静态变量</strong></li>
</ol>
<blockquote>
<p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p>
<p>内存中的位置：静态存储区</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
</blockquote>
<ol start="3">
<li><strong>静态函数</strong></li>
</ol>
<blockquote>
<p>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p>
<p>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>
<p>warning：不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p>
</blockquote>
<ol start="4">
<li><strong>类的静态成员</strong></li>
</ol>
<blockquote>
<p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>
</blockquote>
<ol start="5">
<li><strong>类的静态函数</strong></li>
</ol>
<blockquote>
<p>静态成员函数和静态数据成员一样，都属于类的静态成员，都不是对象成员。因此，对静态成员的引用不需要用对象名。</p>
<p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>
</blockquote>
</blockquote>
<h4 id="2-静态变量什么时候初始化"><a href="#2-静态变量什么时候初始化" class="headerlink" title="2. 静态变量什么时候初始化"></a>2. 静态变量什么时候初始化</h4><blockquote>
<p>静态变量存储在虚拟地址空间的数据段和bss段，</p>
<p>C语言中其在代码执行之前初始化，属于编译期初始化。</p>
<p>而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造</p>
</blockquote>
<h4 id="3-C-中四种cast类型转换"><a href="#3-C-中四种cast类型转换" class="headerlink" title="3. C++中四种cast类型转换"></a>3. C++中四种cast类型转换</h4><blockquote>
<p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast</p>
<p><strong>1、const_cast</strong></p>
<p>将const变量转为非const</p>
<p><strong>2、static_cast</strong></p>
<p>各种隐式转换， static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p>
<p><strong>3、dynamic_cast</strong></p>
<p>动态类型转换。</p>
<p>只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p>
<p>向上转换：指的是子类向基类的转换</p>
<p>向下转换：指的是基类向子类的转换</p>
<p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p>
<p><strong>4、reinterpret_cast</strong></p>
<p>几乎什么都可以转，比如将int转指针，可能会出问题，几乎什么都可以转，</p>
<p><strong>5、为什么不使用C的强制转换？</strong></p>
<p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
</blockquote>
<blockquote>
<table>
<thead>
<tr>
<th>类型转换</th>
<th>功能</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td>const_cast</td>
<td>把const变量转换为非const变量；<br>去掉变量const属性或者volatile属性的转换符</td>
<td align="left"></td>
</tr>
<tr>
<td>static_cast</td>
<td>各种隐式转换， <br>static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</td>
<td align="left">非const转const<br>void*转指针等,</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>动态类型转换。<br>只能用于含有虚函数的类，用于类层次间的向上和向下转化。<br>只能转指针或引用。<br>向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。<br>要深入了解内部转换的原理。</td>
<td align="left"></td>
</tr>
<tr>
<td>reinterpret_cast</td>
<td>重新解释（无理）转换</td>
<td align="left">将int转指针，可能会出问题，</td>
</tr>
</tbody></table>
<p>调用方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(str);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="4-const"><a href="#4-const" class="headerlink" title="4. const"></a>4. const</h4><blockquote>
<ol>
<li>const 修饰<strong>变量</strong>：可用于定义常量。const’定义的常量编译器可以对数据静态类型进行安全检查。</li>
<li>const修饰<strong>函数形式参数</strong>：当输入参数为用户自定义类型和抽象数据类型时，可将值传递改为const &amp;传递，可以提高效率。引用传递不需要产生临时对象，节省了临时对象的构造、复制、析构过程消耗的时间。但光用引用可能改变a，因此加const</li>
<li>const可以<strong>修饰函数返回值</strong>：如果要给指针传递的函数返回值加const，则返回值不能被直接修改，且该返回值只能被赋值给加const修饰的同类型指针。</li>
<li>const修饰的<strong>成员函数</strong>：表明函数调用不会对对象做出任何更改。事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">GetChar</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;;</span><br><span class="line"><span class="keyword">char</span> *ch = GetChar(); <span class="comment">//error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ch = GetChar(); <span class="comment">//right</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="5-C-怎么定义常量？常量存放在内存的哪个位置？"><a href="#5-C-怎么定义常量？常量存放在内存的哪个位置？" class="headerlink" title="5. C++怎么定义常量？常量存放在内存的哪个位置？"></a>5. C++怎么定义常量？常量存放在内存的哪个位置？</h4><blockquote>
<p>常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。</p>
<ol>
<li>对于局部对象，常量存放在栈区；</li>
<li>对于全局对象，常量存放在全局/静态存储区；</li>
<li>对于字面值常量，常量存放在常量存储区。</li>
</ol>
</blockquote>
<h4 id="6-以下四行const代码的区别？"><a href="#6-以下四行const代码的区别？" class="headerlink" title="6. 以下四行const代码的区别？"></a>6. 以下四行const代码的区别？</h4><blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * arr = <span class="string">"123"</span>; <span class="comment">//字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</span></span><br><span class="line"><span class="keyword">char</span> * brr = <span class="string">"123"</span>; <span class="comment">//字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改"123"的值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> crr[] = <span class="string">"123"</span>; <span class="comment">//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</span></span><br><span class="line"><span class="keyword">char</span> drr[] = <span class="string">"123"</span>; <span class="comment">//字符串123保存在栈区，可以通过drr去修改</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="7-隐式类型转换"><a href="#7-隐式类型转换" class="headerlink" title="7. 隐式类型转换"></a>7. 隐式类型转换</h4><blockquote>
<p>首先，对于内置类型，低精度变量赋值给高精度变量时会发生隐式类型转换；</p>
<p>其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。</p>
</blockquote>
<h4 id="8-RTTI"><a href="#8-RTTI" class="headerlink" title="8. RTTI"></a>8. <a href="https://www.cnblogs.com/xuelisheng/p/9479288.html" target="_blank" rel="noopener"><code>RTTI</code></a></h4><blockquote>
<p>RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法</p>
<p>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info。</p>
<p>typeid的主要作用就是让用户知道当前变量的类型，对于内置数据类型以及自定义数据类型都生效；</p>
<p>typeid函数返回的是一个结构体或者类，然后，再调用这个返回的结构体或类的name成员函数；</p>
</blockquote>
<h4 id="9-extern"><a href="#9-extern" class="headerlink" title="9. extern"></a>9. extern</h4><blockquote>
<p><strong>extern</strong>是一种“<strong>外部声明</strong>”的关键字，字面意思就是<strong>在此处声明</strong>某种变量或函数，<strong>在外部定义</strong>。</p>
</blockquote>
<blockquote>
<p>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。</p>
<p>extern也可用来进行链接指定。</p>
</blockquote>
<h5 id="extern-“c”的作用"><a href="#extern-“c”的作用" class="headerlink" title="*extern “c”的作用? *"></a>*<em>extern “c”的作用? *</em></h5><blockquote>
<p>Extern “C”是由Ｃ＋＋提供的一个连接交换指定符号，用于告诉Ｃ＋＋这段代码是Ｃ函数。这是因为C++编译后库中函数名会变得很长，与C生成的不一致，造成Ｃ＋＋不能直接调用C函数，加上extren “c”后，C++就能直接调用C函数了。</p>
<p>Extern “C”主要使用正规DLL函数的引用和导出和在C++包含C函数或C头文件时使用。使用时在前面加上extern “c” 关键字即可</p>
<p>extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。</p>
<p>记住下列语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>

<p>仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。</p>
<p>变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。</p>
<p>通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。</p>
<p>例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。</p>
</blockquote>
<blockquote>
<p>C++调用C函数需要extern “C”，因为C语言没有函数重载。</p>
</blockquote>
<blockquote>
<p><strong>extern对应的关键字是static，static表明变量或者函数只能在本模块中使用，因此，被static修饰的变量或者函数不可能被extern C修饰。</strong></p>
</blockquote>
<p><strong>extern “C”的使用要点总结</strong></p>
<blockquote>
<ul>
<li>可以是如下的单一语句</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> doublesqrt(<span class="keyword">double</span>`);</span><br></pre></td></tr></table></figure>

<ul>
<li>可以是复合语句, 相当于复合语句中的声明都加了extern “C”</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以包含头文件，相当于头文件中的声明都加了extern “C”</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line">    ＃include &lt;cmath&gt;</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure>

<ul>
<li>不可以将extern “C” 添加在函数内部</li>
<li>如果函数有多个声明，可以都加extern “C”, 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则。</li>
<li>除extern “C”, 还有extern “FORTRAN” 等。</li>
</ul>
</blockquote>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/carsonzhu/p/5272271.html" target="_blank" rel="noopener">extern “C”的作用详解</a></p>
</blockquote>
<h3 id="二-指针、引用"><a href="#二-指针、引用" class="headerlink" title="二 指针、引用"></a>二 指针、引用</h3><h4 id="1-指针和引用的区别"><a href="#1-指针和引用的区别" class="headerlink" title="1. 指针和引用的区别"></a>1. 指针和引用的区别</h4><p>回答要点：空间、大小、初始化、修改、const、级数、++运算、作为返回值返回。</p>
<blockquote>
<ol>
<li><p>指针有自己的一块空间，而引用只是一个别名；</p>
</li>
<li><p>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</p>
</li>
<li><p>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</p>
</li>
<li><p>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p>
</li>
<li><p>可以有const指针，但是没有const引用；</p>
</li>
<li><p>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p>
</li>
<li><p>指针可以有多级指针（**p），而引用至于一级；</p>
</li>
<li><p>指针和引用使用++运算符的意义不一样；</p>
</li>
<li><p>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p>
</li>
</ol>
</blockquote>
<h4 id="2-数组和指针的区别"><a href="#2-数组和指针的区别" class="headerlink" title="2. 数组和指针的区别"></a>2. 数组和指针的区别</h4><blockquote>
<table>
<thead>
<tr>
<th>指针</th>
<th>数组</th>
</tr>
</thead>
<tbody><tr>
<td>保存数据的地址</td>
<td>保存数据</td>
</tr>
<tr>
<td>间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据</td>
<td>直接访问数据，</td>
</tr>
<tr>
<td>通常用于动态的数据结构</td>
<td>通常用于固定数目且数据类型相同的元素</td>
</tr>
<tr>
<td>通过Malloc分配内存，free释放内存</td>
<td>隐式的分配和删除</td>
</tr>
<tr>
<td>通常指向匿名数据，操作匿名函数</td>
<td>自身即为数据名</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="3-野指针"><a href="#3-野指针" class="headerlink" title="3. 野指针"></a>3. 野指针</h4><blockquote>
<p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</p>
</blockquote>
<h4 id="4-函数指针"><a href="#4-函数指针" class="headerlink" title="4. 函数指针"></a>4. 函数指针</h4><blockquote>
<p><strong>1、定义</strong></p>
<p>函数指针是指向函数的指针变量。</p>
<p>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。</p>
<p>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>
<p><strong>2、用途</strong></p>
<p>调用函数和做函数的参数，比如回调函数。</p>
<p><strong>3、示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fun</span><span class="params">(<span class="keyword">char</span> * p)</span>  </span>&#123;…&#125;    <span class="comment">// 函数fun</span></span><br><span class="line"><span class="keyword">char</span> * (*pf)(<span class="keyword">char</span> * p);       <span class="comment">// 函数指针pf</span></span><br><span class="line">pf = fun;            <span class="comment">// 函数指针pf指向函数fun</span></span><br><span class="line">pf(p);            <span class="comment">// 通过函数指针pf调用函数fun</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="5-传值、传指针和传引用的区别和联系"><a href="#5-传值、传指针和传引用的区别和联系" class="headerlink" title="5. 传值、传指针和传引用的区别和联系"></a>5. 传值、传指针和传引用的区别和联系</h4><blockquote>
<p><strong>指针：</strong>指针就是一个变量，指针存放的是变量的地址。</p>
<p><strong>传值：</strong>传值即实参拷贝传递给形参，单向传递（实参-&gt;形参），赋值完毕后实参就和形参没有任何联系，对形参的修改就不会影响到实参。</p>
<p><strong>传地址：</strong>传地址也是一种传值呢？因为传地址是把实参地址的拷贝传递给形参。对形参地址所指向对象的修改却直接反应在实参中，因为形参指向的对象就是实参的对象。</p>
<p><strong>传引用：</strong>传引用本质没有任何实参的拷贝，其实就是让另外一个变量也执行该实参。就是两个变量指向同一个对象。这是对形参的修改，必然反映到实参上。</p>
<p><strong>分析</strong><br>值传递时函数操作的并不是实参本身，形参和实参是相互独立的，所以对形参进行操作并不会改变实参的值。</p>
<p>引用传递操作地址是实参地址 ，形参相当于实参的一个别名，对它的操作就是对实参的操作。</p>
<p><strong>总结</strong><br>传引用和传指针看上去效果一样的，但本质上有区别：</p>
<p><strong>指针传递</strong>参数本质上是值传递的方式，它所传递的是一个地址值。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。</p>
<p>在值传递过程中，被调函数的形式参数作为被调函数的局部变量，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，指针通过局部变量中存储的地址访空间。</p>
<p>既然形参和实参是相互独立的，在没有任何修饰形参时，形参是可以被修改的，形参指针可以指向任何地方，而且修改后就无法再访问到实参。</p>
<p>例如Pointer函数中n = &amp;b后，（*n）++不会再修改实参的值，这也是传递指针时通常会用const进行修饰的原因。</p>
</blockquote>
<h4 id="6-this指针"><a href="#6-this指针" class="headerlink" title="6. this指针"></a>6. this指针</h4><blockquote>
<p>（1）一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。</p>
<p>（2）this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。</p>
<h5 id="this指针的使用"><a href="#this指针的使用" class="headerlink" title="this指针的使用"></a>this指针的使用</h5><p>（1）在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this。</p>
<p>（2）当参数与成员变量名相同时，如this-&gt;n = n （不能写成n = n)。</p>
</blockquote>
<h3 id="三-智能指针"><a href="#三-智能指针" class="headerlink" title="三 智能指针"></a>三 智能指针</h3><h4 id="0-概念和作用"><a href="#0-概念和作用" class="headerlink" title="0. 概念和作用"></a>0. 概念和作用</h4><blockquote>
<p>智能指针主要用于管理在堆上分配的内存，它把普通的指针封装为一个栈对象。</p>
<p>当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。</p>
<p>因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。</p>
</blockquote>
<h4 id="1-四个智能指针"><a href="#1-四个智能指针" class="headerlink" title="1. 四个智能指针"></a>1. 四个智能指针</h4><p><strong>为什么要使用智能指针</strong></p>
<blockquote>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。</p>
<p>智能指针的作用：<strong>在函数结束时自动释放内存空间，不需要手动释放内存空间</strong>。</p>
</blockquote>
<blockquote>
<p>C++里面的四个智能指针: <strong>auto_ptr, shared_ptr, weak_ptr, unique_ptr</strong> 其中后三个是c++11支持，并且第一个已经被11弃用。</p>
<blockquote>
<p>C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。</p>
<p>只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。</p>
</blockquote>
</blockquote>
<h5 id="1-auto-ptr（c-98的方案，cpp11已经抛弃）"><a href="#1-auto-ptr（c-98的方案，cpp11已经抛弃）" class="headerlink" title="1. auto_ptr（c++98的方案，cpp11已经抛弃）"></a><strong>1. auto_ptr（c++98的方案，cpp11已经抛弃）</strong></h5><blockquote>
<p>采用所有权模式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"I reigned lonely as a cloud.”));</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br></pre></td></tr></table></figure>

<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。</p>
<p>auto_ptr的缺点是：存在潜在的内存崩溃问题！</p>
</blockquote>
<h5 id="2-unique-ptr（替换auto-ptr）"><a href="#2-unique-ptr（替换auto-ptr）" class="headerlink" title="2. unique_ptr（替换auto_ptr）"></a><strong>2. unique_ptr（替换auto_ptr）</strong></h5><blockquote>
<p><strong>unique_ptr实现独占式拥有或严格拥有的概念，保证同一时间内只有一个智能指针可以指向该对象。</strong></p>
<p>采用所有权模式，还是上面那个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"auto"</span>))</span></span>;  <span class="comment">//#4</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4；  <span class="comment">//#5</span></span><br><span class="line">p4 = p3; <span class="comment">//此时会报错！！</span></span><br></pre></td></tr></table></figure>

<p>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</p>
<p>另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"hello world"</span>))</span></span>;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));   <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>

<p>其中#1留下悬挂的<code>unique_ptr(pu1)</code>，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p>
<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。</p>
<p>C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(<span class="string">"hello"</span>);</span><br><span class="line">ps2 = <span class="built_in">move</span>(ps1);</span><br><span class="line">ps1 = demo(<span class="string">"alexia"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-shared-ptr"><a href="#3-shared-ptr" class="headerlink" title="3. shared_ptr"></a><strong>3. shared_ptr</strong></h5><blockquote>
<p><strong>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。</strong></p>
<p>资源可以被多个指针共享，它<strong>使用计数机制来表明资源被几个指针共享</strong>。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入<code>auto_ptr</code>,<code>unique_ptr</code>,<code>weak_ptr</code>来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>成员函数</p>
<ul>
<li>use_count 返回引用计数的个数</li>
<li>unique 返回是否是独占所有权( use_count 为 1)</li>
<li>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</li>
<li>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</li>
<li>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></li>
</ul>
</blockquote>
<h5 id="4-weak-ptr"><a href="#4-weak-ptr" class="headerlink" title="4. weak_ptr"></a><strong>4. weak_ptr</strong></h5><blockquote>
<p>weak_ptr 是<strong>一种不控制对象生命周期的智能指针</strong>。</p>
<p>它指向一个 <code>shared_ptr</code> 管理的对象. 进行该对象的内存管理的是那个强引用的 <code>shared_ptr</code>. </p>
<p>weak_ptr只是提供了对管理对象的一个访问手段。</p>
<p>weak_ptr设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。</p>
<p>它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">      ~A()&#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">	~B()&#123;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">      <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">      pb-&gt;pa_ = pa;</span><br><span class="line">      pa-&gt;pb_ = pb;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb； 改为<code>weak_ptr pb;</code> 这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p>
<p>注意的是我们<strong>不能通过weak_ptr直接访问对象的方法</strong>，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb_-&gt;print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</p>
</blockquote>
<h4 id="2-智能指针会不会内存泄露，如何解决？"><a href="#2-智能指针会不会内存泄露，如何解决？" class="headerlink" title="2. 智能指针会不会内存泄露，如何解决？"></a>2. 智能指针会不会内存泄露，如何解决？</h4><blockquote>
<p>当两个对象相互使用一个<code>shared_ptr</code>成员变量指向对方，会造成循环引用，使引用计数失效，导致内存泄漏。</p>
<p>为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; Child)</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>-&gt;ChildPtr = Child;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ChildPtr.use_count)&#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ~Parent()&#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; parent)</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ParentPtr.use_count)&#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ~Child()&#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">  <span class="built_in">std</span>::weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">      p-&gt;setChild(c);</span><br><span class="line">      p-&gt;setParent(p);</span><br><span class="line">      wpp = p;</span><br><span class="line">      wpc = c;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;p.use_count() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;c.use_count() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;wpp.use_count() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;wpc.use_count() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，parent有一个shared_ptr类型的成员指向孩子，而child也有一个shared_ptr类型的成员指向父亲。然后在创建孩子和父亲对象时也使用了智能指针c和p，随后将c和p分别又赋值给child的智能指针成员parent和parent的智能指针成员child。从而形成了一个循环引用：</p>
</blockquote>
<h4 id="3-智能指针shared-ptr的实现"><a href="#3-智能指针shared-ptr的实现" class="headerlink" title="3. 智能指针shared_ptr的实现"></a>3. 智能指针<code>shared_ptr</code>的实现</h4><p>核心：要理解引用计数，什么时候销毁底层指针，还有赋值，拷贝构造时候的引用计数的变化，析构的时候要判断底层指针的引用计数为0了才能真正释放底层指针的内存</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     T *ptr;    <span class="comment">//底层真实的指针</span></span><br><span class="line">     <span class="keyword">int</span> *use_count;<span class="comment">//保存当前对象被多少指针引用计数</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     SmartPtr(T *p); <span class="comment">//SmartPtr&lt;int&gt;p(new int(2));</span></span><br><span class="line">     SmartPtr(<span class="keyword">const</span> SmartPtr&lt;T&gt;&amp;orig);<span class="comment">//SmartPtr&lt;int&gt;q(p);</span></span><br><span class="line">     SmartPtr&lt;T&gt;&amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr&lt;T&gt; &amp;rhs);<span class="comment">//q=p</span></span><br><span class="line">     ~SmartPtr();</span><br><span class="line">     T <span class="keyword">operator</span>*();  <span class="comment">//为了能把智能指针当成普通指针操作定义解引用操作</span></span><br><span class="line">     T*<span class="keyword">operator</span>-&gt;();  <span class="comment">//定义取成员操作</span></span><br><span class="line">     T* <span class="keyword">operator</span>+(<span class="keyword">int</span> i);<span class="comment">//定义指针加一个常数</span></span><br><span class="line">     <span class="keyword">int</span> <span class="keyword">operator</span>-(SmartPtr&lt;T&gt;&amp;t1,SmartPtr&lt;T&gt;&amp;t2);<span class="comment">//定义两个指针相减</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">getcount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *use_count &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> SmartPtr&lt;T&gt;::<span class="keyword">operator</span>-(SmartPtr&lt;T&gt; &amp;t1, SmartPtr&lt;T&gt; &amp;t2) &#123; <span class="keyword">return</span> t1.ptr-t2.ptr; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; SmartPtr&lt;T&gt;::SmartPtr(T *p) &#123; </span><br><span class="line">     ptr=p; </span><br><span class="line">     <span class="keyword">try</span> &#123; </span><br><span class="line">         use_count=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>); </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">         <span class="keyword">delete</span> ptr;    <span class="comment">//申请失败释放真实指针和引用计数的内存</span></span><br><span class="line">         ptr= <span class="literal">nullptr</span>; <span class="keyword">delete</span> use_count; use_count= <span class="literal">nullptr</span>; </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; SmartPtr&lt;T&gt;::SmartPtr(<span class="keyword">const</span> SmartPtr&lt;T&gt; &amp;orig)&#123;<span class="comment">//复制构造函数</span></span><br><span class="line">     use_count=orig.use_count;<span class="comment">//引用计数保存在一块内存，所有的SmarPtr对象的引用计数都指向这里</span></span><br><span class="line">     <span class="keyword">this</span>-&gt;ptr=orig.ptr;</span><br><span class="line">     ++(*use_count);<span class="comment">//当前对象的引用计数加1</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; SmartPtr&lt;T&gt;&amp; SmartPtr&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr&lt;T&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="comment">//重载=运算符，例如SmartPtr&lt;int&gt;p,q; p=q;这个语句中，首先给q指向的对象的引用计数加1，因为p重新指向了q所指的对象，所以p需要先给原来的对象的引用计数减1，如果减一后为0，先释放掉p原来指向的内存，然后讲q指向的对象的引用计数加1后赋值给p</span></span><br><span class="line">     ++*(rhs.use_count); </span><br><span class="line">     <span class="keyword">if</span>((--*(use_count))==<span class="number">0</span>) &#123; </span><br><span class="line">         <span class="keyword">delete</span> ptr; </span><br><span class="line">         ptr= <span class="literal">nullptr</span>; </span><br><span class="line">         <span class="keyword">delete</span> use_count; </span><br><span class="line">         use_count= <span class="literal">nullptr</span>; </span><br><span class="line">     &#125; </span><br><span class="line"> 	<span class="comment">//SmartPtr的对象会在其生命周期结束的时候调用其析构函数，在析构函数中检测当前对象的引用计数是不是只有正在结束生命周期的这个SmartPtr引用，如果是，就释放掉，如果不是，就还有其他的SmartPtr引用当前对象，就等待其他的SmartPtr对象在其生命周期结束的时候调用析构函数释放掉</span></span><br><span class="line">     ptr=rhs.ptr; </span><br><span class="line">     *use_count=*(rhs.use_count); </span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; SmartPtr&lt;T&gt;::~SmartPtr() &#123; </span><br><span class="line">     getcount(); </span><br><span class="line">     <span class="keyword">delete</span> ptr;</span><br><span class="line">     ptr= <span class="literal">nullptr</span>;</span><br><span class="line">     <span class="keyword">delete</span> use_count;</span><br><span class="line">     use_count=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;T SmartPtr&lt;T&gt;::<span class="keyword">operator</span>*()&#123;</span><br><span class="line">	<span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;T*  SmartPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T* SmartPtr&lt;T&gt;::<span class="keyword">operator</span>+(<span class="keyword">int</span> i)&#123;</span><br><span class="line">     T *temp=ptr+i;</span><br><span class="line">     <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="四-表达式与函数"><a href="#四-表达式与函数" class="headerlink" title="四 表达式与函数"></a>四 表达式与函数</h3><h4 id="1-fork函数"><a href="#1-fork函数" class="headerlink" title="1. fork函数"></a>1. fork函数</h4><blockquote>
<p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
</blockquote>
<h4 id="2-strcpy和strlen的区别"><a href="#2-strcpy和strlen的区别" class="headerlink" title="2. strcpy和strlen的区别"></a>2. strcpy和strlen的区别</h4><blockquote>
<p>strcpy是字符串拷贝函数，原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure>

<p>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。</p>
<p>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</p>
</blockquote>
<h4 id="3-写个函数在main函数前运行"><a href="#3-写个函数在main函数前运行" class="headerlink" title="3. 写个函数在main函数前运行"></a>3. 写个函数在main函数前运行</h4><blockquote>
<p> <a href="https://blog.csdn.net/qq_30968657/article/details/55049341" target="_blank" rel="noopener">使用<code>_attribute_</code>机制</a></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__attribute((constructor))<span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before main\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>void main_enter() <strong>attribute</strong>((constructor)); //main_enter函数在进入main函数前调用<ul>
<li>void main_exit() <strong>attribute</strong>((destructor)); //main_exit函数在main函数返回后调用</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="4-内联函数的作用"><a href="#4-内联函数的作用" class="headerlink" title="4. 内联函数的作用"></a>4. 内联函数的作用</h4><blockquote>
<p><strong>内联函数inline：</strong>引入内联函数的目的是为了解决程序中函数调用的效率问题。</p>
<p>程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x &gt; y)? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max (20,10): "</span> &lt;&lt; Max(<span class="number">20</span>,<span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max (0,200): "</span> &lt;&lt; Max(<span class="number">0</span>,<span class="number">200</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max (100,1010): "</span> &lt;&lt; Max(<span class="number">100</span>,<span class="number">1010</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="5-C语言怎么进行函数调用？"><a href="#5-C语言怎么进行函数调用？" class="headerlink" title="5. C语言怎么进行函数调用？"></a>5. C语言怎么进行函数调用？</h4><blockquote>
<p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。</p>
</blockquote>
<h4 id="6-C语言参数压栈顺序？"><a href="#6-C语言参数压栈顺序？" class="headerlink" title="6. C语言参数压栈顺序？"></a>6. C语言参数压栈顺序？</h4><blockquote>
<p>从右到左</p>
</blockquote>
<h4 id="7-C-如何处理返回值？"><a href="#7-C-如何处理返回值？" class="headerlink" title="7. C++如何处理返回值？"></a>7. C++如何处理返回值？</h4><blockquote>
<p> 函数的返回值用于初始化在调用函数是创建的临时对象。</p>
<p> 1、返回值为非引用类型：</p>
<p> 会将函数的返回值复制给临时对象。跟实参初始化形参的方式一样。</p>
<p> 2、返回值为引用类型：</p>
<p> 没有复制返回值，返回的是对象本身。返回引用时，在函数的参数中要有以引用方式或指针方式传入的要返回的参数</p>
<p> 不能返回局部对象的引用。（因为函数执行结束，将释放分配给局部对象的存储空间，对局部对象的引用就会指向不确定的内存）</p>
</blockquote>
<h4 id="8-说说fork-wait-exec函数"><a href="#8-说说fork-wait-exec函数" class="headerlink" title="8. 说说fork,wait,exec函数"></a>8. 说说fork,wait,exec函数</h4><blockquote>
<p>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。</p>
<p>fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。</p>
<p>exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1</p>
</blockquote>
<h4 id="9-i和i-的区别"><a href="#9-i和i-的区别" class="headerlink" title="9. ++i和i++的区别"></a>9. ++i和i++的区别</h4><blockquote>
<p>++i先自增1，再返回，i++先返回i,再自增1</p>
<p>內建数据类型的时候，效率没有区别；</p>
<p>自定义数据类型的时候，++i的效率更高；</p>
</blockquote>
<p><strong>具体实现</strong></p>
<blockquote>
<p><strong>++i  实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;  <span class="keyword">int</span>::<span class="keyword">operator</span>++（）&#123;</span><br><span class="line">  *<span class="keyword">this</span> +=<span class="number">1</span>；</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>i++实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  <span class="keyword">int</span>::<span class="keyword">operator</span>（<span class="keyword">int</span>）&#123;</span><br><span class="line">  <span class="keyword">int</span> oldValue = *<span class="keyword">this</span>；</span><br><span class="line">  ++（*<span class="keyword">this</span>）；</span><br><span class="line">  <span class="keyword">return</span> oldValue；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="五-Volatile"><a href="#五-Volatile" class="headerlink" title="五 Volatile"></a>五 Volatile</h3><h4 id="1-关键字volatile的含义？"><a href="#1-关键字volatile的含义？" class="headerlink" title="1. 关键字volatile的含义？"></a>1. 关键字volatile的含义？</h4><blockquote>
<p>volatile表示该变量可能会被意向不到的改变，因此编译器不要去假设这个变量的值。</p>
<p>精确地说，优化器在用到这个变量时必须每次都去内存中读取这个变量的值，而不是使用保存在寄存器里的备份。</p>
<p>下面是<code>volatile</code>变量的几个例子：</p>
<ol>
<li>并列设备的硬件寄存器</li>
<li>一个终端服务子程序会访问到的非自动变量</li>
<li>多线程应用中被几个任务共享的变量</li>
</ol>
<p><a href="https://www.runoob.com/w3cnote/c-volatile-keyword.html" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h4 id="2-volatile的特性？"><a href="#2-volatile的特性？" class="headerlink" title="2. volatile的特性？"></a>2. volatile的特性？</h4><blockquote>
<p> volatile 可以保证对特殊地址的稳定访问</p>
<p> 三个特性</p>
<ol>
<li>易变性。易变性在汇编层面，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。</li>
<li>“不可优化”性。volatile告诉编译器，不要这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。</li>
<li>”顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。</li>
</ol>
</blockquote>
<h4 id="3-为什么Volatile不能保证原子性"><a href="#3-为什么Volatile不能保证原子性" class="headerlink" title="3. 为什么Volatile不能保证原子性"></a>3. 为什么Volatile不能保证原子性</h4><p>volatile可以保证可见性和顺序性，但不能保证原子性</p>
<h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a><strong>可见性</strong></h5><blockquote>
<p>volatile保证了变量的可见性，变量经过volatile修饰后，对此变量进行写操作时，汇编指令中会有一个LOCK前缀指令，这个不需要过多了解，但是加了这个指令后，会引发两件事情：</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存</li>
<li>这个写回内存的操作会使得在其他处理器缓存了该内存地址无效</li>
</ul>
<p>什么意思呢？意思就是说<strong>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值，这就保证了可见性。</strong></p>
</blockquote>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><blockquote>
<p>问题来了，既然它可以保证修改的值立即能更新到主存，其他线程也会捕捉到被修改后的值，那么为什么不能保证原子性呢？<br>首先需要了解的是，Java中只有对基本类型变量的赋值和读取是原子操作，如i = 1的赋值操作，但是像j = i或者i++这样的操作都不是原子操作，因为他们都进行了多次原子操作，比如先读取i的值，再将i的值赋值给j，两个原子操作加起来就不是原子操作了。</p>
<p>所以，如果一个变量被volatile修饰了，那么肯定可以保证每次读取这个变量值的时候得到的值是最新的，但是一旦需要对变量进行自增这样的非原子操作，就不会保证这个变量的原子性了。</p>
</blockquote>
<h4 id="4-mutable关键字"><a href="#4-mutable关键字" class="headerlink" title="4. mutable关键字"></a>4. mutable关键字</h4><blockquote>
<ol>
<li>在类中修饰成员变量，当成员函数被const修饰时，可以在const函数中修改该变量的值</li>
<li>在Lambda表达式中，<strong>按值捕获</strong>（值传递）时，不可以在匿名函数体内部修改该值，当<code>[]()mutable{}</code>时可以在函数体内部进行修改，但是不会修改外部的数值</li>
</ol>
</blockquote>
<blockquote>
<p>在C++中，mutable是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中，甚至结构体变量或者类对象为const，其mutable成员也可以被修改。mutable在类中只能够修饰非静态数据成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">mutable</span> <span class="keyword">int</span> a;</span><br><span class="line">     <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">     test(<span class="keyword">int</span> _a,<span class="keyword">int</span> _b) :a(_a),b(_b)&#123;&#125;;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">const</span>            <span class="comment">//fun是const 函数，不能修改类的对象的数据成员，但由于a被mutable修饰，可以修改，但不能修改b</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">           a += b;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">","</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被<code>mutatle</code>来修饰。</p>
</blockquote>
<h3 id="六-异常处理"><a href="#六-异常处理" class="headerlink" title="六 异常处理"></a>六 异常处理</h3><blockquote>
<p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>
<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<ul>
<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>
<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>
<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>
</ul>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。</p>
<p>用 try/catch 语句的语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName e1 )&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName e2 )&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName eN )&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出异常</p>
<p>您可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">"Division by zero condition!"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捕获异常</p>
<p>catch 块跟在 try 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;   </span><br><span class="line">    <span class="comment">// 保护代码 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName e ) &#123;</span><br><span class="line">    <span class="comment">// 处理 ExceptionName 异常的代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码会捕获一个类型为 <strong>ExceptionName</strong> 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;   </span><br><span class="line">    <span class="comment">// 保护代码 </span></span><br><span class="line">&#125;<span class="keyword">catch</span>(...) &#123;  </span><br><span class="line">    <span class="comment">// 能处理任何异常的代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="七-其它操作"><a href="#七-其它操作" class="headerlink" title="七 其它操作"></a>七 其它操作</h3><blockquote>
<p>对输入流操作：seekg（）与tellg（）</p>
<p>对输出流操作：seekp（）与tellp（） seekg（）是对输入文件定位，它有两个参数：第一个参数是偏移量，第二个参数是基地址。 </p>
<p>对于第一个参数，可以是正负数值，正的表示向后偏移，负的表示向前偏移。而第二个参数可以是： ios：：beg：表示输入流的开始位置 ios：：cur：表示输入流的当前位置 ios：：end：表示输入流的结束位置 tellg（）函数不需要带参数，它返回当前定位指针的位置，也代表着输入流的大小。</p>
</blockquote>
<h2 id="二-类与数据抽象"><a href="#二-类与数据抽象" class="headerlink" title="二 类与数据抽象"></a>二 类与数据抽象</h2><h3 id="一-类"><a href="#一-类" class="headerlink" title="一  类"></a>一  类</h3><h4 id="1-若类里面有static、virtual等，类的内存如何分布"><a href="#1-若类里面有static、virtual等，类的内存如何分布" class="headerlink" title="1. 若类里面有static、virtual等，类的内存如何分布"></a>1. 若类里面有static、virtual等，类的内存如何分布</h4><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470920741_7D40CEF3951A10F626301148E06D89DA" alt="img"></p>
<blockquote>
<h4 id="1、static修饰符"><a href="#1、static修饰符" class="headerlink" title="1、static修饰符"></a>1、static修饰符</h4><blockquote>
<p>1）static修饰成员变量</p>
<p>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。</p>
<p>因为静态数据成员在<strong>全局数据区</strong>分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。</p>
<p>2）static修饰成员函数</p>
<p>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。</p>
<p>Static修饰的成员函数，在<strong>代码区</strong>分配内存。</p>
</blockquote>
<h4 id="2、virtual修饰符"><a href="#2、virtual修饰符" class="headerlink" title="2、virtual修饰符"></a>2、virtual修饰符</h4><p>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。</p>
<p>如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着函数指针，函数指针指向代码段中的具体函数。</p>
<p>如果类中成员是virtual属性，会隐藏父类对应的属性。</p>
</blockquote>
<h4 id="2-类中的数据成员-static、const"><a href="#2-类中的数据成员-static、const" class="headerlink" title="2 类中的数据成员(static、const)"></a>2 类中的数据成员(static、const)</h4><h5 id="const-数据成员"><a href="#const-数据成员" class="headerlink" title="const 数据成员"></a><strong>const 数据成员</strong></h5><blockquote>
<p>const 数据成员在某个对象生存期内是常量，对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其 const 数据成员的值可以不同。</p>
<p>不能在类声明中初始化 const 数据成员，因为类的对象未被创建时，编译器不知道const 数据成员的值是什么。</p>
<p> const 数据成员的初始化只能在类的构造函数的初始化表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static const。</p>
</blockquote>
<h5 id="static-数据成员"><a href="#static-数据成员" class="headerlink" title="static 数据成员"></a><strong>static 数据成员</strong></h5><blockquote>
<p>static 数据成员目的是作为类作用域的全局变量，被类里的所有对象共享，即使没有创建任何对象，该成员也存在。</p>
<p>static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。</p>
<p>在类的内部只是声明，定义必须在类定义体的外部，并且不能在函数体内，通常在类外定义时初始化，或者使用静态函数初始化。</p>
<p>借用 gcc 的话：<em>ISO C++ forbids in-class initialization of non-const static member</em></p>
<p>注意：static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在编译时在静态数据区分配内存，到程序结束时才释放。</p>
</blockquote>
<h5 id="const-static-数据成员"><a href="#const-static-数据成员" class="headerlink" title="const static 数据成员"></a><strong>const static 数据成员</strong></h5><blockquote>
<p>const static 数据成员被一个类的所有对象共享，常量，可以在类内定义处初始化，也可以在类外初始化。</p>
</blockquote>
<h5 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a><strong>const 成员函数</strong></h5><blockquote>
<p>const 成员函数主要是防止修改对象的成员变量（mutable 修饰的成员变量，static 变量除外）。</p>
<p>即const成员函数不能修改成员变量的值，但可以访问成员变量。注意 const 成员函数只能保证不修改当前 this 指针所指的对象的成员变量，若通过参数传递进来有别的对象名，是可以修改其成员变量的，还有就是在 const 成员函数里通过 const_cast 移除 *this 的 const 特性后调用一些非 const 成员函数也有可能会改变 *this 对象的成员变量，虽然这种做法其实是错误的。</p>
</blockquote>
<h5 id="static-成员函数"><a href="#static-成员函数" class="headerlink" title="static 成员函数"></a>static 成员函数</h5><blockquote>
<p>static成员函数主要目的是作为<strong>类作用域的全局函数</strong>，不能访问类的非静态数据成员。</p>
<p>类的静态成员函数没有this指针：</p>
<ol>
<li>静态成员函数可以直接访问类的静态数据和函数成员，而访问非静态成员必须通过参数传递的方式得到一个对象名，然后通过对象名来访问，与其不同的是非静态成员函数可以任意地（非）静态成员函数和（非）静态数据成员；</li>
<li>不能被声明为virtual。</li>
</ol>
</blockquote>
<h4 id="3-构造函数中的变量初始化顺序"><a href="#3-构造函数中的变量初始化顺序" class="headerlink" title="3 构造函数中的变量初始化顺序"></a>3 构造函数中的变量初始化顺序</h4><blockquote>
<p><strong>变量的初始化顺序</strong>就应该是：</p>
<p>1 基类的静态变量或全局变量</p>
<p>2 派生类的静态变量或全局变量</p>
<p>3 基类的成员变量</p>
<p>4 派生类的成员变量</p>
</blockquote>
<blockquote>
<ol>
<li>成员变量在使用初始化列表初始化时，<strong>与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关</strong>。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。这点在EffectiveC++中有详细介绍。</li>
<li>如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。</li>
<li><strong>注意：</strong>类成员在定义时，是不能初始化的</li>
<li><strong>注意：</strong>类中const成员常量必须在构造函数初始化列表中初始化。</li>
<li><strong>注意：</strong>类中static成员变量，必须在类外初始化。</li>
<li>静态变量进行初始化顺序是基类的静态变量先初始化，然后是它的派生类。直到所有的静态变量都被初始化。这里需要注意全局变量和静态变量的初始化是不分次序的。</li>
</ol>
</blockquote>
<h4 id="4-析构函数"><a href="#4-析构函数" class="headerlink" title="4 析构函数"></a>4 析构函数</h4><blockquote>
<p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数调用完毕时，系统会自动执行析构函数。</p>
<p>析构函数名应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>
<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>
<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>
</blockquote>
<p>析构函数的其它要点</p>
<blockquote>
<ol>
<li>与构造函数相对应</li>
<li>与构造函数的作用相反</li>
<li>析构函数的形式：~类名( ){…}特点：</li>
<li>固定的函数名称：~类名( )</li>
<li>没有返回类型</li>
<li>没有参数</li>
<li>不可以重载</li>
<li>一般由系统自动调用</li>
<li>当类中含有虚函数的时候，创建该类的对象时，该对象的首地址即为虚函数表的地址，无论对该对象进行怎样的类型转换，该对象都只能访问自己的虚函数表</li>
</ol>
</blockquote>
<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>
<h5 id="3-1-为什么析构函数必须是虚函数？而默认的析构函数不是虚函数？"><a href="#3-1-为什么析构函数必须是虚函数？而默认的析构函数不是虚函数？" class="headerlink" title="3.1. 为什么析构函数必须是虚函数？而默认的析构函数不是虚函数？"></a>3.1. 为什么析构函数必须是虚函数？而默认的析构函数不是虚函数？</h5><blockquote>
<p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<p>C++默认的析构函数不是虚函数是因为<strong>虚函数需要额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
</blockquote>
<h4 id="5-struct与class的区别"><a href="#5-struct与class的区别" class="headerlink" title="5 struct与class的区别"></a>5 struct与class的区别</h4><blockquote>
<p>C语言中，strcut只是一种复杂数据结构类型定义，struct只能定义成员变量，不能定义成员函数，不能使用面向对象编程。</p>
<p>C++中，如果没有标明成员函数或者成员变量的访问权限级别，那么在struct中默认的是public，而class中默认的是private；</p>
</blockquote>
<h4 id="6-C-中类成员的访问权限"><a href="#6-C-中类成员的访问权限" class="headerlink" title="6 C++中类成员的访问权限"></a>6 C++中类成员的访问权限</h4><blockquote>
<p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。</p>
<p>在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。</p>
<p>在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员</p>
</blockquote>
<h4 id="7-拷贝赋值函数的形参能否进行值传递？"><a href="#7-拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="7 拷贝赋值函数的形参能否进行值传递？"></a>7 拷贝赋值函数的形参能否进行值传递？</h4><blockquote>
<p>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。如此循环，无法完成拷贝，栈也会满。</p>
</blockquote>
<h4 id="8-This指针"><a href="#8-This指针" class="headerlink" title="8 This指针"></a>8 This指针</h4><blockquote>
<p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof（对象）的结果。this<a href="https://baike.baidu.com/item/作用域/10944767" target="_blank" rel="noopener">作用域</a>是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，<a href="https://baike.baidu.com/item/编译器/8853067" target="_blank" rel="noopener">编译器</a>会自动将对象本身的地址作为一个隐含<a href="https://baike.baidu.com/item/参数传递/9019335" target="_blank" rel="noopener">参数传递</a>给函数。</p>
</blockquote>
<h4 id="9-Sizeof-计算类的大小计算"><a href="#9-Sizeof-计算类的大小计算" class="headerlink" title="9 Sizeof() 计算类的大小计算"></a>9 Sizeof() 计算类的大小计算</h4><blockquote>
<ul>
<li>空类的大小为1字节</li>
<li>一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。</li>
<li>对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针vptr的大小。</li>
<li>普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小</li>
<li>虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！</li>
<li>虚继承, 继承基类的vptr。</li>
</ul>
</blockquote>
<h4 id="10-友元"><a href="#10-友元" class="headerlink" title="10 友元"></a>10 友元</h4><blockquote>
<p>友元提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员 的机制。也就是说有两种形式的友元：</p>
<p>（1）友元函数：普通函数对一个访问某个类中的私有或保护成员。</p>
<p>（2）友元类：类A中的成员函数访问类B中的私有或保护成员</p>
<p>优点：提高了程序的运行效率。</p>
<p>缺点：破坏了类的封装性和数据的透明性。</p>
<p>总结： - 能访问私有成员 - 破坏封装性 - 友元关系不可传递 - 友元关系的单向性 - 友元声明的形式及数量不受限制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="title">function</span><span class="params">(...)</span></span>;</span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> class <span class="title">B::memberfunction</span><span class="params">(...)</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为友元函数没有this指针，则参数要有三种情况： </p>
<ol>
<li>要访问非static成员时，需要对象做参数；</li>
<li>要访问static成员或全局变量时，则不需要对象做参数；</li>
<li>如果做参数的对象是全局对象，则不需要对象做参数.</li>
<li>可以直接调用友元函数，不需要通过对象或指针</li>
</ol>
<p>样例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">INTEGER</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> INTEGER&amp; obj)</span></span>;<span class="comment">//声明友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> INTEGER&amp; obj）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//函数体</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> main()&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    INTEGER obj;</span></span></span><br><span class="line"><span class="function"><span class="params">    Print(obj);<span class="comment">//直接调用</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="二-继承"><a href="#二-继承" class="headerlink" title="二 继承"></a>二 继承</h3><blockquote>
<p>多继承（Multiple Inheri<a href="http://c.biancheng.net/ref/tan.html" target="_blank" rel="noopener">tan</a>ce）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。</p>
<p>多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承。</p>
</blockquote>
<h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><blockquote>
<p>为了解决多继承时的命名冲突和冗余数据问题，<a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a> 提出了虚继承，使得在派生类中只保留一份间接基类的成员。</p>
<p>在继承方式前面加上 virtual 关键字就是虚继承。</p>
<p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p>
</blockquote>
<h3 id="三-多态"><a href="#三-多态" class="headerlink" title="三 多态"></a>三 多态</h3><blockquote>
<p>要点： 当类中含有虚函数的时候，创建该类的对象时，该对象的首地址即为虚函数表的地址，无论对该对象进行怎样的类型转换，该对象都只能访问自己的虚函数表</p>
<p>C++多态分为静态多态和动态多态。</p>
<blockquote>
<p>静态多态是通过重载和模板技术实现，在编译的时候确定。</p>
<p>动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。</p>
</blockquote>
<p>动态多态实现有几个条件：</p>
<blockquote>
<p>(1) 虚函数；</p>
<p>(2) 一个基类的指针或引用指向派生类的对象；</p>
</blockquote>
<p>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。</p>
<p>虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。</p>
<p>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象都指向这同一个虚函数表。</p>
<p>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。</p>
</blockquote>
<h4 id="1-多态及其作用"><a href="#1-多态及其作用" class="headerlink" title="1. 多态及其作用"></a>1. 多态及其作用</h4><blockquote>
<p>同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。</p>
<p>简单的说就是用基类的引用指向子类的对象。</p>
</blockquote>
<h4 id="2-虚函数和多态的区别"><a href="#2-虚函数和多态的区别" class="headerlink" title="2. 虚函数和多态的区别"></a>2. 虚函数和多态的区别</h4><blockquote>
<p>多态主要分为<strong>静态多态</strong>和<strong>动态多态</strong></p>
<blockquote>
<p>静态多态主要是<strong>重载</strong>，在编译的时候就已经确定；</p>
<p>动态多态是用<strong>虚函数机制</strong>实现的，在运行期间动态绑定。</p>
<p>举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。</p>
</blockquote>
<p><strong>虚函数</strong>的实现</p>
<blockquote>
<p>在有虚函数的类中，类的头部是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
</blockquote>
</blockquote>
<h4 id="3-重载和覆盖（重写）的区别"><a href="#3-重载和覆盖（重写）的区别" class="headerlink" title="3. 重载和覆盖（重写）的区别"></a>3. 重载和覆盖（重写）的区别</h4><blockquote>
<p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中<br>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>
</blockquote>
<blockquote>
<p>重载是编写一个与已有函数同名但是参数表不同的方法，具有如下特征：</p>
<blockquote>
<p>（1）方法名必须相同</p>
<p>（2）参数列表必须不同，与参数列表的顺序无关</p>
<p>（3）返回值类型可以不相同。</p>
</blockquote>
<p>重写是派生类重写基类的虚函数</p>
<blockquote>
<p>（1）只有虚函数和抽象方法才能被重写</p>
<p>（2）相同的函数名</p>
<p>（3）相同的参数列表</p>
<p>（4）相同的返回值类型</p>
</blockquote>
</blockquote>
<blockquote>
<p>重载是一种语法规则，由编译器在编译阶段完成，不属于面向对象的编程；</p>
<p>而重写是由运行阶段决定的，是面向对象编程的重要特征</p>
</blockquote>
<h4 id="4-虚函数表怎样实现运行时多态"><a href="#4-虚函数表怎样实现运行时多态" class="headerlink" title="4. 虚函数表怎样实现运行时多态?"></a>4. 虚函数表怎样实现运行时多态?</h4><blockquote>
<p>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换。</p>
<p>对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</p>
</blockquote>
<p>其它点：</p>
<blockquote>
<ul>
<li>虚函数表属于类，类的所有对象共享这个类的虚函数表。</li>
<li>不同对象虚函数表是一样的（虚函数表的第一个函数地址相同）；</li>
<li>每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象的vptr的存放地址都不一样，但是都指向同一虚函数表。</li>
</ul>
</blockquote>
<h4 id="5-虚函数与纯虚函数的区别"><a href="#5-虚函数与纯虚函数的区别" class="headerlink" title="5. 虚函数与纯虚函数的区别"></a>5. 虚函数与纯虚函数的区别</h4><ol>
<li>虚函数与纯虚函数 在他们的子类中都可以被重写.它们的区别是：</li>
</ol>
<blockquote>
<p>（1）纯虚函数只有定义,没有实现；而虚函数既有定义,也有实现的代码；纯虚函数一般没有代码实现部分，如  virtual void print() = 0;  </p>
<p>，而一般虚函数必须要有代码的实现部分，否则会出现函数未定义的错误。</p>
<p>（2）包含纯虚函数的类不能定义其对象,而包含虚函数的则可以.</p>
</blockquote>
<ol start="2">
<li>虚函数的引入主要是为了实现多态</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		a()&#123;      <span class="comment">//构造函数用内联函数的形式 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//虚函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span>  <span class="keyword">void</span>  <span class="title">xhs</span><span class="params">()</span></span>&#123;   	   <span class="comment">//这个虚函数必须得在基类中实现 </span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"我是基类的虚函数"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//即使是空的虚函数也要在基类中实现 </span></span><br><span class="line">		&#125;  <span class="comment">//派生类中可以不写这个函数，但是派生类对象调用时会调用积累的虚函数 	</span></span><br><span class="line">		<span class="comment">//纯虚函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cxhs</span><span class="params">()</span> </span>=<span class="number">0</span>;  <span class="comment">//这个纯虚函数不在基类中实现，必须在子类中实现 </span></span><br><span class="line">		</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="6-虚函数可以是内联函数吗？"><a href="#6-虚函数可以是内联函数吗？" class="headerlink" title="6. 虚函数可以是内联函数吗？"></a>6. 虚函数可以是内联函数吗？</h4><blockquote>
<ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
</blockquote>
<h4 id="7-静态函数和虚函数的区别"><a href="#7-静态函数和虚函数的区别" class="headerlink" title="7.  静态函数和虚函数的区别"></a>7.  静态函数和虚函数的区别</h4><blockquote>
<p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。</p>
<p>虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</p>
</blockquote>
<h2 id="三-模板与泛型编程"><a href="#三-模板与泛型编程" class="headerlink" title="三 模板与泛型编程"></a>三 模板与泛型编程</h2><h3 id="1-什么是右值引用，跟左值的区别？"><a href="#1-什么是右值引用，跟左值的区别？" class="headerlink" title="1. 什么是右值引用，跟左值的区别？"></a>1. 什么是右值引用，跟左值的区别？</h3><blockquote>
<p>右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。</p>
<p>主要目的有两个方面：</p>
<ol>
<li><p><strong>消除两个对象交互时不必要的对象拷贝</strong>，节省运算存储资源，提高效率。</p>
</li>
<li><p>能够更简洁明确地定义泛型函数。</p>
</li>
</ol>
<h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><ul>
<li>左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。</li>
<li>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</li>
</ul>
<h4 id="右值和左值的区别"><a href="#右值和左值的区别" class="headerlink" title="右值和左值的区别"></a>右值和左值的区别</h4><ol>
<li>左值可以寻址，而右值不可以。</li>
<li>左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。</li>
<li>左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）</li>
</ol>
</blockquote>
<h3 id="2-左值引用与右值引用。什么情况下使用右值引用"><a href="#2-左值引用与右值引用。什么情况下使用右值引用" class="headerlink" title="2. 左值引用与右值引用。什么情况下使用右值引用"></a>2. <a href="https://guodong.plus/2020/0307-190855/" target="_blank" rel="noopener">左值引用与右值引用</a>。什么情况下使用右值引用</h3><blockquote>
<p>要了解什么情况下使用右值引用，我们就要先了充分了解右值的特性。</p>
<p>首先与左值不同，右值是非常短暂的，它要么是字面常量，要么是在表达式求值过程中创建的临时对象。由于这样的特性我们可以总结：</p>
<ul>
<li>所引用的对象将要被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p>这就意味着，使用右值引用的代码可以自由的接管被引用对象的资源。</p>
</blockquote>
<blockquote>
<p>需要注意的是，所有的变量都是左值，我们不能将一个右值引用绑定到一个右值引用类型的变量上。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int &amp;&amp;rr1 &#x3D; 42;   &#x2F;&#x2F; 正确：字面量是右值</span><br><span class="line">int &amp;&amp;rr2 &#x3D; rr1;  &#x2F;&#x2F; 错误：rr1 是变量，虽然他是右值引用，但任然是左值Copy</span><br></pre></td></tr></table></figure>

<p>可以这样理解：变量 rr1 是持久的，它不会像字面值 42 那样转瞬即逝，所以它是左值。这就引出了下面两个主题：移动、转发。<br>[点击标题可以细看]</p>
</blockquote>
<h3 id="3-泛型算法"><a href="#3-泛型算法" class="headerlink" title="3. 泛型算法"></a>3. 泛型算法</h3><blockquote>
<p>只读算法：accumulate、count、equal；</p>
<p>写算法：fill、fill_n、back_inserter、copy;</p>
<p>重排：sort；unique(去掉重复元素); erase(真正的删除一个元素);</p>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span>&#123;</span><br><span class="line">    sort(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> end_unique = unique(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">    words.erase(end_unique,words.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-Lambda表达式"><a href="#4-Lambda表达式" class="headerlink" title="4. Lambda表达式"></a>4. Lambda表达式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 匿名lambda表达式</span></span><br><span class="line">sort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), [](<span class="built_in">string</span> a, <span class="built_in">string</span> b) &#123;</span><br><span class="line">     <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.具名lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> lam = [](<span class="built_in">string</span> a, <span class="built_in">string</span> b) &#123;</span><br><span class="line">     <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line"> &#125;;</span><br><span class="line">sort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), lam);;</span><br></pre></td></tr></table></figure>



<h3 id="5-模板"><a href="#5-模板" class="headerlink" title="5. 模板"></a>5. 模板</h3><blockquote>
<p>函数模板是一种抽象的函数定义，代表一类同构函数。</p>
<p>类模板是一种更高层次的抽象的类定义，用于使用相同代码创建不同的类。</p>
<p>函数模板的实例化是由编译程序在处理函数调用自动完成的，而类模板的实例化必须由程序员在程序中显式指定。</p>
</blockquote>
<h4 id="模板的缺点"><a href="#模板的缺点" class="headerlink" title="模板的缺点"></a>模板的缺点</h4><blockquote>
<p>不当的使用模板会导致代码膨胀，即二进制代码臃肿松散，会严重影响程序的运行效率</p>
<p>解决方法，把C++模板中与参数无关的代码分离出来</p>
</blockquote>
<h2 id="四-STL-标准模板库"><a href="#四-STL-标准模板库" class="headerlink" title="四 STL 标准模板库"></a>四 STL 标准模板库</h2><h3 id="0-STL基本组成"><a href="#0-STL基本组成" class="headerlink" title="0 STL基本组成"></a>0 STL基本组成</h3><blockquote>
<p>STL主要核心分为三大部分：容器（container）、算法（algorithm）和迭代器（iterator），另外还有容器适配器（container adaptor）和函数对象（functor）等其它标准组件。</p>
<p>其中的关系：</p>
<ol>
<li>分配器给容器分配存储空间；</li>
<li>算法通过迭代器获取容器中的内容；</li>
<li>仿函数可以协助算法完成各种操作；</li>
<li>配接器用来套接适配仿函数；</li>
</ol>
<p>STL算法部分主要由头文件<algorithm>,<numeric>,<functional>组成。要使用 STL中的算法函数必须包含头文件<algorithm>，对于数值算法须包含<numeric>，<functional>中则定义了一些模板类，用来声明函数对象。</functional></numeric></algorithm></functional></numeric></algorithm></p>
</blockquote>
<h3 id="1-分配器（allocator）"><a href="#1-分配器（allocator）" class="headerlink" title="1 分配器（allocator）"></a>1 分配器（allocator）</h3><blockquote>
<p><strong>STL的分配器用于封装STL容器在内存管理上的底层细节</strong>。</p>
<p>作用：分配内存和释放；构造和析构对象。</p>
<p>C++中的内存配置和释放过程如下：</p>
<ul>
<li><strong>new运算</strong>分两个阶段：(1)调用::operator new配置内存; (2)调用对象构造函数</li>
<li><strong>delete运算</strong>分两个阶段：(1)调用对象希构函数；(2)调用::operator delete释放内存</li>
</ul>
<p>而 STL allocator 将两个阶段操作分开：</p>
<ul>
<li>内存配置由alloc::allocate()负责，内存释放由alloc::deallocate()负责；</li>
<li>对象构造由::construct()负责，对象析构由::destroy()负责。</li>
</ul>
<p>为了提升内存管理效率，减少申请小内存造成的内存碎片问题，SGI STL中的<code>Allocator</code>采用了两级配置器</p>
<ol>
<li>当分配的空间大于128B时，使用第一级空间配置器；</li>
<li>当分配的空间小于128B时，使用第二级空间配置器。</li>
</ol>
<p>其中</p>
<ul>
<li><p>第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放;</p>
</li>
<li><p>第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。存在一个内存空间管理的链表，长度为16，分别指向内存大小为8、16…128字节大小的内存块，从内存链表上取所需内存向上扩充的内存块以供使用</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>以如下过程为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A *a=<span class="keyword">new</span> A()</span><br></pre></td></tr></table></figure>

<ol>
<li>调用operator new分配一段内存</li>
<li>在这块内存上调用构造函数分配一个对象</li>
</ol>
<h5 id="1-operator-new"><a href="#1-operator-new" class="headerlink" title="1 operator new"></a>1 operator new</h5><p><code>operator new</code>是一个操作符，该操作符可以进行重载。</p>
<p>在<code>Allocator</code>这个模板类上，存在一组构造函数，该构造函数会调用<code>allocate</code>这个函数去分配内存。</p>
<ol>
<li><code>allocate</code>调用<code>operator new</code></li>
<li><code>operator new</code>再根据类型、元素个数去调用<code>malloc</code></li>
</ol>
<h5 id="2-在内存上调用构造函数"><a href="#2-在内存上调用构造函数" class="headerlink" title="2 在内存上调用构造函数"></a>2 在内存上调用构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> (p) T(value);</span><br></pre></td></tr></table></figure>

<ol>
<li>这里的<code>new</code>是一个<code>replacement new</code> ，意思是在<code>p</code>所指的内存空间上构造对象</li>
<li><code>T</code>是类名，也是构造函数名</li>
</ol>
<p>使用完毕的析构过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先，在指定内存上调用析构内存释放对象</li>
<li>调用<code>operator delete</code>释放内存空间</li>
</ol>
<h5 id="3-operator-delete"><a href="#3-operator-delete" class="headerlink" title="3 operator delete"></a>3 operator delete</h5><p><code>operator delete</code>是一个可以重载的操作符，负责释放内存</p>
<ol>
<li>在<code>Allocator</code>中存在<code>deallocate</code>函数，该函数调用<code>operator delete</code></li>
<li><code>operator delete</code>会调用<code>free</code>进行内存释放</li>
</ol>
<h5 id="4-析构函数的调用"><a href="#4-析构函数的调用" class="headerlink" title="4 析构函数的调用"></a>4 析构函数的调用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span></span>&#123;</span><br><span class="line">	p-&gt;~T();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据指针调用析构函数即可</p>
</blockquote>
<h3 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2  迭代器"></a>2  迭代器</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h4><blockquote>
<p>Iterator（迭代器）又称Cursor（游标），提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p>
<p>换个说法：Iterator是运用于聚合对象的一种模式，通过该模式，我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p>由于Iterator模式的以上特性：与聚合对象耦合，一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。</p>
<p>在不同容器的不同使用场景中，迭代器的种类和用途各不相同，因此，算法需要先来<strong>推导出迭代器类型，即萃取技术</strong></p>
<p>萃取技术用到<strong>模板偏特化</strong></p>
</blockquote>
<blockquote>
<p>迭代器是指向节点的指针，有如下操作</p>
<ol>
<li>前向查询 –</li>
<li>后向查询 ++</li>
<li>解引用</li>
<li>指针指向</li>
</ol>
</blockquote>
<blockquote>
<p>在迭代器中存储的有四个信息</p>
<ol>
<li><code>cur</code> 在当前缓冲区中的位置</li>
<li><code>first</code> 当前缓冲区中的第一个位置</li>
<li><code>last</code> 当前缓冲区中的最后一个位置</li>
<li><code>node</code> 指向当前当前缓冲区的map中的节点</li>
</ol>
</blockquote>
<h4 id="2-迭代器和指针的区别"><a href="#2-迭代器和指针的区别" class="headerlink" title="2 迭代器和指针的区别"></a>2 迭代器和指针的区别</h4><blockquote>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、–等。</p>
<p>迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p>迭代器返回的是对象引用而不是对象的值，所以<strong>cout只能输出迭代器使用*取值后的值而不能直接输出其自身</strong>。</p>
</blockquote>
<h4 id="3-迭代器产生原因"><a href="#3-迭代器产生原因" class="headerlink" title="3 迭代器产生原因"></a>3 迭代器产生原因</h4><blockquote>
<p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
</blockquote>
<h4 id="4-用迭代器删除元素"><a href="#4-用迭代器删除元素" class="headerlink" title="4 用迭代器删除元素"></a>4 用迭代器删除元素</h4><blockquote>
<ol>
<li><p>对于序列容器vector、deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;  <span class="comment">//容器删除元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span> (iter = val.begin(); iter != val.end();)&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">3</span> == *iter)  </span><br><span class="line">          iter = val.erase(iter);     <span class="comment">//返回下一个有效的迭代器，无需+1  </span></span><br><span class="line">     <span class="keyword">else</span>  </span><br><span class="line">          ++iter;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>对于关联容器map, set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的迭代器，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; valset = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;  </span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;  </span><br><span class="line"><span class="keyword">for</span> (iter = valset.begin(); iter != valset.end(); ) &#123;  </span><br><span class="line">     <span class="keyword">if</span> (<span class="number">3</span> == *iter)  </span><br><span class="line">          valset.erase(iter++);  </span><br><span class="line">     <span class="keyword">else</span>  </span><br><span class="line">          ++iter;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。</li>
</ol>
</blockquote>
<h5 id="5-迭代器失效的情况"><a href="#5-迭代器失效的情况" class="headerlink" title="5 迭代器失效的情况"></a>5 迭代器失效的情况</h5><blockquote>
<h6 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h6><ol>
<li>对于<code>vector</code>和<code>string</code>是连续空间，如果容器内存被重新分配，全部迭代器失效；否则，插入位置前的迭代器有效，插入位置后的迭代器失效</li>
<li>对于<code>deque</code>，如果插入点是<code>front</code>或<code>back</code>时，deque的迭代器失效，但<code>reference</code>和<code>pointer</code>有效；否则，全部失效</li>
<li>对于<code>list</code>和<code>forward_list</code>，所有的迭代器有效</li>
</ol>
<h6 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h6><ol>
<li>对于<code>vector</code>和<code>string</code>，删除位置前的迭代器有效，后面的无效</li>
<li>对于<code>deque</code>，如果删除点位于除<code>front</code>和<code>back</code>之外的其他位置，迭代器失效（移动）；否则，其余元素有效</li>
<li>对于<code>list</code>和<code>forward_list</code>所有的迭代器有效</li>
<li>对于<code>map</code>来说，如果一个元素被删除，其对应的迭代器失效</li>
</ol>
</blockquote>
<h3 id="3-容器"><a href="#3-容器" class="headerlink" title="3 容器"></a>3 容器</h3><p>容器主要包括顺序容器、关联容器、无序容器</p>
<h4 id="1-顺序容器"><a href="#1-顺序容器" class="headerlink" title="1 顺序容器"></a>1 顺序容器</h4><table>
<thead>
<tr>
<th>名称</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>模拟的数据结构式动态数组，在内存中是连续储存的，支持随机存取，支持在尾部快速插入和删除元素，搜索速度较慢</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列，在内存中的储存方式是小片连续，每片之间用链表连接起来，支持随机存取，支持在头部和尾部快速插入和删除元素，搜索速度较慢</td>
</tr>
<tr>
<td>list</td>
<td>称为双向链表，在内存中的储存是不连续的，每个元素的内存之间用指针相连，不支持随机存取（因为要从首或尾遍历至指定位置），但是支持在任意位置快速插入和删除元素，搜索速度最慢，扩展内存时无需复制和拷贝原元素</td>
</tr>
<tr>
<td>array</td>
<td>称为静态数组，在内存中是连续储存的，支持随机存取，不支持插入或删除元素</td>
</tr>
<tr>
<td>forward_list</td>
<td>称为前向链表，在内存中的储存是不连续的，同list一样支持在任意位置快速插入和删除元素，不支持随机存取，搜索速度也较慢，与list最大的区别在于其只能从头部遍历至尾部，不能反向遍历，因此没有保存后向指针，比list更省内存，插入和删除元素比list稍慢。</td>
</tr>
</tbody></table>
<h5 id="vector和list"><a href="#vector和list" class="headerlink" title="vector和list"></a>vector和list</h5><table>
<thead>
<tr>
<th align="center"></th>
<th align="left">Vector</th>
<th align="left">List</th>
</tr>
</thead>
<tbody><tr>
<td align="center">概念</td>
<td align="left">连续存储的容器，动态数组<br>在堆上分配空间</td>
<td align="left">动态链表<br>在堆上分配空间</td>
</tr>
<tr>
<td align="center">底层实现</td>
<td align="left">数组</td>
<td align="left">双向链表</td>
</tr>
<tr>
<td align="center">访问性能</td>
<td align="left">支持随机访问，O(1)</td>
<td align="left">不支持随机访问<br>随机访问性能很差<br>只能快速访问头尾节点。</td>
</tr>
<tr>
<td align="center">插入性能</td>
<td align="left">在最后插入（空间够）：很快<br>在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。<br>在中间插入（空间够）：内存拷贝<br>在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</td>
<td align="left">很快，一般是常数开销<br>每插入一个元数都会分配空间，<br>每删除一个元素都会释放空间。</td>
</tr>
<tr>
<td align="center">删除性能</td>
<td align="left">在最后删除：很快<br>在中间删除：内存拷贝</td>
<td align="left">很快，一般是常数开销</td>
</tr>
<tr>
<td align="center">适用场景</td>
<td align="left">经常随机访问，且不经常对非尾节点进行插入删除。</td>
<td align="left">经常插入删除大量数据</td>
</tr>
</tbody></table>
<p><strong>区别</strong></p>
<blockquote>
<p>1）vector底层实现是数组；list是双向链表。</p>
<p>2）vector支持随机访问，list不支持。</p>
<p>3）vector是顺序内存，list不是。</p>
<p>4）vector在中间节点进行插入删除会导致内存拷贝，list不会。</p>
<p>5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</p>
<p>6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</p>
</blockquote>
<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><blockquote>
<p>list使用一个双向链表来管理元素，list的内部结构和vector或deque截然不同，以下在主要方面与前述二者存在明显区别：</p>
<ul>
<li>list不支持随机存取</li>
<li>任何位置执行元素的安插和删除都非常快，始终是在常数时间内完成</li>
<li>对异常处理，要么成功，要么什么都不发生</li>
<li>由于不支持随机存储，既不提供下标操作符，也不提供at()</li>
<li>并未提供容量、空间重新分配等操作函数</li>
<li>提供不少成员 函数用于移动函数。</li>
</ul>
<p>List 是<strong>带头结点的</strong>双向循环链表，头结点本身是end()迭代器，同时，头结点是链表中唯一的元素</p>
<p>链表的优势是：元素的插入与删除是常数时间的</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>首部</td>
<td><code>push_front  emplace_front  pop_front   front</code></td>
</tr>
<tr>
<td>尾部</td>
<td><code>push_back   emplace_back   pop_back   back</code></td>
</tr>
<tr>
<td>任意位置</td>
<td><code>emplace</code>在迭代器指定的位置处构造元素并插入<br><code>insert</code>在指定的迭代器之前进行操作<br><code>erase</code></td>
</tr>
</tbody></table>
<p>其它操作</p>
<ol>
<li><code>remove  remova_if</code> 前者删除等于输入参数的全部节点，后者根据谓词条件进行删除</li>
<li><code>unique</code> 删除重复元素；同时可以传入二元谓词，来根据条件删除</li>
<li><code>sort</code> 链表的排序函数，默认是字典序增大的方向，可以自己传入函数指针</li>
<li><code>merge  reverse</code></li>
</ol>
</blockquote>
<h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><blockquote>
<p>vector是内存空间可动态变化的连续空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> _<span class="title">Ax</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">        :</span> <span class="keyword">public</span> _Vector_val&lt;_Ty, _Ax&gt;</span><br><span class="line">&#123;   <span class="comment">// varying size array of values</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/********/</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    pointer _Myfirst;<span class="comment">//pointer to beginning of array</span></span><br><span class="line">    pointer _Mylast;<span class="comment">// pointer to current end of sequence</span></span><br><span class="line">    pointer _Myend; <span class="comment">// pointer to end of array</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>维护了三个变量</p>
<ol>
<li><code>_Myfirst</code></li>
<li><code>_Mylast</code></li>
<li><code>_Myend</code></li>
</ol>
<p>在vector中与大小相关的属性有：当前元素个数，容器的容量，分别可以通过上述三个变量求得</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>=_Mylast-_Myfirst;<span class="comment">//已使用空间</span></span><br><span class="line">capcity=_Myend-_Myfirst;<span class="comment">//未使用空间</span></span><br></pre></td></tr></table></figure>

<p><strong>构造相关</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ector&lt;Elem&gt; c</span><br><span class="line"><span class="built_in">vector</span> &lt;Elem&gt; c1(c2)</span><br><span class="line"><span class="built_in">vector</span> &lt;Elem&gt; c(n)</span><br><span class="line"><span class="built_in">vector</span> &lt;Elem&gt; c(n, elem)</span><br><span class="line"><span class="built_in">vector</span> &lt;Elem&gt; c(beg,<span class="built_in">end</span>)</span><br><span class="line">c.~ <span class="built_in">vector</span> &lt;Elem&gt;()</span><br></pre></td></tr></table></figure>

<p><strong>插入、删除、赋值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c.push_back(elem)</span><br><span class="line">c.pop_back()</span><br><span class="line">c.insert(pos,elem)</span><br><span class="line">c.insert(pos,n,elem)</span><br><span class="line">c.insert(pos,beg,<span class="built_in">end</span>)</span><br><span class="line">c.erase(pos)</span><br><span class="line">c.erase(beg,<span class="built_in">end</span>)</span><br><span class="line">c.<span class="built_in">clear</span>()</span><br><span class="line">c.assign(beg,<span class="built_in">end</span>)</span><br><span class="line">c.assign(n,elem)</span><br></pre></td></tr></table></figure>

<p><strong>大小相关</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.capacity()</span><br><span class="line">c.max_size()</span><br><span class="line">c.resize(num)</span><br><span class="line">c.reserve()</span><br><span class="line">c.size()</span><br></pre></td></tr></table></figure>

</blockquote>
<h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><blockquote>
<p>C++中数组是一种内置的数据类型。数组是存放类型相同的对象的容器，数组的大小确定不变，不能随意向数组中增加元素。</p>
<ol>
<li><p>元素在内存中连续存放，每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。</p>
</li>
<li><p>插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。</p>
</li>
<li><p>随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。</p>
</li>
<li><p>数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组。</p>
</li>
</ol>
<p>array也位于名称空间std中,与数组一样,array对象的长度也是固定的,也使用栈(静态内存分配),而不是自由存储区,因此其效率与数组相同,但更方便,更安全.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;typeName, nElem&gt; arr;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; ai;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; ad = &#123;<span class="number">1.1</span>,<span class="number">1.2</span>,<span class="number">1.2</span>,<span class="number">1.3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：不允许拷贝和赋值——不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。</p>
</blockquote>
<h6 id="array与vector的区别"><a href="#array与vector的区别" class="headerlink" title="array与vector的区别"></a>array与vector的区别</h6><table>
<thead>
<tr>
<th>数组</th>
<th>vector</th>
<th>array</th>
</tr>
</thead>
<tbody><tr>
<td>访问方式</td>
<td>支持随机访问</td>
<td>支持随机访问</td>
</tr>
<tr>
<td>存储位置</td>
<td>堆</td>
<td>栈</td>
</tr>
<tr>
<td>复制</td>
<td>逐个复制</td>
<td></td>
</tr>
<tr>
<td>大小</td>
<td>可以变化。可以增加元素</td>
<td>大小不变，定义时指定</td>
</tr>
<tr>
<td>初始化</td>
<td>可以初始化其他vector</td>
<td>不能将数组的内容拷贝给其他数组作为初始值<br>也不能用数组为其他数组赋值</td>
</tr>
<tr>
<td>效率</td>
<td>低（扩容需要消耗大量时间）</td>
<td>高</td>
</tr>
</tbody></table>
<h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><blockquote>
<p>deque是<strong>双向开口</strong>的<strong>连续线性空间</strong></p>
<ol>
<li>允许常数时间内在头尾进行元素的插入或移除</li>
<li>没有容量的概念，<strong>分段连续空间</strong>，可以随时增加一段新的空间并<strong>链接</strong>起来</li>
<li>提供<strong>随机访问迭代器</strong>，但是复杂度比vector高很多</li>
</ol>
<p><strong>deque的数据结构</strong></p>
<ol>
<li><code>start</code>  第一个缓冲区的第一个元素</li>
<li><code>finist</code> 最后一个缓冲区的最后一个元素的下一个位置</li>
<li><code>map</code> 指向缓冲区的指针数组</li>
<li><code>map</code>的大小，当<code>map</code>所能提供的节点不足，要配置一块更大的<code>map</code></li>
</ol>
<p><strong>deque的中控器</strong></p>
<p>deque在<strong>逻辑上</strong>是连续空间，由<strong>一段一段的定量连续空间构成</strong>，一旦有必要，在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端</p>
<p>deque采用一块<strong>所谓的map</strong>，map中的每个元素都是指针（map是指针数组，是二级指针），指向另一端<strong>连续线性空间</strong>，成为缓冲区，是deque的存储空间主体。当map满了，再申请一块更大的map，将map的数据搬过去</p>
<p><strong>deque的迭代器</strong></p>
<p>deque的迭代器在进行移动时，要判断是否到达缓冲区的边缘，如果下一个将要访问的位置不在本缓冲区中，要根据<code>node</code>和<code>map</code>跳跃到新的缓冲区上，更新迭代器信息</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>访问相关</td>
<td>at()<br>operator[]<br>front()<br>back()</td>
</tr>
<tr>
<td>容量相关</td>
<td>empty()<br>size();<br>max_size();<br>shrink_to_fit()<br>resize()</td>
</tr>
<tr>
<td><strong>修改相关</strong></td>
<td>clear()<br>insert()<br>emplace()<br>erase()</td>
</tr>
<tr>
<td></td>
<td>push_back()<br>push_front()<br>emplace_back()<br>emplace_front()</td>
</tr>
<tr>
<td></td>
<td>pop_back()<br>pop_front()</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>stack</td>
<td>默认用deque来实现数据结构的栈的功能</td>
</tr>
<tr>
<td>queue</td>
<td>默认用deque来实现数据结构的队列的功能</td>
</tr>
<tr>
<td>priority_queue</td>
<td>默认用vector来实现，其中保存的元素按照某种严格弱序进行排列，队首元素总是值最大的</td>
</tr>
</tbody></table>
</blockquote>
<h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><blockquote>
<p>stack是LIFO的数据结构，栈是一个单端开口的数据结构，提供在栈顶位置的插入、删除、读取，<strong>只能在栈顶操作</strong></p>
<p><strong>在STL中的实现</strong></p>
<p>封闭<strong>deque</strong>的前端开口，即可提供stack操作，这里称之为<strong>adapter</strong>，即配接器，除了deque，还可以使用list、vector作为其底层结构</p>
<p><strong>不提供迭代器和随机访问功能</strong></p>
<p><strong>提供的操作</strong></p>
<p><strong>访问</strong>：top()//栈顶元素</p>
<p><strong>容量相关</strong>：size(); empty();//判断栈空</p>
<p><strong>修改</strong>：push()；emplace()；pop()；</p>
</blockquote>
<h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><blockquote>
<p>队列是一种FIFO结构，两端分别称之为<strong>队头和队尾</strong>，只允许</p>
<ol>
<li>在队头取元素</li>
<li>在队尾存元素</li>
</ol>
<p><strong>不提供迭代器</strong></p>
<p>默认以deque为底层结构，可选list，不可以选择vector，进行简单的封装实现所需功能</p>
<p><strong>提供的操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">front()</span><br><span class="line">back()</span><br><span class="line">push()</span><br><span class="line">emplace()</span><br><span class="line">pop()</span><br><span class="line">empty()</span><br><span class="line"><span class="built_in">size</span>()</span><br></pre></td></tr></table></figure>

</blockquote>
<h6 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h6><blockquote>
<p>heap即堆是一种数据结构，它是<strong>优先队列</strong>的底层结构，支持</p>
<ol>
<li>允许以任何次序将元素插入容器</li>
<li>总是<strong>按照优先级最高的次序</strong>从容器中取数据</li>
</ol>
<p><code>binary heap</code>是一种<strong>完全二叉树</strong>，从根节点到最后一个节点没有空指针，可以利用<strong>数组</strong>进行存储</p>
<ol>
<li>保留数组的0号元素位置（不用）</li>
<li>对于编号为$i$的节点，其左子树编号为$2i$，右子树编号为$2i+1$</li>
<li>对于一个编号为$i$节点，其根节点的位置为$i/2$</li>
</ol>
<p>利用一个<code>vector</code>和一组<code>heap</code>算法（插入元素、删除元素、取极值、将一组数据排列成一个<code>heap</code>）</p>
<p><strong>sort heap</strong></p>
<p>不断的执行pop操作即可完成排序操作</p>
<p><strong>提供的操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">top()</span><br><span class="line">push()</span><br><span class="line">pop()</span><br><span class="line">emplace()</span><br><span class="line">empty()</span><br><span class="line"><span class="built_in">size</span>()</span><br></pre></td></tr></table></figure>

<p><strong>构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;T,<span class="built_in">vector</span>&lt;T&gt;,less&lt;T&gt;&gt; que;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">less</span>;</span></span><br><span class="line">less::<span class="keyword">operator</span>()(<span class="keyword">const</span> T &amp;lhs, <span class="keyword">const</span> T &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs&lt;rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认是构造一个最大堆</p>
<p>对于自定义数据类型，可以认为定义操作符</p>
<p><a href="https://blog.csdn.net/AAMahone/article/details/82787184" target="_blank" rel="noopener">自定义priority_queue比较</a></p>
<p><strong>不提供迭代器，不提供遍历</strong></p>
</blockquote>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><blockquote>
<p>可变长的字符串</p>
</blockquote>
<h5 id="1-resize和reserve的区别"><a href="#1-resize和reserve的区别" class="headerlink" title="1. resize和reserve的区别"></a>1. resize和reserve的区别</h5><p>主要在于改变大小之后，是否会填充元素；</p>
<h6 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h6><blockquote>
<p>改变当前容器内含有元素的数量(size())，eg:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v; </span><br><span class="line">v.resize(len);</span><br></pre></td></tr></table></figure>

<p>v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0. 当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；</p>
</blockquote>
<h6 id="reserve"><a href="#reserve" class="headerlink" title="reserve()"></a>reserve()</h6><blockquote>
<p>改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">      a.reserve(<span class="number">100</span>);</span><br><span class="line">      a.resize(<span class="number">50</span>);</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;         <span class="comment">//50  100</span></span><br><span class="line">      a.resize(<span class="number">150</span>);</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;        <span class="comment">//150  200</span></span><br><span class="line">      a.reserve(<span class="number">50</span>);</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;        <span class="comment">//150  200</span></span><br><span class="line">      a.resize(<span class="number">50</span>);</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">"  "</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;        <span class="comment">//50  200    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="2-push-back与emplace-back的区别"><a href="#2-push-back与emplace-back的区别" class="headerlink" title="2. push_back与emplace_back的区别"></a>2. push_back与emplace_back的区别</h5><blockquote>
<ol>
<li>调用push_back时，<strong>参数为元素类型的对象</strong>，这个对象被拷贝到容器中。</li>
<li>调用emplace_back时，<strong>参数与该元素类型构造函数的参数相同</strong>，会在容器管理的内存空间内直接创建对象。</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>push_back</th>
<th>emplace_back</th>
</tr>
</thead>
<tbody><tr>
<td>参数为未被构造的对象</td>
<td></td>
<td></td>
</tr>
<tr>
<td>涉及操作</td>
<td>新建临时对象<br>将该临时对象拷贝至容器末尾<br>销毁该临时对象<br></td>
<td>在容器末尾新建对象</td>
</tr>
<tr>
<td>参数为已构造对象</td>
<td></td>
<td></td>
</tr>
<tr>
<td>涉及操作</td>
<td>将该对象拷贝至容器末尾</td>
<td>将该对象拷贝至容器末尾</td>
</tr>
</tbody></table>
</blockquote>
<h5 id="3-Array-amp-List，-数组和链表的区别"><a href="#3-Array-amp-List，-数组和链表的区别" class="headerlink" title="3 Array&amp;List， 数组和链表的区别"></a>3 Array&amp;List， 数组和链表的区别</h5><blockquote>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>1. 随机访问性强<br>2. 查找速度快</td>
<td>1. 插入和删除效率低<br>2. 可能浪费内存<br>3. 内存空间要求高，必须有足够的连续内存空间。<br>4. 数组大小固定，不能动态拓展</td>
</tr>
<tr>
<td>链表</td>
<td>1. 插入删除速度快<br>2. 内存利用率高，不会浪费内存<br>3. 大小没有固定，拓展很灵活。</td>
<td>1. 不能随机查找，必须从第一个开始遍历，查找效率低</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="2-关联容器"><a href="#2-关联容器" class="headerlink" title="2 关联容器"></a>2 关联容器</h4><table>
<thead>
<tr>
<th>名称</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>set</td>
<td>以红黑树实现，内存中是不连续储存的，保存的是元素是唯一的键值且不可变，排列的方式根据指定的严格弱序排列，不支持随机存取，搜索速度较快</td>
</tr>
<tr>
<td>multiset</td>
<td>与set基本一致，差别就在于允许保存重复键值</td>
</tr>
<tr>
<td>map</td>
<td>同样以红黑树实现，保存的元素是一个pair类型{key, value}，每个键值对应一个值，且键值唯一不可变，键值的排列方式根据指定的严格弱序排列，支持用key进行随机存取，搜索速度较快</td>
</tr>
<tr>
<td>multimap</td>
<td>与map基本一致，差别在于键值可以重复</td>
</tr>
</tbody></table>
<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><blockquote>
<p><code>map</code>是一种映射表，元素是一组<code>pair</code>，即<code>key-value</code>，<code>map</code>根据<code>key</code>的大小进行排序，关键字是不能更改的，而关键值所对应的值是可以改变的。关键字不允许重复</p>
<p>支持的操作有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clear</span>()</span><br><span class="line">insert()</span><br><span class="line"><span class="keyword">operator</span>[]</span><br><span class="line">empty()</span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line">max_size()</span><br><span class="line">emplace()</span><br><span class="line">insert_or_assign()</span><br><span class="line">erase()</span><br><span class="line">count()</span><br><span class="line"><span class="built_in">find</span>()...</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><blockquote>
<p><code>set</code>不同于<code>map</code>，<code>set</code>只有关键字，无对应的实值，相同的地方</p>
<ol>
<li>底层使用红黑树</li>
<li>关键字不允许重复</li>
<li>有序排列</li>
</ol>
<p>允许的操作和map基本一致</p>
</blockquote>
<h5 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h5><blockquote>
<p>允许关键字相同的<code>set</code>，差别在于使用的插入函数</p>
<ol>
<li><code>set</code>使用的是<code>insert_unique</code></li>
<li><code>multiset</code>使用的是<code>insert_equal</code></li>
</ol>
</blockquote>
<h5 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h5><h5 id="1-map和set的区别及各自的实现方法"><a href="#1-map和set的区别及各自的实现方法" class="headerlink" title="1 map和set的区别及各自的实现方法"></a>1 map和set的区别及各自的实现方法</h5><blockquote>
<p><strong>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）</strong>。</p>
<p>由于map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。</p>
<h5 id="map和set区别"><a href="#map和set区别" class="headerlink" title="map和set区别"></a>map和set区别</h5><p>（1）map中的<strong>元素</strong>是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。</p>
<p>（2）set的<strong>迭代器</strong>是const的，不允许修改元素的值；map允许修改value，但不允许修改key。</p>
<p>其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p>
<p>（3）map支持<strong>下标操作</strong>，set不支持下标操作。</p>
<p>map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p>
</blockquote>
<h5 id="2-Map与Multimap"><a href="#2-Map与Multimap" class="headerlink" title="2 Map与Multimap"></a>2 Map与Multimap</h5><blockquote>
<p>1、Map映射，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p>
<ul>
<li><p>底层实现：红黑树</p>
</li>
<li><p>适用场景：有序键值对不重复映射</p>
</li>
</ul>
<p>2、Multimap</p>
<p>多重映射。multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许键值重复。</p>
<ul>
<li><p>底层实现：红黑树</p>
</li>
<li><p>适用场景：有序键值对可重复映射</p>
</li>
</ul>
</blockquote>
<h4 id="3-无序容器"><a href="#3-无序容器" class="headerlink" title="3 无序容器"></a>3 无序容器</h4><blockquote>
<p>无序容器的底层结构是哈希表，哈希表采用的避免碰撞方法普遍是拉链法</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>unordered_set</td>
<td>以哈希表实现，内存中是不连续储存的，保存的是元素是唯一的键值且不可变，无序的排列方式，不支持随机存取，搜索速度比红黑树实现的set要快</td>
</tr>
<tr>
<td>unordered_multiset</td>
<td>与unordered_set基本一致，差别就在于允许保存重复键值</td>
</tr>
<tr>
<td>unordered_map</td>
<td>以哈希表实现，保存的元素是一个pair类型{key, value}，每个键值对应一个值，且键值唯一不可变，key值无序排列，支持用key进行随机存取，搜索速度比红黑树实现的map要快</td>
</tr>
<tr>
<td>unordered_multimap</td>
<td>与unordered_map基本一致，差别在于键值可以重复</td>
</tr>
</tbody></table>
<h3 id="4-容器适配器"><a href="#4-容器适配器" class="headerlink" title="4 容器适配器"></a>4 容器适配器</h3><blockquote>
<p>allocator模板类定义在头文件memory.h中，它帮助我们将内存分配和对象构造分开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。利用allocate方法分配一段内存，当利用allocator对象分配了内存以后，要再用construct方法来再这块内存中构造指定类型的对象。当使用完这块内存中的对象后，可以利用destroy方法来销毁这个对象，这块内存又变为原始的未构造的内存，可以再次在这块内存中构造指定类型的对象。当使用完这块内存后，要先销毁其中保存的对象，再利用deallocate方法销毁这块内存。</p>
<p>均可以用vector, list和deque来实现，没有提供迭代器</p>
</blockquote>
<h3 id="5-线程安全"><a href="#5-线程安全" class="headerlink" title="5 线程安全"></a>5 线程安全</h3><blockquote>
<p>STL容器提供的线程安全性只有两点：</p>
<ol>
<li>多个线程<strong>读取</strong>是安全的</li>
<li>多个线程<strong>对不同容器的写入</strong>是安全的</li>
</ol>
</blockquote>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="* 其他操作"></a>* 其他操作</h3><h4 id="1-vector与set之间的相互转化"><a href="#1-vector与set之间的相互转化" class="headerlink" title="1 vector与set之间的相互转化"></a>1 vector与set之间的相互转化</h4><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v</span><span class="params">(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>())</span></span>;</span><br></pre></td></tr></table></figure>

</blockquote>
<h4 id="2-vector的扩容原理"><a href="#2-vector的扩容原理" class="headerlink" title="2 vector的扩容原理"></a>2 vector的扩容原理</h4><p>在VS 下，扩容都是以 1.5 倍扩大，但是，在 gcc 编译环境下，是以 2 倍的方式扩容。</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_Count == <span class="number">0</span>)<span class="comment">//这里进行了判断，但是什么都不做，不知道为什么？？？？？？？  </span></span><br><span class="line">    ;  </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (max_size() - size() &lt; _Count)<span class="comment">//编译器可以申请的最大容量也装不下，抛出异常_THROW(length_error, "vector&lt;T&gt; too long");  </span></span><br><span class="line">    _Xlen();     </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_Capacity &lt; size() + _Count) <span class="comment">//当前空间不足，需要扩容  </span></span><br><span class="line">&#123;   <span class="comment">// not enough room, reallocate  </span></span><br><span class="line">    _Capacity = max_size() - _Capacity / <span class="number">2</span> &lt; _Capacity  </span><br><span class="line">        ? <span class="number">0</span> : _Capacity + _Capacity / <span class="number">2</span>;    <span class="comment">// 先保证扩容后的内存大小不超限。如果满足，就扩容50%  </span></span><br><span class="line">    <span class="keyword">if</span> (_Capacity &lt; size() + _Count)<span class="comment">// 扩容50%后依然不够容下，则使容量等于当前数据个数加上新增数据个数（有时候是好多数据（存在文件夹）一起push进去  </span></span><br><span class="line">        _Capacity = size() + _Count;  </span><br><span class="line">    pointer _Newvec = <span class="keyword">this</span>-&gt;_Alval.allocate(_Capacity);<span class="comment">//申请新的空间  </span></span><br><span class="line">    pointer _Ptr = _Newvec;  </span><br><span class="line"></span><br><span class="line">    _TRY_BEGIN  </span><br><span class="line">        _Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),  </span><br><span class="line">                      _Newvec);   <span class="comment">// copy prefix      //拷贝原有数据到新的内存中  </span></span><br><span class="line">    _Ptr = _Ucopy(_First, _Last, _Ptr); <span class="comment">//  //拷贝新增数据到新的内存的后面  </span></span><br><span class="line">    _Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);  <span class="comment">// copy suffix  </span></span><br><span class="line">    _CATCH_ALL  </span><br><span class="line">        _Destroy(_Newvec, _Ptr);  </span><br><span class="line">    <span class="keyword">this</span>-&gt;_Alval.deallocate(_Newvec, _Capacity);<span class="comment">//释放原来申请的内存  </span></span><br><span class="line">    _RERAISE;  </span><br><span class="line">    _CATCH_END  </span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="五-内存管理"><a href="#五-内存管理" class="headerlink" title="五 内存管理"></a>五 内存管理</h2><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552467921124_13956548C4BB199139A2744C39350272" alt="img"></p>
<h3 id="1-C-的内存管理"><a href="#1-C-的内存管理" class="headerlink" title="1. C++的内存管理"></a>1. C++的内存管理</h3><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</p>
<blockquote>
<ol>
<li>代码段：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</li>
<li>数据段：存储程序中已初始化的全局变量和静态变量，（虚函数表)</li>
<li>bss 段：存储未初始化以及所有被初始化为0的全局变量和静态变量（局部+全局）。</li>
<li>堆区：调用new/malloc函数时在堆区动态分配内存，需要调用delete/free来手动释放申请的内存。</li>
<li>映射区：存储动态链接库以及调用mmap函数进行的文件映射</li>
<li>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</li>
</ol>
</blockquote>
<p><strong>示例说明</strong></p>
<blockquote>
<p>32bit CPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0<del>3G是用户态空间，3</del>4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：</p>
<p>各个段说明如下：</p>
<p><code>3G</code>用户空间和<code>1G</code>内核空间</p>
<p>静态区域：</p>
<ol>
<li><code>text segment</code>(代码段)：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</li>
<li><code>data segment</code>(数据段)：存储程序中已初始化的全局变量和静态变量</li>
<li><code>bss segment</code>：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0。</li>
</ol>
<p>动态区域：</p>
<ol>
<li>heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时会分配一个堆，并在程序运行过程中动态增加堆大小 (移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。 堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。</li>
<li>memory mapping segment (映射区) :    存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）</li>
<li>stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。</li>
</ol>
</blockquote>
<h3 id="2-malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#2-malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="2. malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>2. malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h3><blockquote>
<p>答：Malloc函数用于动态分配内存。</p>
<p>为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。</p>
<p>当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</p>
<p>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p>
</blockquote>
<h3 id="3-内存泄漏？"><a href="#3-内存泄漏？" class="headerlink" title="3. 内存泄漏？"></a>3. 内存泄漏？</h3><blockquote>
<p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。</p>
<p>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p>
<p>内存泄漏的分类：</p>
<ol>
<li><strong>堆内存泄漏 （Heap leak）</strong>。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</li>
<li><strong>系统资源泄露（Resource Leak）</strong>。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li>
<li><strong>没有将基类的析构函数定义为虚函数</strong>。<strong>当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用</strong>，子类的资源没有正确是释放，因此造成内存泄露。</li>
</ol>
</blockquote>
<h3 id="4-如何判断及处理内存泄漏？"><a href="#4-如何判断及处理内存泄漏？" class="headerlink" title="4. 如何判断及处理内存泄漏？"></a>4. 如何判断及处理内存泄漏？</h3><blockquote>
<p>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。</p>
<p>判断方法：可以使用linux环境下的内存泄漏检查工具Valgrind；另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</p>
<p>处理方法：使用varglind，mtrace检测。</p>
</blockquote>
<p>例子：在未把析构函数定义为虚函数的情况下，父类指针指向子类对象或者父类引用子类对象</p>
<h3 id="5-段错误"><a href="#5-段错误" class="headerlink" title="5. 段错误"></a>5. 段错误</h3><blockquote>
<p>段错误通常发生在访问非法内存地址的时候, 比如：</p>
<ol>
<li>使用野指针</li>
<li>试图修改字符串常量的内容</li>
</ol>
</blockquote>
<h3 id="6-new和malloc的区别"><a href="#6-new和malloc的区别" class="headerlink" title="6. new和malloc的区别"></a>6. new和malloc的区别</h3><blockquote>
<p>1、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；</p>
<p>2、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。</p>
<p>3、new不仅分配一段内存，而且会调用构造函数，malloc不会。</p>
<p>4、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。</p>
<p>5、new是一个操作符可以重载，malloc 是一个库函数。</p>
<p>6、malloc分配的内存不够的时候，可以用realloc 扩容。new没这样操作。new如果分配失败了会抛出bad_malloc 的异常，而malloc失败了会返回NULL。</p>
<p>7、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。</p>
</blockquote>
<h4 id="new-delete与malloc-free的区别"><a href="#new-delete与malloc-free的区别" class="headerlink" title="new/delete与malloc/free的区别"></a><strong>new/delete与malloc/free的区别</strong></h4><blockquote>
<p>首先，new/delete是C++的关键字，而malloc/free是C语言的库函数。</p>
<p>malloc需要给定申请内存的大小，返回的指针需要强转。</p>
<p>new会调用构造函数，不用指定内存大小，返回的指针不用强转。</p>
</blockquote>
<h3 id="7-共享内存相关API"><a href="#7-共享内存相关API" class="headerlink" title="7. 共享内存相关API"></a>7. 共享内存相关API</h3><blockquote>
<p>Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在<code>sys/shm.h</code>中。</p>
<ol>
<li><p>新建共享内存shmget</p>
<p>int shmget(key_t key,size_t size,int shmflg);</p>
<p>key：共享内存键值，可以理解为共享内存的唯一性标记。</p>
<p>size：共享内存大小</p>
<p>shmflag：创建进程和其他进程的读写权限标识。</p>
<p>返回值：相应的共享内存标识符，失败返回-1</p>
</li>
<li><p>连接共享内存到当前进程的地址空间shmat</p>
<p>void *shmat(int shm_id,const void *shm_addr,int shmflg);</p>
<p>shm_id：共享内存标识符</p>
<p>shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</p>
<p>shmflg：标志位</p>
<p>返回值：指向共享内存第一个字节的指针，失败返回-1</p>
</li>
<li><p>当前进程分离共享内存shmdt</p>
<p>int shmdt(const void *shmaddr);</p>
</li>
<li><p>控制共享内存shmctl</p>
<p>和信号量的semctl函数类似，控制共享内存</p>
<p>int shmctl(int shm_id,int command,struct shmid_ds *buf);</p>
<p>shm_id：共享内存标识符</p>
<p>command: 有三个值</p>
<p>IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</p>
<p>IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</p>
<p>IPC_RMID:删除共享内存</p>
<p>buf：共享内存管理结构体。</p>
</li>
</ol>
</blockquote>
<h3 id="8-STL的内存优化"><a href="#8-STL的内存优化" class="headerlink" title="8. STL的内存优化"></a>8. STL的内存优化</h3><blockquote>
<h4 id="1）二级配置器结构"><a href="#1）二级配置器结构" class="headerlink" title="1）二级配置器结构"></a>1）二级配置器结构</h4><p>STL内存管理使用二级内存配置器。</p>
<h5 id="1、第一级配置器"><a href="#1、第一级配置器" class="headerlink" title="1、第一级配置器"></a>1、第一级配置器</h5><p>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。<br>一级空间配置器分配的是大于128字节的空间<br>如果分配不成功，调用句柄释放一部分内存<br>如果还不能分配成功，抛出异常</p>
<h5 id="2、第二级配置器"><a href="#2、第二级配置器" class="headerlink" title="2、第二级配置器"></a>2、第二级配置器</h5><p>在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。</p>
<h5 id="3、分配原则"><a href="#3、分配原则" class="headerlink" title="3、分配原则"></a>3、分配原则</h5><p>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。<br>当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表<br>如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块<br>如果内存池空间足够，则取出内存<br>如果不够分配20块，则分配最多的块数给自由链表，并且更新每次申请的块数<br>如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器</p>
</blockquote>
<h4 id="2）二级内存池"><a href="#2）二级内存池" class="headerlink" title="2）二级内存池"></a>2）二级内存池</h4><blockquote>
<p>二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190414/970829_1555246716341_19203EAD1152E0317EE9B5F6BFE090C6" alt="img"></p>
<h5 id="1、空间配置函数allocate"><a href="#1、空间配置函数allocate" class="headerlink" title="1、空间配置函数allocate"></a>1、空间配置函数allocate</h5><p>首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数据块，则调用refill重新填充空间。</p>
<h5 id="2、空间释放函数deallocate"><a href="#2、空间释放函数deallocate" class="headerlink" title="2、空间释放函数deallocate"></a>2、空间释放函数deallocate</h5><p>首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。</p>
<h5 id="3、重新填充空闲链表refill"><a href="#3、重新填充空闲链表refill" class="headerlink" title="3、重新填充空闲链表refill"></a>3、重新填充空闲链表refill</h5><p>在用allocate配置空间时，如果空闲链表中没有可用数据块，就会调用refill来重新填充空间，新的空间取自内存池。缺省取20个数据块，如果内存池空间不足，那么能取多少个节点就取多少个。<br>从内存池取空间给空闲链表用是chunk_alloc的工作，首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去，如果内存连一个数据块的空间都无法供应，需要用malloc取堆中申请内存。<br>假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。</p>
<h4 id="3、总结："><a href="#3、总结：" class="headerlink" title="3、总结："></a>3、总结：</h4><ol>
<li>使用allocate向内存池请求size大小的内存空间，如果需要请求的内存大小大于128bytes，直接使用malloc。</li>
<li>如果需要的内存大小小于128bytes，allocate根据size找到最适合的自由链表。<ol>
<li>a. 如果链表不为空，返回第一个node，链表头改为第二个node。</li>
<li>b. 如果链表为空，使用blockAlloc请求分配node。</li>
<li>x. 如果内存池中有大于一个node的空间，分配竟可能多的node(但是最多20个)，将一个node返回，其他的node添加到链表中。</li>
<li>y. 如果内存池只有一个node的空间，直接返回给用户。</li>
<li>z. 若果如果连一个node都没有，再次向操作系统请求分配内存。<ol>
<li>①分配成功，再次进行b过程。</li>
<li>②分配失败，循环各个自由链表，寻找空间。</li>
<li>I. 找到空间，再次进行过程b。</li>
<li>II. 找不到空间，抛出异常。</li>
</ol>
</li>
</ol>
</li>
<li>用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。</li>
<li>否则按照其大小找到合适的自由链表，并将其插入。</li>
</ol>
</blockquote>
<h3 id="9-select-epoll的区别、原理、性能、限制"><a href="#9-select-epoll的区别、原理、性能、限制" class="headerlink" title="9. select/epoll的区别、原理、性能、限制"></a>9. select/epoll的区别、原理、性能、限制</h3><blockquote>
<h4 id="1-IO多路复用"><a href="#1-IO多路复用" class="headerlink" title="1 IO多路复用"></a>1 IO多路复用</h4></blockquote>
<blockquote>
<p>IO复用模型在阻塞IO模型上多了一个select函数，select函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。</p>
<p>这种IO模型是属于阻塞的IO。但是由于它可以对多个文件描述符进行阻塞监听，所以它的效率比阻塞IO模型高效。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/826546_1552638064152_94DD1FAB6C2E289FF496A8013E092EA5" alt="img"></p>
<p>IO多路复用就是我们说的select，poll，epoll。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>I/O多路复用和阻塞I/O其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h4 id="2-select"><a href="#2-select" class="headerlink" title="2 select"></a>2 select</h4><p>select：是最初解决IO阻塞问题的方法。用结构体fd_set来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。</p>
<p>存在的问题：</p>
<ol>
<li><p>内置数组的形式使得select的最大文件数受限与FD_SIZE；</p>
</li>
<li><p>每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态；</p>
</li>
<li><p>轮寻排查当文件描述符个数很多时，效率很低；</p>
</li>
</ol>
<h4 id="3-poll"><a href="#3-poll" class="headerlink" title="3 poll"></a>3 poll</h4><p>poll：通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。</p>
<h4 id="4-epoll"><a href="#4-epoll" class="headerlink" title="4 epoll"></a>4 epoll</h4><ul>
<li>epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。</li>
<li>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式</li>
</ul>
<ol>
<li><h6 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h6></li>
</ol>
<p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<ol start="2">
<li><h6 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h6></li>
</ol>
<ul>
<li>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。</li>
<li>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</li>
</ul>
<ol start="3">
<li><h6 id="LT模式与ET模式的区别"><a href="#LT模式与ET模式的区别" class="headerlink" title="LT模式与ET模式的区别"></a>LT模式与ET模式的区别</h6></li>
</ol>
<ul>
<li>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li>
</ul>
</blockquote>
<h3 id="10-堆和栈的概念"><a href="#10-堆和栈的概念" class="headerlink" title="10. 堆和栈的概念"></a>10. 堆和栈的概念</h3><blockquote>
<p>堆（Heap）与栈（Stack）的理解需要放到具体的场景下，因为不同场景下，堆与栈代表不同的含义。</p>
<ol>
<li>程序内存布局场景下，堆与栈表示两种内存管理方式；</li>
<li>数据结构场景下，堆与栈表示两种常用的数据结构。</li>
</ol>
<h4 id="内存场景"><a href="#内存场景" class="headerlink" title="内存场景"></a>内存场景</h4><p>堆上内存空间的分配过程</p>
<ul>
<li><p>首先，操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点；</p>
</li>
<li><p>然后，将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。</p>
</li>
<li><p>另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。</p>
<p>由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。</p>
</li>
</ul>
<p>栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>栈是一种运算受限的线性表，其限制是指只仅允许在表的一端进行插入和删除操作，这一端被称为栈顶（Top），相对地，把另一端称为栈底（Bottom）。</p>
<p>堆是一种常用的树形结构，是一种特殊的完全二叉树，当且仅当满足所有节点的值总是不大于或不小于其父节点的值的完全二叉树被称之为堆。</p>
</blockquote>
<h3 id="11-堆和栈的区别"><a href="#11-堆和栈的区别" class="headerlink" title="11. 堆和栈的区别"></a>11. <a href="https://www.cnblogs.com/yiluyisha/p/9049051.html" target="_blank" rel="noopener">堆和栈的区别</a></h3><blockquote>
<p>  1、管理方式；<br>  2、空间大小；<br>  3、能否产生碎片；<br>  4、生长方向；<br>  5、分配方式；<br>  6、分配效率；</p>
</blockquote>
<blockquote>
<p>（1）管理方式：堆中资源由程序员控制（通过malloc/free、new/delete，容易产生memory leak），栈资源由编译器自动管理。</p>
<p>（2）系统响应：对于堆，系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个大于所申请空间的空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外，系统会将多余的部分重新放入空闲链表中）。对于栈，只要栈的剩余空间大于所申请空间，系统就会为程序分配内存，否则报异常出现栈空间溢出错误。</p>
<p>（3）空间大小：堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址的，自然不是连续），堆的大小受限于计算机系统中有效的虚拟内存（32位机器上理论上是4G大小），所以堆的空间比较灵活，比较大。栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在编译时确定，VC中可设置）。</p>
<p>（4）碎片问题：对于堆，频繁的new/delete会造成大量内存碎片，降低程序效率。栈是一个先进后出（first-in-last-out）的结构，进出一一对应，不会产生碎片。</p>
<p>（5）生长方向：堆向上，向高地址方向增长；栈向下，向低地址方向增长。</p>
<p>（6）分配方式：堆是动态分配（没有静态分配的堆）。栈有静态分配和动态分配，静态分配由编译器完成（如函数局部变量），动态分配由alloca函数分配，但栈的动态分配资源由编译器自动释放，无需程序员实现。</p>
<p>（7）分配效率：堆由C/C++函数库提供，机制复杂，因此堆的效率比栈低很多。栈是机器系统提供的数据结构，计算机在底层对栈提供支持，分配专门的寄存器存放栈地址，提供栈操作专门的指令。</p>
</blockquote>
<h3 id="12-分堆和栈的原因"><a href="#12-分堆和栈的原因" class="headerlink" title="12. 分堆和栈的原因"></a>12. 分堆和栈的原因</h3><blockquote>
<p>第一，从软件设计的角度看，栈代表处理逻辑，而堆代表数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</p>
<p>第二，堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</p>
<p>第三，栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</p>
<p>第四，面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。</p>
<h4 id="反证法"><a href="#反证法" class="headerlink" title="反证法"></a>反证法</h4><p>仅使用栈</p>
<p>假设我们的程序代码仅仅使用栈，那么我们的代码会变得非常的简单，程序在执行函数的时候，只需要依次的将变量压入堆栈就好了，当要释放的时候取出来就好了，针对实现的时候，只需要让指针上下移动就好。这么一看栈似乎很完美，它性能优越快速，而且不会产生内存碎片。但是假设我们现在有这么一个操作现在有两个变量 A,B 我们先依次把他们入栈，入栈后的后续操作我们主要是围绕 B 进行的，与 A 已经没有关系了，但是 A 依旧占用着空间，如果我们希望释放 A 的内存空间，那么根据后进先出的原则，那么我们必须先释放 B 才能释放 A，但是后续的计算又需要 B 这就导致我们无法释放 A，在后续的过程中 A 已经没有价值了，但是它还是必须驻留在内存中。而这个时候如果将 A 放入堆中，那么当 A 不在使用的时候，我们可以很容易的在堆中释放 A 所占用的空间，提高内存的有效使用率。这就是堆出现的初衷。</p>
<p>仅使用堆</p>
<p>堆之所以能与比栈更好的动态分配的性能是因为堆往往使用了较为复杂的数据结构，这就会导致操作堆的成本要远远大于栈的成本，所以如果仅仅使用堆会使的程序整体效率变慢。</p>
</blockquote>
<h3 id="13-C-函数栈空间的最大值"><a href="#13-C-函数栈空间的最大值" class="headerlink" title="13. C++函数栈空间的最大值"></a>13. C++函数栈空间的最大值</h3><blockquote>
<p>默认是1M，不过可以调整</p>
</blockquote>
<h3 id="14-说说stack-overflow，并举个简单例子"><a href="#14-说说stack-overflow，并举个简单例子" class="headerlink" title="14. 说说stack overflow，并举个简单例子"></a>14. 说说stack overflow，并举个简单例子</h3><blockquote>
<p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，导致栈中与其相邻的变量的值被改变。</p>
<h4 id="栈溢出的原因"><a href="#栈溢出的原因" class="headerlink" title="栈溢出的原因"></a>栈溢出的原因</h4><ol>
<li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。</li>
<li>递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</li>
<li>指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</li>
</ol>
<h4 id="栈溢出例子"><a href="#栈溢出例子" class="headerlink" title="栈溢出例子"></a>栈溢出例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input:%s\n"</span>,buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的<code>strcpy(buf,argv[1])</code>;这一行发生了缓冲区溢出错误，因为源缓冲区内容是用户输入的。</p>
</blockquote>
<h3 id="15-栈和堆的区别，以及为什么栈要快"><a href="#15-栈和堆的区别，以及为什么栈要快" class="headerlink" title="15.  栈和堆的区别，以及为什么栈要快"></a>15.  栈和堆的区别，以及为什么栈要快</h3><blockquote>
<h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><ol>
<li>堆是由低地址向高地址扩展；栈是由高地址向低地址扩展</li>
<li>堆中的内存需要手动申请和手动释放；栈中内存是由OS自动申请和自动释放，存放着参数、局部变量等内存</li>
<li>堆中频繁调用malloc和free,会产生内存碎片，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片</li>
<li>堆的分配效率较低，而栈的分配效率较高</li>
</ol>
<h4 id="栈的效率高的原因"><a href="#栈的效率高的原因" class="headerlink" title="栈的效率高的原因"></a>栈的效率高的原因</h4><p>栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。</p>
</blockquote>
<h3 id="16-A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？"><a href="#16-A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？" class="headerlink" title="16.  A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？"></a>16.  A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？</h3><blockquote>
<p>1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4/8字节的空间（0x000m），分配给指针a。</p>
<p>2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。</p>
<p>3）a = new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）=0x000n。</p>
<p>4）a-&gt;i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。</p>
</blockquote>
<h3 id="17-大端小端及如何判断"><a href="#17-大端小端及如何判断" class="headerlink" title="17. 大端小端及如何判断"></a>17. 大端小端及如何判断</h3><blockquote>
<p>大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。</p>
<p>我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。</p>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">union</span> test&#123;</span><br><span class="line">         <span class="keyword">int</span> i;</span><br><span class="line">         <span class="keyword">char</span> c;</span><br><span class="line">     &#125;;</span><br><span class="line">     test t;</span><br><span class="line">     t.i = <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//如果是大端，则t.c为0x00,则t.c!=1;否则 t.c为0x01,则t.c==1，返回1</span></span><br><span class="line">     <span class="keyword">return</span> (it.c == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="六-C-特性"><a href="#六-C-特性" class="headerlink" title="六 C++ 特性"></a>六 C++ 特性</h2><h3 id="1-C-和C的区别"><a href="#1-C-和C的区别" class="headerlink" title="1 C++和C的区别"></a>1 C++和C的区别</h3><blockquote>
<ol>
<li>(设计思想上) C++是面向对象的语言，而C是面向过程的结构化编程语言;</li>
<li>(语法上)</li>
</ol>
<ul>
<li><p>C++具有封装、继承和多态三种特性；C不支持</p>
</li>
<li><p>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</p>
</li>
<li><p>C++支持范式编程，比如模板类、函数模板等</p>
</li>
</ul>
</blockquote>
<h3 id="2-C-高级特性"><a href="#2-C-高级特性" class="headerlink" title="2 C++高级特性"></a>2 C++高级特性</h3><blockquote>
<ol>
<li>auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导</li>
<li>nullptr关键字：nullptr 是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。</li>
<li>智能指针：C++11新增了<code>std::shared_ptr</code>、<code>std::weak_ptr</code>等类型的智能指针，用于解决内存管理的问题。</li>
<li>初始化列表：使用初始化列表来对类进行初始化</li>
<li>右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</li>
<li><code>atomic</code>原子操作用于多线程资源互斥操作</li>
<li>新增<code>STL</code>容器<code>array</code>以及<code>tuple</code></li>
</ol>
</blockquote>
<h4 id="Auto的初始化"><a href="#Auto的初始化" class="headerlink" title="Auto的初始化"></a>Auto的初始化</h4><blockquote>
<p>为了让编译器能够根据初始值的类型推断变量的类型，C++重新定义了auto的含义。</p>
<p>在初始化声明中，如果使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同；但自动推断类型并不是为这种简单情况而设计的，如果永用于简单情形，会出错，假设要将x,y,z都指定为double</p>
</blockquote>
<h3 id="3-GDB调试"><a href="#3-GDB调试" class="headerlink" title="3 GDB调试"></a>3 GDB调试</h3><h4 id="1-请问GDB调试用过吗，什么是条件断点"><a href="#1-请问GDB调试用过吗，什么是条件断点" class="headerlink" title="1. 请问GDB调试用过吗，什么是条件断点"></a>1. 请问GDB调试用过吗，什么是条件断点</h4><blockquote>
<h4 id="1、GDB调试"><a href="#1、GDB调试" class="headerlink" title="1、GDB调试"></a>1、GDB调试</h4><p>GDB 是一种软件工具，作用是协助程序员找到代码中的错误。如果没有GDB的帮助，程序员要想跟踪代码的执行流程，唯一的办法就是添加大量的语句来产生特定的输出。但这一手段本身就可能会引入新的错误，从而也就无法对那些导致程序崩溃的错误代码进行分析。</p>
<p>GDB 的出现减轻了开发人员的负担，他们可以在程序运行的时候单步跟踪自己的代码，或者通过断点暂时中止程序的执行。此外还能够随时察看变量和内存的当前状态，并监视关键的数据结构是如何影响代码运行的。</p>
<h4 id="2、条件断点"><a href="#2、条件断点" class="headerlink" title="2、条件断点"></a>2、条件断点</h4><p>条件断点是当满足条件就中断程序运行，命令：break line-or-function if expr。</p>
<p>例如：(gdb)break 666 if testsize==100</p>
</blockquote>
<h1 id="二-算法与数据结构"><a href="#二-算法与数据结构" class="headerlink" title="二 算法与数据结构"></a>二 算法与数据结构</h1><h2 id="一-堆、栈、队列、字符串"><a href="#一-堆、栈、队列、字符串" class="headerlink" title="一 堆、栈、队列、字符串"></a>一 堆、栈、队列、字符串</h2><h3 id="1-堆"><a href="#1-堆" class="headerlink" title="1. 堆"></a>1. 堆</h3><blockquote>
<p>堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。</p>
<p>小根堆：若根节点存在左子女则根节点的值小于左子女的值；若根节点存在右子女则根节点的值小于右子女的值。</p>
<p>大根堆：若根节点存在左子女则根节点的值大于左子女的值；若根节点存在右子女则根节点的值大于右子女的值。</p>
</blockquote>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><blockquote>
<p><strong>push heap</strong>算法</p>
<ol>
<li>将新元素放入vector的末尾，即heap的尾元素</li>
<li>将当前元素与父节点进行比较<ol>
<li>如果满足交换的需求（最大堆中，当前节点大于父节点）则交换</li>
<li>否则，停止，退出</li>
</ol>
</li>
<li>重复2直至条件不再满足，或者到达根节点</li>
</ol>
<p>$log(n)$的时间复杂度</p>
<p><strong>pop heap</strong>算法</p>
<p>每一次pop操作都是将vector元素的首元素取出，并从原vector中删除，以最大堆的操作为例</p>
<ol>
<li>取vector的首元素</li>
<li>将vector的尾元素取出放在vector的首元素</li>
<li>将当前元素与左右子树中权值较大的节点进行交换，不断地向下回溯</li>
</ol>
</blockquote>
<h3 id="2-栈"><a href="#2-栈" class="headerlink" title="2. 栈"></a>2. 栈</h3><blockquote>
<p>栈是允许在同一端进行插入和删除操作的特殊线性表。允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈底固定，而栈顶浮动；栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。</p>
</blockquote>
<h2 id="二-数组与链表"><a href="#二-数组与链表" class="headerlink" title="二 数组与链表"></a>二 数组与链表</h2><h3 id="1-合并两个有序链表"><a href="#1-合并两个有序链表" class="headerlink" title="1 合并两个有序链表"></a>1 合并两个有序链表</h3><blockquote>
<h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>)	<span class="keyword">return</span> l2;</span><br><span class="line">      <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>)   <span class="keyword">return</span> l1;</span><br><span class="line">      <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">         l1-&gt;next=mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">         <span class="keyword">return</span> l1;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">         l2-&gt;next=mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">          <span class="keyword">return</span> l2;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-反转链表"><a href="#2-反转链表" class="headerlink" title="2 反转链表"></a>2 反转链表</h3><blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">reversal_list</span><span class="params">(node * head)</span></span>&#123;</span><br><span class="line">      node* pre_node = <span class="literal">nullptr</span>;</span><br><span class="line">       node* cur_node = head-&gt;next;</span><br><span class="line">       node* next_node = cur_node-&gt;next;</span><br><span class="line">       <span class="keyword">if</span>(cur_node == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           cur_node-&gt;next = forward_node;</span><br><span class="line">           pre_node = cur_node;</span><br><span class="line">           cur_node = next_node;</span><br><span class="line">           <span class="keyword">if</span>(cur_node == <span class="literal">nullptr</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           next_node = cur_node-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">     head-&gt;next = pre_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-判断回文链表"><a href="#3-判断回文链表" class="headerlink" title="3 判断回文链表"></a>3 判断回文链表</h3><blockquote>
<p>使用栈来判断</p>
</blockquote>
<h3 id="4-判断公共节点"><a href="#4-判断公共节点" class="headerlink" title="4 判断公共节点"></a>4 判断公共节点</h3><blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">       ListNode *node1 = headA;</span><br><span class="line">       ListNode *node2 = headB;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (node1 != node2) &#123;</span><br><span class="line">           node1 = node1 != <span class="literal">NULL</span> ? node1-&gt;next : headB;</span><br><span class="line">           node2 = node2 != <span class="literal">NULL</span> ? node2-&gt;next : headA;</span><br><span class="line">       &#125;</span><br><span class="line">    	<span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-判断数组否有重复的数"><a href="#5-判断数组否有重复的数" class="headerlink" title="5 判断数组否有重复的数"></a>5 判断数组否有重复的数</h3><blockquote>
<p>一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数</p>
<p>把每个数放到自己对应序号的位置上，如果其他位置上有和自己对应序号相同的数，那么即为有重复的数值。时间复杂度为O(N),同时为了节省空间复杂度，可以在原数组上进行操作，空间复杂度为O(1)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsDuplicateNumber</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">array</span>==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">int</span> i,temp;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="built_in">array</span>[i]!=i)&#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="built_in">array</span>[<span class="built_in">array</span>[i]]==<span class="built_in">array</span>[i])</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">               temp=<span class="built_in">array</span>[<span class="built_in">array</span>[i]];</span><br><span class="line">               <span class="built_in">array</span>[<span class="built_in">array</span>[i]]=<span class="built_in">array</span>[i];</span><br><span class="line">               <span class="built_in">array</span>[i]=temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="三-树"><a href="#三-树" class="headerlink" title="三 树"></a>三 树</h2><h3 id="零-二叉树的性质"><a href="#零-二叉树的性质" class="headerlink" title="零 二叉树的性质"></a>零 二叉树的性质</h3><blockquote>
<p><strong>性质1</strong> ：在二叉树的第i层上至多有$2^{i-1}$ 个结点（i≥1）。（数学归纳法可证）</p>
<p><strong>性质2</strong> ：深度为k的二叉树最多有$2^{k-1}$个结点（k≥1）。（由性质1，通过等比数列求和可证）</p>
<p><strong>性质3</strong> ：一棵二叉树的叶子结点数为n0 ，度为2的结点数为n2 ，则n0 = n2 + 1。</p>
<p><strong>性质4</strong> ：具有n个结点的完全二叉树的深度为floor(log2n) + 1 。</p>
<p><strong>性质5</strong> ：如果对一棵有n个结点的完全二叉树（其深度为floor(log2n) + 1 ）的结点按层序编号，则对任一结点i（1≤i≤n）有：</p>
<p>（1） 如果i = 1，则结点i是二叉树的根，无双亲；如果i &gt; 1，则其双亲PARENT(i)是结点 floor((i)/2)。</p>
<p>（2）如果2i &gt; n，则结点i无左孩子；否则其左孩子LCHILD(i)是结点2i。</p>
<p>（3）如果2i + 1 &gt; n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2i + 1</p>
</blockquote>
<h4 id="树与二叉树的关系"><a href="#树与二叉树的关系" class="headerlink" title="树与二叉树的关系"></a>树与二叉树的关系</h4><blockquote>
<ol>
<li>树的先序对应二叉树的先序</li>
<li>树的后序对应二叉树的中序</li>
</ol>
</blockquote>
<h4 id="树与二叉树的转换"><a href="#树与二叉树的转换" class="headerlink" title="树与二叉树的转换"></a>树与二叉树的转换</h4><blockquote>
<p>1-加线：在所有的兄弟节点之间加一条线<br>2-去线：对树中每个结点，只保留它与第一个孩子节点的连线，删除它与其他孩子节点之间的连线。<br>3-层次调整：以树的根节点为轴心，将整颗树顺时针旋转一定的角度，使之结构层次分明。</p>
</blockquote>
<h3 id="一-递归遍历"><a href="#一-递归遍历" class="headerlink" title="一 递归遍历"></a>一 递归遍历</h3><h3 id="二-非递归遍历"><a href="#二-非递归遍历" class="headerlink" title="二 非递归遍历"></a>二 非递归遍历</h3><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       node* p = root;</span><br><span class="line">       <span class="built_in">stack</span>&lt;node*&gt; st;</span><br><span class="line">       <span class="keyword">while</span>(!st.empty()||p)&#123;</span><br><span class="line">           <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">               st.push(p);</span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">               p = p-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           p = st.top();</span><br><span class="line">           st.pop();</span><br><span class="line">           p = p-&gt;right;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     node* p = root;</span><br><span class="line">     <span class="built_in">stack</span>&lt;node*&gt; st;</span><br><span class="line">     <span class="keyword">while</span>(!st.empty()||p)&#123;</span><br><span class="line">           <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">               st.push(p);</span><br><span class="line">               p = p-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           p = st.top();</span><br><span class="line">           st.pop();</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//与前序遍历相比，输出位置有区别</span></span><br><span class="line">           p = p-&gt;right;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种方法不需要辅助空间保存结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;node*&gt; st;</span><br><span class="line">    node *pcur,*plast;</span><br><span class="line">    pcur = root;</span><br><span class="line">    plast = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(pcur)&#123;</span><br><span class="line">        st.push(pcur);</span><br><span class="line">        pcur = pcur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">        pcur = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span>(pcur-&gt;left==<span class="literal">nullptr</span>||pcur-&gt;right==plast)&#123; </span><br><span class="line">            <span class="comment">// 如果左右子树都访问过，则输出根节点；</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;pcur-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            plast = pcur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 否则，再次入栈，并挪到右子树的左端点</span></span><br><span class="line">            st.push(pcur);</span><br><span class="line">            pcur = pcur-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(pcur)&#123;</span><br><span class="line">                st.push(pcur);</span><br><span class="line">                pcur = pcur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">PostOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">           <span class="keyword">return</span> ret;</span><br><span class="line">       TreeNode* cur = root;</span><br><span class="line">       <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(cur || st.size()) &#123;</span><br><span class="line">           <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">               ret.push_back(cur-&gt;val);</span><br><span class="line">               st.push(cur);</span><br><span class="line">               cur = cur-&gt;right;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = st.top();</span><br><span class="line">           st.pop();</span><br><span class="line">           cur = cur-&gt;left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(ret.rbegin(), ret.rend());<span class="comment">//最后需要逆序输出，或者做个转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="三-Huffman树"><a href="#三-Huffman树" class="headerlink" title="三 Huffman树"></a>三 Huffman树</h3><blockquote>
<p>Huffman树的带权路劲长度WPL等于个叶子节点的带权路劲长度之和。</p>
</blockquote>
<h3 id="四-红黑树"><a href="#四-红黑树" class="headerlink" title="四 红黑树"></a>四 红黑树</h3><blockquote>
<p>红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在<a href="https://baike.baidu.com/item/计算机" target="_blank" rel="noopener">计算机</a>科学中用到的一种<a href="https://baike.baidu.com/item/数据结构/1450" target="_blank" rel="noopener">数据结构</a>，典型的用途是实现<a href="https://baike.baidu.com/item/关联数组/3317025" target="_blank" rel="noopener">关联数组</a>。</p>
<p>红黑树是一种特化的AVL树（<a href="https://baike.baidu.com/item/平衡二叉树/10421057" target="_blank" rel="noopener">平衡二叉树</a>），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。 [2] </p>
<p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。</p>
<p>红黑树是一种特定类型的<a href="https://baike.baidu.com/item/二叉树" target="_blank" rel="noopener">二叉树</a>，是在计算机科学中用来组织数据比如数字的块的一种结构。若一棵二叉查找树是红黑树，则它的任一子树必为红黑树。红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的<a href="https://baike.baidu.com/item/平衡二叉树/10421057" target="_blank" rel="noopener">平衡二叉树</a>（AVL），但 对之进行平衡的代价较低， 其平均统计性能要强于 AVL 。 由于每一颗红黑树都是一颗二叉排序树，因此对红黑树进行查找时，可以采用运用于普通二叉排序树上的查找算法，在查找过程中不需要颜色信息。</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>节点是红色或黑色。 </li>
<li>根节点是黑色。 </li>
<li>所有叶子都是黑色。（叶子是NULL节点） </li>
<li>每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 </li>
</ol>
<p><strong>应用</strong>：广泛应用于C++的STL中，map和set底层都是用红黑树实现的。</p>
</blockquote>
<p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/1732651-20190821151029589-676793772.png" alt="img"></p>
<blockquote>
<h6 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h6><ol>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li>
<li>任何相邻的节点（父子节点）都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li>
</ol>
<p><a href="https://time.geekbang.org/column/article/68638" target="_blank" rel="noopener">近似平衡的原因</a></p>
</blockquote>
<h4 id="1-红黑树与平衡二叉树的区别"><a href="#1-红黑树与平衡二叉树的区别" class="headerlink" title="1. 红黑树与平衡二叉树的区别"></a>1. 红黑树与平衡二叉树的区别</h4><blockquote>
<p>说它不严格是因为它不是严格控制左、右子树高度或节点数之差小于等于1。<br>但红黑树高度依然是平均log(n)，且最坏情况高度不会超过<code>2log(n)</code>，这有数学证明。所以它算平衡树，只是不严格。不过严格与否并不影响数据结构的复杂度。</p>
</blockquote>
<h3 id="五-B树与B-树"><a href="#五-B树与B-树" class="headerlink" title="五 B树与B+树"></a>五 B树与B+树</h3><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><blockquote>
<p>m阶B树满足以下条件：</p>
<ul>
<li>每个节点至多可以拥有m棵子树。</li>
<li>根节点，只有至少有2个节点（要么极端情况，就是一棵树就一个根节点，单细胞生物，即是根，也是叶，也是树)。</li>
<li>非根非叶的节点至少有的Ceil(m/2)个子树(Ceil表示向上取整，图中5阶B树，每个节点至少有3个子树，也就是至少有3个叉)。</li>
<li>非叶节点中的信息包括[n,A0,K1,A1,K2,A2,…,Kn,An]，，其中n表示该节点中保存的关键字个数，K为关键字且Ki&lt;Ki+1，A为指向子树根节点的指针。</li>
<li>从根到叶子的每一条路径都有相同的长度，也就是说，叶子节在相同的层，并且这些节点不带信息，实际上这些节点就表示找不到指定的值，也就是指向这些节点的指针为空。</li>
</ul>
</blockquote>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><blockquote>
<p>作为B树的加强版，B+树与B树的差异在于</p>
<ul>
<li>有n棵子树的节点含有n个关键字（也有认为是n-1个关键字）。</li>
<li>所有的关键字全部存储在叶子节点上，且叶子节点本身根据关键字自小而大顺序连接。</li>
<li>非叶子节点可以看成索引部分，节点中仅含有其子树（根节点）中的最大（或最小）关键字。</li>
</ul>
<p>B+树的查找过程，与B树类似，只不过查找时，如果在非叶子节点上的关键字等于给定值，并不终止，而是继续沿着指针直到叶子节点位置。因此在B+树，不管查找成功与否，每次查找都是走了一条从根到叶子节点的路径。</p>
<img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/758447-20180126171338850-1455023219.png" alt="img" style="zoom:67%;">

<p>B+树的特性如下：</p>
<ul>
<li>所有关键字都存储在叶子节上，且链表中的关键字恰好是有序的。</li>
<li>不可能非叶子节点命中返回。</li>
<li>非叶子节点相当于叶子节点的索引，叶子节点相当于是存储（关键字）数据的数据层。</li>
<li>更适合文件索引系统。</li>
</ul>
<h4 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h4><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p>
<p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/758447-20180126172151522-1626747450.png" alt="img"></p>
<p>如上图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提高了区间查询效率。</p>
</blockquote>
<h3 id="六-平衡二叉树"><a href="#六-平衡二叉树" class="headerlink" title="六 平衡二叉树"></a>六 平衡二叉树</h3><blockquote>
<ul>
<li><code>平衡因子</code> : 树中某结点其左子树的高度和右子树的高度之差</li>
<li><code>AVL树</code>：中的任意一个结点, 其<code>平衡因子</code>的<strong>绝对值小于2</strong></li>
<li><code>AVL树</code>是一种特殊的二叉搜索树 (BST树), 相对于数据极端情况下, 二叉搜索树会退化成为单链表, <code>AVL树</code>定义了<strong>旋转操作</strong>, 在<code>平衡因子</code>大于等于2时, <code>AVL树</code>会旋转来调整树的结构, 来重新满足<code>平衡因子</code>小于2</li>
</ul>
<h4 id="树的平衡"><a href="#树的平衡" class="headerlink" title="树的平衡"></a>树的平衡</h4><ul>
<li>左子树的左子树插入结点 (左左)；（右旋）</li>
<li>右子树的右子树插入节点 (右右)；（左旋）</li>
<li>左子树的右子树插入节点 (左右)；（先左旋 后右旋）</li>
<li>右子树的左子树插入节点 (右左)；（先右旋 后左旋）</li>
</ul>
</blockquote>
<h2 id="四-图"><a href="#四-图" class="headerlink" title="四 图"></a>四 图</h2><h3 id="1-最小生成树是否唯一"><a href="#1-最小生成树是否唯一" class="headerlink" title="1. 最小生成树是否唯一"></a>1. 最小生成树是否唯一</h3><blockquote>
<p>最小生成树不唯一，最小生成树代价唯一</p>
<p>解释：Kruskal与prim算法都是贪婪算法，特别的Kruskal算法是Dijkstra算法的变种。</p>
<p>对于一个权重各不相同的无向图来说，这两种算法的最小生成树唯一（权值和自然唯一）。</p>
<p>但是如果在无向图中有两个边的权值相同，则在Kruskal算法中选择更新该边的顶点，还是其他权值相同的边的顶点会导致不同的结论。</p>
<p>与使用不相交集合实现的prim同理，这是贪婪算法的特性，因为局部最优，结果唯一。</p>
<p>特别的贪婪与动态规划都具有唯一确定性，结果都是唯一。不要指望用greed或者dp去求最优解的全集。但两者的区别就是greed保证局部最优，我不管你前因后果，我就管现在我做出最佳选择。DP保证全局最优（通过状态转移方程实现）</p>
</blockquote>
<h3 id="2-如何判断一个图是否有环"><a href="#2-如何判断一个图是否有环" class="headerlink" title="2. 如何判断一个图是否有环"></a>2. 如何判断一个图是否有环</h3><blockquote>
<ol>
<li><p>DFS，如果要访问的元素已经访问过，它在当前的栈内还没出栈，那么就是有环。BFS不行是因为可能有多个节点指向该节点，不一定是因为有环。</p>
</li>
<li><p>拓扑排序，拓扑排序会循环执行以下两步：</p>
<ol>
<li>选择一个入度为0的顶点，输出</li>
<li>从图中删除此顶点以及所有的出边<br>循环结束后，若输出的顶点数小于网中的顶点数，则说明有回路</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="五-哈希表"><a href="#五-哈希表" class="headerlink" title="五 哈希表"></a>五 哈希表</h2><h3 id="0-哈希表"><a href="#0-哈希表" class="headerlink" title="0. 哈希表"></a>0. <a href="https://www.cnblogs.com/zzdbullet/p/10512670.html" target="_blank" rel="noopener">哈希表</a></h3><blockquote>
<p><a href="https://baike.baidu.com/item/散列表/10027933" target="_blank" rel="noopener">散列表</a>（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的<a href="https://baike.baidu.com/item/数据结构/1450" target="_blank" rel="noopener">数据结构</a>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a href="https://baike.baidu.com/item/散列函数/2366288" target="_blank" rel="noopener">散列函数</a>，存放记录的<a href="https://baike.baidu.com/item/数组/3794097" target="_blank" rel="noopener">数组</a>叫做<a href="https://baike.baidu.com/item/散列表/10027933" target="_blank" rel="noopener">散列表</a>。</p>
</blockquote>
<h3 id="1-哈希表的构造方法"><a href="#1-哈希表的构造方法" class="headerlink" title="1. 哈希表的构造方法"></a>1. 哈希表的构造方法</h3><blockquote>
<p> <strong>构造哈希函数的原则</strong></p>
<p> ① 函数本身便于计算；② 计算出来的地址分布均匀，即对任一关键字k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突。</p>
<p> <strong>构造方法</strong></p>
<ol>
<li><p>数字分析法 </p>
<blockquote>
<p>  如果事先知道关键字集合，并且每个关键字的位数比哈希表的地址码位数多时，可以从关键字中选出分布较均匀的若干位，构成哈希地址。</p>
</blockquote>
</li>
<li><p>平方取中法</p>
<blockquote>
<p>  当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。</p>
</blockquote>
</li>
<li><p>分段叠加法</p>
<blockquote>
<p>  按哈希表地址位数将关键字分成位数相等的几部分（最后一部分可以较短），然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。具体方法有<strong>折叠法</strong>与<strong>移位法。</strong></p>
<p>  移位法是将分割后的每部分低位对齐相加；</p>
<p>  折叠法是从一端向另一端沿分割界来回折叠（奇数段为正序，偶数段为倒序），然后将各段相加。</p>
</blockquote>
</li>
<li><p>除留余数法</p>
<blockquote>
<p>  假设哈希表长为m，p为小于等于m的最大素数，则哈希函数为</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h（k）= k % p; <span class="comment">//其中%为模p取余运算。</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>伪随机数法</p>
<blockquote>
<p> 采用一个伪随机函数做哈希函数，即h(key)=random(key)。</p>
<p>  在实际应用中，应根据具体情况，灵活采用不同的方法，并用实际数据测试它的性能，以便做出正确判定。通常应考虑以下五个因素 ：</p>
<ol>
<li><p>l     计算哈希函数所需时间 （简单）。</p>
</li>
<li><p>l     关键字的长度。</p>
</li>
<li><p>l     哈希表大小。</p>
</li>
<li><p>l     关键字分布情况。</p>
</li>
<li><p>l     记录查找频率</p>
</li>
</ol>
</blockquote>
</li>
</ol>
</blockquote>
<h3 id="2-处理冲突的四种方法"><a href="#2-处理冲突的四种方法" class="headerlink" title="2. 处理冲突的四种方法"></a>2. 处理冲突的四种方法</h3><h4 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1 开放寻址法"></a><strong>1 开放寻址法</strong></h4><blockquote>
<p>这种方法也称<strong>再散列法，</strong>其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：</p>
<p>$     Hi=（H（key）+di）% m  i=1，2，…，n$</p>
<p>其中H（key）为哈希函数，m 为表长，di称为<strong>增量序列。</strong>增量序列的取值方式不同，相应的再散列方式也不同。</p>
<p>主要有以下三种：</p>
<ol>
<li><p>线性探测再散列</p>
<p>  $d_ii=1，2，3，…，m-1$</p>
<p>这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p>
</li>
<li><p>二次探测再散列<br>$$<br>di=12，-12，22，-22，…，k2，-k2  ( k&lt;=m/2 )<br>$$<br>这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。</p>
</li>
<li><p>伪随机探测再散列</p>
<p>$di=伪随机数序列。$</p>
<p>具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。</p>
</li>
</ol>
</blockquote>
<h4 id="2-再哈希法"><a href="#2-再哈希法" class="headerlink" title="2 再哈希法"></a><strong>2 再哈希法</strong></h4><blockquote>
<p>这种方法是同时构造多个不同的哈希函数：<br>$$<br>H_i=RH_1（key） i=1，2，…，k<br>$$<br>当哈希地址$H_i=RH_1(key)$，发生冲突时，再计算$Hi=RH_2(key)$……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
</blockquote>
<h4 id="3-拉链法"><a href="#3-拉链法" class="headerlink" title="3 拉链法"></a>3 拉链法</h4><blockquote>
<p>基本思想：将所有哈希地址为i的元素构成一个称为<strong>同义词链</strong>的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>
</blockquote>
<h4 id="4-建立一个公共的溢出区"><a href="#4-建立一个公共的溢出区" class="headerlink" title="4 建立一个公共的溢出区"></a><strong>4 建立一个公共的溢出区</strong></h4><blockquote>
<p>基本思想是：将哈希表分为<strong>基本表</strong>和<strong>溢出表</strong>两部分，凡是和基本表发生冲突的元素，一律填入溢出表</p>
</blockquote>
<h3 id="3-哈希表的优缺点"><a href="#3-哈希表的优缺点" class="headerlink" title="3. 哈希表的优缺点"></a>3. 哈希表的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><blockquote>
<ol>
<li>冲突少的情况下，访问速度很快</li>
</ol>
</blockquote>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><blockquote>
<ol>
<li>哈希函数的设计需要一些策略</li>
<li>当数的数目较少时，哈希表会有冗余；</li>
<li>当数的数目很多时，哈希表冲突的可能性很大。</li>
<li>扩容机制复杂：在决定建立哈希表之前，最好可以估计输入的数据的size。否则，resize哈希表的过程将会是一个非常消耗时间的过程。例如，如果现在你的哈希表的长度是100，但是现在有第101个数要插入。这时，不仅哈希表的长度可能要扩展到150，且扩展之后所有的数都需要重新rehash。</li>
<li>元素没有被排序：然而有些情况下，我们希望储存的数据是有序的。</li>
</ol>
</blockquote>
<h2 id="六-查找与排序"><a href="#六-查找与排序" class="headerlink" title="六 查找与排序"></a>六 查找与排序</h2><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/849589-20180402133438219-1946132192.png" alt="img" style="zoom: 50%;">



<h3 id="1-各种排序算法及时间复杂度"><a href="#1-各种排序算法及时间复杂度" class="headerlink" title="1 各种排序算法及时间复杂度"></a>1 各种排序算法及时间复杂度</h3><blockquote>
<ol>
<li><p><strong>插入排序</strong>：对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素，插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前元素的下一位中。</p>
</li>
<li><p><strong>希尔排序</strong>：先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关，其最后一个值必须为1.</p>
</li>
<li><p><strong>归并排序</strong>：该算法采用分治法；对于包含m个元素的待排序序列，将其看成m个长度为1的子序列。然后两两合归并，得到n/2个长度为2或者1的有序子序列；然后再两两归并，直到得到1个长度为m的有序序列。</p>
</li>
<li><p><strong>冒泡排序</strong>：对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前前n-i个元素中的最大的元素移到n-i位置。遍历n次，完成排序。</p>
</li>
<li><p><strong>快速排序</strong>：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
</li>
<li><p><strong>选择排序</strong>：每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空。</p>
</li>
<li><p><strong>堆排序</strong>：堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆（升序）/最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素交换位置，此时末尾元素就是最大/最小的值。然后将剩余n-1个元素重新构造成最大堆/最小堆。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>稳定的排序算法：基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序</p>
<p>不稳定的排序算法：快些选堆（快速，希尔排序，直接选择排序（可以改造成稳定的），堆排序）。</p>
</blockquote>
<h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2 快速排序"></a>2 快速排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">     quicksort(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">return</span> nums;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">int</span> num = nums[low];</span><br><span class="line">     <span class="keyword">int</span> left = low+<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> right = high;</span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">         <span class="keyword">while</span>(left&lt;=right &amp;&amp; nums[left]&lt;=num) left++;</span><br><span class="line">         <span class="keyword">while</span>(left&lt;=right &amp;&amp; nums[right]&gt;=num) right--;</span><br><span class="line">         <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         swap(nums[left],nums[right]);</span><br><span class="line">     &#125;</span><br><span class="line">     nums[low] = nums[right];</span><br><span class="line">     nums[right] = num;</span><br><span class="line">     quicksort(nums,low,right<span class="number">-1</span>);</span><br><span class="line">     quicksort(nums,right+<span class="number">1</span>,high);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3    堆排序"></a>3    堆排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Max_Heapify</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> i,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>*i;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> large = i;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= size &amp;&amp; A[l] &gt; A[i])</span><br><span class="line">        large = l;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        large = i;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= size &amp;&amp; A[r] &gt; A[large])</span><br><span class="line">        large = r;</span><br><span class="line">    <span class="keyword">if</span>(large != i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = A[large];</span><br><span class="line">        A[large] = A[i];</span><br><span class="line">        A[i] = t;</span><br><span class="line">        Max_Heapify(A, large, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build_Max_Heap</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=size/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        Max_Heapify(A,i,size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    Build_Max_Heap(A, len);</span><br><span class="line">    <span class="keyword">while</span>(len<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = A[<span class="number">1</span>];</span><br><span class="line">        A[<span class="number">1</span>] = A[i];</span><br><span class="line">        A[i] = t;</span><br><span class="line">        len--;</span><br><span class="line">        Max_Heapify(A,<span class="number">1</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="七-高级算法"><a href="#七-高级算法" class="headerlink" title="七 高级算法"></a>七 高级算法</h2><h3 id="1-KMP算法"><a href="#1-KMP算法" class="headerlink" title="1. KMP算法"></a>1. KMP算法</h3><blockquote>
<p>核心：部分匹配表（PMT）<strong>PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度</strong></p>
<p>PMT的意义：例如，对于”aba”，它的前缀集合为{”a”, ”ab”}，后缀 集合为{”ba”, ”a”}。两个集合的交集为{”a”}，那么长度最长的元素就是字符串”a”了，长 度为1，所以对于”aba”而言，它在PMT表中对应的值就是1。再比如，对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。</p>
<p>主要思路：简言之，以图中的例子来说，在 i 处失配，那么主字符串和模式字符串的前边6位就是相同的。又因为模式字符串的前6位，它的前4位前缀和后4位后缀是相同的，所以我们推知主字符串i之前的4位和模式字符串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p>
<img src="https://pic2.zhimg.com/80/v2-03a0d005badd0b8e7116d8d07947681c_720w.jpg?source=1940ef5c" alt="img" style="zoom:80%;">

<p>有了上面的思路，我们就可以使用PMT加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值，所以为了编程的方便， 我们不直接使用PMT数组，而是将PMT数组向后偏移一位。我们把新得到的这个数组称为next数组。下面给出根据next数组进行字符串匹配加速的字符串匹配程序。其中要注意的一个技巧是，在把PMT进行向右偏移时，第0位的值，我们将其设成了-1，这只是为了编程的方便，并没有其他的意义。在本节的例子中，next数组如下表所示。</p>
<img src="https://pic3.zhimg.com/80/v2-40b4885aace7b31499da9b90b7c46ed3_720w.jpg?source=1940ef5c" alt="img" style="zoom:67%;">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> * t, <span class="keyword">char</span> * p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(t) &amp;&amp; j &lt; <span class="built_in">strlen</span>(p))&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || t[i] == p[j]) &#123;</span><br><span class="line">			i++;</span><br><span class="line">     	j++;</span><br><span class="line">		&#125;</span><br><span class="line">	 	<span class="keyword">else</span> &#123;</span><br><span class="line">      j = next[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="built_in">strlen</span>(p))</span><br><span class="line"> <span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们再看一下如何编程快速求得next数组。其实，求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。</p>
<p>具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。如下图所示。</p>
<p>求next数组的程序如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> * p, <span class="keyword">int</span> * next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(p))&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || p[i] == p[j])&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">			next[i] = j;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j = next[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="拓展题目"><a href="#拓展题目" class="headerlink" title="拓展题目"></a>拓展题目</h4><h5 id="1392-最长快乐前缀"><a href="#1392-最长快乐前缀" class="headerlink" title="1392. 最长快乐前缀"></a><a href="https://leetcode-cn.com/problems/longest-happy-prefix/" target="_blank" rel="noopener">1392. 最长快乐前缀</a></h5><p>「快乐前缀」是在原字符串中既是 <strong>非空</strong> 前缀也是后缀（不包括原字符串自身）的字符串。给你一个字符串 <code>s</code>，请你返回它的 <strong>最长快乐前缀</strong>。如果不存在满足题意的前缀，则返回一个空字符串。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;level&quot;</span><br><span class="line">输出：&quot;l&quot;</span><br><span class="line">解释：不包括 s 自己，一共有 4 个前缀（&quot;l&quot;, &quot;le&quot;, &quot;lev&quot;, &quot;leve&quot;）和 4 个后缀（&quot;l&quot;, &quot;el&quot;, &quot;vel&quot;, &quot;evel&quot;）。最长的既是前缀也是后缀的字符串是 &quot;l&quot; 。</span><br></pre></td></tr></table></figure>

<p>使用KMP算法进行求解</p>
<p>思想：「最长快乐前缀」就是最长的既是前缀也是后缀的字符串，因此我们使用 KMP 算法计算出数组 \textit{fail}<em>fail<em>，那么 s</em>s</em> 的长度为 \textit{fail}[s.\textit{length} - 1] + 1<em>fail</em>[<em>s</em>.<em>length</em>−1]+1 的前缀（或者后缀）即为答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPrefix</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">          <span class="keyword">int</span> j = next[i<span class="number">-1</span>];</span><br><span class="line">          <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;s[j+<span class="number">1</span>]!=s[i])&#123;</span><br><span class="line">              j = next[j];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(s[j+<span class="number">1</span>]==s[i])&#123;</span><br><span class="line">              next[i] = j+<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> s.substr(<span class="number">0</span>,next[n<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-Manacher算法-马拉车算法"><a href="#2-Manacher算法-马拉车算法" class="headerlink" title="2. Manacher算法(马拉车算法)"></a>2. Manacher算法(马拉车算法)</h3><blockquote>
<p><strong>Manacher算法是一个用来查找一个字符串中的最长回文子串(不是最长回文序列)的线性算法。它的优点就是把时间复杂度为O(n2)的暴力算法优化到了O(n)。</strong></p>
<p><strong>基本概念</strong></p>
<ol>
<li>ManacherString：经过Manacher预处理的字符串，以下的概念都是基于ManasherString产生的。</li>
<li>回文半径和回文直径：因为处理后回文字符串的长度一定是奇数，所以回文半径是包括回文中心在内的回文子串的一半的长度，回文直径则是回文半径的2倍减1。比如对于字符串 “aba”，在字符 ‘b’ 处的回文半径就是2，回文直径就是3。</li>
<li>最右回文边界R：在遍历字符串时，每个字符遍历出的最长回文子串都会有个右边界，而R则是所有已知右边界中最靠右的位置，也就是说R的值是只增不减的。</li>
<li>回文中心C：取得当前R的第一次更新时的回文中心。由此可见R和C时伴生的。</li>
<li>半径数组：这个数组记录了原字符串中每一个字符对应的最长回文半径。</li>
</ol>
<p><strong>基本步骤</strong>：</p>
<ol>
<li>字符串预处理。把偶数回文串都变成奇数回文串</li>
<li>R和C的初始值为-1，创建半径数组pArr</li>
<li>开始从下标 i = 0去遍历字符串S<ol>
<li>i &gt; R ，也就是i在R外，此时没有什么花里胡哨的方法，直接暴力匹配，此时记得看看C和R要不要更新。</li>
<li>i &lt;= R，也就是i在R内，此时分三种情况，在讨论这三个情况前，我们先构建一个模型。L是当前R关于C的对称点，i’是i关于C的对称点，可知 i’ = 2*C - i，并且我们会发现，i’的回文区域是我们已经求过的，从这里我们就可以开始判断是不是可以进行加速处理了<ol>
<li>i’的回文区域在L-R的内部，此时i的回文直径与 i’ 相同，我们可以直接得到i的回文半径；</li>
<li>i’的回文区域左边界超过了L，此时i的回文半径则是i到R；</li>
<li>i’ 的回文区域左边界恰好和L重合，此时i的回文半径最少是i到R，回文区域从R继续向外部匹配。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>我们可以计算出时间复杂度为何是线性的，分支一的情况下时间时间复杂度是O(n)，分支二的前两种情况都是O(1)，分支二的第三种情况，我们可能会出现O(1)——无法从R继续向后匹配，也可能出现O(n)——可以从R继续匹配，即使可以继续匹配，R的值也会增大，这样会影响到后续的遍历匹配复杂度，所以综合起来整个算法的时间复杂度就是线性的，也就是O(n)。</p>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">     <span class="built_in">string</span> t = <span class="string">"$#"</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> &amp;c: s) &#123;</span><br><span class="line">         t += c;</span><br><span class="line">         t += <span class="string">'#'</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     n = t.<span class="built_in">size</span>();</span><br><span class="line">     t += <span class="string">'!'</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">auto</span> f = <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; (n);</span><br><span class="line">     <span class="keyword">int</span> iMax = <span class="number">0</span>, rMax = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">         <span class="comment">// 初始化 f[i]</span></span><br><span class="line">         f[i] = (i &lt;= rMax) ? <span class="built_in">min</span>(rMax - i + <span class="number">1</span>, f[<span class="number">2</span> * iMax - i]) : <span class="number">1</span>;</span><br><span class="line">         <span class="comment">// 中心拓展</span></span><br><span class="line">         <span class="keyword">while</span> (t[i + f[i]] == t[i - f[i]]) ++f[i];</span><br><span class="line">         <span class="comment">// 动态维护 iMax 和 rMax</span></span><br><span class="line">         <span class="keyword">if</span> (i + f[i] - <span class="number">1</span> &gt; rMax) &#123;</span><br><span class="line">             iMax = i;</span><br><span class="line">             rMax = i + f[i] - <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整</span></span><br><span class="line">         ans += (f[i] / <span class="number">2</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-洗牌算法"><a href="#3-洗牌算法" class="headerlink" title="3. 洗牌算法"></a>3. 洗牌算法</h3><blockquote>
<h4 id="1、Fisher-Yates-Shuffle算法"><a href="#1、Fisher-Yates-Shuffle算法" class="headerlink" title="1、Fisher-Yates Shuffle算法"></a>1、Fisher-Yates Shuffle算法</h4><p>最早提出这个洗牌方法的是 Ronald A. Fisher 和 Frank Yates，即 Fisher–Yates Shuffle。</p>
<p>基本思想就是<strong>从原始数组中随机取一个之前没取过的数字到新的数组中</strong>，具体如下：</p>
<ol>
<li>初始化原始数组和新数组，原始数组长度为n(已知)。</li>
<li>还没处理的数组（假如还剩k个）中，随机产生一个[0, k)之间的数字p（假设数组从0开始）。</li>
<li>剩下的k个数中把第p个数取出。</li>
<li>重复步骤2和3直到数字全部取完。</li>
<li>从步骤3取出的数字序列便是一个打乱了的数列。</li>
</ol>
<p>时间复杂度为O(n*n)，空间复杂度为O(n)。</p>
<h4 id="2、Knuth-Durstenfeld-Shuffle"><a href="#2、Knuth-Durstenfeld-Shuffle" class="headerlink" title="2、Knuth-Durstenfeld Shuffle"></a>2、Knuth-Durstenfeld Shuffle</h4><p>Knuth 和 Durstenfeld  在Fisher 等人的基础上对算法进行了改进，在原始数组上对数字进行交互，省去了额外O(n)的空间。该算法的基本思想和 Fisher 类似，每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。</p>
<p>算法步骤为：</p>
<ol>
<li>建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值；</li>
<li>生成一个从 0 到 n - 1 的随机数 x；</li>
<li>输出 arr 下标为 x 的数值，即为第一个随机数；</li>
<li>将 arr 的尾元素和下标为 x 的元素互换；</li>
<li>同2，生成一个从 0 到 n - 2 的随机数 x；</li>
<li>输出 arr 下标为 x 的数值，为第二个随机数；</li>
<li>将 arr 的倒数第二个元素和下标为 x 的元素互换；</li>
</ol>
<p>……</p>
<p>如上，直到输出m 个数为止</p>
<p>时间复杂度为O(n)，空间复杂度为O(1)，缺点必须知道数组长度n。</p>
</blockquote>
<h1 id="三-操作系统"><a href="#三-操作系统" class="headerlink" title="三 操作系统"></a>三 操作系统</h1><h2 id="一-系统概念"><a href="#一-系统概念" class="headerlink" title="一 系统概念"></a>一 系统概念</h2><h3 id="1-并发和并行"><a href="#1-并发和并行" class="headerlink" title="1. 并发和并行"></a>1. 并发和并行</h3><blockquote>
<p>并发（concurrency）：指宏观上看起来两个程序在同时运行。</p>
<p>比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p>
<p>并行（parallelism）：指严格物理意义上的同时运行。</p>
<p>比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p>
<ul>
<li>并发不加以控制会带来数据的不一致性问题，而对并发加以控制了，也就是加锁了，但是锁的控制没有弄好，才会带来死锁问题</li>
</ul>
</blockquote>
<h3 id="2-用户态和内核态的区别"><a href="#2-用户态和内核态的区别" class="headerlink" title="2. 用户态和内核态的区别"></a>2. 用户态和内核态的区别</h3><blockquote>
<p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。</p>
<p>用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。</p>
<p>内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</p>
</blockquote>
<h3 id="3-为什么要分内核态和用户态"><a href="#3-为什么要分内核态和用户态" class="headerlink" title="3. 为什么要分内核态和用户态"></a>3. 为什么要分内核态和用户态</h3><blockquote>
<p>为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。</p>
<p>分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。</p>
</blockquote>
<h3 id="4-用户态到内核态的方式"><a href="#4-用户态到内核态的方式" class="headerlink" title="4. 用户态到内核态的方式"></a>4. 用户态到内核态的方式</h3><blockquote>
<p>1、<strong>系统调用</strong></p>
<p>这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。</p>
<p>2、<strong>异常</strong></p>
<p>当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此异常的内核相关程序中，也就到了内核态，比如缺页异常。</p>
<p>3、<strong>外围设备的中断</strong></p>
<p>当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</blockquote>
<p>2）切换操作</p>
<blockquote>
<p>从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的。</p>
</blockquote>
<p>用户态切换到内核态的步骤主要包括：</p>
<blockquote>
<p>1、从当前进程的描述符中提取其内核栈的ss0及esp0信息。</p>
<p>2、使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</p>
<p>3、将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</p>
</blockquote>
<h3 id="5-微内核与宏内核"><a href="#5-微内核与宏内核" class="headerlink" title="5. 微内核与宏内核"></a>5. 微内核与宏内核</h3><p>宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。</p>
<blockquote>
<p>优点：效率高。</p>
<p>缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。</p>
</blockquote>
<p>微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。</p>
<blockquote>
<p>优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃</p>
<p>缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。</p>
</blockquote>
<h3 id="6-中断和异常"><a href="#6-中断和异常" class="headerlink" title="6. 中断和异常"></a>6. 中断和异常</h3><h4 id="操作系统中的中断"><a href="#操作系统中的中断" class="headerlink" title="操作系统中的中断"></a>操作系统中的中断</h4><blockquote>
<p>中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。中断一般三类，一种是由CPU外部引起的，如I/O中断、时钟中断，一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出），最后一种是在程序中使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。</p>
</blockquote>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><blockquote>
<p>中断指 <strong>CPU</strong> 对系统发生某事件时的这样一种响应<strong>:</strong> </p>
<p>CPU 暂停正在执行的程序，在保留现场后自动地转去执行该事件的中断处理程序；执行完后，再返回到原程序的断点处继续执行。</p>
</blockquote>
<h4 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h4><blockquote>
<ul>
<li>外中断——就是我们指的<strong>中断</strong>——是指由于外部设备事件所引起的中断，如通常的磁盘中断、打印机中断等；</li>
<li>内中断——就是<strong>异常</strong>——是指由于 CPU 内部事件所引起的中断，如程序出错(非法指令、地址越界)。内中断(trap)也被译为“<strong>捕获</strong>”或“<strong>陷入</strong>”。</li>
</ul>
</blockquote>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><blockquote>
<p>异常是由于执行了现行指令所引起的。由于系统调用引起的中断属于异常。</p>
</blockquote>
<h4 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h4><blockquote>
<ul>
<li><p>相同点：都是CPU对系统发生的某个事情做出的一种反应。</p>
</li>
<li><p>区别：中断由外因引起，异常由CPU本身原因引起。</p>
</li>
</ul>
</blockquote>
<h4 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h4><blockquote>
<p><strong>中断的引入</strong>——为了支持CPU和设备之间的并行操作</p>
<p><strong>异常的引入</strong>——表示CPU执行指令时本身出现的问题</p>
</blockquote>
<h4 id="引发中断或异常的事件"><a href="#引发中断或异常的事件" class="headerlink" title="引发中断或异常的事件"></a>引发中断或异常的事件</h4><blockquote>
<ul>
<li><strong>中断</strong>——<strong>外部事件引起</strong>，<strong>正在运行的程序所不期望的</strong></li>
<li><strong>异常</strong>——<strong>内部执行指令引起</strong></li>
</ul>
</blockquote>
<img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/20190328033536613.png" alt="img" style="zoom: 80%;">

<img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/20190328033643556.png" alt="img" style="zoom:80%;">



<h2 id="二-进程与线程"><a href="#二-进程与线程" class="headerlink" title="二 进程与线程"></a>二 进程与线程</h2><h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1 进程与线程"></a>1 进程与线程</h3><blockquote>
<p><strong>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位</strong>，实现了操作系统的并发；</p>
<p><strong>线程是进程的子任务，是CPU调度和分派的基本单位</strong>，用于保证程序的实时性，实现进程内部的并发；每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p>
</blockquote>
<h4 id="1-进程与线程的区别"><a href="#1-进程与线程的区别" class="headerlink" title="1 进程与线程的区别"></a>1 进程与线程的区别</h4><blockquote>
<ol>
<li><p><strong>一个线程只能属于一个进程，而一个进程可以有多个线程</strong>，但至少有一个线程。线程依赖于进程而存在。</p>
</li>
<li><p><strong>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</strong>（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</p>
</li>
<li><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位；</strong></p>
</li>
<li><p><strong>系统开销</strong>： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。</p>
<p>类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，<strong>进程切换的开销也远大于线程切换的开销。</strong></p>
</li>
<li><p><strong>通信：</strong>由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信—需要进程同步和互斥手段的辅助，以保证数据的一致性。</p>
</li>
<li><p><strong>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</strong></p>
</li>
</ol>
</blockquote>
<h4 id="2-线程产生的原因"><a href="#2-线程产生的原因" class="headerlink" title="2 线程产生的原因"></a>2 线程产生的原因</h4><blockquote>
<p>进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量；但有一些缺点：</p>
<ol>
<li><p>进程在同一时间只能干一件事</p>
</li>
<li><p>进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。</p>
</li>
</ol>
<p>因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。</p>
<p>和进程相比，线程的优势如下：</p>
<ul>
<li><p>从<strong>资源</strong>上来讲，线程是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。</p>
</li>
<li><p>从<strong>切换效率</strong>上来讲，运行于进程中的多个线程将使用相同的地址空间，线程间切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。</p>
</li>
<li><p>从<strong>通信机制</strong>上来讲，线程间方便的通信机制。不同进程具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。</p>
</li>
</ul>
<p>除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：</p>
<p>1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</p>
<p>2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。</p>
</blockquote>
<h4 id="3-多进程和多线程的使用场景"><a href="#3-多进程和多线程的使用场景" class="headerlink" title="3 多进程和多线程的使用场景"></a>3 多进程和多线程的使用场景</h4><blockquote>
<ol>
<li>多线程模型主要优势为线程间切换代价较小，因此适用于I/O密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多核分布式场景。</li>
<li>多进程模型的优势是CPU，适用于CPU密集型。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。</li>
</ol>
</blockquote>
<h3 id="2-进程的通信方式"><a href="#2-进程的通信方式" class="headerlink" title="2 进程的通信方式"></a>2 进程的通信方式</h3><p><strong>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket</strong>。</p>
<blockquote>
<ol>
<li><p>管道：速度慢，容量有限，只有父子进程能通讯   </p>
</li>
<li><p>命名管道：任何进程间都能通讯，但速度慢   </p>
</li>
<li><p>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题   </p>
</li>
<li><p>信号量：不能传递复杂消息，只能用来同步   </p>
</li>
<li><p>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存</p>
</li>
</ol>
</blockquote>
<p><strong>linux下的多个进程间的通信机制叫做IPC(Inter-Process Communication)，它是多个进程之间相互沟通的一种方法</strong></p>
<blockquote>
<ol>
<li>管道(pipe)：管道用于具有亲缘关系的进程间的通信，是一种半双工的方式，数据只能单向流动，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li>
<li>命名管道(named pipe)：命名管道克服了管道没有名字的限制，同时除了具有管道的功能外（也是半双工），它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li>
<li>信号（signal）：信号是比较复杂的通信方式，用于通知接收进程有某种事件发生，除了进程间通信外，进程还可以发送信号给进程本身。</li>
<li>消息队列：消息队列是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</li>
<li>共享内存：使多个进程可访问同一块内存空间，是最快的可用IPC形式。往往与信号量等通信机制结合使用，来实现进程间的同步及互斥。</li>
<li>内存映射：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>
<li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li>
<li>套接字（Socket）：可用于不同机器之间的进程间通信。</li>
</ol>
</blockquote>
<h4 id="1-管道"><a href="#1-管道" class="headerlink" title="1 管道"></a>1 管道</h4><blockquote>
<p><strong>本质</strong></p>
<blockquote>
<p>管道是由内核管理的一个缓冲区，是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。</p>
</blockquote>
<p><strong>特点</strong></p>
<blockquote>
<p>1、管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；<br>2、只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。比如fork或exec创建的新进程，在使用exec创建新进程时，需要将管道的文件描述符作为参数传递给exec创建的新进程。当父进程与使用fork创建的子进程直接通信时，发送数据的进程关闭读端，接受数据的进程关闭写端。<br>3、单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。<br>4、数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p>
</blockquote>
<p><strong>分类</strong></p>
<blockquote>
<p>管道主要包括无名管道和命名管道；</p>
<p>管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p>
<p>1 普通管道PIPE</p>
<ul>
<li><p>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p>
</li>
<li><p>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p>
</li>
<li><p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
</li>
</ul>
<p>2 命名管道FIFO</p>
<p>命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了管道的弊端，他可以允许没有亲缘关系的进程间通信。 </p>
<ul>
<li>FIFO可以在无关的进程之间交换数据</li>
<li>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2 消息队列"></a>2 消息队列</h4><blockquote>
<p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。</p>
<p>消息队列是内核地址空间中的内部链表，通过linux内核在各个进程直接传递内容，消息顺序地发送到消息队列中，并以几种不同的方式从队列中获得，每个消息队列可以用IPC标识符唯一地进行识别。内核中的消息队列是通过IPC的标识符来区别，不同的消息队列直接是相互独立的。每个消息队列中的消息，又构成一个独立的链表。</p>
<p>(消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p>
</blockquote>
<p><strong>特点</strong></p>
<blockquote>
<ul>
<li><p>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
</li>
<li><p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
</li>
<li><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
</li>
</ul>
</blockquote>
<h4 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3 信号量"></a>3 信号量</h4><blockquote>
<p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。</p>
<p>信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
</blockquote>
<p>特点</p>
<blockquote>
<ul>
<li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</li>
<li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</li>
<li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li>
<li>支持信号量组。</li>
</ul>
</blockquote>
<h4 id="4-信号"><a href="#4-信号" class="headerlink" title="4 信号"></a>4 信号</h4><blockquote>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
</blockquote>
<h4 id="5-共享内存"><a href="#5-共享内存" class="headerlink" title="5 共享内存"></a>5 共享内存</h4><blockquote>
<p>共享内存使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。</p>
<p>这种方式需要依靠某种同步操作，如互斥锁和信号量等</p>
</blockquote>
<p>特点</p>
<blockquote>
<ul>
<li>共享内存是最快的一种IPC，因为进程是直接对内存进行存取</li>
<li>因为多个进程可以同时操作，所以需要进行同步</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</li>
</ul>
</blockquote>
<h4 id="6-套接字SOCKET"><a href="#6-套接字SOCKET" class="headerlink" title="6 套接字SOCKET"></a>6 套接字SOCKET</h4><blockquote>
<p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p>
</blockquote>
<h3 id="3-线程的通信方式和同步方式"><a href="#3-线程的通信方式和同步方式" class="headerlink" title="3 线程的通信方式和同步方式"></a>3 线程的通信方式和同步方式</h3><h4 id="线程之间的通信方式"><a href="#线程之间的通信方式" class="headerlink" title="线程之间的通信方式"></a>线程之间的通信方式</h4><blockquote>
<ol>
<li><p>全局变量</p>
<p>主要由于多个线程可能更改全局变量，因此全局变量最好声明为volatile</p>
</li>
<li><p>使用消息实现通信<br> 在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。</p>
</li>
<li><p>使用事件CEvent类实现线程间通信<br>Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。</p>
</li>
</ol>
</blockquote>
<h4 id="线程间的同步方式"><a href="#线程间的同步方式" class="headerlink" title="线程间的同步方式"></a>线程间的同步方式</h4><blockquote>
<ol>
<li>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</li>
<li>互斥量<code>Synchronized/Lock</code>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</li>
<li>信号量<code>Semphare</code>：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</li>
<li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li>
</ol>
</blockquote>
<h5 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1 临界区"></a>1 临界区</h5><blockquote>
<p>通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p>
<p>临界区对应着一个CcriticalSection对象，当线程需要访问保护数据时，调用EnterCriticalSection函数；当对保护数据的操作完成之后，调用LeaveCriticalSection函数释放对临界区对象的拥有权，以使另一个线程可以夺取临界区对象并访问受保护的数据。</p>
</blockquote>
<h5 id="2-互斥量"><a href="#2-互斥量" class="headerlink" title="2 互斥量"></a>2 互斥量</h5><blockquote>
<p>互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：</p>
<ul>
<li>pthread_mutex_init:初始化互斥锁</li>
<li>pthread_mutex_destroy：销毁互斥锁</li>
<li>pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。</li>
<li>pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。</li>
</ul>
</blockquote>
<h5 id="3-信号量-1"><a href="#3-信号量-1" class="headerlink" title="3 信号量"></a>3 信号量</h5><blockquote>
<p>信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：</p>
<p>P(SV)：如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。wait()</p>
<p>V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。notify()</p>
<p>其系统调用为：</p>
<ul>
<li>sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</li>
<li>sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</li>
</ul>
<p>× 信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程访问同一个资源，PV操作</p>
</blockquote>
<h5 id="4-条件变量"><a href="#4-条件变量" class="headerlink" title="4 条件变量"></a>4 条件变量</h5><blockquote>
<p>条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：</p>
<ul>
<li>pthread_cond_init:初始化条件变量</li>
<li>pthread_cond_destroy：销毁条件变量</li>
<li>pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。</li>
<li>pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。</li>
</ul>
</blockquote>
<h4 id="5-事件-信号-，Wait-Notify："><a href="#5-事件-信号-，Wait-Notify：" class="headerlink" title="5 事件(信号)，Wait/Notify："></a>5 事件(信号)，Wait/Notify：</h4><blockquote>
<p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>
</blockquote>
<h3 id="4-线程之间共享-独享的资源？"><a href="#4-线程之间共享-独享的资源？" class="headerlink" title="4 线程之间共享/独享的资源？"></a>4 线程之间共享/独享的资源？</h3><p>共享的资源</p>
<blockquote>
<ol>
<li><p>堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）</p>
</li>
<li><p>全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的</p>
</li>
<li><p>静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的</p>
</li>
<li><p>文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。</p>
</li>
</ol>
</blockquote>
<p>独享的资源有</p>
<blockquote>
<p>a. 栈 栈是独享的</p>
<p>b. 寄存器  这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC</p>
</blockquote>
<p><strong>线程共享的环境包括：</strong></p>
<blockquote>
<p>进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p>
</blockquote>
<h3 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5 线程池"></a>5 线程池</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。</p>
</blockquote>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><blockquote>
<p>在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。</p>
<p>一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</p>
</blockquote>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><blockquote>
<p>多线程运行时间，系统不断的启动和关闭新线程，成本非常高，会过渡消耗系统资源，以及过渡切换线程的危险，从而可能导致系统资源的崩溃。这时，线程池就是最好的选择了。</p>
</blockquote>
<h4 id="死循环-来连接时新建线程的方法效率有点低，怎么改进？"><a href="#死循环-来连接时新建线程的方法效率有点低，怎么改进？" class="headerlink" title="死循环+来连接时新建线程的方法效率有点低，怎么改进？"></a>死循环+来连接时新建线程的方法效率有点低，怎么改进？</h4><blockquote>
<p>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll 这样的技术。</p>
</blockquote>
<h3 id="6-进程和线程的状态"><a href="#6-进程和线程的状态" class="headerlink" title="6 进程和线程的状态"></a>6 进程和线程的状态</h3><h4 id="进程的五种基本状态"><a href="#进程的五种基本状态" class="headerlink" title="进程的五种基本状态"></a>进程的五种基本状态</h4><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470678794_F9BF116BD97A95A5E655DF9E1672186F" alt="img"></p>
<blockquote>
<p>1）创建状态：进程正在被创建</p>
<p>2）就绪状态：进程被加入到就绪队列中等待CPU调度运行</p>
<p>3）执行状态：进程正在被运行</p>
<p>4）等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。</p>
<p>5）终止状态：进程运行完毕</p>
</blockquote>
<h4 id="线程的五种状态"><a href="#线程的五种状态" class="headerlink" title="线程的五种状态"></a>线程的五种状态</h4><p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/20161017181631639" alt="img"></p>
<blockquote>
<ol>
<li><p>新建状态：当用new操作符创建一个线程时。此时程序还没有开始运行线程中的代码。</p>
</li>
<li><p>就绪状态：一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。</p>
<p>处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序来调度的。</p>
</li>
<li><p>运行状态（running）当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法。</p>
</li>
<li><p>阻塞状态（blocked）</p>
<p>线程运行过程中，可能由于各种原因进入阻塞状态：</p>
<p>① 线程通过调用sleep方法进入睡眠状态；</p>
<p>② 线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；</p>
<p>③ 线程试图得到一个锁，而该锁正被其他线程持有；</p>
<p>④ 线程在等待某个触发条件；</p>
<p>所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。</p>
</li>
<li><p>死亡状态（dead）</p>
<p>有两个原因会导致线程死亡：</p>
<p>① run方法正常退出而自然死亡；</p>
<p>② 一个未捕获的异常终止了run方法而使线程猝死；</p>
<p>为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法，如果是可运行或被阻塞，这个方法返回true；如果线程仍旧是new状态且不是可运行的，或者线程死亡了，则返回false。</p>
</li>
</ol>
</blockquote>
<h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><blockquote>
<p>当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O。</p>
<p>针对以上问题，提出了两种解决方法：</p>
<p>1）交换技术：换出一部分进程到外存，腾出内存空间。</p>
<p>2）虚拟存储技术：每个进程只能装入一部分程序和数据。</p>
<p>在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。</p>
<p>从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。</p>
</blockquote>
<p>3、活动阻塞，静止阻塞，活动就绪，静止就绪</p>
<blockquote>
<p>1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。</p>
<p>2）静止阻塞：进程在外存，同时被某种原因阻塞了。</p>
<p>3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。</p>
<p>4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。</p>
</blockquote>
<p>从而出现了：</p>
<blockquote>
<p>活动就绪 ——  静止就绪    （内存不够，调到外存）</p>
<p>活动阻塞 ——  静止阻塞    （内存不够，调到外存）</p>
<p>执行   ——  静止就绪     （时间片用完）</p>
</blockquote>
<h3 id="7-多线程同步、锁的机制"><a href="#7-多线程同步、锁的机制" class="headerlink" title="7 多线程同步、锁的机制"></a>7 多线程同步、锁的机制</h3><blockquote>
<p>同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。</p>
<p>对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。</p>
<p>如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。</p>
<p>在这种方式下，每次只有一个线程可以向前执行</p>
</blockquote>
<h3 id="8-常用的线程模型"><a href="#8-常用的线程模型" class="headerlink" title="8 常用的线程模型"></a>8 常用的线程模型</h3><h4 id="1-Future模型"><a href="#1-Future模型" class="headerlink" title="1 Future模型"></a>1 Future模型</h4><blockquote>
<p>该模型通常在使用的时候需要结合Callable接口配合使用。</p>
<p>Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。</p>
<p>Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。</p>
</blockquote>
<h4 id="2-fork-amp-join模型"><a href="#2-fork-amp-join模型" class="headerlink" title="2 fork&amp;join模型"></a>2 fork&amp;join模型</h4><blockquote>
<p>该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。</p>
<p>这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。</p>
</blockquote>
<h4 id="3-actor模型"><a href="#3-actor模型" class="headerlink" title="3 actor模型"></a>3 actor模型</h4><blockquote>
<p>actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。</p>
</blockquote>
<h4 id="4-生产者消费者模型"><a href="#4-生产者消费者模型" class="headerlink" title="4 生产者消费者模型"></a>4 生产者消费者模型</h4><blockquote>
<p>生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。</p>
</blockquote>
<h4 id="5-master-worker模型"><a href="#5-master-worker模型" class="headerlink" title="5 master-worker模型"></a>5 master-worker模型</h4><blockquote>
<p>master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。</p>
</blockquote>
<h3 id="9-协程"><a href="#9-协程" class="headerlink" title="9 协程"></a>9 协程</h3><blockquote>
<p><strong>概念</strong></p>
<p>协程，又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执<strong>行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</strong></p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span> :</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">'1'</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">'2'</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">'3'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span> :</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">'x'</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">'y'</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">'z'</span></span><br></pre></td></tr></table></figure>

<p>由协程运行结果可能是<code>12x3yz</code>。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。</p>
</blockquote>
<p><strong>协程和线程区别</strong></p>
<blockquote>
<p>那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p><strong>其他</strong></p>
<p>在协程上利用多核CPU呢——多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p>
</blockquote>
<h3 id="10-进程的种类"><a href="#10-进程的种类" class="headerlink" title="10 进程的种类"></a>10 进程的种类</h3><h4 id="正常进程"><a href="#正常进程" class="headerlink" title="正常进程"></a>正常进程</h4><blockquote>
<p>正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p>
<p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：</p>
<p>1 进程号the process ID</p>
<p>2 退出状态the termination status of the process</p>
<p>3 运行时间the amount of CPU time taken by the process等</p>
</blockquote>
<h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><blockquote>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
</blockquote>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><blockquote>
<p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</p>
<p>僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。</p>
<p><strong>查看僵尸进程</strong></p>
<p>如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。</p>
<p>如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>
<p><strong>危害</strong></p>
<p>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p><strong>外部消灭</strong></p>
<p>通过<code>kill</code>发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源</p>
<p><strong>内部解决</strong></p>
<p>1、子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</p>
<p>2、fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。</p>
</blockquote>
<h3 id="11-线程需要保存哪些上下文，SP、PC、EAX-这些寄存器的作用。"><a href="#11-线程需要保存哪些上下文，SP、PC、EAX-这些寄存器的作用。" class="headerlink" title="11 线程需要保存哪些上下文，SP、PC、EAX 这些寄存器的作用。"></a>11 线程需要保存哪些上下文，SP、PC、EAX 这些寄存器的作用。</h3><blockquote>
<p>线程在切换的过程中需要保存<strong>当前线程Id、线程状态、堆栈、寄存器状态</strong>等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：</p>
<ul>
<li>SP:堆栈指针，指向当前栈的栈顶地址</li>
<li>PC:程序计数器，存储下一条将要执行的指令</li>
<li>EAX:累加寄存器，用于加法乘法的缺省寄存器</li>
</ul>
</blockquote>
<h3 id="12-fork和vfork的区别"><a href="#12-fork和vfork的区别" class="headerlink" title="12 fork和vfork的区别"></a>12 fork和vfork的区别</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><blockquote>
<p>fork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>成功调用<code>fork( )</code>会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
</blockquote>
<h4 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h4><blockquote>
<p>在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">vfork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用所产生的结果和fork( )是一样的。vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像。通过这样的方式，vfork( )避免了地址空间的按页复制。在这个过程中，父进程和子进程共享相同的地址空间和页表项。实际上vfork( )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。</p>
<p>vfork( )是一个历史遗留产物，Linux本不应该实现它。需要注意的是，即使增加了写时复制，vfork( )也要比fork( )快，因为它没有进行页表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork( )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可行的。</p>
</blockquote>
<h4 id="补充知识点：写时复制"><a href="#补充知识点：写时复制" class="headerlink" title="补充知识点：写时复制"></a>补充知识点：写时复制</h4><blockquote>
<p>Linux采用了写时复制的方法，以减少fork时对父进程空间进程整体复制带来的开销。</p>
<p>写时复制是一种采取了惰性优化方法来避免复制时的系统开销。它的前提很简单：如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。</p>
<p>写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。</p>
<p>在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork( )调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。</p>
<p>写时复制在内核中的实现非常简单。与内核页相关的数据结构可以被标记为只读和写时复制。如果有进程试图修改一个页，就会产生一个缺页中断。内核处理缺页中断的方式就是对该页进行一次透明复制。这时会清除页面的COW属性，表示着它不再被共享。</p>
<p>现代的计算机系统结构中都在内存管理单元（MMU）提供了硬件级别的写时复制支持，所以实现是很容易的。</p>
<p>在调用fork( )时，写时复制是有很大优势的。因为大量的fork之后都会跟着执行exec，那么复制整个父进程地址空间中的内容到子进程的地址空间完全是在浪费时间：如果子进程立刻执行一个新的二进制可执行文件的映像，它先前的地址空间就会被交换出去。写时复制可以对这种情况进行优化。</p>
</blockquote>
<h4 id="fork和vfork的区别"><a href="#fork和vfork的区别" class="headerlink" title="fork和vfork的区别"></a>fork和vfork的区别</h4><blockquote>
<ol>
<li><p>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</p>
</li>
<li><p>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</p>
</li>
<li><p>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</p>
</li>
<li><p>当需要改变共享数据段中变量的值，则拷贝父进程。</p>
</li>
</ol>
</blockquote>
<h3 id="13-进程切换与线程切换的区别"><a href="#13-进程切换与线程切换的区别" class="headerlink" title="13 进程切换与线程切换的区别"></a>13 进程切换与线程切换的区别</h3><blockquote>
<p><strong>进程切换涉及到虚拟地址空间的切换</strong>而线程切换则不会。</p>
<p>因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</p>
</blockquote>
<h2 id="三-互斥-同步"><a href="#三-互斥-同步" class="headerlink" title="三 互斥 同步"></a>三 互斥 同步</h2><h3 id="1-单核机器上写多线程程序是否需要加锁？"><a href="#1-单核机器上写多线程程序是否需要加锁？" class="headerlink" title="1 单核机器上写多线程程序是否需要加锁？"></a>1 单核机器上写多线程程序是否需要加锁？</h3><blockquote>
<p>在单核机器上写多线程程序，仍然需要线程锁。</p>
<p>因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</p>
</blockquote>
<h3 id="2-Linux的4种锁-C"><a href="#2-Linux的4种锁-C" class="headerlink" title="2 Linux的4种锁(C++)"></a>2 Linux的4种锁(C++)</h3><blockquote>
<ol>
<li><p>互斥锁：<code>mutex</code>，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p>
</li>
<li><p>读写锁：<code>rwlock</code>，分为读锁和写锁。</p>
<p>处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p>
</li>
<li><p>自旋锁：<code>spinlock</code>，在任何时刻同样只能有一个线程访问对象。</p>
<p>当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</p>
</li>
<li><p>RCU：即<code>read-copy-update</code>，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。</p>
</li>
</ol>
</blockquote>
<h3 id="3-互斥锁、读写锁的区别"><a href="#3-互斥锁、读写锁的区别" class="headerlink" title="3 互斥锁、读写锁的区别"></a>3 互斥锁、读写锁的区别</h3><blockquote>
<ol>
<li>读写锁区分读者和写者，而互斥锁不区分</li>
<li>互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</li>
</ol>
</blockquote>
<h3 id="4-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#4-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="4 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>4 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h3><blockquote>
<p>单核CPU，并且开了抢占可以造成这种情况。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;   <span class="comment">//实现对文件的互斥访问</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//实现对count变量的互斥访问</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(rw); <span class="comment">//写之前“加锁”</span></span><br><span class="line">        写文件</span><br><span class="line">        V(rw); <span class="comment">//写之后“解锁”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader ()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);     <span class="comment">//各读进程互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)  <span class="comment">//第一个读进程负责“加锁”</span></span><br><span class="line">        &#123;</span><br><span class="line">            P(rw);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;      <span class="comment">//访问文件的进程数+1</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        读文件</span><br><span class="line">        P(mutex);     <span class="comment">//各读进程互斥访问count</span></span><br><span class="line">        count--;      <span class="comment">//访问文件的进程数-1</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)  <span class="comment">//最后一个读进程负责“解锁”</span></span><br><span class="line">        &#123;</span><br><span class="line">            V(rw);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四-死锁"><a href="#四-死锁" class="headerlink" title="四 死锁"></a>四 死锁</h2><h3 id="1-死锁的条件及解决方法"><a href="#1-死锁的条件及解决方法" class="headerlink" title="1 死锁的条件及解决方法"></a>1 死锁的条件及解决方法</h3><blockquote>
<p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的相互等待的现象。</p>
</blockquote>
<h4 id="死锁发生的四个必要条件"><a href="#死锁发生的四个必要条件" class="headerlink" title="死锁发生的四个必要条件"></a>死锁发生的四个必要条件</h4><blockquote>
<ol>
<li>互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；</li>
<li>请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源</li>
<li>不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</li>
<li>循环等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链</li>
</ol>
</blockquote>
<h4 id="1-死锁预防"><a href="#1-死锁预防" class="headerlink" title="1 死锁预防"></a>1 死锁预防</h4><blockquote>
<ol>
<li>资源一次性分配，从而剥夺请求和保持条件</li>
<li>可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件</li>
<li>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件</li>
</ol>
</blockquote>
<h4 id="2-死锁避免（银行家算法）"><a href="#2-死锁避免（银行家算法）" class="headerlink" title="2 死锁避免（银行家算法）"></a><strong>2 死锁避免（银行家算法）</strong></h4><blockquote>
<p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入<a href="http://metc.gdut.edu.cn/os/oscai/chapter2/pages/ch29.htm#概念" target="_blank" rel="noopener">不安全状态</a>，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是<strong>银行家算法</strong>。</p>
</blockquote>
<h4 id="3-死锁检测"><a href="#3-死锁检测" class="headerlink" title="3 死锁检测"></a><strong>3 死锁检测</strong></h4><blockquote>
<p>首先为每个进程和每个资源指定一个唯一的号码；然后建立资源分配表和进程等待表，</p>
</blockquote>
<h4 id="4-死锁解除"><a href="#4-死锁解除" class="headerlink" title="4 死锁解除"></a><strong>4 死锁解除</strong></h4><blockquote>
<p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来.</p>
<p>常采用的方法有：</p>
<ol>
<li><p><strong>剥夺资源</strong>：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</p>
</li>
<li><p><strong>撤消进程</strong>：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p>
</li>
</ol>
</blockquote>
<h3 id="2-生产者-消费者问题"><a href="#2-生产者-消费者问题" class="headerlink" title="2 生产者-消费者问题"></a>2 生产者-消费者问题</h3><blockquote>
<p>两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者（将信息放入缓冲区），另一个是消费者（从缓冲区去除信息）。</p>
<p>问题在于当缓冲区已满，而此时生产者还想向其中放入一个新的数据项的情况。其解决方法是，让生产者睡眠，等消费者从缓冲区中去取一个数据项或者多个数据项时再唤醒它。同样的，当消费者试图从缓冲区中取数据而发现缓冲区为空时，消费者就睡眠，知道生产者向其中放入一些数据时再将其唤醒。</p>
<p>竞争条件</p>
<ol>
<li>跟踪数据项数需要一个变量 count（互斥访问）；</li>
</ol>
<p>有问题的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100;	<span class="comment">//缓冲区的槽数目</span></span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;	<span class="comment">//缓冲区的数据项数目</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        item = produce_item();</span><br><span class="line">        <span class="keyword">if</span>(count == N) sleep();</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count = count+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) wakeup(consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) sleep();</span><br><span class="line">        item = remove_item();</span><br><span class="line">        count = count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(count == N<span class="number">-1</span>) wakeup(producer);</span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在的问题：1. 未对count的访问进行限制，可能会导致wakeup信号丢失。</p>
<p>用信号量解决生产者-消费者问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10;</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">//控制对临界区的访问</span></span><br><span class="line">semaphore tmpty = N;	<span class="comment">//计数缓冲区的空槽数目</span></span><br><span class="line">semaphore full = <span class="number">0</span>;		<span class="comment">//计数缓冲区的满槽数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        item = produce_item();</span><br><span class="line">        P(&amp;empty);		<span class="comment">//将空槽数目减1</span></span><br><span class="line">        P(&amp;mutex);		<span class="comment">//进入临界区</span></span><br><span class="line">        insert_item(item);	<span class="comment">//将新数据项放到缓冲区中</span></span><br><span class="line">        V(&amp;mutex);		<span class="comment">//离开临界区</span></span><br><span class="line">        V(&amp;full);		<span class="comment">//将满槽的数目加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        P(&amp;full);		<span class="comment">//将满槽数目减1</span></span><br><span class="line">        V(&amp;mutex);		<span class="comment">//进入临界区</span></span><br><span class="line">        item = remove_item();	<span class="comment">//从缓冲区中去除数据项</span></span><br><span class="line">        V(&amp;mutex);		<span class="comment">//离开临界区</span></span><br><span class="line">        V(&amp;empty);		<span class="comment">//将空槽数目加1</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="3-银行家算法"><a href="#3-银行家算法" class="headerlink" title="3 银行家算法"></a>3 银行家算法</h3><blockquote>
<p>银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。</p>
<blockquote>
<p><strong>银行家算法中的数据结构</strong></p>
<p>​        为了实现银行家算法，在系统中必须设置这样四个数据结构，分别用来描述系统中可利用的资源、所有进程对资源的最大需求、系统中的资源分配，以及所有进程还需要多少资源的情况。</p>
<p>(1)    可利用资源向量 Available。这是一个含有 m 个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果 Available[j] = K，则表示系统中现Rj类资源K个。<br>(2)    最大需求矩阵Max。这是一个n x m的矩阵，它定义了系统中n个进程中的每个进程对m类资源的最大需求。如果Max[i,j] = K，则表示进程i需要Rj 类资源的最大数目为K。<br>(3)    分配矩阵 Allocation。这也是一个n x m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果 Allocation[i,jl = K，则表示进程i当前己分得Rj类资源的数目为K。<br>(4)    需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j] = K，则表示进程i还需要Rj类资源K个方能完成其任务。</p>
<p>上述三个矩阵间存在下述关系<br>　　　　　　　　　　　　　　$Need[i,j] = Max[i,j] - allocation[i, j]$<br>　　　　　　　　　　　　　　<br><strong>银行家算法</strong></p>
<p>设 Request；是进程Pi的请求向量，如果 Requesti[j] = K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检査:</p>
<p>(1)    如果 Requesti[j] ≤ Need[i,j]便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</p>
<p>(2)    如果 Requesti[j] ≤ Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。</p>
<p>(3)    系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值<br>$$<br>Available[j] = Available[j] - Requesti[j];\<br>　　　　Allocation[i,j] = Allocation[i,j] + Requesti[j];\<br>　　　　Need[i,j] = Need[i,j] - Requesti[j];<br>$$</p>
<p>(4)    系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。</p>
</blockquote>
</blockquote>
<h3 id="4-死锁避免和死锁预防的区别"><a href="#4-死锁避免和死锁预防的区别" class="headerlink" title="4 死锁避免和死锁预防的区别"></a>4 死锁避免和死锁预防的区别</h3><blockquote>
<p>死锁预防是设法至少破坏产生死锁的四个必要条件之一, 严格的防止死锁的出现.</p>
<p>死锁避免则不那么严格的限制产生死锁的必要条件, 因为即使死锁的必要条件存在,也不一定发生死锁.</p>
<p>死锁避免是在系统运行过程中注意避免死锁的发生.</p>
</blockquote>
<h2 id="五-内存管理-1"><a href="#五-内存管理-1" class="headerlink" title="五 内存管理"></a>五 内存管理</h2><img src="https://img-blog.csdn.net/20180923212410372?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pdWJpcWlnYWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="计算机系统组成" style="zoom: 50%;">

<p><strong>内存储器</strong></p>
<img src="https://img-blog.csdn.net/20180923212521350?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pdWJpcWlnYWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="冯·诺依曼体系结构" style="zoom:80%;">

<ul>
<li>运算器:　负责数据的算术运算和逻辑运算，即数据的加工处理。</li>
<li>控制器:　是整个计算机的中枢神经，分析程序规定的控制信息，并根据程序要求进行控制，协调计算机各部分组件工作及内存与外设的访问等。</li>
<li>运算器和控制器统称中央处理器（即CPU)</li>
<li>存储器:　实现记忆功能的部件，用来存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。</li>
<li>输入设备:　实现将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。</li>
<li>输出设备:　实现将计算机处理后生成的中间结果或最后结果（各种数据符号及文字或各种控制信号等信息）输出出来。</li>
</ul>
<h3 id="1-程序的内存结构"><a href="#1-程序的内存结构" class="headerlink" title="1 程序的内存结构"></a>1 程序的内存结构</h3><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153" alt="img"></p>
<p>一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</p>
<blockquote>
<ol>
<li><p>BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</p>
</li>
<li><p>数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配</p>
</li>
<li><p>代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量</p>
</li>
<li><p>text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。</p>
</li>
<li><p>bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。</p>
</li>
<li><p>data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。</p>
<p>数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。</p>
</li>
</ol>
<p><strong>可执行程序在运行时又多出两个区域：栈区和堆区。</strong></p>
<ol start="7">
<li><p>栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p>
</li>
<li><p>堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p>
</li>
</ol>
</blockquote>
<h3 id="2-虚拟内存"><a href="#2-虚拟内存" class="headerlink" title="2 虚拟内存"></a>2 虚拟内存</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>目的：为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。</p>
<p>作用：虚拟内存是计算机系统内存管理的一种技术。能使程序在只有一部分被调入内存的情况下运行；它使程序有一个连续完整的地址空间，而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
</blockquote>
<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><blockquote>
<p>每个程序都有自己的地址空间，这个空间被分割成多个快，每一块被分割成多块，每一块称作一页或页面。每一页有连续的传值范围。这些也被映射到物理内存，但不是所有的页都必须在内存中才能运行程序。</p>
<ul>
<li><p>当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。</p>
</li>
<li><p>当程序引用到一部分不在物理内存中的地址空间时，这些页被映射到物理内存并重新执行失败的指令。</p>
</li>
</ul>
</blockquote>
<h4 id="虚拟内存的好处"><a href="#虚拟内存的好处" class="headerlink" title="虚拟内存的好处"></a>虚拟内存的好处</h4><blockquote>
<ol>
<li><p>扩大地址空间；</p>
</li>
<li><p>内存保护：</p>
<p>每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还能对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</p>
</li>
<li><p>公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。</p>
</li>
<li><p>当进程通信时，可采用虚存共享的方式实现。</p>
</li>
<li><p>当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存。</p>
</li>
<li><p>虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高</p>
</li>
<li><p>在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</p>
</li>
</ol>
</blockquote>
<h4 id="虚拟内存的代价"><a href="#虚拟内存的代价" class="headerlink" title="虚拟内存的代价"></a>虚拟内存的代价</h4><blockquote>
<ol>
<li>虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</li>
<li>虚拟地址到物理地址的转换，增加了指令的执行时间。</li>
<li>页面的换入换出需要磁盘I/O，这是很耗时的</li>
<li>如果一页中只有一部分数据，会浪费内存。</li>
</ol>
</blockquote>
<h3 id="3-缺页中断"><a href="#3-缺页中断" class="headerlink" title="3 缺页中断"></a>3 缺页中断</h3><blockquote>
<p>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。</p>
<p>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<blockquote>
<p>1、保护CPU现场</p>
<p>2、分析中断原因</p>
<p>3、转入缺页中断处理程序进行处理</p>
<p>4、恢复CPU现场，继续执行</p>
</blockquote>
<p>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</p>
<blockquote>
<p>1、在指令执行期间产生和处理缺页中断信号</p>
<p>2、一条指令在执行期间，可能产生多次缺页中断</p>
<p>3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。</p>
</blockquote>
</blockquote>
<h3 id="4-页表寻址"><a href="#4-页表寻址" class="headerlink" title="4 页表寻址"></a>4 页表寻址</h3><blockquote>
<p>页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。</p>
<p>Linux最初的两级页表机制：</p>
<p>两级分页机制将32位的虚拟空间分成三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。</p>
<ol>
<li>PGD(Page Global Directory): 最高10位，全局页目录表索引</li>
<li>PTE(Page Table Entry)：中间10位，页表入口索引</li>
</ol>
<p>当在进行地址转换时，结合在CR3寄存器中存放的页目录(page directory, PGD)的这一页的物理地址，再加上从虚拟地址中抽出高10位叫做页目录表项(内核也称这为pgd)的部分作为偏移, 即定位到可以描述该地址的pgd；从该pgd中可以获取可以描述该地址的页表的物理地址，再加上从虚拟地址中抽取中间10位作为偏移, 即定位到可以描述该地址的pte；在这个pte中即可获取该地址对应的页的物理地址, 加上从虚拟地址中抽取的最后12位，即形成该页的页内偏移, 即可最终完成从虚拟地址到物理地址的转换。从上述过程中，可以看出，对虚拟地址的分级解析过程，实际上就是不断深入页表层次，逐渐定位到最终地址的过程，所以这一过程被叫做page talbe walk。</p>
<p>Linux的三级页表机制：</p>
<p>当X86引入物理地址扩展(Pisycal Addrress Extension, PAE)后，可以支持大于4G的物理内存(36位），但虚拟地址依然是32位，原先的页表项不适用，它实际多4 bytes被扩充到8 bytes，这意味着，每一页现在能存放的pte数目从1024变成512了(4k/8)。相应地，页表层级发生了变化，Linus新增加了一个层级，叫做页中间目录(page middle directory, PMD), 变成：</p>
<p>字段      描述            位数</p>
<p>cr3      指向一个PDPT      crs寄存器存储</p>
<p>PGD    指向PDPT中4个项中的一个  位31~30</p>
<p>PMD    指向页目录中512项中的一个  位29~21</p>
<p>PTE      指向页表中512项中的一个  位20~12</p>
<p>page offset  4KB页中的偏移      位11~0</p>
<p>现在就同时存在2级页表和3级页表，在代码管理上肯定不方便。巧妙的是，Linux采取了一种抽象方法：所有架构全部使用3级页表: 即PGD -&gt; PMD -&gt; PTE。那只使用2级页表(如非PAE的X86)怎么办？</p>
<p>办法是针对使用2级页表的架构，把PMD抽象掉，即虚设一个PMD表项。这样在page table walk过程中，PGD本直接指向PTE的，现在不了，指向一个虚拟的PMD，然后再由PMD指向PTE。这种抽象保持了代码结构的统一。</p>
<p>Linux的四级页表机制：</p>
<p>硬件在发展，3级页表很快又捉襟见肘了，原因是64位CPU出现了, 比如X86_64， 它的硬件是实实在在支持4级页表的。它支持48位的虚拟地址空间1。如下：</p>
<p>字段      描述            位数</p>
<p>PML4    指向一个PDPT      位47~39</p>
<p>PGD    指向PDPT中4个项中的一个  位38~30</p>
<p>PMD    指向页目录中512项中的一个  位29~21</p>
<p>PTE      指向页表中512项中的一个  位20~12</p>
<p>page offset  4KB页中的偏移      位11~0</p>
<p>Linux内核针为使用原来的3级列表(PGD-&gt;PMD-&gt;PTE)，做了折衷。即采用一个唯一的，共享的顶级层次，叫PML4。这个PML4没有编码在地址中，这样就能套用原来的3级列表方案了。不过代价就是，由于只有唯一的PML4, 寻址空间被局限在(239=)512G, 而本来PML4段有9位, 可以支持512个PML4表项的。现在为了使用3级列表方案，只能限制使用一个， 512G的空间很快就又不够用了，解决方案呼之欲出。</p>
</blockquote>
<h3 id="5-缺页置换算法"><a href="#5-缺页置换算法" class="headerlink" title="5 缺页置换算法"></a>5 缺页置换算法</h3><blockquote>
<p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。</p>
<p>当前操作系统最常采用的缺页置换算法如下：</p>
<ol>
<li><p>先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。</p>
</li>
<li><p>最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。</p>
</li>
</ol>
<p>当前最常采用的就是LRU算法。</p>
<p>比较常见的内存替换算法有：<strong>FIFO，LRU，LFU，LRU-K，2Q</strong>。</p>
<h4 id="1、FIFO（先进先出淘汰算法）"><a href="#1、FIFO（先进先出淘汰算法）" class="headerlink" title="1、FIFO（先进先出淘汰算法）"></a>1、FIFO（先进先出淘汰算法）</h4><p>思想：最近刚访问的，将来访问的可能性比较大。</p>
<p>实现：使用一个队列，新加入的页面放入队尾，每次淘汰队首的页面，即最先进入的数据，最先被淘汰。</p>
<p>弊端：无法体现页面冷热信息 BELADY</p>
<h4 id="2、LFU（最不经常访问淘汰算法）"><a href="#2、LFU（最不经常访问淘汰算法）" class="headerlink" title="2、LFU（最不经常访问淘汰算法）"></a>2、LFU（最不经常访问淘汰算法）</h4><p>思想：如果数据过去被访问多次，那么将来被访问的频率也更高。</p>
<p>实现：每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。</p>
<p>开销：排序开销。</p>
<p>弊端：缓存颠簸。</p>
<p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/311436_1552470476683_909843CE326FD7243A252E09C80772B8" alt="img"></p>
<h4 id="3、LRU（最近最少使用替换算法）"><a href="#3、LRU（最近最少使用替换算法）" class="headerlink" title="3、LRU（最近最少使用替换算法）"></a>3、LRU（最近最少使用替换算法）</h4><p>思想：如果数据最近被访问过，那么将来被访问的几率也更高。</p>
<p>实现：使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。</p>
<p>优点：LRU算法对热点数据命中率是很高的。</p>
<p>缺陷：</p>
<p>1）缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。</p>
<p>2）缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。</p>
<h4 id="4、LRU-K（LRU-2、LRU-3）"><a href="#4、LRU-K（LRU-2、LRU-3）" class="headerlink" title="4、LRU-K（LRU-2、LRU-3）"></a>4、LRU-K（LRU-2、LRU-3）</h4><p>思想：最久未使用K次淘汰算法。</p>
<p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</p>
<p>实现：</p>
<p>1）数据第一次被访问，加入到访问历史列表；</p>
<p>2）如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</p>
<p>3）当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</p>
<p>4）缓存数据队列中被再次访问后，重新排序；</p>
<p>5）需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</p>
<p>针对问题：</p>
<p>LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<h4 id="5、2Q"><a href="#5、2Q" class="headerlink" title="5、2Q"></a>5、2Q</h4><p>类似LRU-2。使用一个FIFO队列和一个LRU队列。</p>
<p>实现：</p>
<p>1）新访问的数据插入到FIFO队列；</p>
<p>2）如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</p>
<p>3）如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；</p>
<p>4）如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；</p>
<p>5）LRU队列淘汰末尾的数据。</p>
<p>针对问题：LRU的缓存污染</p>
<p>弊端：</p>
<p>当FIFO容量为2时，访问负载是：ABCABCABC会退化为FIFO，用不到LRU。</p>
</blockquote>
<h3 id="6-虚拟内存与物理内存的对应关系"><a href="#6-虚拟内存与物理内存的对应关系" class="headerlink" title="6 虚拟内存与物理内存的对应关系"></a>6 虚拟内存与物理内存的对应关系</h3><blockquote>
<p>物理地址：用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。</p>
<p>虚拟地址：对整个内存的抽像描述。它是相对于物理内存来讲的，可以直接理解成“不直实的”，“假的”内存，例如，一个0x08000000内存地址，它并不对就物理地址上那个大数组中0x08000000 - 1那个地址元素；</p>
<p>现代操作系统都提供了一种内存管理的抽像，即虚拟内存（virtual memory）。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。这个“转换”，是所有问题讨论的关键。有了这样的抽像，一个程序，就可以使用比真实物理地址大得多的地址空间。甚至多个进程可以使用相同的地址。不奇怪，因为转换后的物理地址并非相同的</p>
</blockquote>
<h4 id="2、地址转换"><a href="#2、地址转换" class="headerlink" title="2、地址转换"></a>2、地址转换</h4><blockquote>
<p><strong>逻辑地址转线性地址</strong></p>
<p>CPU要利用其段式内存管理单元，先将为个逻辑地址转换成一个线程地址。</p>
<p>一个逻辑地址由两部份组成，【段标识符：段内偏移量】。</p>
<p>段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，如图：</p>
<p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/311436_1552470210037_13DB46E4DEE567FEF6756A26C5A0EC62" alt="img"></p>
<p>通过段标识符中的索引号从GDT或者LDT找到该段的段描述符，段描述符中的base字段是段的起始地址。</p>
<p>段描述符：Base字段，它描述了一个段的开始位置的线性地址。</p>
<p>一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。</p>
<p>段起始地址+ 段内偏移量 = 线性地址</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470239469_B327A1776BDD614C1FA189B123676D44" alt="img"></p>
<p>首先，给定一个完整的逻辑地址 [段选择符：段内偏移地址]，</p>
<p>1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。</p>
<p>2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。</p>
<p>3、把Base + offset，就是要转换的线性地址了。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470270211_A8B080AAD8609459CD745F5E2480B919" alt="img"></p>
<p>第一步：页式管理——线性地址转物理地址</p>
<p>再利用其页式内存管理单元，转换为最终物理地址。</p>
<p>linux假的段式管理</p>
<p>Intel要求两次转换，这样虽说是兼容了，但是却是很冗余，但是这是intel硬件的要求。其它某些硬件平台，没有二次转换的概念，Linux也需要提供一个高层抽像，来提供一个统一的界面。所以，Linux的段式管理，事实上只是“哄骗”了一下硬件而已。按照Intel的本意，全局的用GDT，每个进程自己的用LDT——不过Linux则对所有的进程都使用了相同的段来对指令和数据寻址。即用户数据段，用户代码段，对应的，内核中的是内核数据段和内核代码段。</p>
<p>在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。</p>
<p>linux页式管理</p>
<p>CPU的页式内存管理单元，负责把一个线性地址，最终翻译为一个物理地址。</p>
<p>线性地址被分为以固定长度为单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，可以用4KB为一个页来划分，这页，整个线性地址就被划分为一个tatol_page[2^20]的大数组，共有2的20个次方个页。</p>
<p>另一类“页”，我们称之为物理页，或者是页框、页桢的。是分页单元把所有的物理内存也划分为固定长度的管理单位，它的长度一般与内存页是一一对应的。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470300375_E395C4896EA5D7621E9211A0C3817BB5" alt="img"></p>
<p>每个进程都有自己的页目录，当进程处于运行态的时候，其页目录地址存放在cr3寄存器中。</p>
<p>每一个32位的线性地址被划分为三部份，【页目录索引(10位)：页表索引(10位)：页内偏移(12位)】</p>
<p>依据以下步骤进行转换：</p>
<p>从cr3中取出进程的页目录地址（操作系统负责在调度进程的时候，把这个地址装入对应寄存器）；</p>
<p>根据线性地址前十位，在数组中，找到对应的索引项，因为引入了二级管理模式，页目录中的项，不再是页的地址，而是一个页表的地址。（又引入了一个数组），页的地址被放到页表中去了。</p>
<p>根据线性地址的中间十位，在页表（也是数组）中找到页的起始地址；</p>
<p>将页的起始地址与线性地址中最后12位相加。</p>
<p>目的：</p>
<p>内存节约：如果一级页表中的一个页表条目为空，那么那所指的二级页表就根本不会存在。这表现出一种巨大的潜在节约，因为对于一个典型的程序，4GB虚拟地址空间的大部份都会是未分配的；</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470330729_28397F90C2D7C059A122BFF0B4DFD63A" alt="img"></p>
<p>32位，PGD = 10bit，PUD = PMD = 0，table = 10bit，offset = 12bit</p>
<p>64位，PUD和PMD ≠ 0</p>
</blockquote>
<h3 id="7-内存溢出和内存泄漏"><a href="#7-内存溢出和内存泄漏" class="headerlink" title="7 内存溢出和内存泄漏"></a>7 内存溢出和内存泄漏</h3><h4 id="1、内存溢出"><a href="#1、内存溢出" class="headerlink" title="1、内存溢出"></a>1、内存溢出</h4><blockquote>
<p>指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</p>
</blockquote>
<h5 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h5><blockquote>
<ol>
<li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据</li>
<li>集合类中有对对象的引用，使用完后未清空，使得不能回收</li>
<li>代码中存在死循环或循环产生过多重复的对象实体</li>
<li>使用的第三方软件中的BUG</li>
<li>启动参数内存值设定的过小</li>
</ol>
</blockquote>
<h4 id="2、内存泄漏"><a href="#2、内存泄漏" class="headerlink" title="2、内存泄漏"></a>2、内存泄漏</h4><blockquote>
<p>内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p>
</blockquote>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><blockquote>
<ol>
<li>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</li>
<li>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li>
<li>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li>
</ol>
</blockquote>
<h3 id="8-为什么要有page-cache，操作系统怎么设计的page-cache"><a href="#8-为什么要有page-cache，操作系统怎么设计的page-cache" class="headerlink" title="8 为什么要有page cache，操作系统怎么设计的page cache"></a>8 为什么要有page cache，操作系统怎么设计的page cache</h3><blockquote>
<p>加快从磁盘读取文件的速率。</p>
<p>page cache中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。</p>
<p>在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache项，一个是radix tree，另一个是双向链表。Radix tree 是一种搜索树，Linux内核利用这个数据结构来通过文件内偏移快速定位Cache 项</p>
</blockquote>
<h3 id="9-动态重定位分区法"><a href="#9-动态重定位分区法" class="headerlink" title="9 动态重定位分区法"></a>9 动态重定位分区法</h3><blockquote>
<p>虽然动态分区法比固定分区法的内存利用率高，但动态分区法有零头（碎片）的问题。</p>
<p>碎片是不连续的小块空闲区，可能所有碎片的综合超过某作业的容量要求，但由于不连续也无法分配。</p>
<p>解决碎片的问题方法是拼接，即当出现上述这种无法分配的情况时，向一个方向（例如向低地址端）移动已分配的作业，使那些零碎的小空闲区在另一个方向连成一片，这就是 “ 紧缩 ” 技术。在紧缩过程中，因为内存中已经存在的作业需要 “ 移动 ” ，因而其中所有关于地址的项均需得到相应的修改，也就是需要进行地址重定位。</p>
<p>因此这种分区方法被称为可重定位分区法</p>
</blockquote>
<h2 id="六-文件系统"><a href="#六-文件系统" class="headerlink" title="六 文件系统"></a>六 文件系统</h2><h3 id="1-修改文件最大句柄数？"><a href="#1-修改文件最大句柄数？" class="headerlink" title="1. 修改文件最大句柄数？"></a>1. 修改文件最大句柄数？</h3><blockquote>
<p>linux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报”too many open files”的错误。故在linux服务器高并发调优时，往往需要预先调优Linux参数，修改Linux最大文件句柄数。</p>
<p>有两种方法：</p>
<ol>
<li>ulimit -n &lt;可以同时打开的文件数&gt;，将当前进程的最大句柄数修改为指定的参数（注：该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值）</li>
</ol>
<p>首先用ulimit -a查询Linux相关的参数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 94739</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 94739</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>

<p>其中，open files就是最大文件句柄数，默认是1024个。修改Linux最大文件句柄数：  ulimit -n 2048， 将最大句柄数修改为 2048个。</p>
<ol start="2">
<li>对所有进程都有效的方法，修改Linux系统参数  <code>vi /etc/security/limits.conf</code> 添加</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soft　　nofile　　65536</span><br><span class="line">hard　　nofile　　65536</span><br></pre></td></tr></table></figure>

<p>将最大句柄数改为65536</p>
<p>修改以后保存，注销当前用户，重新登录，修改后的参数就生效了。</p>
</blockquote>
<h3 id="2-操作系统中的结构体对齐，字节对齐"><a href="#2-操作系统中的结构体对齐，字节对齐" class="headerlink" title="2. 操作系统中的结构体对齐，字节对齐"></a>2. 操作系统中的结构体对齐，字节对齐</h3><p>1、原因：</p>
<blockquote>
<p>1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
<p>2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p>
</blockquote>
<p>2、规则</p>
<blockquote>
<p>1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</p>
<p>2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p>
<p>3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</p>
<p>3、定义结构体对齐</p>
<p>可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</p>
</blockquote>
<p>4、举例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AA</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;    <span class="comment">//长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]</span></span><br><span class="line">    <span class="keyword">char</span> b;  <span class="comment">//长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]</span></span><br><span class="line">    short c;   <span class="comment">//长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</span></span><br><span class="line">    <span class="keyword">char</span> d;  <span class="comment">//长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>



<h3 id="3-软链接和硬链接的区别"><a href="#3-软链接和硬链接的区别" class="headerlink" title="3. 软链接和硬链接的区别"></a>3. 软链接和硬链接的区别</h3><blockquote>
<p>为了解决文件共享问题，Linux引入了软链接和硬链接。</p>
<p>除了为Linux解决文件共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若1个inode号对应多个文件名，则为硬链接，即硬链接就是同一个文件使用了不同的别名,使用ln创建。若文件用户数据块中存放的内容是另一个文件的路径名指向，则该文件是软连接。</p>
<p>软连接是一个普通文件，有自己独立的inode,但是其数据块内容比较特殊。</p>
</blockquote>
<h2 id="七-输入和输出"><a href="#七-输入和输出" class="headerlink" title="七 输入和输出"></a>七 输入和输出</h2><h3 id="1-5种IO模型"><a href="#1-5种IO模型" class="headerlink" title="1. 5种IO模型"></a>1. 5种IO模型</h3><blockquote>
<ol>
<li>阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li>
<li>非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。</li>
<li>信号驱动IO:信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</li>
<li>IO复用/多路转接IO:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</li>
<li>异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li>
</ol>
</blockquote>
<h3 id="2-异步编程的事件循环"><a href="#2-异步编程的事件循环" class="headerlink" title="2.  异步编程的事件循环"></a>2.  异步编程的事件循环</h3><blockquote>
<p>事件循环就是不停循环等待时间的发生，然后将这个事件的所有处理器，以及他们订阅这个事件的时间顺序依次依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。当同时并发地处理多个请求时，以上的概念也是正确的，可以这样理解：在单个的线程中，事件处理器是一个一个按顺序执行的。即如果某个事件绑定了两个处理器，那么第二个处理器会在第一个处理器执行完毕后，才开始执行。在这个事件的所有处理器都执行完毕之前，事件循环不会去检查是否有新的事件触发。在单个线程中，一切都是有顺序地一个一个地执行的！</p>
</blockquote>
<h1 id="四-计算机网络"><a href="#四-计算机网络" class="headerlink" title="四 计算机网络"></a>四 计算机网络</h1><h2 id="一-整体架构"><a href="#一-整体架构" class="headerlink" title="一 整体架构"></a>一 整体架构</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><table>
<thead>
<tr>
<th align="center">OSI模型</th>
<th>作用</th>
<th align="center">传输单位</th>
<th align="center">协议</th>
<th>设备</th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用层</td>
<td>允许访问OSI环境的手段</td>
<td align="center">APDU</td>
<td align="center">FTP HTTP DNS</td>
<td></td>
</tr>
<tr>
<td align="center">表示层</td>
<td>对数据进行翻译、加密、压缩</td>
<td align="center">PPDU</td>
<td align="center">JPEG ASII</td>
<td></td>
</tr>
<tr>
<td align="center">会话层</td>
<td>建立、管理和终止对话</td>
<td align="center">SPDU</td>
<td align="center">RPC NFS</td>
<td></td>
</tr>
<tr>
<td align="center">运输层</td>
<td>提供端到端的可靠报文传递和错误恢复</td>
<td align="center">报文</td>
<td align="center">TCP UDP</td>
<td></td>
</tr>
<tr>
<td align="center">网络层</td>
<td>负责数据包从源到宿的传递和网际互连</td>
<td align="center">包</td>
<td align="center">IP ARP ICMP</td>
<td>路由器、网关</td>
</tr>
<tr>
<td align="center">数据链路层</td>
<td>将比特组装成帧和点到点的传递</td>
<td align="center">帧</td>
<td align="center">MAC VLAN PPP</td>
<td>网桥、交换机</td>
</tr>
<tr>
<td align="center">物理层</td>
<td>通过媒介传输比特,确定机械及电气规范</td>
<td align="center">比特</td>
<td align="center">IEEE802.3 CLOCK RJ45</td>
<td>中继器、集线器</td>
</tr>
</tbody></table>
<h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><table>
<thead>
<tr>
<th align="center">TCP/IP模型</th>
<th align="center">协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用层</td>
<td align="center">HTTP DNS SMTP</td>
</tr>
<tr>
<td align="center">传输层</td>
<td align="center">TCP UDP</td>
</tr>
<tr>
<td align="center">网络层</td>
<td align="center">IP ARP ICMP</td>
</tr>
<tr>
<td align="center">网络接口层</td>
<td align="center">MAC VLAN</td>
</tr>
</tbody></table>
<h2 id="二-物理层和数据链路层"><a href="#二-物理层和数据链路层" class="headerlink" title="二 物理层和数据链路层"></a>二 物理层和数据链路层</h2><h3 id="1-ARP协议与RARP协议"><a href="#1-ARP协议与RARP协议" class="headerlink" title="1 ARP协议与RARP协议"></a>1 ARP协议与RARP协议</h3><blockquote>
<p>ARP协议和RARP协议是作用于数据链路层的；</p>
<p>ARP协议的作用是将IP地址转换为物理地址;</p>
<p>工作原理：将ARP请求报文广播到所在网络上的所有主机，报文中含有目的主机的IP地址，只有目标主机可以返回一个ARP应答报文，报文中含有该主机的物理地址。</p>
</blockquote>
<h3 id="2-ARP协议如何查询MAC地址"><a href="#2-ARP协议如何查询MAC地址" class="headerlink" title="2 ARP协议如何查询MAC地址"></a>2 ARP协议如何查询MAC地址</h3><blockquote>
<p>现在路由器要给主机B发送一条消息，必须得知道主机B的MAC地址才能进行通信。</p>
<p>路由器会以广播的形式发送一个ARP请求，每一台连接到该路由器的主机都收到得到这条消息。</p>
<p>但是只有主机B检查到自己的IP地址符合要求。</p>
<p>于是主机B发送给路由器一条ARP响应，把自己的MAC的地址告诉了路由器。就像下面图示的那样：</p>
<p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/640" alt="img"></p>
<p>每次路由器发送一个ARP请求的时候，就会增加一条数据，这一条数据记录了IP地址对应的MAC地址，这样路由器下次再给该主机发送消息的时候就不用广播了。当然如同交换机的CAM表中的数据有生存了时间一样，路由表中的数据也有生存时间。试想一下，如果数据一直存在，那么路由器岂不是需要花大量的存储空间来缓存已经失效的数据。</p>
</blockquote>
<h2 id="三-网络层"><a href="#三-网络层" class="headerlink" title="三 网络层"></a>三 网络层</h2><h3 id="1-IP地址以及MAC地址的作用"><a href="#1-IP地址以及MAC地址的作用" class="headerlink" title="1  IP地址以及MAC地址的作用"></a>1  IP地址以及MAC地址的作用</h3><blockquote>
<p>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。</p>
<p>IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>
</blockquote>
<h3 id="2-TCP-IP数据链路层的交互过程"><a href="#2-TCP-IP数据链路层的交互过程" class="headerlink" title="2 TCP/IP数据链路层的交互过程"></a>2 TCP/IP数据链路层的交互过程</h3><blockquote>
<p>网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候。</p>
<p>首先会去自己的arp缓存表(存着ip-mac对应关系)去查找目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：<code>who is ip XXX tell ip XXX</code>,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器</p>
</blockquote>
<h3 id="3-IP层怎么知道报文该给哪个应用程序，如何区分UDP报文还是TCP报文"><a href="#3-IP层怎么知道报文该给哪个应用程序，如何区分UDP报文还是TCP报文" class="headerlink" title="3 IP层怎么知道报文该给哪个应用程序，如何区分UDP报文还是TCP报文"></a>3 IP层怎么知道报文该给哪个应用程序，如何区分UDP报文还是TCP报文</h3><blockquote>
<p>根据端口区分；</p>
<p>看ip头中的协议标识字段，17是udp，6是tcp</p>
</blockquote>
<h3 id="4-电脑接入局域网后，怎么分配IP地址"><a href="#4-电脑接入局域网后，怎么分配IP地址" class="headerlink" title="4 电脑接入局域网后，怎么分配IP地址"></a>4 电脑接入局域网后，怎么分配IP地址</h3><blockquote>
<ol>
<li><p>手动完成</p>
<p>配置主机连接到网络时，可以手动完成，也可以由网络管理员或DHCP服务器完成。对于家庭网络，手动配置非常简单。而在大型网络中，网络管理员可能会面临许多问题。</p>
</li>
<li><p>使用DHCP配置主机</p>
<p>动态主机配置协议，用于获取网络设置信息的应用层协议。DHCP由DHCP服务器控制，动态分配网络配置参数，如IP地址，子网掩码和网关地址</p>
</li>
</ol>
</blockquote>
<h3 id="5-ICMP协议-Internet-Control-Message-Protocol-ICMP"><a href="#5-ICMP协议-Internet-Control-Message-Protocol-ICMP" class="headerlink" title="5 ICMP协议(Internet Control Message Protocol, ICMP)"></a>5 ICMP协议(Internet Control Message Protocol, ICMP)</h3><blockquote>
<p>IP协议是不可靠的传输协议，网络中进行可靠传输的是TCP协议，这个后面在讲传输层的时候会说到。那么，如果在消息没有送达的情况下，网络层是怎么解决的了？这个时候，就需要用到ICMP协议。什么是ICMP协议</p>
<p>ICMP是网络控制报文协议(Internet Control Message Protocol, ICMP)。</p>
<p>它的作用：更加有效地转发IP数据报作为IP数据报的数据部分，可以分为ICMP差错报文，和ICMP查询报文。差错报文是用来简单的报告错误的, 至于对于错误怎么处理是高层协议的职责。同时, 差错报文总是发送给最初的数据源(这是因为在ICMP数据报中唯一可以使用的就是源IP和目的IP)，查询报文总是成对出现。</p>
</blockquote>
<h2 id="四-传输层"><a href="#四-传输层" class="headerlink" title="四 传输层"></a>四 传输层</h2><h3 id="零-TCP和UDP的区别"><a href="#零-TCP和UDP的区别" class="headerlink" title="零 TCP和UDP的区别"></a>零 TCP和UDP的区别</h3><table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>连接</td>
<td>面向连接<br>传输数据之前必须先建立好连接。</td>
<td>无连接</td>
</tr>
<tr>
<td>服务对象</td>
<td>是点对点的两点间服务，即一条TCP连接只能有两个端点；</td>
<td>支持一对一，一对多，多对一，多对多的交互通信。</td>
</tr>
<tr>
<td>可靠性</td>
<td>可靠交付：无差错，不丢失，不重复，按序到达。</td>
<td>尽最大努力交付，不保证可靠交付。</td>
</tr>
<tr>
<td>拥塞控制<br>流量控制</td>
<td>有拥塞控制和流量控制保证数据传输的安全性。</td>
<td>没有拥塞控制，网络拥塞不会影响源主机的发送效率。</td>
</tr>
<tr>
<td>报文长度</td>
<td>根据接收方的窗口大小和当前网络拥塞情况决定的</td>
<td>面向报文，不合并，不拆分，保留上面传下来报文的边界。</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销大，首部20个字节。</td>
<td>首部开销小，8字节。<br>（源端口，目的端口，数据长度，校验和）</td>
</tr>
<tr>
<td>使用场景</td>
<td>通信数据完整性需让位与通信实时性<br>文件传输、重要状态的更新等</td>
<td>通信实时性不重要<br>视频传输、实时通信等</td>
</tr>
</tbody></table>
<h3 id="一-TCP协议"><a href="#一-TCP协议" class="headerlink" title="一 TCP协议"></a>一 TCP协议</h3><h4 id="1-TCP怎么保证可靠性。"><a href="#1-TCP怎么保证可靠性。" class="headerlink" title="1 TCP怎么保证可靠性。"></a>1 TCP怎么保证可靠性。</h4><blockquote>
<p>（1）序列号、确认应答、超时重传</p>
<p>数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送方迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</p>
<p>（2）窗口控制与高速重发控制/快速重传（重复确认应答）</p>
<p>TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。</p>
<p>使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒……</p>
<p>（3）拥塞控制</p>
<p>如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。</p>
<ol>
<li><p>慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</p>
</li>
<li><p>拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。</p>
<p>将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。</p>
</li>
<li><p>快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。</p>
<p>然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。</p>
</li>
</ol>
<p>这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。</p>
</blockquote>
<h4 id="2-TCP建立连接和断开连接的过程："><a href="#2-TCP建立连接和断开连接的过程：" class="headerlink" title="2. TCP建立连接和断开连接的过程："></a>2. TCP建立连接和断开连接的过程：</h4><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzA5MzY3" alt="这里写图片描述" style="zoom:50%;">

<blockquote>
<ol>
<li><p>Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ol>
</blockquote>
<h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzU2MjU1" alt="这里写图片描述"></p>
<blockquote>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<ol>
<li>数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。</li>
<li>服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。</li>
<li>当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认</li>
<li>客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。</li>
</ol>
</blockquote>
<p>三次握手确认了什么？</p>
<blockquote>
<ul>
<li><strong>「第一次握手」</strong>：Client 什么都不能确认；Server 确认了Client发送正常。</li>
<li><strong>「第二次握手」</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，Client发送正常。</li>
<li><strong>「第三次握手」</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常。</li>
</ul>
</blockquote>
<p>既然三次握手的需要发送方和接收方确认，那么四次挥手也要得到发送方和接收方的确认。</p>
<blockquote>
<ul>
<li><strong>「第一次挥手」</strong>：Client向Server发送断开的连接的请求。</li>
<li><strong>「第二次挥手」</strong>：Server向Client发送断开连接的确认。Client收到以后，这个时候TCP进入了半连接的状态，从Client向Server发送数据的通道被关闭了。</li>
<li><strong>「第三次挥手」</strong>：Server向Client发送一个断开连接的请求。</li>
<li><strong>「第四次挥手」</strong>：Client向Server发送断开连接的确认。Server收到以后，这个时候TCP连接就完全断开了。</li>
</ul>
</blockquote>
<h4 id="3-为什么客户端最后还要等待2MSL？"><a href="#3-为什么客户端最后还要等待2MSL？" class="headerlink" title="3. 为什么客户端最后还要等待2MSL？"></a>3. 为什么客户端最后还要等待2MSL？</h4><blockquote>
<p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>2MSL意义：</p>
<blockquote>
<p>1、保证最后一次握手报文能到B，能进行超时重传。</p>
<p>2、2MSL后，这次连接的所有报文都会消失，不会影响下一次连接。</p>
</blockquote>
<p>详细解答 </p>
<blockquote>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
</blockquote>
</blockquote>
<h4 id="4-TCP的状态转移模型（有限状态机）"><a href="#4-TCP的状态转移模型（有限状态机）" class="headerlink" title="4. TCP的状态转移模型（有限状态机）"></a>4. TCP的状态转移模型（有限状态机）</h4><blockquote>
<ul>
<li>TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态。</li>
<li>每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。</li>
<li>状态之间的箭头表示可能发生的状态变迁。</li>
<li>箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。</li>
</ul>
<p>图中有三种不同的箭头。</p>
<ol>
<li>粗实线箭头表示对客户进程的正常变迁。</li>
<li>粗虚线箭头表示对服务器进程的正常变迁。</li>
<li>另一种细线箭头表示异常变迁。</li>
</ol>
</blockquote>
<p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/730879-20170219170921285-996689810.png" alt="img"></p>
<h4 id="5-TCP的三次握手和四次挥手的过程及原因"><a href="#5-TCP的三次握手和四次挥手的过程及原因" class="headerlink" title="5. TCP的三次握手和四次挥手的过程及原因"></a>5. TCP的三次握手和四次挥手的过程及原因</h4><blockquote>
<p>TCP的三次握手过程如下：</p>
<ol>
<li>C-&gt; SYN -&gt; S</li>
<li>S-&gt;SYN/ACK-&gt;C</li>
<li>C-&gt;ACK-&gt;S</li>
</ol>
<p>三次握手的原因：<strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</strong></p>
<p>例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。</p>
<p>TCP的四次挥手过程如下：</p>
<ul>
<li>C-&gt;FIN-&gt;S</li>
<li>S-&gt;ACK-&gt;C</li>
<li>S-&gt;FIN-&gt;C</li>
<li>C-&gt;ACK-&gt;S</li>
</ul>
<p>四次挥手的原因：<strong>由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到FIN包时，TCP协议栈会直接发送一个ACK确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送FIN包</strong>。应用层可以使用系统调用函数read==0来判断对端是否关闭连接。</p>
</blockquote>
<h5 id="5-1-TCP为什么不用两次握手？为什么不用四次？"><a href="#5-1-TCP为什么不用两次握手？为什么不用四次？" class="headerlink" title="5.1  TCP为什么不用两次握手？为什么不用四次？"></a>5.1  TCP为什么不用两次握手？为什么不用四次？</h5><blockquote>
<p>两次不可以</p>
<blockquote>
<p>tcp是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常</p>
</blockquote>
<p>不用四次：</p>
<blockquote>
<p>本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：</p>
</blockquote>
<blockquote>
<ol>
<li>客户端发送syn0给服务器</li>
<li>服务器收到syn0，回复ack(syn0+1)</li>
<li>服务器发送syn1</li>
<li>客户端收到syn1，回复ack(syn1+1) </li>
</ol>
<p>因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。</p>
</blockquote>
</blockquote>
<h5 id="5-2-在三次握手的过程中可以传输数据吗？为什么"><a href="#5-2-在三次握手的过程中可以传输数据吗？为什么" class="headerlink" title="5.2 在三次握手的过程中可以传输数据吗？为什么"></a>5.2 在三次握手的过程中可以传输数据吗？为什么</h5><blockquote>
<p>可以</p>
<ul>
<li>在三次握手的过程中，SYN报文段不能携数据，但需要消耗掉一个序号</li>
<li>ACK报文段可以携带数据，但要消耗一个序号；但不携带数据话，不需要消耗序列号</li>
<li>因此在第三次握手的时候可以携带数据</li>
</ul>
</blockquote>
<h4 id="6-TCP的拥塞控制？"><a href="#6-TCP的拥塞控制？" class="headerlink" title="6 TCP的拥塞控制？"></a>6 TCP的拥塞控制？</h4><blockquote>
<p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>
<p>过程cwnd的大小呈指数增长，直到超过慢启动门限，然后进入拥塞避免阶段，cwnd的大小线性增长，当出现网络拥塞(三个重复的ack或者超时)时候，将慢启动门限设置为出现拥塞时候大小的一半，cwnd的大小重新从0开始进入慢启动阶段。<br>快重传和快恢复：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p>拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口——cwnd。</p>
<p>1、慢开始</p>
<p>最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。</p>
<p>2、拥塞避免</p>
<p>每经过一个往返时间RTT，cwnd就增长1。</p>
<p>在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）</p>
<p>3、快重传</p>
<p>接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。</p>
<p>4、快恢复</p>
<p>当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。</p>
<p>采用快恢复算法时，慢开始只在建立连接和网络超时才使用。</p>
</blockquote>
<h4 id="7-拥塞控制什么时候减慢增长速度？"><a href="#7-拥塞控制什么时候减慢增长速度？" class="headerlink" title="7 拥塞控制什么时候减慢增长速度？"></a>7 拥塞控制什么时候减慢增长速度？</h4><blockquote>
<p>采用慢开始和拥塞避免算法的时候</p>
<ol>
<li><p>一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</p>
</li>
<li><p>一旦出现丢包的情况，就重新进行慢开始，减慢增长速度</p>
</li>
</ol>
<p>采用快恢复和快重传算法的时候</p>
<ol>
<li><p>一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</p>
</li>
<li><p>一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度</p>
</li>
</ol>
</blockquote>
<h4 id="8-介绍滑动窗口协议"><a href="#8-介绍滑动窗口协议" class="headerlink" title="8. 介绍滑动窗口协议"></a>8. 介绍滑动窗口协议</h4><p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/926914251_1582337620808_94597327B024F1B694D69B3314AC9532" alt="img"></p>
<blockquote>
<p>当发送窗口和接收窗口的大小都等于 1时，就是停止等待协议。每发完一个分组就停止发送，等待下一个。</p>
<p>当发送窗口大于1，接收窗口等于1时，就是回退N步协议。</p>
<p>当发送窗口和接收窗口的大小均大于1时，就是选择重发协议。</p>
</blockquote>
<h4 id="9-粘包问题"><a href="#9-粘包问题" class="headerlink" title="9. 粘包问题"></a>9. 粘包问题</h4><h5 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1 概念"></a>1 概念</h5><blockquote>
<p><strong>端到端通信</strong>，由客户端端口+服务端端口+客户端IP+服务端IP+传输协议组成的五元组可以明确的标识一条连接。</p>
<p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</p>
</blockquote>
<h5 id="2-原因"><a href="#2-原因" class="headerlink" title="2 原因"></a>2 原因</h5><blockquote>
<p>1 发送方原因</p>
<p>TCP默认使用<code>Nagle</code>算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：</p>
<ol>
<li>只有上一个分组得到确认，才会发送下一个分组</li>
<li>收集多个小分组，在一个确认到来时一起发送</li>
</ol>
<p>Nagle算法造成了发送方可能会出现粘包问题</p>
<p>2 接收方原因</p>
<p>TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p>
</blockquote>
<h5 id="3-什么时候需要处理沾包现象"><a href="#3-什么时候需要处理沾包现象" class="headerlink" title="3 什么时候需要处理沾包现象"></a>3 什么时候需要处理沾包现象</h5><blockquote>
<ol>
<li>如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象</li>
<li>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了</li>
</ol>
</blockquote>
<h5 id="4-如何处理沾包现象"><a href="#4-如何处理沾包现象" class="headerlink" title="4 如何处理沾包现象"></a>4 如何处理沾包现象</h5><blockquote>
<p>（1）发送方</p>
<p>对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</p>
<p>（2）接收方</p>
<p>接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。</p>
<p>（2）应用层</p>
<p>应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。</p>
<p>解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？</p>
<ol>
<li>格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。</li>
<li>发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。</li>
</ol>
</blockquote>
<h3 id="二-UDP协议"><a href="#二-UDP协议" class="headerlink" title="二 UDP协议"></a>二 UDP协议</h3><blockquote>
<p>UDP协议全称用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p>它有以下特点：</p>
<ol>
<li><p>面向无连接</p>
<p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>
<p>具体来说就是：</p>
</li>
</ol>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<ol start="2">
<li><p>有单播，多播，广播的功能</p>
<p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
</li>
<li><p>UDP是面向报文的</p>
<p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
</li>
<li><p>不可靠性</p>
<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>
<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
</li>
</ol>
<p>5.头部开销小，传输数据报文时是很高效的。</p>
</blockquote>
<h4 id="1-UDP的connect函数"><a href="#1-UDP的connect函数" class="headerlink" title="1. UDP的connect函数"></a>1. UDP的connect函数</h4><blockquote>
<p>除非套接字已连接，否则异步错误是不会返回到UDP套接字的。我们确实可以给UDP套接字调用connect，然而这样做的结果却与TCP连接不同的是没有三路握手过程。内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回调用进程。</p>
<p>对于已连接UDP套接字，与默认的未连接UDP套接字相比，发生了三个变化。</p>
<p>UDP套接字调用了connect系统调用，那么这个UDP上的连接就变成一对一的连接，但是通过这个UDP连接传输数据的性质还是不变的，仍然是不可靠的UDP连接。一旦变成一对一的连接，在调用系统调用发送和接受数据时也就可以使用TCP那一套系统调用了。</p>
<ul>
<li>1、我们再也不能给输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。可以给已连接的UDP套接字调用sendto，但是不能指定目的地址。sendto的第五个参数必须为空指针，第六个参数应该为0.</li>
<li>2、不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect指定协议地址的数据报。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报。</li>
<li>3、由已连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接的UDP套接字不接收任何异步错误。</li>
</ul>
<p>来自任何其他IP地址或断开的数据报不投递给这个已连接套接字，因为它们要么源IP地址要么源UDP端口不与该套接字connect到的协议地址相匹配。</p>
<p>UDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect。调用connect的通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信TFTP，这种情况下，客户和服务器都可能调用connect。</p>
</blockquote>
<h4 id="2-UDP会不会产生粘包问题呢？"><a href="#2-UDP会不会产生粘包问题呢？" class="headerlink" title="2 UDP会不会产生粘包问题呢？"></a>2 UDP会不会产生粘包问题呢？</h4><blockquote>
<p>TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。</p>
<p>UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<p>举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。</p>
</blockquote>
<h2 id="五-应用层"><a href="#五-应用层" class="headerlink" title="五 应用层"></a>五 应用层</h2><h3 id="一-HTTP-HTTPs协议"><a href="#一-HTTP-HTTPs协议" class="headerlink" title="一 HTTP/HTTPs协议"></a>一 HTTP/HTTPs协议</h3><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>1 概念</p>
<blockquote>
<p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件，图片文件，查询结果等）。</p>
<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
</blockquote>
<p>2 特点</p>
<blockquote>
<p>1、<strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。<strong>HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话</strong>。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p>2、无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>3、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>4、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>
<p>5、支持B/S及C/S模式。</p>
<p>6、默认端口80</p>
<p>7、基于TCP协议</p>
</blockquote>
<p>3 HTTP过程概述</p>
<blockquote>
<p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。</p>
<p>HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。</p>
<p>服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
</blockquote>
<p>HTTP 请求/响应的步骤如下：</p>
<blockquote>
<p>1、客户端连接到Web服务器    </p>
<p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com</a>。</p>
<p>2、发送HTTP请求</p>
<p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>
<p>3、服务器接受请求并返回HTTP响应</p>
<p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
<p>4、释放连接TCP连接</p>
<p>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
<p>5、客户端浏览器解析HTML内容</p>
<p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
</blockquote>
<p>4、举例</p>
<blockquote>
<p>在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；</p>
<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口80，和服务器建立TCP连接；</p>
<p>3、浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；</p>
<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；</p>
<p>5、释放 TCP连接；</p>
<p>6、浏览器将该 html 文本并显示内容；</p>
</blockquote>
<h4 id="1-HTTP返回码"><a href="#1-HTTP返回码" class="headerlink" title="1 HTTP返回码"></a>1 HTTP返回码</h4><p>HTTP协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下：</p>
<blockquote>
<p><code>1xx</code>：指示信息–表示请求已接收，继续处理。</p>
<p><code>2xx</code>：成功–表示请求已被成功接收、理解、接受。</p>
<p><code>3xx</code>：重定向–要完成请求必须进行更进一步的操作。</p>
<p><code>4xx</code>：客户端错误–请求有语法错误或请求无法实现。</p>
<p><code>5xx</code>：服务器端错误–服务器未能实现合法的请求。</p>
</blockquote>
<p>常见状态代码、状态描述的详细说明如下。</p>
<blockquote>
<ul>
<li>200 OK：客户端请求成功。</li>
<li>206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围</li>
<li>300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。</li>
<li>301 moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。</li>
<li>302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得，</li>
<li>304 not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li>
<li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li>
</ul>
</blockquote>
<h4 id="2-HTTP报文"><a href="#2-HTTP报文" class="headerlink" title="2 HTTP报文"></a>2 HTTP报文</h4><blockquote>
<p><strong>请求报文构成</strong></p>
<ol>
<li>请求行：包括请求方法、URL、协议/版本</li>
<li>请求头(Request Header)</li>
<li>请求正文(body)</li>
</ol>
<p><strong>响应报文构成</strong></p>
<ol>
<li>状态行</li>
<li>响应头</li>
<li>响应正文</li>
</ol>
</blockquote>
<h4 id="3-HTTP中常见的方法"><a href="#3-HTTP中常见的方法" class="headerlink" title="3 HTTP中常见的方法"></a>3 HTTP中常见的方法</h4><blockquote>
<ul>
<li>GET: 请求指定的页面信息，并返回实体主体。</li>
<li>POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>
<li>HEAD: 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
<li>PUT: 从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li>DELETE: 请求服务器删除指定的页面。</li>
</ul>
</blockquote>
<p>详细内容</p>
<blockquote>
<p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p>
<ol>
<li>GET ：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。</li>
<li>HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</li>
<li>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</li>
<li>PUT：向指定资源位置上传其最新内容。</li>
<li>DELETE：请求服务器删除Request-URI所标识的资源。</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>
<li>OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</li>
<li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</li>
</ol>
</blockquote>
<p>注意事项：</p>
<blockquote>
<ol>
<li>方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。</li>
<li>HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源<em>。</em></li>
</ol>
</blockquote>
<p>请求方式: get与post请求（通过form表单我们自己写写看）</p>
<blockquote>
<ul>
<li>GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输数据，参数之间以&amp;相连，如EditBook?name=test1&amp;id=123456.（请求头里面那个content-type做的这种参数形式，后面讲） POST方法是把提交的数据放在HTTP包的请求体中.</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</li>
<li>GET与POST请求在服务端获取请求数据方式不同，就是我们在服务端取请求数据的时候的方式不同。</li>
</ul>
</blockquote>
<h4 id="4-GET和POST的区别"><a href="#4-GET和POST的区别" class="headerlink" title="4 GET和POST的区别"></a>4 GET和POST的区别</h4><blockquote>
<p>对于GET的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>对于POST的请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p>
</blockquote>
<blockquote>
<ul>
<li>都包含请求头请求行，post多了请求body。</li>
<li>get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入body中。</li>
<li>GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。</li>
<li>GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。</li>
</ul>
</blockquote>
<p>区别：</p>
<blockquote>
<p>1、get参数通过url传递，post放在request body中。</p>
<p>2、get请求在url中传递的参数是有长度限制的，而post没有。</p>
<p>3、get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</p>
<p>4、get请求只能进行url编码，而post支持多种编码方式。</p>
<p>5、get请求会浏览器主动cache，而POST不会，除非手动设置。</p>
<p>6、get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</p>
<p>7、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>
<p>8、GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
</blockquote>
<h5 id="产生两次TCP连接的原因"><a href="#产生两次TCP连接的原因" class="headerlink" title="产生两次TCP连接的原因"></a>产生两次TCP连接的原因</h5><blockquote>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
</blockquote>
<h4 id="5-http协议会话的结束标志"><a href="#5-http协议会话的结束标志" class="headerlink" title="5 http协议会话的结束标志"></a>5 http协议会话的结束标志</h4><blockquote>
<p>看tcp连接是否有断开的四部挥手阶段。</p>
</blockquote>
<h4 id="6-Cookie"><a href="#6-Cookie" class="headerlink" title="6 Cookie"></a>6 Cookie</h4><blockquote>
<p>Cookie，类型为“<strong>小型文本文件</strong>”，是某些网站为了辨别用户身份，进行<a href="https://baike.baidu.com/item/Session/479100" target="_blank" rel="noopener">Session</a>跟踪而储存在用户本地终端上的数据（通常经过加密），由用户<a href="https://baike.baidu.com/item/客户端/101081" target="_blank" rel="noopener">客户端</a>计算机暂时或永久保存的信息</p>
<p>Cookie诞生的最初目的是<strong>为了存储web中的状态信息，以方便服务器端使用</strong>。</p>
<p>Cookie是一个保存在客户机中的简单的文本文件, 这个文件与特定的 <a href="https://baike.baidu.com/item/Web/150564" target="_blank" rel="noopener">Web</a> 文档关联在一起, 保存了该客户机访问这个Web 文档时的信息, 当客户机再次访问这个 Web 文档时这些信息可供该文档使用</p>
</blockquote>
<blockquote>
<p><strong>会话（Session）</strong>跟踪是Web程序中常用的技术，用来<strong>跟踪用户的整个会话</strong>。常用的会话跟踪技术是Cookie与Session。<strong>Cookie通过在客户端记录信息确定用户身份</strong>，<strong>Session通过在服务器端记录信息确定用户身份</strong>。在程序中，会话跟踪是很重要的事情。理论上，<strong>一个用户的所有请求操作都应该属于同一个会话</strong>，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。<strong>HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话</strong>。Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p>
</blockquote>
<p>补充：HTTP的cookie是明文传送的，HTTPS的cooike是密文传送的。</p>
<h4 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h4><blockquote>
<p>HTTPS是身披SSL外壳的HTTP。</p>
<p>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p>
<p>PS: TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。</p>
</blockquote>
<h4 id="2-HTTPS协议的优缺点"><a href="#2-HTTPS协议的优缺点" class="headerlink" title="2 HTTPS协议的优缺点"></a>2 HTTPS协议的优缺点</h4><p>HTTPS优点：</p>
<blockquote>
<ul>
<li>HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</li>
<li>HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</li>
</ul>
</blockquote>
<p>HTTPS缺点：</p>
<blockquote>
<ul>
<li><p>HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</p>
</li>
<li><p>HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</p>
</li>
</ul>
</blockquote>
<h4 id="3-HTTP和HTTPS的区别"><a href="#3-HTTP和HTTPS的区别" class="headerlink" title="3 HTTP和HTTPS的区别"></a>3 HTTP和HTTPS的区别</h4><p>HTTP协议和HTTPS协议区别如下：</p>
<blockquote>
<p>1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</p>
<p>2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</p>
<p>3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</p>
<p>4）HTTP协议端口是80，HTTPS协议端口是443</p>
</blockquote>
<h4 id="4-HTTPS的加密方法"><a href="#4-HTTPS的加密方法" class="headerlink" title="4 HTTPS的加密方法"></a>4 HTTPS的加密方法</h4><p>加密方法主要有对称加密和费对称加密</p>
<h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><blockquote>
<p>需要对加密和解密使用相同密钥的加密算法。所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。</p>
<p>对称加密也叫密钥加密 </p>
<p>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。<br>缺点：对称加密，密钥管理的安全性很低，因为加密和解密都使用同一个密钥，在密钥的发送过程中，密钥可能被第三方截取，导致第三方也可以破解密文。</p>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>在每次发送真实数据之前，服务器先生成一把密钥，然后先把密钥传输给客户端。之后服务器给客户端发送真实数据的时候，会用这把密钥对数据进行加密，客户端收到加密数据之后，用刚才收到的密钥进行解密。</p>
</blockquote>
<h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><blockquote>
<h5 id="密钥的形式"><a href="#密钥的形式" class="headerlink" title="密钥的形式"></a>密钥的形式</h5><p>公钥与私钥是一对。传输双方均有自己的一对密钥（也就是双方每方均有：公、私密钥一把，双方加起来共4把）</p>
<p>例子:传输双方比如是甲乙双方，甲方有配对的公、私密钥一对，且公钥负责加密，私钥负责解对应的公钥加的密。乙方同理。</p>
<h6 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h6><p>非对称密钥的算法强度复杂（是优点也是缺点），安全性依赖于算法与密钥。<br>优点：安全性较高，比对称密钥安全性高很多。 非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要。<br>缺点：由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。</p>
<h6 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h6><ol>
<li>客户端要向服务器发送信息，客户端和服务器都要产生一对用于加密和解密的公钥和私钥。</li>
<li>客户端的私钥保密，客户端的公钥告诉服务器；服务器的私钥保密，服务器的公钥告诉客户端。</li>
<li>客户端要给服务器发送信息时，客户端用服务器的公钥加密信息，因为服务器的公钥是公开的，客户端可以得到。</li>
<li>客户端将这个消息发给服务器（已经用服务器的公钥加密消息）。</li>
<li>服务器收到这个消息后，服务器用自己的私钥解密客户端的消息。其他所有收到这个报文的人都无法解密，因为只有服务器才有服务器的私钥。 </li>
</ol>
</blockquote>
<h4 id="5-HTTPS采用的加密"><a href="#5-HTTPS采用的加密" class="headerlink" title="5 HTTPS采用的加密"></a>5 HTTPS采用的加密</h4><p>HTTPS结合了对称加密+非对称加密这两种方式。</p>
<ul>
<li>首先用非对称加密的方式来传输对称加密过程中的密钥，</li>
<li>其次采取对称加密的方式来传输数据了。</li>
</ul>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><blockquote>
<p>非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
</blockquote>
<h5 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h5><blockquote>
<p>HTTPS采用的是处理信息的方式是：结合对称加密+非对称加密这两种方式，我们可以用非对称加密的方式来传输对称加密过程中的密钥，之后我们就可以采取对称加密的方式来传输数据了。具体是这样子的：</p>
<p>服务器用明文的方式给客户端发送自己的公钥，客户端收到公钥之后，会生成一把密钥(对称加密用的)，然后用服务器的公钥对这把密钥进行加密，之后再把密钥传输给服务器，服务器收到之后进行解密，最后服务器就可以安全得到这把密钥了，而客户端也有同样一把密钥，他们就可以进行对称加密了。</p>
</blockquote>
<h4 id="6-证书"><a href="#6-证书" class="headerlink" title="6 证书"></a>6 证书</h4><blockquote>
<p>事实上，在没有引入证书之前，非对称加密也并非传输安全的，在此举个例子：</p>
<p>服务器以明文的方式给客户端传输公钥的时候，中间人截取了这把属于服务器的公钥，并且把中间人自己的公钥冒充服务器的公钥传输给了客户端。</p>
<p>之后客户端就会用中间人的公钥来加密自己生成的密钥。然后把被加密的密钥传输给服务器，这个时候中间人又把密钥给截取了，中间人用自己的私钥对这把被加密的密钥进行解密，解密后中间人就可以获得这把密钥了。</p>
<p>最后中间人再对这把密钥用刚才服务器的公钥进行加密，再发给服务器。</p>
<p>毫无疑问，在这个过程中，中间人获取了对称加密中的密钥，在之后服务器和客户端的对称加密传输中，这些加密的数据对中间人来说，和明文没啥区别。</p>
<p>非对称性加密之所以不安全，是应为客户端不知道，这把公钥是不是服务器的。因此，我们需要找到一种策略来证明这把公钥就是服务器的，而不是别人冒充的。解决这个问题的方式就是使用数字证书，具体是这样的：</p>
<p>1、我们需要找到一个第三方机构，它是一个拥有公信力、大家都认可的认证中心，那就是数字证书认证机构(简称CA)。<br>2、服务器在给客户端传输公钥的过程中，会把公钥以及服务器的个人信息通过Hash算法生成信息摘要。为了防止信息摘要被人调换，客户端还会用CA提供的私钥对信息摘要进行加密来形成数字签名。并且，最后还会把原来没Hash算法之前的个人信息以及公钥和数字签名合并在一起，形成数字证书。<br>3、当客户端拿到这份数字证书之后，就会用CA提供的公钥来对数字证书里面的数字签名进行解密来得到信息摘要，然后对数字证书里服务器的公钥以及个人信息进行Hash得到另外一份信息摘要。最后把两份信息摘要进行对比，如果一样，则证明这个人是服务器，否则就不是。这样，就可以保证服务器的公钥安全着交给客户端了。</p>
<p>一个重要的问题是，如何安全转交认证机构的公钥是一件很困难的事，因此，大多数浏览器开发商发布版本时，会事先植入常用认证机关的公钥。</p>
</blockquote>
<h4 id="7-数字证书是什么，里面包含哪些内容"><a href="#7-数字证书是什么，里面包含哪些内容" class="headerlink" title="7. 数字证书是什么，里面包含哪些内容"></a>7. 数字证书是什么，里面包含哪些内容</h4><blockquote>
<p>1）概念：</p>
<p>数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系的基础。在用户使用数字证书之前必须首先下载和安装。</p>
<p>认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。</p>
<p>2）数字证书颁发过程：</p>
<p>数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。</p>
<p>3）内容：</p>
<p>数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容：</p>
<ol>
<li><p>证书的版本信息；</p>
</li>
<li><p>证书的序列号，每个证书都有一个唯一的证书序列号；</p>
</li>
<li><p>证书所使用的签名算法；</p>
</li>
<li><p>证书的发行机构名称，命名规则一般采用X.500格式；</p>
</li>
<li><p>证书的有效期，通用的证书一般采用UTC时间格式；</p>
</li>
<li><p>证书所有人的名称，命名规则一般采用X.500格式；</p>
</li>
<li><p>证书所有人的公开密钥；</p>
</li>
<li><p>证书发行者对证书的签名。</p>
</li>
</ol>
</blockquote>
<h3 id="二-DNS协议"><a href="#二-DNS协议" class="headerlink" title="二 DNS协议"></a>二 DNS协议</h3><h4 id="1-DNS解析过程"><a href="#1-DNS解析过程" class="headerlink" title="1. DNS解析过程"></a>1. DNS解析过程</h4><blockquote>
<ol>
<li><p>检查浏览器缓存中是否缓存过该域名对应的IP地址</p>
</li>
<li><p>如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP</p>
</li>
<li><p>向本地域名解析服务系统发起域名解析的请求</p>
</li>
<li><p>向根域名解析服务器发起域名解析请求</p>
</li>
<li><p>根域名服务器返回gTLD域名解析服务器地址</p>
</li>
<li><p>向gTLD服务器发起解析请求</p>
</li>
<li><p>gTLD服务器接收请求并返回Name Server服务器</p>
</li>
<li><p>Name Server服务器返回IP地址给本地服务器</p>
</li>
<li><p>本地域名服务器缓存解析结果</p>
</li>
<li><p>返回解析结果给用户</p>
</li>
</ol>
</blockquote>
<h4 id="2-DNS的查询方式"><a href="#2-DNS的查询方式" class="headerlink" title="2. DNS的查询方式"></a>2. DNS的查询方式</h4><p>递归查询</p>
<p>迭代查询</p>
<h4 id="3-搜索baidu，会用到计算机网络中的什么层？每层是干什么的"><a href="#3-搜索baidu，会用到计算机网络中的什么层？每层是干什么的" class="headerlink" title="3. 搜索baidu，会用到计算机网络中的什么层？每层是干什么的"></a>3. 搜索baidu，会用到计算机网络中的什么层？每层是干什么的</h4><blockquote>
<p>浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p>
<p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p>
<p>其中：</p>
<h4 id="1、DNS协议，http协议，https协议属于应用层"><a href="#1、DNS协议，http协议，https协议属于应用层" class="headerlink" title="1、DNS协议，http协议，https协议属于应用层"></a>1、DNS协议，http协议，https协议属于应用层</h4><p>应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。</p>
<h4 id="2、TCP-UDP属于传输层"><a href="#2、TCP-UDP属于传输层" class="headerlink" title="2、TCP/UDP属于传输层"></a>2、TCP/UDP属于传输层</h4><p>传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>，和无连接的用户数据报协议<a href="https://www.baidu.com/s?wd=UDP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">UDP</a>。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。</p>
<h4 id="3、IP协议，ARP协议属于网络层"><a href="#3、IP协议，ARP协议属于网络层" class="headerlink" title="3、IP协议，ARP协议属于网络层"></a>3、IP协议，ARP协议属于网络层</h4><p>网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。</p>
<h4 id="4、数据链路层"><a href="#4、数据链路层" class="headerlink" title="4、数据链路层"></a>4、数据链路层</h4><p>当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及<a href="https://www.baidu.com/s?wd=流量控制&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">流量控制</a>信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。</p>
<h4 id="5、物理层"><a href="#5、物理层" class="headerlink" title="5、物理层"></a>5、物理层</h4><p>物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如<a href="https://www.baidu.com/s?wd=双绞线&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">双绞线</a>、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。</p>
</blockquote>
<h2 id="六-网络编程"><a href="#六-网络编程" class="headerlink" title="六 网络编程"></a>六 网络编程</h2><h3 id="1-网络编程的基本步骤"><a href="#1-网络编程的基本步骤" class="headerlink" title="1. 网络编程的基本步骤"></a>1. 网络编程的基本步骤</h3><blockquote>
<p>服务端：socket-bind-listen-accept</p>
<p>客户端：socket-connect</p>
</blockquote>
<h3 id="2-请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"><a href="#2-请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？" class="headerlink" title="2. 请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"></a>2. 请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？</h3><blockquote>
<p>这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了epoll,select等这样的io复用情况下，处于运行状态</p>
</blockquote>
<h3 id="3-socket编程中服务器端和客户端主要用到哪些函数"><a href="#3-socket编程中服务器端和客户端主要用到哪些函数" class="headerlink" title="3. socket编程中服务器端和客户端主要用到哪些函数"></a>3. socket编程中服务器端和客户端主要用到哪些函数</h3><blockquote>
<h4 id="1）基于TCP的socket："><a href="#1）基于TCP的socket：" class="headerlink" title="1）基于TCP的socket："></a>1）基于TCP的socket：</h4><p>1、服务器端程序：</p>
<ul>
<li>1 创建一个socket，用函数socket()</li>
<li>2 绑定IP地址、端口等信息到socket上，用函数bind()</li>
<li>3 设置允许的最大连接数，用函数listen()</li>
<li>4 接收客户端上来的连接，用函数accept()</li>
<li>5 收发数据，用函数send()和recv()，或者read()和write()</li>
<li>6 关闭网络连接</li>
</ul>
<p>2、客户端程序：</p>
<ul>
<li>1 创建一个socket，用函数socket()</li>
<li>2 设置要连接的对方的IP地址和端口等属性</li>
<li>3 连接服务器，用函数connect()</li>
<li>4 收发数据，用函数send()和recv()，或read()和write()</li>
<li>5 关闭网络连接</li>
</ul>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552654678444_69CF8398BCC9F204991E623723D022E7" alt="img"></p>
<h4 id="2）基于UDP的socket："><a href="#2）基于UDP的socket：" class="headerlink" title="2）基于UDP的socket："></a>2）基于UDP的socket：</h4><p>1、服务器端流程</p>
<ul>
<li>1 建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</li>
<li>2 设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</li>
<li>3 绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</li>
<li>4 接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</li>
<li>5 向客户端发送数据，使用sendto()函数向服务器主机发送数据。</li>
<li>6 关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</li>
</ul>
<p>2、客户端流程</p>
<ul>
<li>1 建立套接字文件描述符，socket()。</li>
<li>2 设置服务器地址和端口，struct sockaddr。</li>
<li>3 向服务器发送数据，sendto()。 </li>
<li>4 接收服务器的数据，recvfrom()。</li>
<li>5 关闭套接字，close()。</li>
</ul>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552654687053_263E6AFD1A48F8511D04B67EB12AA24C" alt="img"></p>
</blockquote>
<h3 id="4-Socket编程的send-、recv-、accept-、socket-函数？"><a href="#4-Socket编程的send-、recv-、accept-、socket-函数？" class="headerlink" title="4. Socket编程的send()、recv()、accept()、socket()函数？"></a>4. Socket编程的send()、recv()、accept()、socket()函数？</h3><blockquote>
<ol>
<li>send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。</li>
<li>recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。</li>
<li>accept函数用了接收一个连接，内核维护了半连接队列和一个已完成连接队列，当队列为空的时候，accept函数阻塞，不为空的时候accept函数从上边取下来一个已完成连接，返回一个文件描述符。</li>
</ol>
</blockquote>
<h3 id="5-Socket的connect函数"><a href="#5-Socket的connect函数" class="headerlink" title="5 Socket的connect函数"></a>5 Socket的connect函数</h3><p><strong>当用socket建立了套接口后，可以调用connect为这个套接字指明远程端的地址；如果是字节流套接口，connect就使用三次握手建立一个连接；如果是数据报套接口，connect仅指明远程端地址，而不向它发送任何数据。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;　　 　 　</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr * servaddr,socklen_taddrlen)</span></span>; 　</span><br><span class="line"><span class="comment">//返回：0－－－成功　　　-1－－－失败</span></span><br></pre></td></tr></table></figure>

<p>第一个参数是socket函数返回的套接口描述字；第二和第三个参数分别是一个指向套接口地址结构的指针和该结构的大小。</p>
<h1 id="五-数据库"><a href="#五-数据库" class="headerlink" title="五 数据库"></a>五 数据库</h1><p>事物 索引 底层结构 隔离性的几个级别</p>
<h2 id="一-数据库基础"><a href="#一-数据库基础" class="headerlink" title="一 数据库基础"></a>一 数据库基础</h2><h3 id="一-事务"><a href="#一-事务" class="headerlink" title="一 事务"></a>一 事务</h3><blockquote>
<p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。</p>
</blockquote>
<h4 id="0-概念"><a href="#0-概念" class="headerlink" title="0 概念"></a>0 概念</h4><blockquote>
<p>事务就是一组SQL语句; 主要是为了在数据库增删查改的过程中，保证数据的正确和安全。</p>
<p>事务处理(transaction processing)可以用来维护数据库的完整性,它保证成批的MySQL操作要么完全执行,要么完全不执行。</p>
<p>事务处理是一种机制,用来管理必须成批执行的MySQL操作,以保证数据库不包含不完整的操作结果。利用事务处理,可以保证一组操作不会中途停止,它们或者作为整体执行,或者完全不执行(除非明确指示)  。如果没有错误发生,整组语句提交给(写到)数据库表。如果发生错误,则进行回退(撤销)以恢复数据库到某个已知且安全的状态。</p>
<p>事务是访问数据库的一个操作序列，数据库应用系统通过事务集来完成对数据库的存取。<strong>事务的正确执行使得数据库从一种状态转换为另一种状态</strong>。</p>
</blockquote>
<h4 id="1-事物的性质"><a href="#1-事物的性质" class="headerlink" title="1 事物的性质"></a>1 事物的性质</h4><blockquote>
<p><strong>1、原子性</strong></p>
<p>即不可分割，事务要么全部被执行，要么全部不执行。如果事务的所有子事务全部提交成功，则所有的数据库操作被提交，数据库状态发生变化；如果有子事务失败，则其他子事务的数据库操作被回滚，即数据库回到事务执行前的状态，不会发生状态转换</p>
<p><strong>2、一致性</strong></p>
<p>事务的执行使得数据库从一种正确状态转换成另外一种正确状态</p>
<p><strong>3、隔离性</strong></p>
<p>在事务正确提交之前，不允许把事务对该数据的改变提供给任何其他事务，即在事务正确提交之前，它可能的结果不应该显示给其他事务</p>
<p><strong>4、持久性</strong></p>
<p>事务正确提交之后，其结果将永远保存在数据库之中，即使在事务提交之后有了其他故障，事务的处理结果也会得到保存</p>
</blockquote>
<h4 id="2-事务的隔离"><a href="#2-事务的隔离" class="headerlink" title="2 事务的隔离"></a>2 事务的隔离</h4><p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<h5 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h5><blockquote>
<h4 id="1-Read-uncommitted"><a href="#1-Read-uncommitted" class="headerlink" title="1 Read uncommitted"></a>1 Read uncommitted</h4><p><code>读未提交</code>：隔离级别最低的一种事务级别。在这种隔离级别下，会引发脏读、不可重复读和幻读。</p>
<h4 id="2-Read-Committed"><a href="#2-Read-Committed" class="headerlink" title="2 Read Committed"></a>2 Read Committed</h4><p><code>读已提交</code>读到的都是别人提交后的值。这种隔离级别下，会引发不可重复读和幻读，但避免了脏读。</p>
<h4 id="3-Repeatable-Reads"><a href="#3-Repeatable-Reads" class="headerlink" title="3 Repeatable Reads"></a>3 Repeatable Reads</h4><p><code>可重复读</code>这种隔离级别下，会引发幻读，但避免了脏读、不可重复读。</p>
<h4 id="4-Serializable"><a href="#4-Serializable" class="headerlink" title="4 Serializable"></a>4 Serializable</h4><p><code>串行化</code>是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行。脏读、不可重复读、幻读都不会出现。</p>
</blockquote>
<h4 id="3-事物隔离级别查看及修改"><a href="#3-事物隔离级别查看及修改" class="headerlink" title="3 事物隔离级别查看及修改"></a>3 事物隔离级别查看及修改</h4><blockquote>
<p>首先说明一下MySQL查看和修改事务隔离级别的几个命令：</p>
<ul>
<li>查看事务隔离级别使用select @@tx_isolation</li>
<li>修改当前会话事务隔离级别使用<strong>SET session TRANSACTION ISOLATION LEVEL Serializable;</strong>（参数可以为：Read uncommitted|Read committed|Repeatable read|Serializable）</li>
<li>修改全局事务隔离级别使用<strong>SET global TRANSACTION ISOLATION LEVEL Serializable;</strong>（参数可以为：Read uncommitted|Read committed|Repeatable read|Serializable）</li>
</ul>
<p>修改了会话的事务隔离级别，比如MyBatis，getSqlSession()的时候，只针对这一次拿到的Session有效；比如CMD命令行，只对这一次的窗口有效。</p>
<p>修改了全局的事务隔离级别，那么针对此后所有的会话有效，<strong>当前已经存在的会话不受影响</strong>。</p>
<p>关于MySQL事务隔离级别，推荐大家一篇文章，很详细地测试了四种事务隔离级别<a href="https://www.cnblogs.com/snsdzjlz320/p/5761387.html，相信大家读了一定有所进步。" target="_blank" rel="noopener">https://www.cnblogs.com/snsdzjlz320/p/5761387.html，相信大家读了一定有所进步。</a></p>
</blockquote>
<h3 id="二-索引"><a href="#二-索引" class="headerlink" title="二 索引"></a>二 索引</h3><blockquote>
<p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。<br>索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</p>
</blockquote>
<h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1 概念"></a>1 概念</h4><blockquote>
<p>索引<strong>是一个排序的列表</strong>，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。</p>
<p>因为索引并不是关系模型的组成部分，因此不同的DBMS有不同的实现，我们针对MySQL数据库的实现进行说明。</p>
</blockquote>
<h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h4><blockquote>
<p>常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引</p>
<p>1、主键索引：即主索引，根据主键pk_clolum(length)建立索引，不允许重复，不允许空值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD PRIMARY KEY pk_index(&#39;col&#39;)</span><br></pre></td></tr></table></figure>

<p>2、唯一索引：用来建立索引的列的值必须是唯一的，允许空值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;)</span><br></pre></td></tr></table></figure>

<p>3、普通索引：用表中的普通列构造的索引，没有限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;)</span><br></pre></td></tr></table></figure>

<p>4、全文索引：用大文本对象的列构造的索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;) </span><br></pre></td></tr></table></figure>

<p>5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;)</span><br></pre></td></tr></table></figure>

<p>遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。</p>
<p>在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(col1(4),col2(3));</span><br></pre></td></tr></table></figure>

<p>表示使用col1的前4个字符和col2的前3个字符作为索引</p>
</blockquote>
<h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a>3 优缺点</h4><blockquote>
<p>优点：优缺点，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组的排序；</p>
<p>缺点：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间是数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据凉的增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表。</p>
</blockquote>
<blockquote>
<p>优点：</p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ol>
<p>缺点：</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
</blockquote>
<h4 id="4-添加索引原则"><a href="#4-添加索引原则" class="headerlink" title="4 添加索引原则"></a>4 添加索引原则</h4><blockquote>
<p>在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
<p>只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
<p>定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p>
<p>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
</blockquote>
<h4 id="5-索引的底层实现原理"><a href="#5-索引的底层实现原理" class="headerlink" title="5 索引的底层实现原理"></a>5 索引的底层实现原理</h4><blockquote>
<p>MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等等，</p>
<p>1、哈希索引</p>
<p>只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</p>
<p>2、全文索引</p>
<p>FULLTEXT（全文）索引，仅可用于<strong>MyISAM和InnoDB</strong>，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，<strong>在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引</strong>。</p>
<p>3、BTree索引和B+Tree索引</p>
</blockquote>
<h4 id="6-使用策略"><a href="#6-使用策略" class="headerlink" title="6 使用策略"></a>6 使用策略</h4><table>
<thead>
<tr>
<th></th>
<th>MyISAM</th>
<th>innoDB</th>
</tr>
</thead>
<tbody><tr>
<td>索引类型</td>
<td>非聚簇</td>
<td>聚簇</td>
</tr>
<tr>
<td>支持事务</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>支持表锁</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>支持行锁</td>
<td>否</td>
<td>是（默认）</td>
</tr>
<tr>
<td>支持外键</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>支持全文索引</td>
<td>是</td>
<td>是（5.6以后支持）</td>
</tr>
<tr>
<td>适用操作类型</td>
<td>大量select下使用</td>
<td>大量insert、delete和update下使用</td>
</tr>
</tbody></table>
<p><strong>MyISAM—非聚簇索引</strong></p>
<p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。</p>
<p>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>下图是MyISAM索引的原理图：</p>
<p><img src="https://images2017.cnblogs.com/blog/758447/201801/758447-20180127161009725-1788644003.png" alt="img"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="https://images2017.cnblogs.com/blog/758447/201801/758447-20180127161153647-1802334548.png" alt="img"></p>
<ul>
<li>MyISAM存储引擎采用的是非聚簇索引，非聚簇索引的<strong>主索引和辅助索引几乎是一样的</strong>，只是主索引不允许重复，不允许空值，他们的<strong>叶子结点的key都存储指向键值对应的数据的物理地址</strong>。</li>
<li>非聚簇索引的<strong>数据表和索引表是分开存储</strong>的。</li>
<li>非聚簇索引中的数据是根据数据的插入顺序保存。因此非聚簇索引更适合单个数据的查询。插入顺序不受键值影响。</li>
<li>只有在MyISAM中才能使用FULLTEXT索引。(mysql5.6以后innoDB也支持全文索引)</li>
</ul>
<p><strong>InnoDB——聚簇索引</strong></p>
<blockquote>
<p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p><img src="https://images2017.cnblogs.com/blog/758447/201801/758447-20180127161454428-323630182.png" alt="img"></p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<ul>
<li>聚簇索引的<strong>主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值</strong>。因此主键的值长度越小越好，类型越简单越好。</li>
<li>聚簇索引的<strong>数据和主键索引存储在一起</strong>。</li>
<li>聚簇索引的数据是根据主键的顺序保存。因此适合按主键索引的区间查找，可以有更少的磁盘I/O，加快查询速度。但是也是因为这个原因，聚簇索引的插入顺序最好按照主键单调的顺序插入，否则会频繁的引起页分裂，严重影响性能。</li>
<li>在InnoDB中，如果只需要查找索引的列，就尽量不要加入其它的列，这样会提高查询效率。</li>
</ul>
</blockquote>
<h3 id="三-脏读"><a href="#三-脏读" class="headerlink" title="三 脏读"></a>三 脏读</h3><blockquote>
<p><code>脏读</code>指一个事务读取了另外一个事务未提交的数据。</p>
<p><code>不可重复读</code>指在一个事务内读取表中的某一行数据，多次读取结果不同。<br>不可重复读和脏读的区别是，脏读是读取前一事务未提交的脏数据，不可重复读是重新读取了前一事务已提交的数据。</p>
<p><code>幻读(虚读)</code>指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。</p>
</blockquote>
<h3 id="四-数据库范式"><a href="#四-数据库范式" class="headerlink" title="四 数据库范式"></a>四 数据库范式</h3><blockquote>
<p>第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分</p>
<p>第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式</p>
<p>第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码</p>
</blockquote>
<h2 id="二-MySQL"><a href="#二-MySQL" class="headerlink" title="二 MySQL"></a>二 MySQL</h2><h3 id="1-mysql的四种隔离状态"><a href="#1-mysql的四种隔离状态" class="headerlink" title="1 mysql的四种隔离状态"></a>1 mysql的四种隔离状态</h3><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="2-MySQL的端口号是多少，如何修改"><a href="#2-MySQL的端口号是多少，如何修改" class="headerlink" title="2 MySQL的端口号是多少，如何修改"></a>2 MySQL的端口号是多少，如何修改</h3><p>查看端口号：</p>
<p>使用命令show global variables like ‘port’;查看端口号 ，mysql的默认端口是3306。（补充：sqlserver默认端口号为：1433；oracle默认端口号为：1521；DB2默认端口号为：5000；PostgreSQL默认端口号为：5432）</p>
<p>修改端口号：</p>
<p>修改端口号：编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。</p>
<h3 id="3-mysql引擎以及其区别"><a href="#3-mysql引擎以及其区别" class="headerlink" title="3 mysql引擎以及其区别"></a>3 mysql引擎以及其区别</h3><blockquote>
<p>在Mysql数据库中，常用的引擎为Innodb和MyIASM。</p>
<p>其中Innodb是一个事务型的存储引擎，有行级锁定和外键约束，提供了对数据库ACID事物的支持，实现了SQL标准的四种隔离级别，即读未提交，不可重复读，可重复读以及串行,其涉及目标就是处理大数据容量的数据库系统。</p>
<p>而MyIASM引擎是Mysql默认的引擎，不提供数据库事务的支持，也不支持行级锁和外键，因此当写操作时需要锁定整个表，效率较低。不过其保存了表的行数，当金星select count(*)form table时，可直接读取已经保存的值，不需要进行全表扫描。因此当表的读操作远多于写操作，并且不需要事务支持时，可以优先选择MyIASM</p>
</blockquote>
<blockquote>
<p>MyISAM：</p>
<ol>
<li>不支持事务，但是每次查询都是原子的；</li>
<li>支持表级锁，即每次操作是对整个表加锁；</li>
<li>存储表的总行数；</li>
<li>一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；</li>
<li>采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。</li>
</ol>
<p>InnoDb：</p>
<ol>
<li>支持ACID的事务，支持事务的四种隔离级别；</li>
<li>支持行级锁及外键约束：因此可以支持写并发；</li>
<li>不存储总行数；</li>
<li>一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；</li>
<li>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</li>
</ol>
</blockquote>
<h3 id="4-MySQL索引语法"><a href="#4-MySQL索引语法" class="headerlink" title="4 MySQL索引语法"></a>4 MySQL索引语法</h3><p>创建索引</p>
<p>根据索引查询</p>
<p>删除索引</p>
<p>查看表中索引</p>
<p>查看查询语句使用索引的情况</p>
<h3 id="5-MySQL语法"><a href="#5-MySQL语法" class="headerlink" title="5 MySQL语法"></a>5 MySQL语法</h3><h4 id="1-请你说一说inner-join和left-join"><a href="#1-请你说一说inner-join和left-join" class="headerlink" title="1. 请你说一说inner join和left join"></a>1. 请你说一说inner join和left join</h4><p>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录<br>inner join(等值连接) 只返回两个表中联结字段相等的行</p>
<h3 id="6-请你介绍一下mysql的MVCC机制"><a href="#6-请你介绍一下mysql的MVCC机制" class="headerlink" title="6 请你介绍一下mysql的MVCC机制"></a>6 请你介绍一下mysql的MVCC机制</h3><p>MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p>
<h3 id="7-请问SQL优化方法有哪些"><a href="#7-请问SQL优化方法有哪些" class="headerlink" title="7 请问SQL优化方法有哪些"></a>7 请问SQL优化方法有哪些</h3><p>通过建立索引对查询进行优化</p>
<p>对查询进行优化，应尽量避免全表扫描</p>
<h3 id="8-请你说一下MySQL引擎和区别"><a href="#8-请你说一下MySQL引擎和区别" class="headerlink" title="8 请你说一下MySQL引擎和区别"></a>8 请你说一下MySQL引擎和区别</h3><p>1、MySQL引擎</p>
<p>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p>
<p>数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。</p>
<p>MySQL存储引擎主要有： MyIsam、InnoDB、Memory、Blackhole、CSV、Performance_Schema、Archive、Federated、Mrg_Myisam。</p>
<p>但是最常用的是InnoDB和Mylsam。</p>
<p>2、InnoDB</p>
<p>InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。</p>
<p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这类型的文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p>
<p>适用场景：</p>
<p>经常更新的表，适合处理多重并发的更新请求。</p>
<p>支持事务。</p>
<p>可以从灾难中恢复（通过bin-log日志等）。</p>
<p>外键约束。只有他支持外键。</p>
<p>支持自动增加列属性auto_increment。</p>
<p>索引结构：</p>
<p>InnoDB也是B+Treee索引结构。Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p>
<p>3、Mylsam</p>
<p>MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整个表，效率便会低一些。MyIsam 存储引擎独立于操作系统，也就是可以在windows上使用，也可以比较简单的将数据转移到linux操作系统上去。</p>
<p>适用场景：</p>
<p>不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。</p>
<p>不支持外键的表设计。</p>
<p>查询速度很快，如果数据库insert和update的操作比较多的话比较适用。</p>
<p>整天对表进行加锁的场景。</p>
<p>MyISAM极度强调快速读取操作。</p>
<p>MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</p>
<p>缺点：就是不能在表损坏后主动恢复数据。</p>
<p>索引结构：</p>
<p>MyISAM索引结构：MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。</p>
<p>3、InnoDB和Mylsam的区别：</p>
<p>1）事务：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。</p>
<p>2）性能：MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。</p>
<p>3）行数保存：InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。</p>
<p>4）索引存储：对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持。</p>
<p>MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</p>
<p>InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。</p>
<p>5）服务器数据备份：InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p>
<p>MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p>
<p>InnoDB是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p>
<p>6）锁的支持：MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p>
<h2 id="三-redis"><a href="#三-redis" class="headerlink" title="三 redis"></a>三 redis</h2><h3 id="1-mongodb和redis的区别"><a href="#1-mongodb和redis的区别" class="headerlink" title="1 mongodb和redis的区别"></a>1 mongodb和redis的区别</h3><blockquote>
<p>内存管理机制上：Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。</p>
</blockquote>
<p>支持的数据结构上：Redis 支持的数据结构丰富，包括hash、set、list等。</p>
<p>MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富</p>
<h3 id="3-Redis的定时机制怎么实现的"><a href="#3-Redis的定时机制怎么实现的" class="headerlink" title="3 Redis的定时机制怎么实现的"></a>3 Redis的定时机制怎么实现的</h3><blockquote>
<p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：文件事件（服务器对套接字操作的抽象）和时间事件（服务器对定时操作的抽象）。Redis的定时机制就是借助时间事件实现的。</p>
<p>一个时间事件主要由以下三个属性组成：id：时间事件标识号；when：记录时间事件的到达时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件</p>
<p>一个时间事件主要由以下三个属性组成：id：时间事件标识号；when：记录时间事件的到达时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件。</p>
</blockquote>
<h3 id="4-Redis是单线程的，为什么高效"><a href="#4-Redis是单线程的，为什么高效" class="headerlink" title="4 Redis是单线程的，为什么高效?"></a>4 Redis是单线程的，为什么高效?</h3><blockquote>
<p>虽然Redis文件事件处理器以单线程方式运行，但是通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p>
</blockquote>
<h3 id="5-Redis的数据类型有哪些，底层怎么实现"><a href="#5-Redis的数据类型有哪些，底层怎么实现" class="headerlink" title="5 Redis的数据类型有哪些，底层怎么实现?"></a>5 Redis的数据类型有哪些，底层怎么实现?</h3><blockquote>
<p>1）字符串：整数值、embstr编码的简单动态字符串、简单动态字符串（SDS)</p>
<p>2）列表：压缩列表、双端链表</p>
<p>3）哈希：压缩列表、字典</p>
<p>4）集合：整数集合、字典</p>
<p>5）有序集合：压缩列表、跳跃表和字典</p>
</blockquote>
<h3 id="6-Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的"><a href="#6-Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的" class="headerlink" title="6 Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的?"></a>6 Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的?</h3><blockquote>
<p>因为redis是单线程，当K很多时，如果一次性将键值对全部rehash，庞大的计算量会影响服务器性能，甚至可能会导致服务器在一段时间内停止服务。不可能一步完成整个rehash操作，所以redis是分多次、渐进式的rehash。渐进性哈希分为两种：</p>
<p>1）操作redis时，额外做一步rehash</p>
<p>对redis做读取、插入、删除等操作时，会把位于table[dict-&gt;rehashidx]位置的链表移动到新的dictht中，然后把rehashidx做加一操作，移动到后面一个槽位。</p>
<p>2）后台定时任务调用rehash</p>
<p>后台定时任务rehash调用链，同时可以通过server.hz控制rehash调用频率</p>
</blockquote>
<h3 id="7-Redis和memcached的区别"><a href="#7-Redis和memcached的区别" class="headerlink" title="7 Redis和memcached的区别"></a>7 Redis和memcached的区别</h3><blockquote>
<p>1）数据类型 ：redis数据类型丰富，支持set liset等类型；memcache支持简单数据类型，需要客户端自己处理复杂对象</p>
<p>2）持久性：redis支持数据落地持久化存储；memcache不支持数据持久存储。)</p>
<p>3）分布式存储：redis支持master-slave复制模式；memcache可以使用一致性hash做分布式。</p>
<p>4）value大小不同：memcache是一个内存缓存，key的长度小于250字符，单个item存储要小于1M，不适合虚拟机使用</p>
<p>5）数据一致性不同：redis使用的是单线程模型，保证了数据按顺序提交；memcache需要使用cas保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作</p>
<p>6）cpu利用：redis单线程模型只能使用一个cpu，可以开启多个redis进程</p>
</blockquote>
<h1 id="六-设计模式"><a href="#六-设计模式" class="headerlink" title="六 设计模式"></a>六 设计模式</h1><blockquote>
<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
</blockquote>
<h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一 简介"></a>一 简介</h2><h4 id="1-概念-3"><a href="#1-概念-3" class="headerlink" title="1. 概念"></a>1. 概念</h4><blockquote>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p>
</blockquote>
<h4 id="2-六大原则"><a href="#2-六大原则" class="headerlink" title="2. 六大原则"></a>2. 六大原则</h4><blockquote>
<p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：<strong>对扩展开放，对内修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
</blockquote>
<h2 id="二-分类"><a href="#二-分类" class="headerlink" title="二 分类"></a>二 分类</h2><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">模式 &amp; 描述</th>
<th align="left">包括</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>创建型模式</strong> <br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。<br>这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>
<td align="left"><strong>工厂模式（</strong>Factory Pattern）<br><strong>抽象工厂模式（Abstract Factory Pattern）</strong><br><strong>单例模式（Singleton Pattern）</strong><br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>结构型模式</strong><br>这些设计模式关注类和对象的组合。<br>继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td align="left"><strong>代理模式（Proxy Pattern）</strong><br><strong>装饰器模式（Decorator Pattern）</strong><br>适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>行为型模式</strong> <br>这些设计模式特别关注对象之间的通信。</td>
<td align="left"><strong>观察者模式（Observer Pattern）<br></strong>责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>J2EE 模式</strong> <br>这些设计模式特别关注表示层。<br>这些模式是由 Sun Java Center 鉴定的。</td>
<td align="left">MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）<br>组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）<br>拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern）</td>
</tr>
</tbody></table>
<h4 id="设计模式之间的关系"><a href="#设计模式之间的关系" class="headerlink" title="设计模式之间的关系"></a>设计模式之间的关系</h4><p><img src="/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/../../Nutstore/aseets/image-20200818164627077.png" alt="image-20200818164627077"></p>
<h2 id="三-设计模式"><a href="#三-设计模式" class="headerlink" title="三 设计模式"></a>三 设计模式</h2><h3 id="0-常见设计模式"><a href="#0-常见设计模式" class="headerlink" title="0 常见设计模式"></a>0 常见设计模式</h3><ol>
<li>单例模式：单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</li>
<li>工厂模式：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。</li>
<li>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li>
</ol>
<h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><h4 id="A-简介"><a href="#A-简介" class="headerlink" title="A. 简介"></a>A. 简介</h4><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h4 id="B-介绍"><a href="#B-介绍" class="headerlink" title="B.介绍"></a>B.介绍</h4><table>
<thead>
<tr>
<th></th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>意图</td>
<td>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</td>
</tr>
<tr>
<td>主要解决</td>
<td>一个全局使用的类频繁地创建与销毁。</td>
</tr>
<tr>
<td>何时使用</td>
<td>当您想控制实例数目，节省系统资源的时候。</td>
</tr>
<tr>
<td>如何解决</td>
<td>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</td>
</tr>
<tr>
<td>关键代码</td>
<td>构造函数是私有的。</td>
</tr>
<tr>
<td>优点</td>
<td>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 <br>2、避免对资源的多重占用（比如写文件操作）。</td>
</tr>
<tr>
<td>缺点</td>
<td>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</td>
</tr>
<tr>
<td><strong>应用实例</strong></td>
<td>1、一个班级只有一个班主任。<br> 2、Windows 是多进程多线程的，<br>在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，<br>所以所有文件的处理必须通过唯一的实例来进行。 <br>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</td>
</tr>
<tr>
<td>使用场景</td>
<td>1、要求生产唯一序列号。<br>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 <br>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</td>
</tr>
<tr>
<td>注意事项</td>
<td>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</td>
</tr>
</tbody></table>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>单例模式有许多种实现方法，在C++中，甚至可以直接用一个全局变量做到这一点，但这样的代码显的很不优雅。 使用全局对象能够保证方便地访问实例，但是不能保证只声明一个对象——也就是说除了一个全局实例外，仍然能创建相同类的本地实例。<br>《设计模式》一书中给出了一种很不错的实现，定义一个单例类，使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。 单例模式通过类本身来管理其唯一实例，这种特性提供了解决问题的方法。唯一的实例是类的一个普通对象，但设计这个类时，让它只能创建一个实例并提供对此实例的全局访问。唯一实例类Singleton在静态成员函数中隐藏创建实例的操作。习惯上把这个成员函数叫做Instance()，它的返回值是唯一实例的指针。</p>
<h4 id="C-的实现"><a href="#C-的实现" class="headerlink" title="C++的实现"></a>C++的实现</h4><ol>
<li><p>一种通过局部静态变量，利用其只初始化一次的特点，返回对象。</p>
</li>
<li><p>另外一种，则是定义全局的指针，<code>getInstance</code>判断该指针是否为空，为空时才实例化对象</p>
</li>
</ol>
<p><strong>1. 饿汉式：基于class loader机制避免多线程的同步问题，不过，instance在类装载时就实例化，可能会产生垃圾对象。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Csingleton m_pInstance = <span class="keyword">new</span> CSingleton();<span class="comment">// 直接初始化一个实例对象</span></span><br><span class="line">    <span class="keyword">private</span>: CSingleton()&#123;    <span class="comment">//构造函数是私有的,保证其他类对象不能直接new一个该对象的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">static</span> CSingleton <span class="title">GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>2. 懒汉式：通过双重锁机制实现线程安全</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CSingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CSingleton *m_pInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CSingleton</span><span class="params">()</span></span>&#123;	<span class="comment">//构造函数是私有的</span></span><br><span class="line">        &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CSingleton * <span class="title">GetInstance</span><span class="params">()</span></span>&#123; <span class="comment">//对获取实例的方法进行同步</span></span><br><span class="line">		<span class="keyword">if</span>(m_pInstance == <span class="literal">NULL</span>)  <span class="comment">//判断是否第一次调用</span></span><br><span class="line">        &#123;</span><br><span class="line">            synchronnized(CSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(m_pInstance == <span class="literal">NULL</span>)</span><br><span class="line">                	m_pInstance = <span class="keyword">new</span> CSingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;			</span><br><span class="line">		<span class="keyword">return</span> m_pInstance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>另一个写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////// 内部静态变量的懒汉实现（C++11 线程安全）////////////////// </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// 获取单实例对象 </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Single &amp;<span class="title">GetInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="comment">// 局部静态特性的方式实现单实例 </span></span><br><span class="line">        <span class="keyword">static</span> Single signal;  <span class="comment">// 如果含有数据成员，需要修改构造函数对数据进行初始化</span></span><br><span class="line">        <span class="keyword">return</span> signal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还需要定义一些外部函数 </span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">// 禁止外部构造 </span></span><br><span class="line">    Single(); </span><br><span class="line">    <span class="comment">// 禁止外部析构 </span></span><br><span class="line">    ~Single(); </span><br><span class="line">    <span class="comment">// 禁止外部复制构造 </span></span><br><span class="line">    Single(<span class="keyword">const</span> Single &amp;signal); </span><br><span class="line">    <span class="comment">// 禁止外部赋值操作 </span></span><br><span class="line">    <span class="keyword">const</span> Single &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Single &amp;signal); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/////////////////// 内部静态变量的懒汉实现 //////////////////</span></span><br></pre></td></tr></table></figure>



<h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h3><p>工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。</p>
<p>优点：解耦，代码复用，更改功能容易。</p>
<h3 id="5-装饰器模式"><a href="#5-装饰器模式" class="headerlink" title="5. 装饰器模式"></a>5. 装饰器模式</h3><p>装饰器模式主要是为了动态的为一个对象增加新的功能，装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</p>
<p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p>缺点：多层装饰比较复杂。</p>
<p>使用场景：1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>
<h3 id="6-观察者模式"><a href="#6-观察者模式" class="headerlink" title="6. 观察者模式"></a>6. 观察者模式</h3><p>观察者模式中分为观察者和被观察者，当被观察者发生装填改变时，观察者会受到通知。主要为了解决对象状态改变给其他对象通知的问题，其实现类似于观察者在被观察者那注册了一个回调函数。</p>
<h1 id="七-其他内容"><a href="#七-其他内容" class="headerlink" title="七 其他内容"></a>七 其他内容</h1><h2 id="一-Git"><a href="#一-Git" class="headerlink" title="一 Git"></a>一 Git</h2><h3 id="0-Git常用指令"><a href="#0-Git常用指令" class="headerlink" title="0 Git常用指令"></a>0 Git常用指令</h3><h4 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git init <span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init [project-name]	<span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]	<span class="comment"># 下载一个项目和它的整个代码历史</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h4><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list <span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config -e [--global]	<span class="comment"># 编辑Git配置文件</span></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">"[name]"</span></span><br><span class="line">$ git config [--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add [file1] [file2] ... 	<span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [dir]		<span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add .		<span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line">$ git add -p	<span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git rm [file1] [file2] ...<span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm --cached [file]	<span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]	<span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m [message]	<span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]	<span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit -a		<span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -v		<span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line">$ git commit --amend -m [message]	<span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...	<span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git branch	<span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch -r		<span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -a		<span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch [branch-name]	<span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git checkout -b [branch]	<span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git branch [branch] [commit]	<span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]	<span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git checkout [branch-name]	<span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout -	<span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]	<span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git merge [branch]	<span class="comment"># 合并指定分支到当前分</span></span><br><span class="line">$ git cherry-pick [commit]	<span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git branch -d [branch-name]	<span class="comment"># 删除分支</span></span><br><span class="line">$ git push origin --delete [branch-name]	<span class="comment"># 删除远程分支</span></span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git tag	<span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag [tag]		<span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag] [commit]	<span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag -d [tag]		<span class="comment"># 删除本地tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]	<span class="comment"># 删除远程tag</span></span><br><span class="line">$ git show [tag]	<span class="comment"># 查看tag信息</span></span><br><span class="line">$ git push [remote] [tag]	<span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] --tags	<span class="comment"># 提交所有tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]	<span class="comment"># 新建一个分支，指向某个tag</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git status	<span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span>	<span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span>	<span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]	<span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s	<span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature	<span class="comment"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]	</span><br><span class="line">$ git whatchanged [file]	</span><br><span class="line">$ git <span class="built_in">log</span> -p [file]		<span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline 	<span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git shortlog -sn <span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git blame [file]	<span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git diff	<span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff --cached [file]	<span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff HEAD	<span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]	<span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span>	<span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git show [commit]	<span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show --name-only [commit]	<span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show [commit]:[filename]	<span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git reflog	<span class="comment"># 显示当前分支的最近几次提交</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote]	<span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git remote -v	<span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote show [remote]	<span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote add [shortname] [url]	<span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git pull [remote] [branch]	<span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git push [remote] [branch]	<span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] --force		<span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --all	<span class="comment"># 推送所有分支到远程仓库</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout [file]	<span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [commit] [file]	<span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout .	<span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git reset [file]	<span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset --hard	<span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset [commit]	<span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset --hard [commit]	<span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --keep [commit]	<span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-请你回答一下git中Merge和rebase区别"><a href="#1-请你回答一下git中Merge和rebase区别" class="headerlink" title="1. 请你回答一下git中Merge和rebase区别"></a>1. 请你回答一下git中Merge和rebase区别</h3><blockquote>
<p>Merge会自动根据两个分支的共同祖先和两个分支的最新提交 进行一个三方合并，然后将合并中修改的内容生成一个新的 commit，即merge合并两个分支并生成一个新的提交,并且仍然后保存原来分支的commit记录。</p>
<p>Rebase会从两个分支的共同祖先开始提取当前分支上的修改，然后将当前分支上的所有修改合并到目标分支的最新提交后面，如果提取的修改有多个，那git将依次应用到最新的提交后面。Rebase后只剩下一个分支的commit记录</p>
</blockquote>
<h2 id="二-Linux"><a href="#二-Linux" class="headerlink" title="二 Linux"></a>二 Linux</h2><h3 id="1-Linux下怎么得到一个文件的100到200行"><a href="#1-Linux下怎么得到一个文件的100到200行" class="headerlink" title="1. Linux下怎么得到一个文件的100到200行"></a>1. Linux下怎么得到一个文件的100到200行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#39;100,200p&#39; inputfile</span><br><span class="line">awk &#39;NR&gt;&#x3D;100&amp;&amp;NR&lt;&#x3D;200&#123;print&#125;&#39; inputfile</span><br><span class="line">### head -200 inputfile|tail -100</span><br></pre></td></tr></table></figure>



<h3 id="2-linux内核中的Timer-定时器机制"><a href="#2-linux内核中的Timer-定时器机制" class="headerlink" title="2. linux内核中的Timer 定时器机制"></a>2. linux内核中的Timer 定时器机制</h3><h4 id="1）低精度时钟"><a href="#1）低精度时钟" class="headerlink" title="1）低精度时钟"></a>1）低精度时钟</h4><blockquote>
<p>Linux 2.6.16之前，内核只支持低精度时钟，内核定时器的工作方式</p>
<p>1、系统启动后，会读取时钟源设备(RTC, HPET，PIT…)，初始化当前系统时间。</p>
<p>2、内核会根据HZ(系统定时器频率，节拍率)参数值，设置时钟事件设备，启动tick(节拍)中断。HZ表示1秒种产生多少个时钟硬件中断，tick就表示连续两个中断的间隔时间。</p>
<p>3、设置时钟事件设备后，时钟事件设备会定时产生一个tick中断，触发时钟中断处理函数，更新系统时钟,并检测timer wheel，进行超时事件的处理。</p>
<p>在上面工作方式下，Linux 2.6.16 之前，内核软件定时器采用timer wheel多级时间轮的实现机制，维护操作系统的所有定时事件。timer wheel的触发是基于系统tick周期性中断。</p>
<p>所以说这之前，linux只能支持ms级别的时钟，随着时钟源硬件设备的精度提高和软件高精度计时的需求，有了高精度时钟的内核设计。</p>
</blockquote>
<h4 id="2）高精度时钟"><a href="#2）高精度时钟" class="headerlink" title="2）高精度时钟"></a>2）高精度时钟</h4><blockquote>
<p>Linux 2.6.16 ，内核支持了高精度的时钟，内核采用新的定时器hrtimer，其实现逻辑和Linux 2.6.16 之前定时器逻辑区别：</p>
<p>hrtimer采用红黑树进行高精度定时器的管理，而不是时间轮；</p>
<p>高精度时钟定时器不在依赖系统的tick中断，而是基于事件触发。</p>
<p>旧内核的定时器实现依赖于系统定时器硬件定期的tick，基于该tick，内核会扫描timer wheel处理超时事件，会更新jiffies，wall time(墙上时间，现实时间)，process的使用时间等等工作。</p>
<p>新的内核不再会直接支持周期性的tick，新内核定时器框架采用了基于事件触发，而不是以前的周期性触发。新内核实现了hrtimer(high resolution timer)：于事件触发。</p>
</blockquote>
<h4 id="hrtimer的工作原理"><a href="#hrtimer的工作原理" class="headerlink" title="hrtimer的工作原理"></a>hrtimer的工作原理</h4><blockquote>
<p>通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的Timer 的时间，时钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。</p>
<p>在高精度时钟模式下，操作系统内核仍然需要周期性的tick中断，以便刷新内核的一些任务。hrtimer是基于事件的，不会周期性出发tick中断，所以为了实现周期性的tick中断(dynamic tick)：系统创建了一个模拟 tick 时钟的特殊 hrtimer，将其超时时间设置为一个tick时长，在超时回来后，完成对应的工作，然后再次设置下一个tick的超时时间，以此达到周期性tick中断的需求。</p>
<p>引入了dynamic tick，是为了能够在使用高精度时钟的同时节约能源，这样会产生tickless 情况下，会跳过一些 tick。</p>
<p>新内核对相关的时间硬件设备进行了统一的封装，定义了主要有下面两个结构：</p>
<p>时钟源设备(closk source device)：抽象那些能够提供计时功能的系统硬件，比如 RTC(Real Time Clock)、TSC(Time Stamp Counter)，HPET，ACPI PM-Timer，PIT等。不同时钟源提供的精度不一样，现在pc大都是支持高精度模式(high-resolution mode)也支持低精度模式(low-resolution mode)。</p>
<p>时钟事件设备(clock event device)：系统中可以触发 one-shot（单次）或者周期性中断的设备都可以作为时钟事件设备。</p>
<p>当前内核同时存在新旧timer wheel 和 hrtimer两套timer的实现，内核启动后会进行从低精度模式到高精度时钟模式的切换，hrtimer模拟的tick中断将驱动传统的低精度定时器系统（基于时间轮）和内核进程调度。</p>
</blockquote>
<h3 id="3-awk的使用"><a href="#3-awk的使用" class="headerlink" title="3. awk的使用"></a>3. awk的使用</h3><blockquote>
<p>AWK 是Linux下一种处理文本文件的语言，是一个强大的文本分析工具。</p>
<h4 id="1）作用"><a href="#1）作用" class="headerlink" title="1）作用"></a>1）作用</h4><p>样式扫描和处理语言。它允许创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p>
<h4 id="2）用法"><a href="#2）用法" class="headerlink" title="2）用法"></a>2）用法</h4><p>awk [-F  field-separator]  ‘commands’  input-file(s)</p>
<h4 id="3）内置变量"><a href="#3）内置变量" class="headerlink" title="3）内置变量"></a>3）内置变量</h4><table>
<thead>
<tr>
<th>ARGC</th>
<th>命令行参数个数</th>
</tr>
</thead>
<tbody><tr>
<td>ARGV</td>
<td>命令行参数排列</td>
</tr>
<tr>
<td>ENVIRON</td>
<td>支持队列中系统环境变量的使用</td>
</tr>
<tr>
<td>FILENAME</td>
<td>awk浏览的文件名</td>
</tr>
<tr>
<td>FNR</td>
<td>浏览文件的记录数</td>
</tr>
<tr>
<td>FS</td>
<td>设置输入域分隔符，等价于命令行 -F选项</td>
</tr>
<tr>
<td>NF</td>
<td>浏览记录的域的个数</td>
</tr>
<tr>
<td>NR</td>
<td>已读的记录数</td>
</tr>
<tr>
<td>OFS</td>
<td>输出域分隔符</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符</td>
</tr>
<tr>
<td>RS</td>
<td>控制记录分隔符</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="4）实例"><a href="#4）实例" class="headerlink" title="4）实例"></a>4）实例</h4><blockquote>
<p>1、找到当前文件夹下所有的文件和子文件夹,并显示文件大小</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\&gt; ls -l | awk <span class="string">'&#123;print $5 "\t" $9&#125;'</span></span><br></pre></td></tr></table></figure>

<p>读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域。$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”。</p>
<p>2、找到当前文件夹下所有的文件和子文件夹，并显示文件大小，并显示排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls -l | awk &#39;BEGIN &#123;COUNT &#x3D; -1; print &quot;BEGIN COUNT&quot;&#125;</span><br><span class="line">&#123;COUNT &#x3D; COUNT + 1; print COUNT&quot;\t&quot;$5&quot;\t&quot;$9&#125;</span><br><span class="line">END &#123;print &quot;END, COUNT &#x3D; &quot;COUNT&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>先处理BEGIN， 然后进行文本分析，进行第二个{}的操作，分析完进行END操作。</p>
<p>3、找到当前文件夹下所有的子文件夹,并显示排序</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\&gt; ls -l | awk 'BEGIN &#123;<span class="built_in">print</span> "BEGIN COUNT"&#125; /<span class="number">4096</span>/&#123;<span class="built_in">print</span> NR"\t"$<span class="number">5</span>"\t"$<span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line">END &#123;<span class="built_in">print</span> "END"&#125;'</span><br></pre></td></tr></table></figure>

<p>* /4096/ 正则匹配式子</p>
<p>* 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推。</p>
</blockquote>
<h3 id="4-linux-的索引节点"><a href="#4-linux-的索引节点" class="headerlink" title="4. linux 的索引节点"></a>4. linux 的索引节点</h3><blockquote>
<p>inode包含文件的元信息，具体来说有以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 文件的字节数</span><br><span class="line">* 文件拥有者的User ID</span><br><span class="line">* 文件的Group ID</span><br><span class="line">* 文件的读、写、执行权限</span><br><span class="line">* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</span><br><span class="line">* 链接数，即有多少文件名指向这个inode</span><br><span class="line">* 文件数据block的位置</span><br></pre></td></tr></table></figure>

<p>至于为什么没有文件名，是因为由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</span><br><span class="line">2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。</span><br><span class="line">3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-Linux-文件操作"><a href="#5-Linux-文件操作" class="headerlink" title="5. Linux 文件操作"></a>5. Linux 文件操作</h3><blockquote>
<p>&gt;        输出重定向到一个文件或设备 覆盖原来的文件<br>&gt;!       输出重定向到一个文件或设备 强制覆盖原来的文件<br>&gt;&gt;       输出重定向到一个文件或设备 追加原来的文件<br>&lt;        输入重定向到一个程序 </p>
</blockquote>
<h3 id="awk-命令"><a href="#awk-命令" class="headerlink" title="awk 命令"></a>awk 命令</h3><blockquote>
<ul>
<li>-F fs or –field-separator fs<br>指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。</li>
<li>-v var=value or –asign var=value<br>赋值一个用户定义变量。</li>
<li>-f scripfile or –file scriptfile<br>从脚本文件中读取awk命令。</li>
<li>-mf nnn and -mr nnn<br>对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li>
<li>-W compact or –compat, -W traditional or –traditional<br>在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</li>
<li>-W copyleft or –copyleft, -W copyright or –copyright<br>打印简短的版权信息。</li>
<li>-W help or –help, -W usage or –usage<br>打印全部awk选项和每个选项的简短说明。</li>
<li>-W lint or –lint<br>打印不能向传统unix平台移植的结构的警告。</li>
<li>-W lint-old or –lint-old<br>打印关于不能向传统unix平台移植的结构的警告。</li>
<li>-W posix<br>打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符<strong>和</strong>=不能代替^和^=；fflush无效。</li>
<li>-W re-interval or –re-inerval<br>允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。</li>
<li>-W source program-text or –source program-text<br>使用program-text作为源代码，可与-f命令混用。</li>
<li>-W version or –version<br>打印bug报告信息的版本。</li>
</ul>
</blockquote>
<h2 id="三-GDB调试"><a href="#三-GDB调试" class="headerlink" title="三 GDB调试"></a>三 GDB调试</h2><p>GNU symbolic debugger，简称「<strong>GDB 调试器</strong>」，是 Linux 平台下最常用的一款程序调试器。GDB 编译器通常以 gdb 命令的形式在终端（Shell）中使用，它有很多选项，这是我们要重点学习的。</p>
<p>发展至今，GDB 调试器已经对 C、C++、Go、Objective-C、OpenCL、Ada 等多种编程语言提供了支持。实际场景中，GDB 更常用来调试 C 和 C++ 程序，虽然 Linux 平台下有很多能编写 C、C++ 代码的集成开发工具（IDE），但它们调试代码的能力往往都源自 GDB 调试器。</p>
<p>调试是开发流程中一个非常重要的环境，每个程序员都应具备调试代码的能力，尤其对于从事 Linux C/C++ 开发的读者，必须具备熟练使用 GDB 调试器的能力。</p>
<p>通过调试程序，我们可以监控程序执行的每一个细节，包括变量的值、函数的调用过程、内存中数据、线程的调度等，从而发现隐藏的错误或者低效的代码。</p>
<h2 id="四-Cmake"><a href="#四-Cmake" class="headerlink" title="四 Cmake"></a>四 Cmake</h2><h1 id="八-面试经历"><a href="#八-面试经历" class="headerlink" title="八 面试经历"></a>八 面试经历</h1><h2 id="一-网易雷火"><a href="#一-网易雷火" class="headerlink" title="一 网易雷火"></a>一 网易雷火</h2><table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>C++</td>
<td>Volatile<br>C++的编译过程</td>
</tr>
<tr>
<td>操作系统</td>
<td>1. 进程与线程的区别；<br>2. 自旋锁 互斥锁<br>3.</td>
</tr>
<tr>
<td></td>
<td>死锁的四个条件</td>
</tr>
<tr>
<td></td>
<td>生产者消费者问题</td>
</tr>
<tr>
<td>计算机网络</td>
<td>四次挥手</td>
</tr>
<tr>
<td>手撕代码</td>
<td>根据前序遍历结果和中序遍历结果得到后序遍历结果<br>#define</td>
</tr>
<tr>
<td></td>
<td>1-n丢了两个数 怎么找出来？</td>
</tr>
<tr>
<td></td>
<td>首先：位运算中异或的性质：<strong>两个相同数字异或=0</strong>，<strong>一个数和0异或还是它本身</strong>。<br>当<strong>只有一个数出现一次</strong>时，我们把数组中所有的数，依次异或运算，最后剩下的就是落单的数，因为成对儿出现的都抵消了。<br>依照这个思路，我们来看两个数（我们假设是AB）出现一次的数组。<br>我们首先还是先异或，剩下的数字肯定是A、B异或的结果，<strong>这个结果的二进制中的1，表现的是A和B的不同的位</strong>。<br>我们就取第一个1所在的位数，假设是第3位，接着把原数组分成<strong>两组</strong>，分组标准是第3位是否为1。<br>如此，<strong>相同的数肯定在一个组</strong>，因为相同数字所有位都相同，而不同的数，<strong>肯定不在一组</strong>。<br>然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。</td>
</tr>
<tr>
<td>反问环节</td>
<td></td>
</tr>
<tr>
<td>结果</td>
<td>人才库</td>
</tr>
</tbody></table>
<p>找丢失的数可以使用异或位运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k:data) ret^=k;</span><br><span class="line">    ret &amp;= (-ret);</span><br><span class="line">    *num1 = <span class="number">0</span>,*num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k:data)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;ret) *num1^=k;</span><br><span class="line">        <span class="keyword">else</span> *num2^=k;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-猿辅导"><a href="#二-猿辅导" class="headerlink" title="二 猿辅导"></a>二 猿辅导</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><blockquote>
<p>做了两个算法题，题目：</p>
<ol>
<li><p>给定一个vector&lt;vector<string>&gt;表示一个段落，其中的vector<string> 表示段落，string表示句子，我们希望一个页面中最多有五句话，同一个段落尽量在同一个页面。因此需要重新划分段落，让他们尽量在同一个页面。</string></string></p>
<p>如果给定的大小为<code>{3,2,1,6,1}</code>，则最后得到的应该是<code>{5,1,5,2}</code></p>
</li>
</ol>
<ol start="2">
<li><h4 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">K 个一组翻转链表</a></h4><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p><strong>示例：</strong></p>
<p>给你这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>当 <em>k</em> = 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>当 <em>k</em> = 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
</li>
</ol>
<p>   我用了一个迭代的思路去做，写题用了10min 最后给面试官讲题用了10分钟，没有时间问我基础知识了，很开心</p>
</blockquote>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>准备：专心致志把网络+算法+数据结构+CPP+操作系统搞定。据说数据库没那么重要之后再学习吧。</p>
<table>
<thead>
<tr>
<th>二面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>C++</td>
<td>1. 指针与引用的区别<br>2. C++中的智能指针</td>
</tr>
<tr>
<td>操作系统</td>
<td>进程与线程的区别；<br>线程共享的是什么东西；<br>一个线程崩溃会不会影响别的线程</td>
</tr>
<tr>
<td></td>
<td>进程中有哪些锁及其机制</td>
</tr>
<tr>
<td></td>
<td>讲讲虚拟内存</td>
</tr>
<tr>
<td>计算机网络</td>
<td>1. HTTP协议中有哪些方法（GET、POST）细说；<br>2. 谈谈Cookie</td>
</tr>
<tr>
<td>手撕代码</td>
<td>删除第K个链表结点（双指针）<br><br>需要注意一下细节；</td>
</tr>
<tr>
<td></td>
<td>之字形遍历二叉树；<br>我用了一个栈把偶数层的数字倒腾一下，然后逆序输出；<br>面试官想要一个更优的解法，没有想出来。<br>最后LeetCode上说是需要用一个双端队列。</td>
</tr>
<tr>
<td>反问环节</td>
<td>数据库的内容相对于客户端开发来说有多重要<br>答：没那么重要，一般都是封装好的。只有数据分析的时候才会用到</td>
</tr>
<tr>
<td>结果</td>
<td>人才库</td>
</tr>
</tbody></table>
<h2 id="三-小米"><a href="#三-小米" class="headerlink" title="三 小米"></a>三 小米</h2><table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td>面试官做过SLAM和可穿戴算法。对项目比较感兴趣。<br>讲过的点主要有：<br>1. 相机的投影模型；IMU的测量模型；相机与IMU的联合标定<br>2. 卡尔曼滤波跟非线性优化的区别，以及为什么要用非线性优化<br>3. 高斯牛顿法和随机梯度下降 凸优化问题<br>4. 雅克比矩阵、海森矩阵与上述两种方法的对应关系</td>
</tr>
<tr>
<td>代码题</td>
<td>股票收益问题（买入和卖出一次，收益的最大值）。</td>
</tr>
<tr>
<td>反问</td>
<td>可穿戴的产品主要有哪些：手环和手表<br>可穿戴产品中的信息源主要有哪些？PPG(生理信号，心率 血糖 血氧)；ECG(运动用户)<br>如果后续有面试，会安排在什么时候？面试官说肯定有，想要个算法的还是工程的，我选了工程的</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>二面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td>工程面直接手撕了三个题</td>
</tr>
<tr>
<td>C语言基础知识</td>
<td>C语言纠错题<br>   1. return 0;表示的意思<br>   2. malloc free一一要对应<br>   3. sizeof()的大小；strlen统计字符串长度<br></td>
</tr>
<tr>
<td>代码题</td>
<td>2. 翻转链表<br>   1. 最好不要用哨兵节点，面试官嫌弃浪费空间；<br>3. 判断数字是不是回文数字<br>   1. 不要用C++转换为字符串来做（不要调string类）<br>   2. 最后的做法 a除10取余， b = b*10+m;保存到另外一个数字b中，最后看a和b是不是相等</td>
</tr>
<tr>
<td>反问</td>
<td>算法与工程之间的关系：<br>没有高下之分，都很重要，但可穿戴算法岗还是更偏算法</td>
</tr>
</tbody></table>
<h2 id="四-奇安信"><a href="#四-奇安信" class="headerlink" title="四 奇安信"></a>四 奇安信</h2><table>
<thead>
<tr>
<th>一面</th>
<th>聊了20分钟项目和常用的环境 面试官说没有啥想问的了，之后可能是看我笔试成绩不错 给了二面机会</th>
</tr>
</thead>
<tbody><tr>
<td>二面</td>
<td>sizeof()；<br>删除链表中的重复元素II<br>删除容器中的偶数元素（尽量用优雅一点的方法）；<br>函数指针的定义等等</td>
</tr>
<tr>
<td>三面</td>
<td>平常的学习方法；<br>城市要求；<br>自己的学习优势</td>
</tr>
</tbody></table>
<h2 id="五-深信服"><a href="#五-深信服" class="headerlink" title="五 深信服"></a>五 深信服</h2><table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td></td>
</tr>
<tr>
<td>C++</td>
<td>多态；虚函数</td>
</tr>
<tr>
<td>算法与数据结构</td>
<td>哈希表</td>
</tr>
<tr>
<td>操作系统</td>
<td>进程的通信方式</td>
</tr>
<tr>
<td>计算机网络</td>
<td>1. TCP与UDP的区别<br>2. TCP/IP五层网络模型</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td></td>
</tr>
<tr>
<td>C++</td>
<td>多态的介绍</td>
</tr>
<tr>
<td></td>
<td>虚函数重写机制及原理（虚函数表指针）</td>
</tr>
<tr>
<td></td>
<td>内存对齐的介绍</td>
</tr>
<tr>
<td></td>
<td>智能指针的原理</td>
</tr>
<tr>
<td>算法与数据结构</td>
<td>哈希表<br>哈希表冲突的解决方式<br>扩容原理</td>
</tr>
<tr>
<td></td>
<td>红黑树与B树介绍一下（答不上来）</td>
</tr>
<tr>
<td>操作系统</td>
<td>进程的通信方式</td>
</tr>
<tr>
<td>手撕代码</td>
<td>白纸上手写翻转链表</td>
</tr>
<tr>
<td>开放性问题</td>
<td>1千万条域名怎么找出其中的一条域名</td>
</tr>
<tr>
<td></td>
<td>马走日，从一个起点到终点的最短距离</td>
</tr>
</tbody></table>
<h2 id="六-腾讯"><a href="#六-腾讯" class="headerlink" title="六 腾讯"></a>六 腾讯</h2><table>
<thead>
<tr>
<th>一面挂流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td>面试官深问过后 觉得我没有什么工作量</td>
</tr>
<tr>
<td>C++</td>
<td></td>
</tr>
<tr>
<td></td>
<td>static关键字的作用</td>
</tr>
<tr>
<td></td>
<td>array与list 的区别</td>
</tr>
<tr>
<td></td>
<td>哈希表；stl；map；unordered_map</td>
</tr>
<tr>
<td></td>
<td>多态 cpp struct A {     int a;     virtual int func(); }; sizeof(A);</td>
</tr>
<tr>
<td>其它工具</td>
<td>gdb；</td>
</tr>
<tr>
<td>Linux</td>
<td>awk；</td>
</tr>
<tr>
<td>Git</td>
<td>git</td>
</tr>
<tr>
<td>代码题</td>
<td>二分查找</td>
</tr>
<tr>
<td></td>
<td>链表翻转</td>
</tr>
<tr>
<td></td>
<td>层序遍历；按行输出</td>
</tr>
<tr>
<td>结果</td>
<td>人才库</td>
</tr>
</tbody></table>
<h2 id="七-字节跳动（头条）"><a href="#七-字节跳动（头条）" class="headerlink" title="七 字节跳动（头条）"></a>七 字节跳动（头条）</h2><table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td>Git<br>怎么做的滤波</td>
</tr>
<tr>
<td>C++</td>
<td>多态与虚函数机制</td>
</tr>
<tr>
<td></td>
<td>vector的扩容原理</td>
</tr>
<tr>
<td></td>
<td>map与unordered_map的区别；<br>哈希表的缺点<br>哈希表与红黑树相比有什么缺点</td>
</tr>
<tr>
<td>数据结构</td>
<td>哈希表的优点和缺点<br>哈希表怎么解决冲突的</td>
</tr>
<tr>
<td>OS</td>
<td>进程与线程的区别</td>
</tr>
<tr>
<td></td>
<td>进程的通信方式<br>管道为什么不属于系统IPC？<br>进程有哪些状态<br>线程有哪些状态<br>异常和中断</td>
</tr>
<tr>
<td>计算机网络</td>
<td>TCP与UDP协议的区别<br>HTTP与HTTPS协议</td>
</tr>
<tr>
<td>代码题</td>
<td>决策树的剪枝<br>使用递归的方法进行剪枝，先减掉左右子树的枝子，再减根节点的就可一</td>
</tr>
<tr>
<td></td>
<td>层序遍历；按行输出</td>
</tr>
<tr>
<td>面试官建议</td>
<td>下一次复习操作系统的知识点，可能会考很多；包括锁什么的`</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>二面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>C++</td>
<td>多态与虚函数机制</td>
</tr>
<tr>
<td></td>
<td>模板与define的区别（答错了）</td>
</tr>
<tr>
<td></td>
<td>new和malloc的区别</td>
</tr>
<tr>
<td></td>
<td>右值引用（瞎答了）</td>
</tr>
<tr>
<td>数据结构</td>
<td>不需要辅助空间的排序算法（快排不算）</td>
</tr>
<tr>
<td></td>
<td>归并排序</td>
</tr>
<tr>
<td></td>
<td>快速排序和归并排序的区别（中招了）</td>
</tr>
<tr>
<td>OS</td>
<td>进程与线程的区别</td>
</tr>
<tr>
<td></td>
<td>进程调度算法</td>
</tr>
<tr>
<td></td>
<td>僵尸进程（不清楚）</td>
</tr>
<tr>
<td></td>
<td>异常和中断</td>
</tr>
<tr>
<td></td>
<td>虚拟内存；分块的程序被加载到了哪里（想不起来）；其实是（cache）</td>
</tr>
<tr>
<td>设计模式</td>
<td>观察者模式</td>
</tr>
<tr>
<td></td>
<td>怎么实现观察者模式（乱说一通）</td>
</tr>
<tr>
<td>Git</td>
<td>怎么合并分支</td>
</tr>
<tr>
<td>代码题</td>
<td>单链表中，奇数节点有序、偶数节点有序，试着在O（n）的时间复杂度内重排整个链表</td>
</tr>
</tbody></table>
<p>代码题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;8-&gt;3-&gt;6-&gt;5-&gt;4-&gt;7-&gt;2-&gt;9&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;重排之后如下:</span><br><span class="line">1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9</span><br><span class="line">&#x2F;&#x2F;我的思路，拆分链表，翻转链表，合并链表</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>三面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>算法与数据结构</td>
<td>讲一下快排和归并的区别</td>
</tr>
<tr>
<td></td>
<td>单链表怎么进行快排</td>
</tr>
<tr>
<td>代码题</td>
<td>判断当前是否发生了死锁</td>
</tr>
<tr>
<td>聊天</td>
<td></td>
</tr>
</tbody></table>
<h2 id="八-网易互娱"><a href="#八-网易互娱" class="headerlink" title="八 网易互娱"></a>八 网易互娱</h2><table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td>Git<br>怎么做的滤波</td>
</tr>
<tr>
<td>C++</td>
<td>多态与虚函数机制<br>C++中的智能指针<br>虚函数与纯虚函数<br>泛型编程（不会）</td>
</tr>
<tr>
<td></td>
<td>vector的扩容原理</td>
</tr>
<tr>
<td></td>
<td>map与unordered_map的区别；<br>vector与list的区别</td>
</tr>
<tr>
<td>数据结构</td>
<td>哈希表的构造方法<br>哈希表怎么解决冲突的</td>
</tr>
<tr>
<td>OS</td>
<td>进程与线程的区别<br>僵尸进程</td>
</tr>
<tr>
<td></td>
<td>进程的通信方式<br>介绍一下虚拟内存<br>异常和中断</td>
</tr>
<tr>
<td>计算机网络</td>
<td>TCP与UDP协议的区别<br>TCP的三次握手与四次挥手<br>HTTP与HTTPS协议</td>
</tr>
<tr>
<td>代码题</td>
<td>1、实现一个循环队列<br>2、LRU算法</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">p = p+<span class="number">1</span>; <span class="comment">//地址+1被重载</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,p); <span class="comment">//输出是4</span></span><br></pre></td></tr></table></figure>



<h2 id="九-58同城"><a href="#九-58同城" class="headerlink" title="九 58同城"></a>九 58同城</h2><table>
<thead>
<tr>
<th>一面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>二面流程</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td>发明怎么写的</td>
</tr>
<tr>
<td></td>
<td>项目怎么做的</td>
</tr>
<tr>
<td>C++</td>
<td>C++的三大特性描述</td>
</tr>
<tr>
<td>计算机网络</td>
<td>TCP有哪些协议</td>
</tr>
<tr>
<td></td>
<td>一个报文发送的时候主要由什么组成（各种报头+数据）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>HR面</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>项目介绍</td>
<td></td>
</tr>
<tr>
<td>意向薪资 当前offer状况</td>
<td></td>
</tr>
<tr>
<td>应聘优势</td>
<td></td>
</tr>
</tbody></table>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://grobenis.github.io/2020/08/18/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C/" rel="tag">工作</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AF%95/" rel="tag">笔试</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/08/29/redis/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            redis
          
        </div>
      </a>
    
    
      <a href="/2020/08/17/C-%E7%AC%94%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">C++ 笔试注意事项</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2021
        guoben
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/cat.ico" alt="曾是少年"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/project">项目</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/pay/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/share.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['曾梦想仗剑走天涯', '愿你出走半生，归来仍是少年', '一杯敬朝阳，一杯敬月光'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>




<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/js/ayer.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>