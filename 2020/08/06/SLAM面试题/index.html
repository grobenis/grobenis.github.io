<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="曾梦想仗剑走天涯" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    SLAM 面试题汇总 |  曾是少年
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/images/cat.ico" />
  
  
<link rel="stylesheet" href="/css/main.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-SLAM面试题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  SLAM 面试题汇总
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2020-08-06T14:44:39.000Z" itemprop="datePublished">2020-08-06</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">24.2k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">89分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>本文总结面试SLAM中可能遇到的各种问题。</p>
<a id="more"></a>

<h1 id="零-数学基础"><a href="#零-数学基础" class="headerlink" title="零  数学基础"></a>零  数学基础</h1><h2 id="一-李群和李代数"><a href="#一-李群和李代数" class="headerlink" title="一 李群和李代数"></a>一 李群和李代数</h2><h4 id="李群和李代数的关系"><a href="#李群和李代数的关系" class="headerlink" title="李群和李代数的关系"></a>李群和李代数的关系</h4><h4 id="雅克比求导"><a href="#雅克比求导" class="headerlink" title="雅克比求导"></a>雅克比求导</h4><h4 id="双线性差值如何去做，写公式"><a href="#双线性差值如何去做，写公式" class="headerlink" title="双线性差值如何去做，写公式"></a>双线性差值如何去做，写公式</h4><h4 id="为什么要引入李群李代数"><a href="#为什么要引入李群李代数" class="headerlink" title="为什么要引入李群李代数"></a>为什么要引入李群李代数</h4><p>旋转矩阵自身是带有约束的，正交且行列式为1，他们作为优化变量时，会引入额外的约束，导致优化变的困难，通过李群李代数的转换关系，把位姿估计变成无约束的优化问题。优化过程求极值，由求导数的定义式，可以知道矩阵对于加法不封闭，对于乘法封闭；我们可以看错把李群就是变换矩阵的集合，但是用李代数的形式去表示变换矩阵，与李群的变换对应关系恰好是与指数相乘的关系，用求导的定义式子就可以求解优化问题了。</p>
<h2 id="二-刚体运动的表示"><a href="#二-刚体运动的表示" class="headerlink" title="二 刚体运动的表示"></a>二 刚体运动的表示</h2><h3 id="1-说一下3D空间的位姿如何去表达"><a href="#1-说一下3D空间的位姿如何去表达" class="headerlink" title="1. 说一下3D空间的位姿如何去表达?"></a>1. 说一下3D空间的位姿如何去表达?</h3><blockquote>
<p>描述3D空间位姿态需要描述旋转和平移；</p>
<p>旋转可用：旋转向量（即李代数）、欧拉角、四元数、RPY表示；</p>
<p>平移可以：向量描述</p>
<p>结合起来可以李代数矩阵描述。</p>
</blockquote>
<h3 id="2-机器人学中表示旋转的方式有哪些？区别是什么？"><a href="#2-机器人学中表示旋转的方式有哪些？区别是什么？" class="headerlink" title="2. 机器人学中表示旋转的方式有哪些？区别是什么？"></a>2. 机器人学中表示旋转的方式有哪些？区别是什么？</h3><blockquote>
<p>表示旋转的方式有4种：旋转矩阵、旋转向量、欧拉角、四元数；</p>
<p><strong>区别</strong></p>
<p><strong>旋转矩阵</strong>：用9个变量描述3个自由度，具有冗余，不够紧凑；<br><strong>旋转向量</strong>：3维，使用向量描述旋转，向量的方向与旋转轴一致、向量长度等于旋转角，即李代数。<br><strong>欧拉角</strong>：3维，比较直观，将一个旋转拆分成了绕3个坐标轴的旋转，如RPY指横滚、俯仰、偏航角度，指绕固定轴XYZ、绕旋转之后的轴：ZYX。<br><strong>四元数</strong>：4维，旋转向量与欧拉角虽然紧凑但具有奇异性，四元数紧凑、没有奇异性；使用1个实部、3个虚部表示。</p>
</blockquote>
<h2 id="三-坐标系变换"><a href="#三-坐标系变换" class="headerlink" title="三 坐标系变换"></a>三 坐标系变换</h2><blockquote>
<p>世界坐标系（world） 相机坐标（camera） 像素坐标（pixel）</p>
</blockquote>
<blockquote>
<ul>
<li>world —— camera：$P_C=T_{cw}∗P_w$</li>
<li>camera —— world： $P_w=T_{cw}^{−1}P_c$</li>
<li>pixel —— camera：$u=f_x * X_c / Z_c+C_x ; \quad v=f_y * Y_c / Z_c+C_y$</li>
<li>camera —— pixel：$X_{c}=(u-C_x) * Z_c / f_x ; \quad Y c=(v-C y) * Z_c / f_y$</li>
</ul>
</blockquote>
<h1 id="一-相机模型"><a href="#一-相机模型" class="headerlink" title="一 相机模型"></a>一 相机模型</h1><h2 id="零-图像"><a href="#零-图像" class="headerlink" title="零 图像"></a>零 图像</h2><h3 id="1-RGB图像的遍历"><a href="#1-RGB图像的遍历" class="headerlink" title="1. RGB图像的遍历"></a>1. RGB图像的遍历</h3><h4 id="1-一个H高W宽的图像或者matrix，如何去访问每一个元素，先访问行还是列？"><a href="#1-一个H高W宽的图像或者matrix，如何去访问每一个元素，先访问行还是列？" class="headerlink" title="1. 一个H高W宽的图像或者matrix，如何去访问每一个元素，先访问行还是列？"></a>1. 一个H高W宽的图像或者matrix，如何去访问每一个元素，先访问行还是列？</h4><p>提示：跟缓存还有关系~</p>
<p>矩阵在存储中需要区别是行优先还是列优先，Eigen中默认为列优先，因此需要按列访问。这样访问连续的存储能够加快矩阵的访问速度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>&gt; A;               <span class="comment">// Fixed rows and cols. Same as Matrix3d.</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, Dynamic&gt; B;         <span class="comment">// Fixed rows, dynamic cols.</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>, RowMajor&gt; E;     <span class="comment">// Row major; default is column-major.</span></span><br></pre></td></tr></table></figure>

<p>图像在<code>opencv</code>中一般是按行存储；一般来说图像行与行之间往往存储是不连续的，但是有些图像可以是连续的，Mat提供了一个检测图像是否连续的函数<code>isContinuous()</code>。当图像连通时，我们就可以把图像完全展开，看成是一行。</p>
<h3 id="2-图像处理"><a href="#2-图像处理" class="headerlink" title="2. 图像处理"></a>2. 图像处理</h3><h4 id="1、直方图均衡化"><a href="#1、直方图均衡化" class="headerlink" title="1、直方图均衡化"></a>1、直方图均衡化</h4><blockquote>
<p><strong>直方图均衡化</strong>（Histogram equalization）就是一种常用的灰度变换方法。</p>
<p>目的：通过拉伸像素强度分布范围来增强图像的对比度</p>
<p>操作：直接以图像的像素操作为基础，主要分为<strong>灰度变换</strong>和<strong>空域滤波</strong>两大类，</p>
<p>原理</p>
<ul>
<li>直方图是图像中像素强度分布的图形表达方式.</li>
<li>它统计了每一个强度值所具有的像素个数.</li>
</ul>
<p>应用：VINS中，如果图片太亮或者太暗，就要进行直方图的均衡化处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果EQUALIZE=1，表示太亮或太暗，进行直方图均衡化处理</span></span><br><span class="line"><span class="keyword">if</span> (EQUALIZE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自适应直方图均衡</span></span><br><span class="line">    <span class="comment">//createCLAHE(double clipLimit, Size tileGridSize)</span></span><br><span class="line">    cv::Ptr&lt;cv::CLAHE&gt; clahe = cv::createCLAHE(<span class="number">3.0</span>, cv::Size(<span class="number">8</span>, <span class="number">8</span>));</span><br><span class="line">    TicToc t_c;</span><br><span class="line">    clahe-&gt;apply(_img, img);</span><br><span class="line">    ROS_DEBUG(<span class="string">"CLAHE costs: %fms"</span>, t_c.toc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2、图像滤波方法"><a href="#2、图像滤波方法" class="headerlink" title="2、图像滤波方法"></a>2、图像滤波方法</h4><p>线性滤波方法：方框滤波(box filter) 、均值滤波(median filter)、 高斯滤波（Gaussian 滤波）</p>
<p>非线性滤波：中值滤波、双边滤波</p>
<h3 id="3-图像变换"><a href="#3-图像变换" class="headerlink" title="3. 图像变换"></a>3. 图像变换</h3><h2 id="一-相机"><a href="#一-相机" class="headerlink" title="一 相机"></a>一 相机</h2><h3 id="1-单目相机"><a href="#1-单目相机" class="headerlink" title="1 单目相机"></a>1 <strong>单目相机</strong></h3><table>
<thead>
<tr>
<th>常用型号：有非常多的种类可以选择</th>
<th>单目相机</th>
</tr>
</thead>
<tbody><tr>
<td>1、应用最广，成本可以做到非常低。<br>2、体积小，标定简单，硬件搭建也简单。<br>3、可以用于室内和室外（有适当光照条件下）。</td>
<td>优点</td>
</tr>
<tr>
<td>1、具有纯视觉传感器的通病：在光照变化较大，纹理特征缺失、快速运动导致模糊的情况下无法使用（睁眼瞎）。<br>2、SLAM过程使用单目相机有尺度不确定性，需要专门初始化。<br>3、必须通过运动才能估计深度（帧间匹配三角化）</td>
<td>缺点</td>
</tr>
</tbody></table>
<h3 id="2-双目相机"><a href="#2-双目相机" class="headerlink" title="2 双目相机"></a>2 双目相机</h3><table>
<thead>
<tr>
<th>双目相机</th>
<th>常用型号：Indemind，小觅，ZED等</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>1、相比于单目，在静止时就能够根据左右相机视差图计算深度。<br>2、可测量距离可以根据基线调节。基线距离越大，测量距离越远。<br>3、可以用于室内和室外（有适当光照条件下）。</td>
</tr>
<tr>
<td>缺点</td>
<td>1、双目相机标定相对复杂<br>2、用视差计算深度比较消耗资源<br>3、具有纯视觉传感器的通病：在光照变化较大，纹理特征缺失、快速运动导致模糊的情况下无法使用（睁眼瞎）。</td>
</tr>
</tbody></table>
<h3 id="3-RGB-D相机"><a href="#3-RGB-D相机" class="headerlink" title="3 RGB-D相机"></a>3 RGB-D相机</h3><table>
<thead>
<tr>
<th>RGBD相机</th>
<th>常用型号：Kinect系列、Realsense系列、Orbbec、Pico等</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>1、使用物理测距方法测量深度，所以避免了纯视觉传感器的通病，<br>在没有光照的情况下、快速运动的情况下都可以测距。这是非常大的优势。<br>2、相对双目，输出帧率较高，更适合运动场景。<br>3、输出深度值比较准，结合RGB信息，容易实现手势识别、人体姿态估计等应用。</td>
</tr>
<tr>
<td>缺点</td>
<td>1、测量范围窄，易受日光干扰，通常只能用于室内场景<br>2、在遇到透射材料、反光表面、黑色物体情况下表现不好，造成深度图缺失<br>3、通常分辨率无法做到很高，目前主流分辨率VGA（640x480）<br>4、标定比较复杂。</td>
</tr>
</tbody></table>
<h4 id="A-RGB-D相机我们知道可以直接输出-RGB-depth两张图比如我们常见的Kinect-是结构光原理，包括一个彩色相机，一个红外发射器，一个红外接收器。另外，Intel的Realsense系列RGB-D相机也非常常用，比如下面Realsense-D415，官网说是Active-IR-stereo，也就是双目深度相机，这个双目和我们平时说的双目有何不同？为什么有如下四个孔？"><a href="#A-RGB-D相机我们知道可以直接输出-RGB-depth两张图比如我们常见的Kinect-是结构光原理，包括一个彩色相机，一个红外发射器，一个红外接收器。另外，Intel的Realsense系列RGB-D相机也非常常用，比如下面Realsense-D415，官网说是Active-IR-stereo，也就是双目深度相机，这个双目和我们平时说的双目有何不同？为什么有如下四个孔？" class="headerlink" title="A. RGB-D相机我们知道可以直接输出 RGB + depth两张图比如我们常见的Kinect 是结构光原理，包括一个彩色相机，一个红外发射器，一个红外接收器。另外，Intel的Realsense系列RGB-D相机也非常常用，比如下面Realsense D415，官网说是Active IR stereo，也就是双目深度相机，这个双目和我们平时说的双目有何不同？为什么有如下四个孔？"></a>A. RGB-D相机我们知道可以直接输出 RGB + depth两张图比如我们常见的Kinect 是结构光原理，包括一个彩色相机，一个红外发射器，一个红外接收器。另外，Intel的Realsense系列RGB-D相机也非常常用，比如下面Realsense D415，官网说是Active IR stereo，也就是双目深度相机，这个双目和我们平时说的双目有何不同？为什么有如下四个孔？</h4><h3 id="4-相机对比"><a href="#4-相机对比" class="headerlink" title="4. 相机对比"></a>4. 相机对比</h3><table>
<thead>
<tr>
<th align="left">相机</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单目</td>
<td>成本低，搭建简单，单目相机有尺度不确定性，需要专门初始化。</td>
</tr>
<tr>
<td align="left">双目</td>
<td>不需要专门初始化，能够计算深度，基线距离越大，测量距离越远，可以用于室内和室外，标定较为复杂，视差计算比较消耗资源。</td>
</tr>
<tr>
<td align="left">深度</td>
<td>测量范围窄，噪声大，易受日光干扰，无法测量透射材料，主要用于室内。</td>
</tr>
</tbody></table>
<h4 id="1-全局快门相机与卷帘快门相机的异同"><a href="#1-全局快门相机与卷帘快门相机的异同" class="headerlink" title="1 全局快门相机与卷帘快门相机的异同"></a>1 全局快门相机与卷帘快门相机的异同</h4><table>
<thead>
<tr>
<th align="center">快门</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义</td>
<td>快门是照相机用来控制感光片有效曝光时间的机构，是照相机的一个重要组成部分，它的结构、形式及功能是衡量照相机档次的一个重要因素。一般而言快门的时间范围越大越好。秒数低适合拍运动中的物体，某款相机就强调快门最快能到1/16000秒，可轻松抓住急速移动的目标。不过当你要拍的是夜晚的车水马龙，快门时间就要拉长，常见照片中丝绢般的水流效果也要用慢速快门才能拍出来</td>
</tr>
<tr>
<td align="center">速度</td>
<td>快门速度单位是”秒”。常见的快门速度有:1 1/2 1/4 1/8 1/15 1/30 1/60 1/125 1/250 1/500 1/1000 1/2000等。相邻两级的快门速度的曝光量相差一倍。如1/60秒比1/125秒的曝光量多一倍，即1/60秒比1/125秒速度慢一级或称低一级。</td>
</tr>
<tr>
<td align="center">全局快门（global shutter）</td>
<td>全局快门是通过整幅图片在同一时间曝光实现的。传感器的所有像素点同时收集光线，同时曝光。当预设的曝光时间到了，传感器停止收集光线，并将曝光图像转成电子图像。在这个过程中，并没有实际意义上的快门存在。在曝光开始的时候，传感器开始收集光线，在曝光结束的时候，光线收集电路被切断，传感器读出值即为一幅图片。</td>
</tr>
<tr>
<td align="center">卷帘快门（rolling shutter）</td>
<td>卷帘快门通过控制芯片逐行曝光。卷帘快门也没有实际意义上的快门，而是通过断电控制传感器，使其不同部分在不同时间下对光的敏感度不同，逐行进行曝光，直至所有像素点都被曝光。所有的动作在很短的时间内完成。一般情况为1/48至1/60秒。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>卷帘快门 rolling shutter</th>
<th>全局快门 global shutter</th>
</tr>
</thead>
<tbody><tr>
<td>rolling shutter是逐行顺序曝光，所以不适合运动物体的拍摄，假如物体或摄像头在拍摄期间处于快速运动状态，拍摄结果就可能出现“倾斜”、“摇摆不定”或“部分曝光”等任意一种情况。</td>
<td>global shutter所有像素在同一时刻曝光，类似于将运动物体冻结了，所以适合拍摄快速运动的物体。但是global shutter可能出现像糊现象。像糊现象出现与否取决于曝光时间的长短，假如曝光时间过长，且物体运动快则会出现像糊；假如曝光时间很短，类似于运动物体在瞬间被冻结了，则少有像糊。</td>
</tr>
</tbody></table>
<h2 id="二-相机投影模型"><a href="#二-相机投影模型" class="headerlink" title="二 相机投影模型"></a>二 相机投影模型</h2><h3 id="1-单目相机-1"><a href="#1-单目相机-1" class="headerlink" title="1  单目相机"></a>1  单目相机</h3><h4 id="1-单目相机的投影模型。"><a href="#1-单目相机的投影模型。" class="headerlink" title="1. 单目相机的投影模型。"></a>1. 单目相机的投影模型。</h4><p>$$<br>\begin{aligned}<br>\left[<br>\begin{array}{ccc}<br>u\v\1<br>\end{array}<br>\right]<br>=<br>\frac{1}{Z}<br>\left[<br>\begin{array}{ccc}<br>\frac{1}{f_x}&amp;0&amp;cx\<br>0 &amp; \frac{1}{f_y}&amp; cy\<br>0 &amp; 0 &amp; 1<br>\end{array}<br>\right]<br>=<br>\left[<br>\begin{array}{ccc}<br>X\Y\Z<br>\end{array}<br>\right]<br>=KP<br>\end{aligned}<br>$$</p>
<h4 id="2-相机内参的物理意义"><a href="#2-相机内参的物理意义" class="headerlink" title="2 相机内参的物理意义"></a>2 相机内参的物理意义</h4><p>答：相机内参包括焦距<code>fx</code>，<code>fy</code>，<code>cx</code>，<code>cy</code>，径向畸变系数<code>k1</code>,<code>k2</code>,<code>k3</code>，切向畸变系数<code>p1</code>,<code>p2</code>。其中内参一般来说是不会改变，但是当使用可变焦距镜头时每次改变焦距需要重新标定内参。</p>
<table>
<thead>
<tr>
<th>内参参数</th>
<th>符号</th>
<th>意义</th>
<th>单位</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><code>fx</code>，<code>fy</code></td>
<td><code>fx = a f</code>；<code>fy=beta f</code></td>
<td>像素</td>
</tr>
<tr>
<td>焦距(Focal Length)</td>
<td><code>f</code></td>
<td>投影中心（光心）到物理成像平面的距离</td>
<td>米</td>
</tr>
<tr>
<td>主点(Principal Point )</td>
<td><code>cx</code>，<code>cy</code></td>
<td>主光轴在物理成像平面上的角点</td>
<td>像素</td>
</tr>
<tr>
<td>径向畸变( Radial Distortion )</td>
<td><code>k1</code>,<code>k2</code></td>
<td>由镜片形状不规则引起的畸变</td>
<td></td>
</tr>
<tr>
<td>切向畸变(Tangential Distortion )</td>
<td><code>q1</code>,<code>q2</code></td>
<td>由镜片不完全与成像平面平行引起的畸变</td>
<td></td>
</tr>
<tr>
<td>分辨率(Resolution)</td>
<td><code>rows</code>,<code>cols</code></td>
<td>像素平面图像的精密度</td>
<td>像素</td>
</tr>
</tbody></table>
<p>相机外参分为旋转矩阵<code>R</code>和平移矩阵<code>t</code>，旋转矩阵和平移矩阵共同描述了如何把点从世界坐标系转换到摄像机坐标系。</p>
<h4 id="3-单目相机，F和H矩阵有何不同，E和F矩阵有何不同，只旋转不平移能不能求F，只旋转不平移能不能求H"><a href="#3-单目相机，F和H矩阵有何不同，E和F矩阵有何不同，只旋转不平移能不能求F，只旋转不平移能不能求H" class="headerlink" title="3 单目相机，F和H矩阵有何不同，E和F矩阵有何不同，只旋转不平移能不能求F，只旋转不平移能不能求H"></a>3 单目相机，F和H矩阵有何不同，E和F矩阵有何不同，只旋转不平移能不能求F，只旋转不平移能不能求H</h4><h4 id="仿射变换、透视变换、欧式变换有什么区别"><a href="#仿射变换、透视变换、欧式变换有什么区别" class="headerlink" title="仿射变换、透视变换、欧式变换有什么区别"></a>仿射变换、透视变换、欧式变换有什么区别</h4><p>a) 仿射变换：形状会改变，但直线的平行关系不变，如矩形变成平行四边形。是透视变换的特殊形式。<br>b) 透视变换（或称射影变换）：是仿射变换更一般的形式，是共面点投影的变换关系，如单应性矩阵。平行的直线变换前后可能不会保持平行。<br>c) 欧式变换（或称等距变换）：旋转、平移；</p>
<h3 id="2-双目相机-1"><a href="#2-双目相机-1" class="headerlink" title="2 双目相机"></a>2 双目相机</h3><h4 id="1-我们知道双目相机两个相机光心的间距我们-称之为-baseline。如果双目相机baseline比较大，我们称之为wide-baseline-现在某代码中使用一个单目相机进行SLAM过程，在特征匹配时资料中提到了wide-baseline，请问这个wide-baseline怎么理解？"><a href="#1-我们知道双目相机两个相机光心的间距我们-称之为-baseline。如果双目相机baseline比较大，我们称之为wide-baseline-现在某代码中使用一个单目相机进行SLAM过程，在特征匹配时资料中提到了wide-baseline，请问这个wide-baseline怎么理解？" class="headerlink" title="1. 我们知道双目相机两个相机光心的间距我们 称之为 baseline。如果双目相机baseline比较大，我们称之为wide baseline.现在某代码中使用一个单目相机进行SLAM过程，在特征匹配时资料中提到了wide baseline，请问这个wide baseline怎么理解？"></a>1. 我们知道双目相机两个相机光心的间距我们 称之为 baseline。如果双目相机baseline比较大，我们称之为wide baseline.现在某代码中使用一个单目相机进行SLAM过程，在特征匹配时资料中提到了wide baseline，请问这个wide baseline怎么理解？</h4><h3 id="3-RGBD相机"><a href="#3-RGBD相机" class="headerlink" title="3 RGBD相机"></a>3 RGBD相机</h3><h4 id="1-RGB-D的SLAM和RGB的SLAM有什么区别？"><a href="#1-RGB-D的SLAM和RGB的SLAM有什么区别？" class="headerlink" title="1. RGB-D的SLAM和RGB的SLAM有什么区别？"></a>1. RGB-D的SLAM和RGB的SLAM有什么区别？</h4><p>a) RGBD-SLAM与RGB-SLAM使用的相机不同，前者可读出深度图像和彩色图像、后者只能读出彩色图像（单目或双目）；</p>
<p>b) 传感器数据不同，主要造成前端视觉里程计很多不同，如RGBD-SLAM不用初始化、计算3D点云方式不同、可以使用ICP直接计算相机位姿，</p>
<p> <a href="https://blog.csdn.net/qq_27550989/article/details/78341904" target="_blank" rel="noopener">参考</a></p>
<h2 id="三-相机畸变模型"><a href="#三-相机畸变模型" class="headerlink" title="三 相机畸变模型"></a>三 相机畸变模型</h2><p><strong>径向畸变</strong>是由透镜形状引起的畸变（Distortion，也叫失真）。<strong>切向畸变</strong>在相机的组装过程中由于不能使透镜和成像面严格平行引入的畸变。</p>
<p>通常使用多项式关系描述畸变，即：<br>$$<br>x_{distorted} = x(1+k_1r^2+k_2r^4+k_3r^6)\<br>y_{distorted} = y(1+k_1r^2+k_2r^4+k_3r^6)<br>$$<br>对于切向畸变，可以使用<code>p_1</code>,<code>p_2</code>进行纠正：<br>$$<br>x_{distorted} = x+2p_1xy+p_2(r^2+2x^2)\<br>y_{distorted} = y+p_1(r^2+2y^2)+2p_2xy<br>$$</p>
<h3 id="1-如何找到点在像素平面上的正确位置"><a href="#1-如何找到点在像素平面上的正确位置" class="headerlink" title="1. 如何找到点在像素平面上的正确位置"></a>1. 如何找到点在像素平面上的正确位置</h3><ol>
<li><p>将三维空间点投影到归一化图像平面。设它的归一化坐标为 [x, y]T。</p>
</li>
<li><p>对归一化平面上的点计算径向畸变和切向畸变。<br>$$<br>x_{distorted} = x(1+k_1r^2+k_2r^4+k_3r^6)+2p_1xy+p_2(r^2+2x^2)\<br>y_{distorted} = y(1+k_1r^2+k_2r^4+k_3r^6)+p_1(r^2+2y^2)+2p_2xy<br>$$</p>
</li>
<li><p>将畸变后的点通过内参数矩阵投影到像素平面，得到该点在图像上的正确位置。<br>$$<br>u = f_xx_{distorted}+c_x\<br>v = f_yy_{distorted}+c_y<br>$$</p>
</li>
</ol>
<h3 id="2-如果把一张图像去畸变，写公式，流程。（如何进行去畸变处理）"><a href="#2-如果把一张图像去畸变，写公式，流程。（如何进行去畸变处理）" class="headerlink" title="2. 如果把一张图像去畸变，写公式，流程。（如何进行去畸变处理）"></a>2. 如果把一张图像去畸变，写公式，流程。（如何进行去畸变处理）</h3><p><strong>去畸变过程</strong>主要包括以下步骤：</p>
<ol>
<li><p>将图像的像素坐标系通过内参矩阵转换到相机归一化坐标系<br>$$<br>x = (u-c_x)/f_x\<br>y = (v-c_y)/f_y<br>$$</p>
</li>
<li><p>在相机坐标系下进行去畸变操作<br>$$<br>r = \sqrt{x^2+y^2}\<br>x’ = x<em>(1+k_1<em>r^2+k_2</em>r^4)+2<em>p_1</em>x*y+p_2</em>(r^2+2<em>x^2)\<br>y’ = y</em>(1+k_1<em>r^2+k_2<em>r^4)+2</em>p_2<em>x</em>y+p_1</em>(r^2+2*y^2)\<br>$$</p>
</li>
<li><p>去畸变操作结束后，将相机坐标系重新转换到图像像素坐标系<br>$$<br>u’=x’<em>f_x+c_x\<br>v’=y’</em>f_y+c_y<br>$$</p>
</li>
<li><p>用源图像的像素值对新图像的像素点进行插值</p>
</li>
</ol>
<h3 id="4-如果一部相机的分辨率变为原来的两倍而其他地方不变，那么他的内参会如何变化？"><a href="#4-如果一部相机的分辨率变为原来的两倍而其他地方不变，那么他的内参会如何变化？" class="headerlink" title="4. 如果一部相机的分辨率变为原来的两倍而其他地方不变，那么他的内参会如何变化？"></a>4. 如果一部相机的分辨率变为原来的两倍而其他地方不变，那么他的内参会如何变化？</h3><p>相机内参<code>fx</code>，<code>fy</code>不会变化，<code>cx</code>，<code>cy</code>变为原来的两倍。</p>
<h3 id="5-我们知道相机的内参有-fx-fy-cx-cy-畸变参数-只考虑k1-k2-，相对世界坐标原点外参T。如果我们现在对相机拍摄的图片进行2倍的下采样，那么这些参数会如何变化？"><a href="#5-我们知道相机的内参有-fx-fy-cx-cy-畸变参数-只考虑k1-k2-，相对世界坐标原点外参T。如果我们现在对相机拍摄的图片进行2倍的下采样，那么这些参数会如何变化？" class="headerlink" title="5. 我们知道相机的内参有 fx, fy, cx, cy, 畸变参数(只考虑k1, k2)，相对世界坐标原点外参T。如果我们现在对相机拍摄的图片进行2倍的下采样，那么这些参数会如何变化？"></a>5. 我们知道相机的内参有 fx, fy, cx, cy, 畸变参数(只考虑k1, k2)，相对世界坐标原点外参T。如果我们现在对相机拍摄的图片进行2倍的下采样，那么这些参数会如何变化？</h3><h4 id><a href="#" class="headerlink" title></a></h4><h2 id="四-相机标定"><a href="#四-相机标定" class="headerlink" title="四 相机标定"></a>四 相机标定</h2><h3 id="一-相机如何标定"><a href="#一-相机如何标定" class="headerlink" title="一 相机如何标定"></a>一 相机如何标定</h3><p>答：相机标定一般是通过棋盘格进行标定</p>
<ul>
<li>检测每张图片中的棋盘图案的角点；</li>
<li>通过使用线性最小二乘法估算相机投影矩阵P；</li>
<li>根据P矩阵就解内参矩阵K和外参矩阵R，t;</li>
<li>通过非线性优化，提高K，R，t矩阵的精度。</li>
</ul>
<h3 id="二-RGB-D相机是如何标定的？需要标定哪些参数"><a href="#二-RGB-D相机是如何标定的？需要标定哪些参数" class="headerlink" title="二 RGB-D相机是如何标定的？需要标定哪些参数"></a>二 RGB-D相机是如何标定的？需要标定哪些参数</h3><p>参考链接：<a href="https://www.cnblogs.com/cv-pr/p/5769617.html" target="_blank" rel="noopener">https://www.cnblogs.com/cv-pr/p/5769617.html</a></p>
<p>机器视觉中，3D相机产生的深度图像（depth image）通常需要配准（registration），以生成配准深度图像（registed depth image）。实际上配准的目的就是想让深度图和彩色图重合在一起，即是将深度图像的图像坐标系转换到彩色图像的图像坐标系下。</p>
<p>已知彩色图像的像素表示为$=(uR,vR,zR)⊤$，$uR,vR,zR$分别表示彩色图像的横坐标，纵坐标和相机坐标系下的深度值（z方向上的值，非两点的距离）；同样地，深度图像的像素为$(uL,vL,zL)⊤$，$uL,vL,zL$分别表示深度图像的横坐标，纵坐标和相机坐标系下的深度值（z方向上的值，非两点的距离）。注意为了方便表示，本文中下标的R,L分别表示Right,Left的意思。那么深度图配准到彩色图的过程就是找到如下公式中的变换矩阵W′：<br>$$<br>\begin{bmatrix} u_{R}\  v_{R}\  1 \end{bmatrix} =W^{‘} \begin{bmatrix} u_{L}\  v_{L}\  1 \end{bmatrix}<br>$$</p>
<h1 id="二-视觉前端"><a href="#二-视觉前端" class="headerlink" title="二 视觉前端"></a>二 视觉前端</h1><h2 id="零-特征点"><a href="#零-特征点" class="headerlink" title="零 特征点"></a>零 特征点</h2><p>我们在阅读文献或者代码中误差相关时，经常可以看到一个概念，叫逆深度（inverse depth）。也就是深度的倒数，那么同学们有没有想过，为什么使用逆深度误差而不是深度误差？</p>
<h3 id="1-FAST-特征点"><a href="#1-FAST-特征点" class="headerlink" title="1 FAST 特征点"></a>1 FAST 特征点</h3><p>FAST特征点则直接利用了关键点与周围像素点灰度值的关系,提取时间非常短,能够实现实时计算,但是FAST关键点不具备尺度和方向不变性,无法应用与SLAM系统</p>
<h4 id="检测过程"><a href="#检测过程" class="headerlink" title="检测过程"></a>检测过程</h4><blockquote>
<ol>
<li>在图像中提取像素p，假设它的亮度为Ip；</li>
<li>设置一个阈值T，比如$I_p$的20%；</li>
<li>以像素p为中心，选取半径为3的圆上的16个像素点。</li>
<li>假如选取的圆上,有连续的 N 个点的亮度大于 Ip + T 或小于 Ip − T ,那么像素 p 可以被认为是特征点 (N 通常取 12,即为 FAST-12。其它常用的 N 取值为 9 和 11, 他们分别被称为 FAST-9,FAST-11)。</li>
<li>循环以上四步,对每一个像素执行相同的操作。</li>
</ol>
</blockquote>
<p>可以使用非极大值抑制在一定区域内保留响应极大值的角点，避免角点集中的问题</p>
<p>优点：速度快</p>
<p>缺点：重复性不强，分布不均匀</p>
<h3 id="SIFT-特征点"><a href="#SIFT-特征点" class="headerlink" title="SIFT 特征点"></a>SIFT 特征点</h3><p>SIFT特征点具备良好的尺度和方向不变性,而且对光照,抖动等噪声具有较强的鲁棒性.但由于SIFT的计算量比较大,根据orbslam2作者发表的论文<strong>“ORB-SLAM a Versatile and Accurate Monocular SLAM System”</strong>中可以知道,一张照片提取1000个SIFT特征点的平均时间为300ms,无法实现实时的SLAM系统,虽然后面有学者提出了在GPU加速下能够实现实时,但是毕竟实际的应用场景中,SLAM主要是为上层应用提高感知信息,理应不能占用过多的计算资源.而基于SIFT描述子改进的SURF描述子尽管提高了一个数量级的提取效率，但仍然无法满足SLAM系统的要求.</p>
<h3 id="3-ORB-特征点"><a href="#3-ORB-特征点" class="headerlink" title="3 ORB 特征点"></a>3 ORB 特征点</h3><p>ORB特征点的提取是<strong>基于图像金字塔</strong>的,在不同尺度的图像上面提取Oriented FAST 关键点<strong>(增加了方向的FAST关键点)</strong>和 BRIEF 描述子,以此来实现尺度和方向的不变性.</p>
<p>而ORB特征点则结合了一种改进的FAST关键点和BRIEF,具备有良好的尺度和方向不变性.提取一张照片的ORB特征点大约需要15ms,既实现了实时性,同时还保证了所提取特征点的可靠性.</p>
<h4 id="提取方法"><a href="#提取方法" class="headerlink" title="提取方法"></a>提取方法</h4><p>ORB取名已经反映出其是一个结合了改良后的FAST角点提取和BRIEF描述子的算法，提取ORB特征分为两步：</p>
<ol>
<li>FAST关键点提取：找出图像中的FAST角点，相较于原版的FAST，ORB中计算了特征点的主方向，为后续的BRIEF描述子增加了旋转不变性；</li>
<li>BRIEF描述子：对上一步提取出关键点的周围图像区域进行描述。</li>
</ol>
<h5 id="提取过程"><a href="#提取过程" class="headerlink" title="提取过程"></a>提取过程</h5><ol>
<li>计算图像块的矩</li>
<li>找到图像块的质心</li>
<li>连接几何中心与质心，得到方向向量，来描述ORB特征点</li>
</ol>
<h5 id="特征点描述"><a href="#特征点描述" class="headerlink" title="特征点描述"></a>特征点描述</h5><p>描述子BRIEF：由图像块中两个随机像素的亮度比较得到</p>
<h3 id="人工设计的特征需要考虑什么性质"><a href="#人工设计的特征需要考虑什么性质" class="headerlink" title="人工设计的特征需要考虑什么性质?"></a>人工设计的特征需要考虑什么性质?</h3><blockquote>
<p>可重复性；可取别想；高效率；本地性</p>
</blockquote>
<h2 id="一-特征提取"><a href="#一-特征提取" class="headerlink" title="一 特征提取"></a>一 特征提取</h2><p>给两组已经匹配好的3D点，计算相对位姿变换。已知匹配的ICP问题，写代码。</p>
<p>什么是Essential，Fundamental矩阵？</p>
<p>计算H矩阵和F矩阵的时候有什么技巧呢？实际上在问归一化的操作。</p>
<h3 id="1-什么是ORB特征，ORB特征的旋转不变性是如何做的，BRIEF算子是怎么提取的。"><a href="#1-什么是ORB特征，ORB特征的旋转不变性是如何做的，BRIEF算子是怎么提取的。" class="headerlink" title="1. 什么是ORB特征，ORB特征的旋转不变性是如何做的，BRIEF算子是怎么提取的。"></a>1. 什么是ORB特征，ORB特征的旋转不变性是如何做的，BRIEF算子是怎么提取的。</h3><p>ORB特征是对FAST特征点检测方法与BRIEF特征描述子进行结合和改进的特征点检测方法；FAST特征点不具备方向，ORB使用矩表示特征点的主方向，有了主方向就可以解决了BRIEF描述子不具备旋转不变性的问题了。方式：关键在于其建立坐标系的方式，ORB在计算BRIEF描述子时是以关键点为圆心、以关键点和取点区域的形心的连线为X轴建立2维坐标，这种方式保证了在不同的旋转角度下，当以同一个取点模式取出的点是相同的，这就解决了旋转不变性的问题？？？<br>ORB并未解决尺度不变性，OpenCV上的实现使用了高斯金字塔来保证其尺度不变性。</p>
<p>参考：<a href="https://blog.csdn.net/u014709760/article/details/87978271" target="_blank" rel="noopener">图像特征点—ORB特征点</a></p>
<ol>
<li>ORB特征即Oriented FAST and Rotated BRIEF，由FAST关键点和BRIEF描述子两部分组成，先使用FAST提取角点作为特征点，再使用BRIEF对特征点周围区域进行描述，计算描述子；</li>
<li>通过改进FAST特征点获得尺度不变性和旋转不变性：普通FAST角点不具备方向性和尺度不变性，ORB对其进行改进，增加了尺度不变性和特征点的方向信息，所以称为Oriented FAST关键点；尺度不变性通过构建图像金字塔、并在金字塔每一层检测角点实现；特征的方向（旋转）信息由灰度质心法计算图像块的质心、再连接图像块几何中心O与质心C，即可得到特征点的方向向量OC，特征点的方向即定义为theta =arctan(m01/m10)。至此FAST角点具有了尺度与旋转的描述。FAST特征点有了方向信息，在后续计算BRIEF描述子时，即可保证特征点的旋转不变性。</li>
<li>FAST角点提取：半径为3的圆上16个像素点，如果连续的N个点的亮度大于Ip+T或小于Ip-T（T为设定的阈值，如0.2*Ip），则认为该点是特征点，N常去12，即FAST-12。</li>
<li>BRIEF算子是二进制描述子，其描述向量由许多0和1组成，通过在关键点附近随机取两个像素（如p和q），比较p和q像素值的大小关系，如果p大于q，则取1，反之取0，取128组这样的p、q，即可得到特征点的128维描述子。</li>
<li>ORB速度快的原因：相比其他特征点检测算法，FAST只是比较像素亮度大小；BRIEF通过随机选点、编码0和1的方式计算描述子，因此速度快。</li>
</ol>
<h3 id="2-ORB-SLAM中的特征是如何提取的？如何均匀化的？"><a href="#2-ORB-SLAM中的特征是如何提取的？如何均匀化的？" class="headerlink" title="2. ORB-SLAM中的特征是如何提取的？如何均匀化的？"></a>2. ORB-SLAM中的特征是如何提取的？如何均匀化的？</h3><p><strong>特征提取</strong></p>
<p>ORB-SLAM2跟踪运行在主线程，是整个SLAM系统的基础。主程序在初始化SLAM系统后，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Examples&#x2F;Monocular&#x2F;mono_kitti.cc line:53&#96;&#96;</span><br><span class="line">&#x2F;&#x2F; Create SLAM system. It initializes all system threads and gets ready to process frames.&#96;&#96;</span><br><span class="line">ORB_SLAM2::System SLAM(argv[1],argv[2],ORB_SLAM2::System::MONOCULAR,&#96;&#96;true&#96;&#96;);</span><br></pre></td></tr></table></figure>

<p>就可以将每一帧图像送往跟踪函数，如下是单目SLAM主函数调用跟踪函数的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Examples&#x2F;Monocular&#x2F;mono_kitti.cc line:84&#96;&#96;</span><br><span class="line">&#x2F;&#x2F; Pass the image to the SLAM system&#96;&#96;</span><br><span class="line">SLAM.TrackMonocular(im,tframe);</span><br></pre></td></tr></table></figure>

<p><code>TrackMonocular()</code>函数调用<code>GrabImageMonocular()</code>函数实现跟踪功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; System.cc line:260&#96;&#96;</span><br><span class="line">cv::Mat Tcw &#x3D; mpTracker-&gt;GrabImageMonocular(im,timestamp);</span><br></pre></td></tr></table></figure>

<p> ORB-SLAM提取ORB特征时采用了8层金字塔，尺寸因子为1.2。对于像素为512<em>384到752</em>480的图片，提取1000个FAST角点，对于更高的分辨率，提取2000个FAST角点就可以了。</p>
<p>至此，得到当前帧ORB特征点<code>mvKeys</code>和描述子<code>mDescriptors</code>，均是<code>Frame</code>类对象<code>mCurrentFrame</code>的成员变量。提取出特征点后，需要对其去失真<code>UndistortKeyPoints();</code>。同时需要将图片分割为64*48大小的栅格，并将关键点按照位置分配到相应栅格中，从而降低匹配时的复杂度，实现函数为<code>AssignFeaturesToGrid();</code> 。</p>
<p><strong>特征均匀化</strong></p>
<h2 id="二-特征匹配"><a href="#二-特征匹配" class="headerlink" title="二 特征匹配"></a>二 特征匹配</h2><h3 id="1-快速最近邻算法（FLANN）"><a href="#1-快速最近邻算法（FLANN）" class="headerlink" title="1 快速最近邻算法（FLANN）"></a>1 快速最近邻算法（FLANN）</h3><h3 id="2-外点去除"><a href="#2-外点去除" class="headerlink" title="2 外点去除"></a>2 外点去除</h3><h4 id="A-RANSAC算法"><a href="#A-RANSAC算法" class="headerlink" title="A. RANSAC算法"></a>A. RANSAC算法</h4><p>RANSAC算法的<strong>基本假设</strong>是样本中包含正确数据(inliers，可以被模型描述的数据)，也包含异常数据(outliers，偏离正常范围很远、无法适应数学模型的数据)，即数据集中含有噪声。这些异常数据可能是由于错误的测量、错误的假设、错误的计算等产生的。同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。</p>
<p><strong>优缺点</strong></p>
<p>​    RANSAC算法的优点是能鲁棒的估计模型参数。例如，他能从包含大量局外点的数据集中估计出高精度的参数。缺点是它计算参数的迭代次数没有上限，如果设置迭代次数的上限，得到的结果可能不是最优的结果，甚至可能得到错误的结果。RANSAC只有一定的概率得到的可信的模型，概率与迭代次数成正比。另一个缺点是它要求设置跟问题相关的阈值，RANSAC只能从特定的数据集中估计出一个模型，如果存在两个（或多个）模型，RANSAC不能找到别的模型。</p>
<p><strong>算法流程</strong></p>
<blockquote>
<p>RANSAC是一个迭代算法。在基础版本中，每次迭代包括一下五个步骤：</p>
<ol>
<li>在原始数据中随机选取一个最小子集作为假设的内点（如果根据数据随机选择一条二维直线，则选择两个点）；</li>
<li>根据假设的内点拟合一个模型（比如根据两个点拟合直线）；</li>
<li>判断生育点的原始数据是否符合拟合的模型，并将其分为内点和外点。如果内点太少，则该次迭代被标记为无效并中止；</li>
<li>根据假设的内点和上一步中划分出的内点重新拟合模型</li>
<li>计算所有内点的残差，根据残差的和重新评估模型。</li>
</ol>
<p>迭代上述步骤，把具有残差和最小的模型作为最佳模型。</p>
</blockquote>
<p><strong>迭代次数的上限</strong></p>
<p>例如，k次才可以保证有概率p可以选到仅有内点组成的子集，假设每个测量为内点的概率均为$w$。<br>$$<br>1-p=(1-w^n)^k<br>$$<br>其中，n是拟合模型所需要的最少数据个数，k为总的迭代次数。k为<br>$$<br>k = \frac{\ln(1-p)}{\ln(1-w^n)}<br>$$</p>
<h4 id="B-M估计"><a href="#B-M估计" class="headerlink" title="B. M估计"></a>B. M估计</h4><h4 id="C-有哪几种鲁棒核函数？"><a href="#C-有哪几种鲁棒核函数？" class="headerlink" title="C. 有哪几种鲁棒核函数？"></a>C. 有哪几种鲁棒核函数？</h4><blockquote>
<p>RANAC和鲁棒核函数都是为了解决出现outlier的问题：RANAC是从数据中选择正确的匹配进行估计，鲁棒核函数则是直接作用在残差上，对残差进行饱和函数运算，限制单个数据点对于误差函数的影响力。等于对最小二乘问题做了包装，通过降低错误匹配的权重，使得观测数据中的outlier影响不到最终的估计结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20190930092003431.png#pic_center" alt="在这里插入图片描述"></p>
<p>常用核函数：Huber、Cauchy、Turkey;</p>
<p><img src="https://img-blog.csdnimg.cn/20190930092025127.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190930092033897.png#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="3-问题"><a href="#3-问题" class="headerlink" title="3 问题"></a>3 问题</h3><h4 id="1-如何对匹配好的点做进一步的处理，更好保证匹配效果"><a href="#1-如何对匹配好的点做进一步的处理，更好保证匹配效果" class="headerlink" title="1 如何对匹配好的点做进一步的处理，更好保证匹配效果"></a>1 如何对匹配好的点做进一步的处理，更好保证匹配效果</h4><blockquote>
<p>（1）确定匹配最大距离，汉明距离小于最小距离的两倍<br>（2）使用KNN-matching算法，令K=2。则每个match得到两个最接近的descriptor，然后计算最接近距离和次接近距离之间的比值，当比值大于既定值时，才作为最终match。<br>（3）RANSAC（使用RANSAC找到最佳单应性矩阵。由于这个函数使用的特征点同时包含正确和错误匹配点，因此计算的单应性矩阵依赖于二次投影的准确性）<br>（4）交叉匹配。针对暴力匹配，可以使用交叉匹配的方法来过滤错误的匹配。交叉过滤的思想很简单，再进行一次匹配，反过来使用被匹配到的点进行匹配，如果匹配到的仍然是第一次匹配的点的话，就认为这是一个正确的匹配。举例来说就是，假如第一次特征点A使用暴力匹配的方法，匹配到的特征点是特征点B；反过来，使用特征点B进行匹配，如果匹配到的仍然是特征点A，则就认为这是一个正确的匹配，否则就是一个错误的匹配。OpenCV中BFMatcher已经封装了该方法，创建BFMatcher的实例时，第二个参数传入true即可，BFMatcher bfMatcher(NORM_HAMMING,true)。</p>
</blockquote>
<h4 id="2-如果对于一个3D点，我们在连续帧之间形成了2D特征点之间的匹配，但是这个匹配中可能存在错误的匹配。请问你如何去构建3D点？除了RANSAC之外，还有什么鲁棒估计的方法？"><a href="#2-如果对于一个3D点，我们在连续帧之间形成了2D特征点之间的匹配，但是这个匹配中可能存在错误的匹配。请问你如何去构建3D点？除了RANSAC之外，还有什么鲁棒估计的方法？" class="headerlink" title="2 如果对于一个3D点，我们在连续帧之间形成了2D特征点之间的匹配，但是这个匹配中可能存在错误的匹配。请问你如何去构建3D点？除了RANSAC之外，还有什么鲁棒估计的方法？"></a>2 如果对于一个3D点，我们在连续帧之间形成了2D特征点之间的匹配，但是这个匹配中可能存在错误的匹配。请问你如何去构建3D点？除了RANSAC之外，还有什么鲁棒估计的方法？</h4><blockquote>
<p>可以使用RANSAC算法去除错误的匹配，M估计、鲁棒核函数。</p>
</blockquote>
<h4 id="3-如何优化重投影误差？采用什么方法求解？如果误匹配的点重投影之后误差很大，如何解决它对整个优化问题的影响？"><a href="#3-如何优化重投影误差？采用什么方法求解？如果误匹配的点重投影之后误差很大，如何解决它对整个优化问题的影响？" class="headerlink" title="3 如何优化重投影误差？采用什么方法求解？如果误匹配的点重投影之后误差很大，如何解决它对整个优化问题的影响？"></a>3 如何优化重投影误差？采用什么方法求解？如果误匹配的点重投影之后误差很大，如何解决它对整个优化问题的影响？</h4><blockquote>
<p>图优化模型将路标点和相机位姿作为两个节点，观测模型作为边，同时优化两个变量，SLAM中常用L-M求解。</p>
<p>如果误匹配误差很大可以考虑用核函数（Huber），核函数可以减小误匹配对整个方法的影响。</p>
</blockquote>
<h4 id="4-RANSAC在选择最佳模型的时候用的metric是什么？"><a href="#4-RANSAC在选择最佳模型的时候用的metric是什么？" class="headerlink" title="4  RANSAC在选择最佳模型的时候用的metric是什么？"></a>4  RANSAC在选择最佳模型的时候用的metric是什么？</h4><h3 id="3-常用边缘检测算子和优缺点"><a href="#3-常用边缘检测算子和优缺点" class="headerlink" title="3. 常用边缘检测算子和优缺点"></a>3. 常用边缘检测算子和优缺点</h3><p>边缘检测一般分为三步，分别是滤波、增强、检测。</p>
<p>基本原理都是用高斯滤波器进行去噪，之后在用卷积内核寻找像素梯度。常用的三种算法：<code>canny</code>算子，<code>sobel</code>算子，<code>laplacian</code>算子。</p>
<table>
<thead>
<tr>
<th>算子</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>scanny 算子</td>
<td>一种完善的边缘检测算法，抗噪能力强，用高斯滤波平滑图像，用一阶偏导的有限差分计算梯度的幅值和方向，<br>对梯度幅值进行非极大值抑制，采用双阈值检测和连接边缘。</td>
</tr>
<tr>
<td>sobel 算子</td>
<td>一阶导数算子，引入局部平均运算，对噪声具有平滑作用，抗噪声能力强，计算量较大，<br>但定位精度不高，得到的边缘比较粗，适用于精度要求不高的场合。</td>
</tr>
<tr>
<td>laplacian 算子</td>
<td>二阶微分算子，具有旋转不变性，容易受噪声影响，不能检测边缘的方向，<br>一般不直接用于检测边缘，而是判断明暗变化。</td>
</tr>
</tbody></table>
<h2 id="三-相机运动求解"><a href="#三-相机运动求解" class="headerlink" title="三 相机运动求解"></a>三 相机运动求解</h2><h3 id="1-极线约束（2D-2D）"><a href="#1-极线约束（2D-2D）" class="headerlink" title="1 极线约束（2D-2D）"></a>1 极线约束（2D-2D）</h3><p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200812162637025.png" alt="image-20200812162637025"><br>$$<br>x^T_2t^{\wedge}R x_1 = 0<br>$$</p>
<h4 id="1-按照你的理解讲解一下什么是极线约束？这个约束能带来什么好处？"><a href="#1-按照你的理解讲解一下什么是极线约束？这个约束能带来什么好处？" class="headerlink" title="1. 按照你的理解讲解一下什么是极线约束？这个约束能带来什么好处？"></a>1. 按照你的理解讲解一下什么是极线约束？这个约束能带来什么好处？</h4><blockquote>
<p>所谓极线约束就是说同一个点在两幅图像上的映射，已知左图映射点<code>p1</code>，那么右图映射点<code>p2</code>一定在相对于p1的极线上，这样可以减少待匹配的点数量。（画图解释）</p>
<p>极线约束的好处：从上面的描述我们可以看到，我们在做特征点匹配时，左图成像点p1的待匹配点p2一定在相对于p1的极线上，那么我们在做搜索时就可以在极线附近（考虑实际可能 会有一点误差）进行搜索，相对暴力匹配极大减少待匹配的点的数量。</p>
<p>可以画图解释，注意成像平面、特征点、极点、极线、极平面、相机光心等概念。</p>
</blockquote>
<h4 id="2-本质矩阵E、基本矩阵F、单应性矩阵H区别？"><a href="#2-本质矩阵E、基本矩阵F、单应性矩阵H区别？" class="headerlink" title="2 本质矩阵E、基本矩阵F、单应性矩阵H区别？"></a>2 本质矩阵E、基本矩阵F、单应性矩阵H区别？</h4><blockquote>
<p><strong>基本矩阵</strong>：描述的是不同帧之间同一空间点像素坐标的几何约束关系，将图像归一化坐标替换为像素点坐标，得到基本矩阵约束，基本矩阵描述的约束又称为极线约束。基本矩阵和相机内参，外参都有关系。</p>
<p><strong>本质矩阵</strong>：描述空间点在不同帧之间的归一化坐标的约束关系，是相机坐标系层面。本质矩阵和相机外参有关系，和内参无关。本质矩阵则是基本矩阵的一种特殊情况，是在归一化图像坐标下的基本矩阵，可以理解为本质矩阵对应的坐标位于相机坐标系，基础矩阵对应的坐标位于图像平面坐标系。</p>
<p><strong>单应性矩阵</strong>：在相机只有旋转而没有平移的情况，此时t为0，E也将为0，导致无法求解R，这时可以使用单应矩阵H求旋转，但仅有旋转，无法三角化求深度。</p>
</blockquote>
<h4 id="3-根据基础矩阵E如何求解相机运动R，t"><a href="#3-根据基础矩阵E如何求解相机运动R，t" class="headerlink" title="3 根据基础矩阵E如何求解相机运动R，t?"></a>3 根据基础矩阵E如何求解相机运动R，t?</h4><p>答：SVD分解</p>
<p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200815164626728.png" alt="image-20200815164626728"></p>
<p>其中的R矩阵怎么定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SVD分解</span></span><br><span class="line"><span class="function">Eigen::JacobiSVD&lt;Eigen::Matrix3d&gt; <span class="title">svd</span><span class="params">(E,ComputeThinU|ComputeThinV)</span></span>;</span><br><span class="line">Matrix3d V=svd.matrixV(),U=svd.matrixU();</span><br><span class="line">Matrix3d un_S=U.inverse()* E*V.transpose().inverse(); <span class="comment">//类型不要搞混</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算后的Sigma矩阵</span></span><br><span class="line"><span class="comment">//调整奇异值矩阵 调成E的解析格式，否则可能补满足E内在形式</span></span><br><span class="line"><span class="keyword">double</span> delta_1=un_S(<span class="number">0</span>,<span class="number">0</span>),delta_2=un_S(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">Matrix3d S = Matrix3d::Zero();</span><br><span class="line">S(<span class="number">0</span>,<span class="number">0</span>)=(delta_1+delta_2)/<span class="number">2</span>;</span><br><span class="line">S(<span class="number">1</span>,<span class="number">1</span>)=(delta_1+delta_2)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set t1, t2, R1, R2 </span></span><br><span class="line">Matrix3d t_wedge1, t_wedge2;</span><br><span class="line">Matrix3d R1, R2;</span><br><span class="line"><span class="comment">// 中间旋转矩阵的定义</span></span><br><span class="line"><span class="function">AngleAxisd <span class="title">V1</span><span class="params">(M_PI / <span class="number">2</span>, Vector3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function">AngleAxisd <span class="title">V2</span><span class="params">(- M_PI / <span class="number">2</span>, Vector3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">Matrix3d Rz_pos = V1.toRotationMatrix();</span><br><span class="line">Matrix3d Rz_neg = V2.toRotationMatrix();</span><br><span class="line">t_wedge1 = U*Rz_pos*S*U.transpose();</span><br><span class="line">t_wedge2 = U*Rz_neg*S*U.transpose();</span><br><span class="line">R1 = U*Rz_pos*V.transpose();</span><br><span class="line">R2 = U*Rz_neg*V.transpose();</span><br></pre></td></tr></table></figure>



<h3 id="2-ICP（3D-3D）"><a href="#2-ICP（3D-3D）" class="headerlink" title="2 ICP（3D-3D）"></a>2 ICP（3D-3D）</h3><p>迭代最近邻估计</p>
<h3 id="3-PnP（2D-3D"><a href="#3-PnP（2D-3D" class="headerlink" title="3 PnP（2D-3D)"></a>3 PnP（2D-3D)</h3><h4 id="1-什么是PnP算法？请用你的语言描述一下原理，它一般用在什么场景，解决什么问题？"><a href="#1-什么是PnP算法？请用你的语言描述一下原理，它一般用在什么场景，解决什么问题？" class="headerlink" title="1. 什么是PnP算法？请用你的语言描述一下原理，它一般用在什么场景，解决什么问题？"></a>1. 什么是PnP算法？请用你的语言描述一下原理，它一般用在什么场景，解决什么问题？</h4><p>Perspective-n-Points, PnP(P3P)提供了一种解决方案，它是一种由3D-2D的位姿求解方式，即需要已知匹配的3D点和图像2D点。目前遇到的场景主要就是SLAM算法中估计相机位姿时通常需要PnP给出相机初始位姿,第一帧图像中的3D点以及对应到第二帧图像中的2D点，通过相机成像模型，将3D点投影到二维平面，通过构建误差目标函数通过优化调整位姿的方法使得误差目标函数达到最小，所以它求得的是当前帧相对于上一帧的位姿变换，都是基于已知3D点和对应的图像2D点求解相机运动的过程。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="四-利用三角化求特征点位置"><a href="#四-利用三角化求特征点位置" class="headerlink" title="四 利用三角化求特征点位置"></a>四 利用三角化求特征点位置</h2><h2 id="六-2D-光流"><a href="#六-2D-光流" class="headerlink" title="六 2D 光流"></a>六 2D 光流</h2><h2 id="七-直接法"><a href="#七-直接法" class="headerlink" title="七 直接法"></a>七 直接法</h2><p>直接法估计相机位姿时，并不需要 提取特征点，而是通过优化匹配点的像素值误差（也称光度误差）估计位姿，但也会面临快速运动，光照变化等的挑战，如果让你改善该问题，你会采用哪些方法来提高跟踪质量(精度，速度，鲁棒性等)？</p>
<h2 id="八-方法对比"><a href="#八-方法对比" class="headerlink" title="八 方法对比"></a>八 方法对比</h2><h3 id="零-特征点法"><a href="#零-特征点法" class="headerlink" title="零 特征点法"></a><strong>零 特征点法</strong></h3><p>特征点法通过特征匹配得出2D-2D匹配点，使用对极几何即可计算相机位姿R、t，进一步通过最小化重投影误差优化R、t，得出最优的相机位姿。<strong>不同与直接法的地方</strong>在于，特征点法使用对极几何(或PnP、ICP)计算出的R、t作为位姿初值，最小化重投影误差进行优化，而直接法则使用经验值设定的R、t作为初值，使用最小化灰度误差进行优化。</p>
<h3 id="一-特征点法与直接法"><a href="#一-特征点法与直接法" class="headerlink" title="一 特征点法与直接法"></a>一 特征点法与直接法</h3><p><strong>特征点法</strong></p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>（1）精确，直接法属于强假设</td>
<td>（1）关键点提取、描述子、匹配耗时长</td>
</tr>
<tr>
<td>（2）运动过大时，只要匹配点在像素内，则不太会引起误匹配，鲁棒性好</td>
<td>（2）特征点丢失场景无法使用</td>
</tr>
<tr>
<td></td>
<td>（3）只能构建稀疏地图</td>
</tr>
</tbody></table>
<p><strong>直接法</strong></p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>（1）省去计算特征点、描述子时间</td>
<td>（1）易受光照和模糊影响</td>
</tr>
<tr>
<td>（2）可以用在特征缺失的场合（比如白墙）</td>
<td>（2）运动必须微小，要求相机运动较慢或采样频率较高（可以用图像金字塔改善）</td>
</tr>
<tr>
<td>（3）可以构建半稠密乃至稠密地图</td>
<td>（3）非凸性；单个像素没有区分度</td>
</tr>
</tbody></table>
<h4 id="简述一下特征点法和直接法的概念，以及对应的优缺点。"><a href="#简述一下特征点法和直接法的概念，以及对应的优缺点。" class="headerlink" title="简述一下特征点法和直接法的概念，以及对应的优缺点。"></a>简述一下特征点法和直接法的概念，以及对应的优缺点。</h4><p>特征点法，根据提取、匹配 特征点来估计相机运动，优化的是重投影误差，对光照变化不敏感 ，是比较成熟的方案。</p>
<table>
<thead>
<tr>
<th>特征点法</th>
<th>比如ORB-SLAM</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>（1）特征点本身对光照、运动、旋转比较不敏感，所以比较稳定<br>（2）相机运动较快（相对直接法来说）也能跟踪成功，鲁棒性好一些<br>（3）研究时间较久，方案比较成熟</td>
</tr>
<tr>
<td>缺点</td>
<td>（1）关键点提取、描述子、匹配耗时长<br>（2）特征点丢失场景无法使用<br>（3）只能构建稀疏地图</td>
</tr>
</tbody></table>
<p><strong>直接法</strong>，根据相机的亮度信息估计相机的运动，可以不需要计算关键点和描述子，优化的是光度误差，根据使用像素数量可分为稀疏、半稠密、稠密三种。</p>
<table>
<thead>
<tr>
<th>直接法</th>
<th>SVO，LSD-SLAM</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>（1）速度快，可以省去计算特征点、描述子时间<br>（2）可以用在特征缺失的场合（比如白墙），特征点法在该情况下会急速变差<br>（3）可以构建半稠密乃至稠密地图</td>
</tr>
<tr>
<td>缺点</td>
<td>（1）因为假设了灰度不变，所以易受光照变化影响<br><br>（2）要求相机运动较慢或采样频率较高（可以用图像金字塔改善）<br><br>（3）单个像素或像素块区分度不强，采用的是数量代替质量的策略</td>
</tr>
</tbody></table>
<h4 id="特征点法和直接法的BA有何不同"><a href="#特征点法和直接法的BA有何不同" class="headerlink" title="特征点法和直接法的BA有何不同"></a>特征点法和直接法的BA有何不同</h4><p> （1） 误差函数不同。<strong>特征点法是重投影误差，直接法是光度误差</strong> </p>
<p>（2） 雅克比矩阵不同</p>
<h3 id="二-光流法与直接法"><a href="#二-光流法与直接法" class="headerlink" title="二 光流法与直接法"></a>二 光流法与直接法</h3><h4 id="光流法"><a href="#光流法" class="headerlink" title="光流法"></a>光流法</h4><p>光流法通过光流跟踪图像像素点，得出两帧间角点的匹配关系，当存在一系列匹配点之后，即可使用三角测量、PnP、ICP等方法估计相机位姿。</p>
<h4 id="光流法与直接法的区别"><a href="#光流法与直接法的区别" class="headerlink" title="光流法与直接法的区别"></a>光流法与直接法的区别</h4><p><strong>光流法</strong></p>
<p>是基于像素的光度不变性假设，跟踪图像像素点的方法，描述了像素在图像中的运动。当使用光流法跟踪图像特征点得出匹配点对之后，即可以用匹配的特征点，使用ICP、PnP或对极几何估计相机运动。<strong>光流法本质上还应该划分到特征点法中</strong>，只不过把提取特征点、计算描述子、特征匹配替换成了光流跟踪而已，之后求解R和t的过程是一样的。</p>
<p><strong>直接法</strong></p>
<ol>
<li>是<strong>由光流法演变而来</strong>的，也是基于灰度不变性假设，通过<strong>最小化光度误差</strong>(或称为<strong>测量误差</strong>)来优化R和t。直接法将获取匹配点对(数据关联关系)与计算相机位姿放到同一个非线性最小二乘问题中，而特征点法是先得出匹配点，再进行非线性优化得出相机位姿，是分步进行的。</li>
<li><strong>区别</strong>：光流仅估计了像素间平移，但没有用到相机本身的几何结构、没有考虑到相机的旋转和图像的缩放、对于边界上的点，光流不好追踪，但直接法则考虑了这些信息；</li>
<li><strong>直接法流程</strong>：假设有两个帧，运动未知，但有初始估计R,t(通过经验值设定)；第一帧上看到了点P,投影为P1；按照初始估计，将P1转到第二帧，得出P在第二帧上投影P2；通过最小化P1与P2点的灰度误差来优化初始估计R、t。以上是定位过程，建图过程如下：当确定最优的R、t后，即可重投影得出3D点坐标。</li>
</ol>
<h4 id="光流和直接法有何不同："><a href="#光流和直接法有何不同：" class="headerlink" title="光流和直接法有何不同："></a>光流和直接法有何不同：</h4><blockquote>
<p><strong>答案1</strong>：匹配方法不同。<br>直接法是通过最小光度误差来匹配特征点，而光流法是通过计算<br>光流仅估计了像素间的平移，但像素梯度以及灰度关于时间的导数来预测像素在下一时刻的位置。</p>
<p><strong>答案2</strong>：光流仅估计了像素间的平移，但</p>
<p>（1）没有用相机结构<br>（2）没有考虑相机的旋转和图像缩放<br>（3）边界点追踪效果差</p>
</blockquote>
<h4 id="特征匹配（稀疏）和稠密匹配区别"><a href="#特征匹配（稀疏）和稠密匹配区别" class="headerlink" title="特征匹配（稀疏）和稠密匹配区别"></a><strong>特征匹配（稀疏）和稠密匹配区别</strong></h4><p>特征匹配： （1）速度快，效率高，可以到亚像素级别，精度高 （2）匹配元素为物体的几何特征，对照明变化不敏感 </p>
<p>稠密匹配 （1）速度慢，效率低 （2）对无纹理区域匹配效果不理想，对光强条件敏感</p>
<h1 id="三-卡尔曼滤波"><a href="#三-卡尔曼滤波" class="headerlink" title="三 卡尔曼滤波"></a>三 卡尔曼滤波</h1><h2 id="一-卡尔曼滤波"><a href="#一-卡尔曼滤波" class="headerlink" title="一 卡尔曼滤波"></a>一 卡尔曼滤波</h2><p>预测：如何从上一时刻的状态，根据输入信息推断当前时刻的状态分布（先验）计算协方差</p>
<p>更新：计算增益Kg，然后计算后验</p>
<h4 id="描述（扩展）卡尔曼滤波与粒子滤波，你自己在用卡尔曼滤波时遇到什么问题没有？"><a href="#描述（扩展）卡尔曼滤波与粒子滤波，你自己在用卡尔曼滤波时遇到什么问题没有？" class="headerlink" title="描述（扩展）卡尔曼滤波与粒子滤波，你自己在用卡尔曼滤波时遇到什么问题没有？"></a>描述（扩展）卡尔曼滤波与粒子滤波，你自己在用卡尔曼滤波时遇到什么问题没有？</h4><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>SLAM后端一般有两种方法：滤波方法和非线性优化方法，这两种方法有什么优缺点？</p>
<h3 id="常见滤波方法的对比（KF、EKF、IEKF、UKF、PF）"><a href="#常见滤波方法的对比（KF、EKF、IEKF、UKF、PF）" class="headerlink" title="常见滤波方法的对比（KF、EKF、IEKF、UKF、PF）"></a>常见滤波方法的对比（KF、EKF、IEKF、UKF、PF）</h3><h3 id="简述EKF和BA的区别"><a href="#简述EKF和BA的区别" class="headerlink" title="简述EKF和BA的区别"></a>简述EKF和BA的区别</h3><p>（1） EKF假设了马尔科夫性，认为k时刻的状态只与k-1时刻有关。非线性优化使用所有的历史数据，做全体的SLAM<br>（2） EKF做了线性化处理，在工作点处用一阶泰勒展开式近似整个函数，但在工作点较远处不一定成立。非线性优化每迭代一次，状态估计发生改变，我们会重新对新的估计点做 泰勒展开</p>
<p>可以把EKF看做只有一次迭代的BA</p>
<h1 id="四-非线性优化"><a href="#四-非线性优化" class="headerlink" title="四 非线性优化"></a>四 非线性优化</h1><p>最小化重投影误差问题（Minimization of Reprojection error）是个非线性，非凸的优化问题，这意味着我们不一定能求解它，也不一定能找到全局最优的解。在实际操作中，我们实际上是在调整每个$X_j$，使得它们更符合每一次观测$z_j$，也就是使每个误差项都尽量的小。由于这个原因，它也叫做捆集调整（Bundle Adjustment）。</p>
<h4 id="重投影误差的表达式，误差关于位姿的偏导数怎么算？误差关于空间点的偏导数怎么计算？"><a href="#重投影误差的表达式，误差关于位姿的偏导数怎么算？误差关于空间点的偏导数怎么计算？" class="headerlink" title="重投影误差的表达式，误差关于位姿的偏导数怎么算？误差关于空间点的偏导数怎么计算？"></a>重投影误差的表达式，误差关于位姿的偏导数怎么算？误差关于空间点的偏导数怎么计算？</h4><h2 id="一-最优化方法"><a href="#一-最优化方法" class="headerlink" title="一 最优化方法"></a>一 最优化方法</h2><h3 id="1-最小二乘法"><a href="#1-最小二乘法" class="headerlink" title="1 最小二乘法"></a>1 最小二乘法</h3><p>对于一个最小二乘问题：<br>$$<br>\min_{x}F(x) = \frac{1}{2} ||f(x)||2_2<br>$$<br>最小二乘法即使用迭代的方式，从一个初始值出发，不断更新优化变量，使得目标函数下降。</p>
<p>具体步骤如下：</p>
<ol>
<li>给定某个初值$x_0$；</li>
<li>对于第k次迭代，寻找一个增量$\Delta x_k$ ,使得$||f(x_k+\Delta x_k)||^2_x$达到极小值；</li>
<li>若$\Delta x_k$ 足够小,则停止‘；</li>
<li>否则，令$x_{k+1} = x_k + \Delta x_k$,返回第二步。</li>
</ol>
<h3 id="2-最速下降法、一阶二阶梯度法"><a href="#2-最速下降法、一阶二阶梯度法" class="headerlink" title="2 最速下降法、一阶二阶梯度法"></a>2 最速下降法、一阶二阶梯度法</h3><p><strong>梯度下降法</strong>：在寻找目标函数极小值时，是沿着反梯度方向进行寻找的。梯度的定义就是指向标量场增长最快的方向，在寻找极小值时，先随便定初始点（x0，y0）然后进行迭代不断寻找直到梯度的模达到预设的要求。但是梯度下降法的<strong>缺点</strong>之处在于：在远离极小值的地方下降很快，而在靠近极小值的地方下降很慢，靠近的时候可能成zig-zag下降。</p>
<h3 id="3-GN、LM算法"><a href="#3-GN、LM算法" class="headerlink" title="3 GN、LM算法"></a>3 GN、LM算法</h3><h4 id="1-Gauss-Netwon法-和-LM算法以及两者的区别。"><a href="#1-Gauss-Netwon法-和-LM算法以及两者的区别。" class="headerlink" title="1 Gauss-Netwon法 和 LM算法以及两者的区别。"></a>1 <code>Gauss</code>-<code>Netwon</code>法 和 <code>LM</code>算法以及两者的区别。</h4><p><strong>为什么用这两种算法</strong>：在SLAM中求解相机位姿时，常构建待优化位姿的误差函数（光度误差或重投影误差），通过使得这个误差函数取最小值，得出最优的相机位姿。如果这个误差函数是线性的，则可以直接求导数等于0处的极值即可，但该误差函数通常是关于待优化位姿的非线性多元函数，这实际上是一个非线性无约束最优化问题，常用的解法是G-N、LM算法。<br>两者均是非线性最小二乘求解方法， 都是通过泰勒展开进行线性化，并利用导数确定最优迭代方向，进行逐步迭代求出最优解的优化算法。</p>
<p><strong>高斯牛顿法</strong>：其利用了目标函数的泰勒展开式把<strong>非线性函数的最小二乘化问题化为每次迭代的线性函数的最小二乘化问题</strong>。高斯牛顿法的<strong>缺点</strong>在于：若初始点距离极小值点过远，迭代步长过大会导致迭代下一代的函数值不一定小于上一代的函数值。<br><strong>LM算法</strong>：在高斯牛顿法中加入了因子μ，当<strong>μ大时相当于梯度下降法</strong>，<strong>μ小时相当于高斯牛顿法</strong>。在使用Levenberg-Marquart时，先设置一个比较小的μ值，当发现目标函数反而增大时，将μ增大使用梯度下降法快速寻找，然后再将μ减小使用牛顿法进行寻找。<br>LM算法在高斯牛顿法中加入了因子μ，当μ大时相当于梯度下降法，μ小时相当于高斯牛顿法。在使用Levenberg-Marquart时，先设置一个比较小的μ值，当发现目标函数反而增大时，将μ增大使用梯度下降法快速寻找，然后再将μ减小使用牛顿法进行寻找。</p>
<h5 id="最速下降法"><a href="#最速下降法" class="headerlink" title="最速下降法"></a>最速下降法</h5><h5 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h5><h5 id="高斯牛顿法"><a href="#高斯牛顿法" class="headerlink" title="高斯牛顿法"></a>高斯牛顿法</h5><h5 id="LM算法"><a href="#LM算法" class="headerlink" title="LM算法"></a>LM算法</h5><p>最速下降法比较直观，但过于贪心，容易走出锯齿路线，反而增加迭代次数，导致局部收敛速度下降。<br>牛顿法在最速下降的基础上引入二阶导数，这样就处理了最速下降法一阶导数为0的情况，但是需要计算目标函数的海塞矩阵，二阶求导运算量不小，在问题规模较大时非常困难。<br>高斯牛顿法则对牛顿法进行了简化，避免了二阶求导，但实际中该近似只有半正定性，容易产生病态方程。<br>列文伯格—马夸尔特算法在高斯牛顿法引入阻尼项，一定程度上避免系数矩阵的非奇异和病态问题，但收敛速度较慢。</p>
<h4 id="2-为什么SLAM中常用LM算法而不是高斯牛顿求解优化问题？"><a href="#2-为什么SLAM中常用LM算法而不是高斯牛顿求解优化问题？" class="headerlink" title="2 为什么SLAM中常用LM算法而不是高斯牛顿求解优化问题？"></a>2 为什么SLAM中常用LM算法而不是高斯牛顿求解优化问题？</h4><ol>
<li>GN：线搜索 将f（x）进行一节泰勒展开，最后求解线性方程H△x=b；用JT*J近似H矩阵，H的计算过程根据特定问题特殊分析；该方法特点是：稳定性差，可能不收敛；</li>
<li>LM：信赖区域； 求解线性方程(H+λI)△x=b；通过调整拉格朗日乘子，可以判断是H占据主导地位(二阶近似较好)，还是λI占据主导地位(一阶近似较好)，</li>
<li>避免非奇异和病态问题，提供更稳定，更准确的增量。</li>
</ol>
<h4 id="4-LM算法里面那个λ是如何变化的呢？"><a href="#4-LM算法里面那个λ是如何变化的呢？" class="headerlink" title="4. LM算法里面那个λ是如何变化的呢？"></a>4. LM算法里面那个λ是如何变化的呢？</h4><p>答：LM算法中$\lambda$ 表示阻尼因子，阻尼因子的变化是根据比例因子来确定的。比例因子根据以下公式确定：<br>$$<br>\rho = \frac{F(x)-F(x+\Delta x_{lm})}{L(0)-L(\Delta x_{lm})}<br>$$</p>
<p><strong>阻尼因子的作用</strong></p>
<ul>
<li>$\lambda&gt;0$ 保证 $J^TJ+\lambda I$的正定性。</li>
<li>$\lambda$非常大的情况下。则$\Delta x_{lm} = -\frac{1}{\mu}J^Tf = -\frac{1}{\lambda}F’(x)^T$，接近最速下降法。</li>
<li>$\lambda$比较小的情况下，则认为$\Delta x_{lm} \approx \Delta x_{gn}$，最进阶高斯牛顿法。</li>
</ul>
<p><strong>基本思想</strong></p>
<p>首先比例因子分母始终大于 0,如果:</p>
<ul>
<li>ρ &lt; 0, 则 F (x) ↑ ,应该 μ ↑→ ∆x ↓, 增大阻尼减小步长。</li>
<li>如果 ρ &gt; 0 且比较大,减小 μ, 让 LM 接近 Gauss-Newton 使得系统更快收敛。</li>
<li>反之,如果是比较小的正数,则增大阻尼 μ,缩小迭代步长。</li>
</ul>
<p><strong>具体的阻尼策略(Marquardt)</strong></p>
<ul>
<li>当$\rho&gt;\frac{3}{4}$,则设置$\lambda = 2\lambda$；</li>
<li>当$\rho &lt; \frac{1}{4}$ ，则设置$\lambda = 0.5 \lambda$</li>
</ul>
<h4 id="5-为什么SLAM中常用L-M？"><a href="#5-为什么SLAM中常用L-M？" class="headerlink" title="5. 为什么SLAM中常用L-M？"></a>5. 为什么SLAM中常用L-M？</h4><p>G-N中的H矩阵可能为奇异矩阵或者病态矩阵，导致算法不收敛。而且当步长较大时，也无法保证收敛性，所以采用L-M求解增量方程，但是它的收敛速度可能较慢。</p>
<h4 id="6-一阶梯度下降，G-N和L-M三种方法的关系"><a href="#6-一阶梯度下降，G-N和L-M三种方法的关系" class="headerlink" title="6. 一阶梯度下降，G-N和L-M三种方法的关系"></a>6. <strong>一阶梯度下降，G-N和L-M三种方法的关系</strong></h4><p>(H+λI)△x=b</p>
<ul>
<li>当λ= 0时，L-M等于G-N；</li>
<li>当λ= ∞时，L-M等于一阶梯度下降。</li>
</ul>
<p>L-M的好处就在于：如果下降的太快，使用较小的λ，如果下降的太慢，使用较大的λ</p>
<h3 id="4-Dog-Leg算法"><a href="#4-Dog-Leg算法" class="headerlink" title="4 Dog-Leg算法"></a>4 Dog-Leg算法</h3><h4 id="22-做图优化时，对比采用四元数法和李代数法在数学直观性、计算量上的差异性"><a href="#22-做图优化时，对比采用四元数法和李代数法在数学直观性、计算量上的差异性" class="headerlink" title="22. 做图优化时，对比采用四元数法和李代数法在数学直观性、计算量上的差异性"></a>22. 做图优化时，对比采用四元数法和李代数法在数学直观性、计算量上的差异性</h4><h4 id="23-优化求解过程中，g2o或者ceres的内部实现过程，有哪些加速计算的处理"><a href="#23-优化求解过程中，g2o或者ceres的内部实现过程，有哪些加速计算的处理" class="headerlink" title="23.优化求解过程中，g2o或者ceres的内部实现过程，有哪些加速计算的处理"></a>23.优化求解过程中，g2o或者ceres的内部实现过程，有哪些加速计算的处理</h4><h4 id="24-画后端优化因子图"><a href="#24-画后端优化因子图" class="headerlink" title="24. 画后端优化因子图"></a>24. 画后端优化因子图</h4><h4 id="25-边缘化的过程全面分析，示意图，公式推导，优缺点，哪些矩阵块有改变"><a href="#25-边缘化的过程全面分析，示意图，公式推导，优缺点，哪些矩阵块有改变" class="headerlink" title="25.边缘化的过程全面分析，示意图，公式推导，优缺点，哪些矩阵块有改变"></a>25.边缘化的过程全面分析，示意图，公式推导，优缺点，哪些矩阵块有改变</h4><h4 id="26-10个相机同时看到100个路标点，问BA优化的雅克比矩阵和信息多少维？"><a href="#26-10个相机同时看到100个路标点，问BA优化的雅克比矩阵和信息多少维？" class="headerlink" title="26. 10个相机同时看到100个路标点，问BA优化的雅克比矩阵和信息多少维？"></a>26. 10个相机同时看到100个路标点，问BA优化的雅克比矩阵和信息多少维？</h4><p>答：雅克比矩阵维度：误差项数*误差变量数 （2000 360）</p>
<p>信息矩阵维度：误差变量数*误差变量数（360*360）</p>
<h2 id="二-编程问题"><a href="#二-编程问题" class="headerlink" title="二 编程问题"></a>二 编程问题</h2><h4 id="1-熟悉Ceres优化库吗？说一下。"><a href="#1-熟悉Ceres优化库吗？说一下。" class="headerlink" title="1 熟悉Ceres优化库吗？说一下。"></a>1 熟悉Ceres优化库吗？说一下。</h4><p>Ceres是一个广泛使用的最小二成求解库。用户只需要按照一定步骤定义待解的优化问题。Ceres求解的最小二成问题一般如下形式：<br>$$<br>\min_x\  \frac{1}{2}\sum_{i}p_i(||f_i(x_{i_1},…,x_{i_n})||^2)\<br>s.t\quad l_j\leq x_j \leq u_j<br>$$<br>一般求解过程：</p>
<ol>
<li><p>定义参数块</p>
</li>
<li><p>定义残差块的计算方式</p>
</li>
<li><p>定义残差快计算雅克比矩阵的方式；</p>
<p>三种方式可以使用：（1）自动求导（需要指定误差项和优化变量的维度）（AutoDiff）（2）使用数值求导(Numeric Diff)；（3）自行推到解析函数的形式。</p>
</li>
<li><p>在option里配置优化选项，比如使用Line search还是trust Regin；迭代次数、步长等</p>
</li>
<li><p>传入problem对象，调用solve函数求解。</p>
</li>
</ol>
<h4 id="2-介绍一下g2o库以及使用的基本方法"><a href="#2-介绍一下g2o库以及使用的基本方法" class="headerlink" title="2 介绍一下g2o库以及使用的基本方法"></a>2 介绍一下g2o库以及使用的基本方法</h4><p>g2o库是一个SLAM领域广为使用的优化库。它主要基于图优化。图优化就是把优化问题表现成图的一种优化方法。图有多个顶点以及链接这些顶点的边组成。用顶点表示优化变量，用边表示误差项。</p>
<p>g2o的基本使用步骤：</p>
<ol>
<li>定义顶点和边的类型；</li>
<li>构建图；</li>
<li>选择优化算法；</li>
<li>调用g2o进行优化，返回结果；</li>
</ol>
<h4 id="3-g2o-与-ceres的区别与联系"><a href="#3-g2o-与-ceres的区别与联系" class="headerlink" title="3 g2o 与 ceres的区别与联系"></a>3 g2o 与 ceres的区别与联系</h4><p>使用中：g2o提供了大量现成的边和顶点，非常便于相机的位姿态估计问题；ceres则需要手动实现每一个cost function。</p>
<h4 id="4-DogLeg-是什么？它与GN-和LM-有何异同？"><a href="#4-DogLeg-是什么？它与GN-和LM-有何异同？" class="headerlink" title="4. DogLeg 是什么？它与GN 和LM 有何异同？"></a>4. DogLeg 是什么？它与GN 和LM 有何异同？</h4><p><a href="http://www.numerical.rl.ac.uk/people/nimg/course/lectures/raphael/lectures/lec7slides.pdf" target="_blank" rel="noopener">DogLeg介绍</a><br>Dogleg属于Trust Region优化方法，即用置信域的方法在最速下降法和高斯牛顿法之间进行切换（将二者的搜索步长及方向转化为向量，两个向量进行叠加得到新的方向和置信域内的步长），相当于是一种加权求解。<br><a href="https://blog.csdn.net/lucylove3943/article/details/41588491" target="_blank" rel="noopener">相关材料</a></p>
<h5 id="我们知道（不知道的话，去查一下十四讲）用g2o和ceres库都能用来进行BA优化，这两者在使用过程中有什么不同？"><a href="#我们知道（不知道的话，去查一下十四讲）用g2o和ceres库都能用来进行BA优化，这两者在使用过程中有什么不同？" class="headerlink" title="我们知道（不知道的话，去查一下十四讲）用g2o和ceres库都能用来进行BA优化，这两者在使用过程中有什么不同？"></a>我们知道（不知道的话，去查一下十四讲）用g2o和ceres库都能用来进行BA优化，这两者在使用过程中有什么不同？</h5><h4 id="5-还有别的什么优化库吗"><a href="#5-还有别的什么优化库吗" class="headerlink" title="5. 还有别的什么优化库吗"></a>5. 还有别的什么优化库吗</h4><p>除了Ceres库和g2o库，还有NLopt库、liblbfgs、slam++库等等。 </p>
<h4 id="6-什么是边缘化？First-Estimate-Jacobian？一致性？可观性？"><a href="#6-什么是边缘化？First-Estimate-Jacobian？一致性？可观性？" class="headerlink" title="6. 什么是边缘化？First Estimate Jacobian？一致性？可观性？"></a>6. 什么是边缘化？First Estimate Jacobian？一致性？可观性？</h4><p> 对于VIO系统，边缘化的目的是把旧的状态量从状态估计窗口中移除，保证运行效率；同时，需要把移除的状态量的信息保留下来，作为当下窗口的先验，尽可能避免信息丢失。</p>
<h4 id="7-相比VSLAM，加入IMU后，哪些状态可观？"><a href="#7-相比VSLAM，加入IMU后，哪些状态可观？" class="headerlink" title="7. 相比VSLAM，加入IMU后，哪些状态可观？"></a>7. 相比VSLAM，加入IMU后，哪些状态可观？</h4><p>a. 单目SLAM7个自由度不可观：6个自由度+尺度；<br>b. 单目+IMU4个自由度不可观：偏航角（yaw）+3自由度不可观；翻滚角（roll）、俯仰角（pitch）由于重力存在而可观，尺度因子由于加速度计的存在而可观；</p>
<h4 id="8-给你m相机n个点的bundle-adjustment。当我们在仿真的时候，在迭代的时候，相机的位姿会很快的接近真值。而地图点却不能很快的收敛这是为什么呢？"><a href="#8-给你m相机n个点的bundle-adjustment。当我们在仿真的时候，在迭代的时候，相机的位姿会很快的接近真值。而地图点却不能很快的收敛这是为什么呢？" class="headerlink" title="8. 给你m相机n个点的bundle adjustment。当我们在仿真的时候，在迭代的时候，相机的位姿会很快的接近真值。而地图点却不能很快的收敛这是为什么呢？"></a>8. 给你m相机n个点的bundle adjustment。当我们在仿真的时候，在迭代的时候，相机的位姿会很快的接近真值。而地图点却不能很快的收敛这是为什么呢？</h4><h1 id="五-闭环检测与重定位"><a href="#五-闭环检测与重定位" class="headerlink" title="五 闭环检测与重定位"></a>五 闭环检测与重定位</h1><h2 id="一-闭环检测"><a href="#一-闭环检测" class="headerlink" title="一 闭环检测"></a>一 闭环检测</h2><h3 id="1-什么是闭环检测？"><a href="#1-什么是闭环检测？" class="headerlink" title="1 什么是闭环检测？"></a>1 什么是闭环检测？</h3><p>在视觉SLAM问题中，位姿的估计往往是由上一帧位姿解算当前帧位姿，这么递增求解，因此相邻两帧之间的误差就会产生累计。如我们在求解第五帧位姿的时候，一般是根据第四帧计算的，但是如果我们发现第5帧还可以由第2帧计算出来，就减少了误差的累计。<strong>这种与之前的某一帧（非相邻帧）建立位姿约束关系就叫做回环</strong>。找到可以建立这种位姿约束的历史帧，就是<strong>回环检测</strong>。</p>
<h4 id="a-什么要进行回环检测？"><a href="#a-什么要进行回环检测？" class="headerlink" title="a 什么要进行回环检测？"></a>a 什么要进行回环检测？</h4><p>回环通过减少约束数，起到了减小累计误差的作用。</p>
<h3 id="2-闭环检测有哪些方法-最常用的方法有哪些？"><a href="#2-闭环检测有哪些方法-最常用的方法有哪些？" class="headerlink" title="2 闭环检测有哪些方法? 最常用的方法有哪些？"></a>2 闭环检测有哪些方法? 最常用的方法有哪些？</h3><h5 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a><strong>朴素方法</strong></h5><ol>
<li>对任意两张图像都做一遍特征匹配，根据正确匹配的数量确定哪两个图像存在关联。（这是 O(N2) 的复杂度，随着轨迹变长增长太快，在实时系统中不实用）</li>
<li>随机抽取历史数据并进行回环检测，比如说在n 帧当中随机抽 5 帧与当前帧比较。（盲目试探方法在帧数 N 增长时，抽到回环的几率又大幅下降，使得检测效率不高）</li>
</ol>
<h5 id="基于里程计的几何关系"><a href="#基于里程计的几何关系" class="headerlink" title="基于里程计的几何关系"></a>基于里程计的几何关系</h5><p>当我们发现当前相机运动到了之前的某个位置附近时，检测它们有没有回环关系</p>
<p><strong>基于外观的检测方法</strong></p>
<p>它和前端后端的估计都无关，仅根据两张图像的相似性确定回环检测关系。核心问题是如何计算图像间的相似性。</p>
<p>方法：特征匹配，提取当前帧与过去所有帧的特征，并进行匹配，这种方式假设了过去所有帧都有可能出现回环，匹配十分耗时、计算量大。基于词袋模型，词袋模型就是把特征看成是一个个单词，通过比较两张图片中单词的一致性，来判断两张图片是否属于同一场景。词袋模型需要训练字典(K-means聚类)，但通常字典内单词数量巨大，在确定某个特征时需要与字典内每个单词进行匹配，效率低下。为提高匹配效率，字典在训练的过程中构建了一个有k个分支，深度为d的树(K叉树)，类似于层次聚类，可容纳$k^d$个单词，保证了对数级别的查找效率。</p>
<h3 id="3-闭环检测的评价方法"><a href="#3-闭环检测的评价方法" class="headerlink" title="3 闭环检测的评价方法"></a>3 闭环检测的评价方法</h3><p>表 12-1 回环检测的结果分类</p>
<table>
<thead>
<tr>
<th>算法 \ 事实</th>
<th>是回环</th>
<th>不是回环</th>
</tr>
</thead>
<tbody><tr>
<td>是回环</td>
<td>真阳性(<strong>T</strong>rue <strong>P</strong>ositive)</td>
<td>假阳性(<strong>F</strong>alse <strong>P</strong>ositive)</td>
</tr>
<tr>
<td>不是回环</td>
<td>假阴性(<strong>F</strong>alse <strong>N</strong>egative)</td>
<td>真阴性(<strong>T</strong>rue <strong>N</strong>egative)</td>
</tr>
</tbody></table>
<h4 id="准确率-False-Positive"><a href="#准确率-False-Positive" class="headerlink" title="准确率 (False Positive)"></a>准确率 (False Positive)</h4><p>准确率描述的是,算法提取的所有回环中,确实是真实回环的概率。<br>$$<br>Precision = T P /(T P + F P ),<br>$$</p>
<h4 id="召回率-Precision-amp-Recall"><a href="#召回率-Precision-amp-Recall" class="headerlink" title="召回率 (Precision &amp; Recall)"></a>召回率 (Precision &amp; Recall)</h4><p>召回率则是说,在所有真实回环中,被正确检测出来的概率<br>$$<br>Recall = T P /(T P + F N ).<br>$$<br>在 SLAM 中,我们对准确率要求更高,而对召回率则相对宽容一些。</p>
<h4 id="PR曲线"><a href="#PR曲线" class="headerlink" title="PR曲线"></a>PR曲线</h4><p>测试回环检测在各种配置下的 P 和 R 值,然后做出一条Precision-Recall 曲线。当用召回率为横轴,用准确率为纵轴时,我们会关心整条曲线偏向右上方的程度、100% 准确率下的召回率,或者 50% 召回率时候的准确率,作为评价算法的指标。</p>
<h3 id="4-词袋模型"><a href="#4-词袋模型" class="headerlink" title="4 词袋模型"></a>4 词袋模型</h3><p>词袋,也就是 Bag-of-Words(BoW) ,目的是用“图像上有哪几种特征”来描述一个图像。</p>
<p>词袋模型的简明流程：</p>
<ol>
<li>提取单词，组成字典；</li>
<li>用单词描述图片，即构成一个向量(对图片的描述)</li>
<li>比较向量的相似程度</li>
</ol>
<h4 id="a-字典构建"><a href="#a-字典构建" class="headerlink" title="a 字典构建"></a>a 字典构建</h4><p>字典生成问题类似于一个聚类(Clustering)问题。</p>
<h4 id="b-K-means聚类"><a href="#b-K-means聚类" class="headerlink" title="b K-means聚类"></a>b K-means聚类</h4><ol>
<li>随机选取 k 个中心点:c1 , . . . , ck ;</li>
<li>对每一个样本,计算与每个中心点之间的距离,取最小的作为它的归类;</li>
<li>重新计算每个类的中心点。</li>
<li>如果每个中心点都变化很小,则算法收敛,退出;否则返回 1。</li>
</ol>
<h4 id="c-字典的表示"><a href="#c-字典的表示" class="headerlink" title="c 字典的表示"></a>c 字典的表示</h4><p>使用一种 k 叉树来表达字典。它的思路很简单,类似于层次聚类,是 k-means 的直接扩展。假定我们有 N 个特征点,希望构建一个深度为 d,每次分叉为 k 的<br>树,那么做法如下(见图 12.3.1 ):</p>
<ol>
<li>在根节点,用 k-means 把所有样本聚成 k 类(实际中为保证聚类均匀性会使用k-means++)  。这样得到了第一层。</li>
<li>对第一层的每个节点,把属于该节点的样本再聚成 k 类,得到下一层。</li>
<li>依此类推,最后得到叶子层。叶子层即为所谓的 Words。</li>
</ol>
<h4 id="d-相似度的计算"><a href="#d-相似度的计算" class="headerlink" title="d 相似度的计算"></a>d 相似度的计算</h4><p>TF-IDF(Term Frequency–Inverse Document Frequency)[100, 101],或译频率-逆文档频率­。TF 部分的思想是,某单词在一个图像中经常出现,它的区分度就高。另一方面,IDF 的思想是,某单词在字典中出现的频率越低,则分类图像时区分度越高。</p>
<p>在词袋模型中,在建立字典时可以考虑 IDF 部分。我们统计某个叶子节点 wi 中的特征数量相对于所有特征数量的比例,作为 IDF 部分。另一方面,TF 部分则是指某个特征在单个图像中出现的频率。<br>$$<br>IDF_i = \log \frac{n}{n_i}\<br>TF_i = \frac{n_i}{n}\<br>\eta_i = TF_i \times IDF_i<br>$$<br>考虑权重以后,对于某个图像 A,它的特征点可对应到许多个单词,组成它的 <strong>Bag-of-Words</strong>:<br>$$<br>A = {(w1 , η1 ), (w2 , η2), . . . , (wN , ηN )} = ∆ v_A<br>$$<br>给定 vA 和 vB ,如何计算它们的差异呢?这个问题和范数定义的方式一样,存在若干种解决方式,比如 [102] 中提到的 <strong>L1 范数</strong>形式:<br>$$<br>s (v_A − v_B ) =2∑^N_{o=1} |v_{A_i} | + |v_{B_i} | − |v_{A_i} − v_{B_i}|.<br>$$</p>
<h4 id="e-相似性评分的处理"><a href="#e-相似性评分的处理" class="headerlink" title="e 相似性评分的处理"></a>e 相似性评分的处理</h4><p>考虑到这种情况,我们会取一个先验相似度 s (vt , vt−∆t ),它表示某时刻关键帧图像与上一时刻的关键帧的相似性。然后,其他的分值都参照这个值进行归一化:<br>$$<br>s（v_t, v_{t_j})’ = s(v_t , v_{t_j}) /s (v_t , v_{(t−∆t)}) .<br>$$<br>:如果当前帧与之前某关键帧的相似度,超过当前帧与上一<br>个关键帧相似度的 3 倍,就认为可能存在回环。</p>
<p>好处：这个步骤避免了引入绝对的相似性阈值,使得算法能够适应更多的环境。</p>
<h4 id="f-关键帧的处理"><a href="#f-关键帧的处理" class="headerlink" title="f 关键帧的处理"></a>f 关键帧的处理</h4><p>检测回环关键帧的选取。如果关键帧选得太近,那么导致两个关键帧之间的相似性过高, 相比之下不容易检测出历史数据中的回环。比如检测结果经常是第 n 帧和第 n − 2 帧、n − 3 帧最为相似,这种结果似乎太平凡了,意义不大。所以从实践上说,用于回环检测的帧最好是稀疏一些,彼此之间不太相同,又能涵盖整个环境。</p>
<h4 id="e-为什么检测到回环之后还要验证-如何验证？"><a href="#e-为什么检测到回环之后还要验证-如何验证？" class="headerlink" title="e 为什么检测到回环之后还要验证 如何验证？"></a>e 为什么检测到回环之后还要验证 如何验证？</h4><p>词袋的回环检测算法完全依赖于外观而没有利用任何的几何信息,这导致外观相似的图像容易被当成回环。并且,由于词袋不在乎单词顺序,只在意单词有无的表达方式,更容易引发感知偏差。所以,在回环检测之后,我们通常还会有一个验证步骤 [80, 103]。</p>
<p><strong>验证的方法</strong></p>
<ol>
<li><strong>时间上的一致性检测</strong>。设立回环的缓存机制,认为单次检测到的回环并不足以构成良好的约束,而在一段时间中一直检测到的回环,才认为是正确的回环。</li>
<li><strong>空间上的一致性检测</strong>。即是对回环检测到的两个帧进行特征匹配,估计相机的运动。然后,再把运动放到之前的 Pose Graph 中,检查与之前的估计是否有很大的出入。总之,验证部分通常是必须的,但如何实现却是见仁见智的问题。</li>
</ol>
<h3 id="6-你用的哪种方法？有没有创新？"><a href="#6-你用的哪种方法？有没有创新？" class="headerlink" title="6. 你用的哪种方法？有没有创新？"></a>6. 你用的哪种方法？有没有创新？</h3><h3 id="7-闭环检测成功之后有什么操作？"><a href="#7-闭环检测成功之后有什么操作？" class="headerlink" title="7. 闭环检测成功之后有什么操作？"></a>7. 闭环检测成功之后有什么操作？</h3><ol>
<li><p>根据PnP等算法计算运动关系</p>
</li>
<li><p>根据重投影关系验证回环是否成立</p>
</li>
<li><p>利用全局BA或Pose Graph进行优化</p>
</li>
</ol>
<h2 id="二-重定位"><a href="#二-重定位" class="headerlink" title="二 重定位"></a>二 重定位</h2><p>绑架问题就是重定位，是指机器人在缺少之前位置信息的情况下，或跟踪丢失的情况下，如何进行重新定位、确定当前位姿。例如当机器人被安置在一个已经构建好地图的环境中，但是并不知道它在地图中的相对位置，或者在移动过程中，由于传感器的暂时性功能故障或相机的快速移动，都导致机器人先前的位置信息的丢失，在这种情况下如何重新确定自己的位置。</p>
<h4 id="我们在看SLAM相关论文的时候，会遇到一个词“kidnap”，-直译过来就是“绑架”，不了解的同学可能感觉怪怪的。你知道这个“绑架”是什么意思吗？可以用哪些方法解决这样的问题？"><a href="#我们在看SLAM相关论文的时候，会遇到一个词“kidnap”，-直译过来就是“绑架”，不了解的同学可能感觉怪怪的。你知道这个“绑架”是什么意思吗？可以用哪些方法解决这样的问题？" class="headerlink" title="我们在看SLAM相关论文的时候，会遇到一个词“kidnap”， 直译过来就是“绑架”，不了解的同学可能感觉怪怪的。你知道这个“绑架”是什么意思吗？可以用哪些方法解决这样的问题？"></a>我们在看SLAM相关论文的时候，会遇到一个词“kidnap”， 直译过来就是“绑架”，不了解的同学可能感觉怪怪的。你知道这个“绑架”是什么意思吗？可以用哪些方法解决这样的问题？</h4><h2 id="三-对比"><a href="#三-对比" class="headerlink" title="三 对比"></a>三 对比</h2><h3 id="1-重定位与闭环检测的区别"><a href="#1-重定位与闭环检测的区别" class="headerlink" title="1 重定位与闭环检测的区别"></a>1 重定位与闭环检测的区别</h3><p><strong>重定位</strong> 指的是当跟丢之后重新找回当前的姿态，通过当前帧与关键帧的特征匹配，定位当前帧的相机位姿。顾名思义，这是“ 重新”定位，当前图像因为和最近的图像或者局部地图之间缺乏足够的匹配，导致机器人无法确定自己的位姿，此时处于当前状态的机器人不再知道其在地图中的位置，也叫做机器人被“绑架”，就说的是人质被蒙上双眼带到未知地方，蒙罩去掉后完全不知道自己在哪里，这时候就需要充分利用之前建好的地图或者存好的数据库。此时机器人需要观察周围环境，并且从已有地图中寻找可靠的匹配关系（一般是关键帧信息），这样就可以根据已有信息“ 重新 ”估计机器人的姿态。</p>
<p><strong>回环检测</strong> 是为了解决解决位置估计随时间漂移的问题。主要是通过识别曾经到过的场景，将其与当前帧对应，优化整个地图信息，包括3D路标点、及相机位姿、相对尺度信息.<br>回环的主要目的是降低机器人随时间增加，轨迹中累积的漂移，一般发生在建图过程中。这是因为基于运动传感器或者视觉信息的里程计容易出错，使估计的轨迹偏离其实际真实的情况。通过回环，优化整个地图信息，包括3D路标点、及相机位姿、相对尺度信息。回环检测提供了回环帧与所有历史帧的关系，可以极大减小误差。</p>
<p><strong>联系</strong>：回环主要是纠正机器人/相机轨迹，而重新定位在从未知状态找回姿态。两者都需要当前图像预先访问过之前的位置附近，本质上都是一个图像识别问题。</p>
<p><strong>区别</strong>：二者目的不同，重定位主要为了恢复姿态估计，而回环为了解决飘移，提高全局精度。之所以容易混淆，可能是因为重定位通常也需要找到与之前帧的对应关系来解出姿态，而这可以通过回环检测来完成。也就是说，二者在匹配帧上可以共享一些算法。然后是第一个问题。专门研究重定位的论文很多，实际在单目VSLAM算法用的比较多的还是基于BoW的匹配方案（ORB-SLAM，VINS等），也有基于机器学习匹配patch的方法（PTAM）。同时也有一些简单粗暴的解决方案，比如单独开线程暴力匹配之前所有关键帧（LSD），或者只扰动初始值不断与上一个关键帧进行匹配（DSO）。</p>
<h3 id="2-词袋模型可以用于回环检测，也可以用于重定位，有什么区别"><a href="#2-词袋模型可以用于回环检测，也可以用于重定位，有什么区别" class="headerlink" title="2 词袋模型可以用于回环检测，也可以用于重定位，有什么区别"></a>2 词袋模型可以用于回环检测，也可以用于重定位，有什么区别</h3><p>词袋模型在SLAM中的应用：当前帧与关键帧的特征匹配、重定位的特征匹配、回环检测的特征匹配；（第一个是后两个的基本原理，后两个是应用场景）。连续帧间特征匹配采用的并不是词袋模型。</p>
<p>a) 重定位：主要是通过当前帧与关键帧的特征匹配，定位当前帧的相机位姿。<br>b) 回环检测：优化整个地图信息，包括3D路标点、及相机位姿、相对尺度信息。回环检测提供了当前帧与所有历史帧的关系，</p>
<h1 id="六-建图"><a href="#六-建图" class="headerlink" title="六 建图"></a>六 建图</h1><h2 id="地图点"><a href="#地图点" class="headerlink" title="地图点"></a>地图点</h2><h3 id="3D地图点是怎么存储的？表达方式？"><a href="#3D地图点是怎么存储的？表达方式？" class="headerlink" title="3D地图点是怎么存储的？表达方式？"></a>3D地图点是怎么存储的？表达方式？</h3><p>a) 地图点构建：单目：可以通过关键帧匹配构造、也可以通过普通帧构造（临时被Tracking用来追踪的）；双目：立体匹配、块匹配；RGBD：彩色深度图对齐得到深度d，再根据彩色(u，v)坐标根据相机投影公式计算3D点坐标。<br>b) 3D地图点存储方式：Vector3f<br>c) 地图主要包含关键帧、3D地图点、BoW向量、共视图、生长树等：关键帧(包括特征点、描述符、当前帧的相机位姿，BoW向量无法保存，可在加载关键帧后重新计算)、3D地图点、共视图、<br>d) <a href="https://www.cnblogs.com/mafuqiang/p/6972342.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><h4 id="不同的需求需要什么样的地图"><a href="#不同的需求需要什么样的地图" class="headerlink" title="不同的需求需要什么样的地图"></a>不同的需求需要什么样的地图</h4><ul>
<li>定位仅需匹配特征点</li>
<li>导航和避障需要稠密障碍物信息</li>
<li>交互需要稠密的物体表面信息</li>
<li>高层任务需要语义信息</li>
</ul>
<h2 id="建图方法"><a href="#建图方法" class="headerlink" title="建图方法"></a>建图方法</h2><h3 id="RGBD稠密建图"><a href="#RGBD稠密建图" class="headerlink" title="RGBD稠密建图"></a>RGBD稠密建图</h3><ul>
<li>点云</li>
<li>网格/面片</li>
<li>TSDF</li>
<li>八叉树</li>
</ul>
<h4 id="给一组点云，从中提取平面。"><a href="#给一组点云，从中提取平面。" class="headerlink" title="给一组点云，从中提取平面。"></a>给一组点云，从中提取平面。</h4><h1 id="七-SLAM方案"><a href="#七-SLAM方案" class="headerlink" title="七 SLAM方案"></a>七 SLAM方案</h1><ol>
<li>你认为室内SLAM与自动驾驶SLAM有什么区别？</li>
<li>读Maplab，设计室内服务机器人地图更新的方法、流程。</li>
</ol>
<h2 id="一-时间戳"><a href="#一-时间戳" class="headerlink" title="一 时间戳"></a>一 时间戳</h2><p>工程目录下有<code>GPS</code>保存的坐标文件<code>gps.txt</code>和激光雷达保存的坐标文件<code>laser.txt</code>两个文件，两个文件的第一列为记录当前数据的时间戳，后两列为坐标。由于GPS每隔500时间单位保存一次数据，激光雷达每隔300时间单位保存一次数据，因此，一段时间内激光雷达保存的数据比<code>GPS</code>保存的数据要多。现在想取出两个文件中时间戳最接近的数据，并分别存放在<code>gps2.txt</code>和<code>laser2.txt</code>中，编写程序实现。（不知道哪位大神能讲下这道题。。。）</p>
<p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200812100331825.png" alt="image-20200812100331825"></p>
<h2 id="二-关键帧"><a href="#二-关键帧" class="headerlink" title="二 关键帧"></a>二 关键帧</h2><h3 id="关键帧的概念"><a href="#关键帧的概念" class="headerlink" title="关键帧的概念"></a>关键帧的概念</h3><blockquote>
<p><strong>关键帧</strong>目前是一种非常常用的方法，可以减少待优化的帧数，并且可以代表其附近的帧。可以理解为一个学校里有100个班级，每个班的班长就是一个关键帧，他可以代表他班里的人，那么如何选取关键帧呢？</p>
<p><strong>关键帧作用</strong>：图像插入频率过高会导致信息冗余度快速增加，而这些冗余的信息对系统的精度提升却十分有限，甚至没有提高，反而消耗了更多的计算资源。关键帧的目的在于，适当地降低信息冗余度，减少计算机资源的损耗，保证系统的平稳运行。</p>
</blockquote>
<h3 id="0-为什么要选择关键帧"><a href="#0-为什么要选择关键帧" class="headerlink" title="0 为什么要选择关键帧"></a>0 为什么要选择关键帧</h3><p>答：1  后端通常实时性较差,不适合处理所有帧；2  如果相机停止,可能给后端留下无用的优化,甚至导致后端问题退化</p>
<h4 id="1-关键帧选择指标（如何选择关键帧）"><a href="#1-关键帧选择指标（如何选择关键帧）" class="headerlink" title="1 关键帧选择指标（如何选择关键帧）"></a>1 关键帧选择指标（如何选择关键帧）</h4><blockquote>
<ol>
<li><strong>跟踪质量</strong>：比如当前帧跟踪到的特征点数大于一定阈值，如大于50个点，或关键帧跟踪到的点比参考关键帧少90%。</li>
<li><strong>距离最近关键帧的距离是否足够远（空间）</strong>：即当前帧空间位置是否有足够的变换，如在静止不动或移动幅度较小的情况下，当移动角度大于一定程度才认为是关键帧。</li>
<li><strong>距离上一关键帧的帧数是否足够多（时间）</strong>：如过了20帧仍没有插入关键帧；</li>
<li><strong>局部地图空闲</strong></li>
</ol>
</blockquote>
<h4 id="2-ORB-SLAM中关键帧之间的连接，共视图（Covisibility-Graph）数据结构"><a href="#2-ORB-SLAM中关键帧之间的连接，共视图（Covisibility-Graph）数据结构" class="headerlink" title="2 ORB-SLAM中关键帧之间的连接，共视图（Covisibility Graph）数据结构"></a>2 ORB-SLAM中关键帧之间的连接，共视图（Covisibility Graph）数据结构</h4><blockquote>
<ol>
<li>ORB-SLAM2中关键帧之间的连接是通过共视图（Covisibility Graph）和生成树（Spanning Tree）表达的。</li>
<li>共视图：是一个有权重的无向图，图的结点为一个关键帧，如果两个关键帧能共同观测到一定数量的地图点，那么这两个关键帧之间建立一条边，边的权重为共同观测到的地图数量。</li>
<li>生成树： 生成树是共视图的包含最少边的子图，每次向生成树添加一个关键帧时，将该关键帧与树中共视地图点数量最多的关键帧连接。从生成树中删除一个关键帧时，也要更新受到影响的所有关键帧的连接关系。</li>
<li><a href="https://sqn175.cn/2017/05/24/ORB-SLAM2局部映射.html" target="_blank" rel="noopener">参考</a><br><img src="https://img-blog.csdnimg.cn/20190930092325386.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
</blockquote>
<h4 id="3-关键帧在SLAM里应用非常多，很多知名的开源算法都使用了关键帧。请你用自己的语言描述一下关键帧是什么？有什么用？如何选择关键帧？"><a href="#3-关键帧在SLAM里应用非常多，很多知名的开源算法都使用了关键帧。请你用自己的语言描述一下关键帧是什么？有什么用？如何选择关键帧？" class="headerlink" title="3. 关键帧在SLAM里应用非常多，很多知名的开源算法都使用了关键帧。请你用自己的语言描述一下关键帧是什么？有什么用？如何选择关键帧？"></a>3. 关键帧在SLAM里应用非常多，很多知名的开源算法都使用了关键帧。请你用自己的语言描述一下关键帧是什么？有什么用？如何选择关键帧？</h4><blockquote>
<p>关键帧目前是一种非常常用的方法，可以减少待优化的帧数，并且可以代表其附近的帧。可以理解为一个学校里有100个班级，每个班的班长就是一个关键帧，他可以代表他班里的人，那么如何选取关键帧呢？</p>
<p>选取的指标主要有：</p>
<p>（1）距离上一关键帧的帧数是否足够多（时间）。比如我每隔固定帧数选择一个关键帧，这样编程简单但效果不好。比如运动很慢的时候，就会选择大量相似的关键帧，冗余，运动快的时候又丢失了很多重要的帧。</p>
<p>（2）距离最近关键帧的距离是否足够远（空间）/运动</p>
<p>比如相邻帧我根据pose计算运动的相对大小，可以是位移也可以是旋转或者两个都考虑，运动足够大（超过一定阈值）就新建一个关键帧，这种方法比第一种好。但问题是如果对着同一个物体来回扫就会出现大量相似关键帧。</p>
<p>（3）跟踪质量（主要根据跟踪过程中搜索到的点数和搜索的点数比例）/共视特征点</p>
<p>这种方法就是记录当前视角下的特征点数，或者视角，当相机离开当前场景时才会新建关键帧，避免了第2种方法的问题。缺点是比较复杂</p>
<p>打个比方，关键帧相当于slam的骨架，是在局部一系列普通帧中选出一帧作为局部帧的代表，记录局部信息。举例来说，摄像头放在原处不动，普通帧还是要记录的，但关键帧因为总看到原场景，所以不会增加。</p>
<p>三角化需要一定程度的共视区域，所以普通帧每2帧之间会存在大量的信息冗余，如果所有帧全部参与计算，不仅浪费了算力，对内存也是极大的考验，这一点在前端vo递归处理方式中表现不明显，但在后端优化里是一个大问题，所以关键帧主要作用是面向后端优化的算力与精度的折中。此外，关键帧选择时还会对图片质量、特征点质量等进行考察，一定程度上也发挥了滤波的作用，防止无用的或错误的信息进入优化过程而破坏定位建图的准确性。</p>
<p>选择关键帧主要从关键帧自身和关键帧与其他关键帧的关系2方面来考虑。一方面，关键帧自身质量要好，例如不能是非常模糊的图像、特征点数量要充足、特征点分布要尽量均匀等等；另一方面，关键帧与其他关键帧之间的关系，需要和局部地图中的其他关键帧有少量的共视关系，但大部分特征点是新特征点，以达到既存在约束，又尽量少的信息冗余的效果，例如局部地图点投影到此帧的点数低于一个阈值或前一个关键帧的特征点在此帧里已经有90%观测不到等等。</p>
<p>在关键帧的运用上，我认为orbslam做的非常好，尤其是在回环检测中使用了以关键帧为代表的帧“簇”的概念，回环筛选中有一步将关键帧前后10帧为一组，计算组内总分，以最高分的组的0.75为阈值，滤除一些组，再在剩下的组内各自找最高分的一帧作为备选帧，这个方法非常好地诠释了“关键帧代表局部”的这个理念。</p>
</blockquote>
<h2 id="三-初始化"><a href="#三-初始化" class="headerlink" title="三 初始化"></a>三 初始化</h2><p>初始化的意义是求取两个图像间的<strong>运动</strong>和特征点<strong>距离</strong>，初始化之后的运动都以初始化时的平移作为单位1，这称为单目的不确定性问题（Scale Ambiguity）。且在初始化时，要保证两帧图片之间的运动必须包括平移（不能只旋转），否则将导致求得的本质矩阵E为0，也就无法分解得到相机位姿。</p>
<h3 id="1-ORB-SLAM初始化的时候为什么要同时计算H矩阵和F矩阵？"><a href="#1-ORB-SLAM初始化的时候为什么要同时计算H矩阵和F矩阵？" class="headerlink" title="1. ORB-SLAM初始化的时候为什么要同时计算H矩阵和F矩阵？"></a>1. ORB-SLAM初始化的时候为什么要同时计算H矩阵和F矩阵？</h3><p>当特征点共面或相机间发生了纯旋转时，基础矩阵自由度下降，即发生了所谓的退化，此时如果仍采用八点法估算F矩阵，基础矩阵多出来的自由度将会由噪声决定，对结果造成极大误差。为避免退化现象造成的影响，通常会同时估计基础矩阵F和单应矩阵H，选择重投影误差较小的那个作为最终的运动估计矩阵。</p>
<h2 id="四-重定位"><a href="#四-重定位" class="headerlink" title="四 重定位"></a>四 重定位</h2><p>绑架问题就是<strong>重定位</strong>，是指机器人在缺少之前位置信息的情况下，如何去确定当前位姿。例如当机器人被安置在一个已经构建好地图的环境中，但是并不知道它在地图中的相对位置，或者在移动过程中，由<strong>于传感器的暂时性功能故障或相机的快速移动</strong>，都导致机器人先前的位置信息的丢失，在这种情况下如何重新确定自己的位置。</p>
<h2 id="五-ORB-SLAM2"><a href="#五-ORB-SLAM2" class="headerlink" title="五 ORB-SLAM2"></a>五 ORB-SLAM2</h2><h3 id="1-ORB-SLAM中的特征是如何提取的？如何均匀化的？"><a href="#1-ORB-SLAM中的特征是如何提取的？如何均匀化的？" class="headerlink" title="1. ORB-SLAM中的特征是如何提取的？如何均匀化的？"></a>1. ORB-SLAM中的特征是如何提取的？如何均匀化的？</h3><h3 id="2-ORB-SLAM在估计相机位姿时，为什么同时计算基础矩阵F和单应性矩阵H？"><a href="#2-ORB-SLAM在估计相机位姿时，为什么同时计算基础矩阵F和单应性矩阵H？" class="headerlink" title="2. ORB-SLAM在估计相机位姿时，为什么同时计算基础矩阵F和单应性矩阵H？"></a>2. ORB-SLAM在估计相机位姿时，为什么同时计算基础矩阵F和单应性矩阵H？</h3><p>当特征点共面或相机间发生了纯旋转时，基础矩阵自由度下降，即发生了所谓的退化，此时如果仍采用八点法估算F矩阵，基础矩阵多出来的自由度将会由噪声决定，对结果造成极大误差。为避免退化现象造成的影响，通常会同时估计基础矩阵F和单应矩阵H，选择重投影误差较小的那个作为最终的运动估计矩阵。</p>
<h2 id="六-视觉SLAM的问题"><a href="#六-视觉SLAM的问题" class="headerlink" title="六 视觉SLAM的问题"></a>六 视觉SLAM的问题</h2><h3 id="1-视觉SLAM存在的问题"><a href="#1-视觉SLAM存在的问题" class="headerlink" title="1. 视觉SLAM存在的问题"></a>1. 视觉SLAM存在的问题</h3><p>虽然双目和RGBD不存在初始化化和尺度漂移问题，但是视觉SLAM仍然存在很多共性问题。相机运动太快会导致图像模糊、相机视野不够会导致匹配特征点少、计算量太大（特征提取和匹配）、遮挡、特征缺失、动态物体或光源干扰等。</p>
<h3 id="2-尺度漂移问题"><a href="#2-尺度漂移问题" class="headerlink" title="2 尺度漂移问题"></a>2 尺度漂移问题</h3><p><strong>根本原因</strong>：单目slam产生尺度漂移的根本原因是单目相机无法根据一张图片得出图中物体的大小，这是尺度漂移的根源；在使用单目估计相机位姿和3D点坐标时，需要通过对极几何、三角化进行估计，在这个过程中会产生误差（特征点精度误差、计算误差），这些误差经过多帧累积后会变得特别大，进而导致尺度的不一致性，造成尺度漂移。<br><strong>解决办法</strong>：1、视觉与IMU融合，借助IMU测得的高帧率的角速度、加速度对视觉进行修正、补充；后端优化时，把尺度作为一个优化变量进行优化，可以减小尺度漂移问题。<br><strong>补充</strong>：由于初始化时存在尺度不确定性，因此单目相机估计的目标物体距离与真实世界里的距离存在比例上的差异，这个比例被称作尺度。而且，受到噪声的影响，导致这个尺度会逐渐漂移、改变，这被称为单目SLAM的尺度漂移问题。从理论上来说，只靠单目相机（不借助其他传感器）是无法确定这个尺度具体是多少的，比较好的解决方法是使用回环检测，但是要求相机的整个运动过程存在回环。</p>
<h4 id="单目视觉slam中尺寸漂移是怎么产生的"><a href="#单目视觉slam中尺寸漂移是怎么产生的" class="headerlink" title="单目视觉slam中尺寸漂移是怎么产生的"></a>单目视觉slam中尺寸漂移是怎么产生的</h4><p>单目相机根据一张图片<strong>无法得出一张图片中物体的实际大小</strong>，同理也就<strong>无法得出运动的尺度大小</strong>，这是产生尺度漂移的根源。而在优化过程中，单目相机使用对极几何中的三角测量原理求解深度信息，而三角测量中，<strong>极小的角度误差在累积之后深度不确定都会变得很大</strong>，从而无法保证尺度一致性。</p>
<h2 id="七-视觉惯性SLAM"><a href="#七-视觉惯性SLAM" class="headerlink" title="七 视觉惯性SLAM"></a>七 视觉惯性SLAM</h2><h3 id="什么是紧耦合、松耦合？优缺点。"><a href="#什么是紧耦合、松耦合？优缺点。" class="headerlink" title="什么是紧耦合、松耦合？优缺点。"></a>什么是紧耦合、松耦合？优缺点。</h3><ol>
<li>VIO是融合相机和IMU数据实现SLAM的算法，根据融合框架的区别又分为紧耦合和松耦合，松耦合中视觉运动估计和惯导运动估计系统是两个独立的模块，将每个模块的输出结果进行融合，而紧耦合则是使用两个传感器的原始数据共同估计一组变量，传感器噪声也是相互影响的，紧耦合算法上比较复杂，但充分利用了传感器数据，可以实现更好的效果，是目前研究的重点。</li>
<li>按照是否把图像的Feature加入到状态向量区分，也就是松耦合是在视觉和IMU各自求出的位姿的基础上做的耦合，紧耦合是使用图像和IMU耦合后的数据计算相机位姿。</li>
</ol>
<h1 id="八-其它传感器"><a href="#八-其它传感器" class="headerlink" title="八 其它传感器"></a>八 其它传感器</h1><h2 id="一-IMU"><a href="#一-IMU" class="headerlink" title="一 IMU"></a>一 IMU</h2><h3 id="1-IMU的优点"><a href="#1-IMU的优点" class="headerlink" title="1. IMU的优点"></a>1. IMU的优点</h3><blockquote>
<p>IMU能帮助单目确定尺度；<br>IMU能测量快速的运动；<br>IMU在相机被遮挡时亦能提供短时间的位姿估计；<br>视觉SLAM相邻两帧之间没有约束关系，优化误差函数是重投影误差；IMU增加了相邻帧之间的约束关系。</p>
</blockquote>
<h3 id="2-如何标定IMU与相机之间的外参数？"><a href="#2-如何标定IMU与相机之间的外参数？" class="headerlink" title="2. 如何标定IMU与相机之间的外参数？"></a>2. 如何标定IMU与相机之间的外参数？</h3><h2 id="二-GPS"><a href="#二-GPS" class="headerlink" title="二 GPS"></a>二 GPS</h2><h3 id="1、给你xx误差的GPS，给你xx误差的惯导你怎么得到一个cm级别的地图。"><a href="#1、给你xx误差的GPS，给你xx误差的惯导你怎么得到一个cm级别的地图。" class="headerlink" title="1、给你xx误差的GPS，给你xx误差的惯导你怎么得到一个cm级别的地图。"></a>1、给你xx误差的GPS，给你xx误差的惯导你怎么得到一个cm级别的地图。</h3><p>在给定一些有噪声的GPS信号的时候如何去精准的定位？</p>
<h2 id="三-其它"><a href="#三-其它" class="headerlink" title="三 其它"></a>三 其它</h2><p>一 除了视觉传感，还用过其他传感吗？比如GPS，激光雷达。</p>
<h1 id="九-通用库"><a href="#九-通用库" class="headerlink" title="九 通用库"></a>九 通用库</h1><h2 id="一-Eigen"><a href="#一-Eigen" class="headerlink" title="一 Eigen"></a>一 Eigen</h2><h3 id="矩阵赋值"><a href="#矩阵赋值" class="headerlink" title="矩阵赋值"></a>矩阵赋值</h3><p>按块赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">4</span>&gt; P;</span><br><span class="line">P.block(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>) = camera_pose[<span class="number">0</span>].Rwc;</span><br><span class="line"><span class="comment">// 前面两个数值是起点，后面两个数值是块的大小，此处是将3*3的Rwc赋值给P的前三列</span></span><br></pre></td></tr></table></figure>



<h3 id="动态矩阵"><a href="#动态矩阵" class="headerlink" title="动态矩阵"></a>动态矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXd <span class="title">M</span><span class="params">(rows,cols)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="二-OpenCV"><a href="#二-OpenCV" class="headerlink" title="二 OpenCV"></a>二 OpenCV</h2><table>
<thead>
<tr>
<th>图像操作</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>直方图均衡化</td>
<td><code>equalizeHist( src, dst )</code></td>
</tr>
</tbody></table>
<h2 id="三-G2O"><a href="#三-G2O" class="headerlink" title="三 G2O"></a>三 G2O</h2><p>概念：<code>g2o</code>全称是什么？<code>g2o</code>是一个通用的图优化框架。<code>g2o</code>的核里带有各种各样的求解器，而它的顶点、边的类型则多种多样。通过自定义顶点和边，事实上，只要一个优化问题能够表达成图，那么就可以用<code>g2o</code>去求解它。常见的，比如bundle adjustment，<code>ICP</code>，数据拟合，都可以用<code>g2o</code>来做。</p>
<p>参考链接：<a href="https://www.cnblogs.com/gaoxiang12/p/5304272.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaoxiang12/p/5304272.html</a></p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>apps</strong></td>
<td>一些应用程序。好用的g2o_viewer就在这里。其他还有一些不常用的命令行工具等。</td>
</tr>
<tr>
<td><strong>core</strong></td>
<td>核心组件，很重要！基本的顶点、边、图结构的定义，算法的定义，求解器接口的定义在这里。</td>
</tr>
<tr>
<td>examples</td>
<td>一些例程，可以参照着这里的东西来写。不过注释不太多。</td>
</tr>
<tr>
<td>solvers</td>
<td>求解器的实现。主要来自choldmod, csparse。在使用g2o时要先选择其中一种。</td>
</tr>
<tr>
<td><strong>types</strong></td>
<td>各种顶点和边，很重要！我们用户在构建图优化问题时，先要想好自己的顶点和边是否已经提供了定义。如果没有，要自己实现。如果有，就用g2o提供的即可。</td>
</tr>
</tbody></table>
<h3 id="1-G2O的类结构"><a href="#1-G2O的类结构" class="headerlink" title="1 G2O的类结构"></a>1 G2O的类结构</h3><p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200815142336116.png" alt="image-20200815142336116"></p>
<p>​        先看上半部分。SparseOptimizer 是我们最终要维护的东东。它是一个Optimizable Graph，从而也是一个Hyper Graph（超图）。一个 SparseOptimizer 含有很多个顶点 （都继承自 Base Vertex）和很多个边（继承自 BaseUnaryEdge, BaseBinaryEdge或BaseMultiEdge）。这些 Base Vertex 和 Base Edge 都是抽象的基类，而实际用的顶点和边，都是它们的派生类。我们用 SparseOptimizer.addVertex 和 SparseOptimizer.addEdge 向一个图中添加顶点和边，最后调用 SparseOptimizer.optimize 完成优化。</p>
<p>　　在优化之前，需要指定我们用的求解器和迭代算法。从图中下半部分可以看到，一个 SparseOptimizer 拥有一个 Optimization Algorithm，继承自Gauss-Newton, Levernberg-Marquardt, Powell’s dogleg 三者之一（我们常用的是GN或LM）。同时，这个 Optimization Algorithm 拥有一个Solver，它含有两个部分。一个是 SparseBlockMatrix ，用于计算稀疏的雅可比和海塞； 一个是用于计算迭代过程中最关键的一步<br>$$<br>HΔx=−b<br>$$<br>这就需要一个线性方程的求解器。而这个求解器，可以从 PCG, CSparse, Choldmod 三者选一。</p>
<h3 id="2-G2O-优化方法的选择步骤："><a href="#2-G2O-优化方法的选择步骤：" class="headerlink" title="2 G2O 优化方法的选择步骤："></a>2 G2O 优化方法的选择步骤：</h3><ol>
<li>选择一个线性方程求解器，从 PCG, CSparse, Choldmod中选，实际则来自 g2o/solvers 文件夹中定义的东东。</li>
<li>选择一个 BlockSolver 。</li>
<li>选择一个迭代策略，从GN, LM, Dogleg中选。</li>
</ol>
<h3 id="3-G2O工程化的注意事项"><a href="#3-G2O工程化的注意事项" class="headerlink" title="3 G2O工程化的注意事项"></a>3 G2O工程化的注意事项</h3><h4 id="图优化流程："><a href="#图优化流程：" class="headerlink" title="图优化流程："></a>图优化流程：</h4><ol>
<li>选择节点和边，确定参数化形式</li>
<li>加入节点和边</li>
<li>选择初值，开始迭代</li>
<li>计算J和H</li>
<li>解H△x = -b</li>
<li>GN/LM</li>
<li>g2o需要实现其中的③-⑥</li>
</ol>
<h4 id="g2o"><a href="#g2o" class="headerlink" title="g2o"></a>g2o</h4><p>实现过程 ：选择节点和边<br>节点：g2o :: VertexSE3Expmap（相机位姿）g2o :: VertexSBApointXYZ（路标）<br>边：g2o :: EdgeProjectXYZ2UV（重投影误差）</p>
<h3 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BA Example</span></span><br><span class="line"><span class="comment"> * Author: Xiang Gao</span></span><br><span class="line"><span class="comment"> * Date: 2016.3</span></span><br><span class="line"><span class="comment"> * Email: gaoxiang12@mails.tsinghua.edu.cn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在这个程序中，我们读取两张图像，进行特征匹配。然后根据匹配得到的特征，计算相机运动以及特征点的位置。这是一个典型的Bundle Adjustment，我们用g2o进行优化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for std</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// for opencv</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/concept_check.hpp&gt;</span></span></span><br><span class="line"><span class="comment">// for g2o</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/sparse_optimizer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/robust_kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/robust_kernel_impl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/cholmod/linear_solver_cholmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/types/slam3d/se3quat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/types/sba/types_six_dof_expmap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找两个图像中的对应点，像素坐标系</span></span><br><span class="line"><span class="comment">// 输入：img1, img2 两张图像</span></span><br><span class="line"><span class="comment">// 输出：points1, points2, 两组对应的2D点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>     <span class="title">findCorrespondingPoints</span><span class="params">( <span class="keyword">const</span> cv::Mat&amp; img1, <span class="keyword">const</span> cv::Mat&amp; img2, <span class="built_in">vector</span>&lt;cv::Point2f&gt;&amp; points1, <span class="built_in">vector</span>&lt;cv::Point2f&gt;&amp; points2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机内参</span></span><br><span class="line"><span class="keyword">double</span> cx = <span class="number">325.5</span>;</span><br><span class="line"><span class="keyword">double</span> cy = <span class="number">253.5</span>;</span><br><span class="line"><span class="keyword">double</span> fx = <span class="number">518.0</span>;</span><br><span class="line"><span class="keyword">double</span> fy = <span class="number">519.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用格式：命令 [第一个图] [第二个图]</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Usage: ba_example img1, img2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取图像</span></span><br><span class="line">    cv::Mat img1 = cv::imread( argv[<span class="number">1</span>] );</span><br><span class="line">    cv::Mat img2 = cv::imread( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到对应点</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Point2f&gt; pts1, pts2;</span><br><span class="line">    <span class="keyword">if</span> ( findCorrespondingPoints( img1, img2, pts1, pts2 ) == <span class="literal">false</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"匹配点不够！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"找到了"</span>&lt;&lt;pts1.<span class="built_in">size</span>()&lt;&lt;<span class="string">"组对应特征点。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 构造g2o中的图</span></span><br><span class="line">    <span class="comment">// 先构造求解器</span></span><br><span class="line">    g2o::SparseOptimizer    optimizer;</span><br><span class="line">    <span class="comment">// 使用Cholmod中的线性方程求解器</span></span><br><span class="line">    g2o::BlockSolver_6_3::LinearSolverType* linearSolver = <span class="keyword">new</span>  g2o::LinearSolverCholmod&lt;g2o::BlockSolver_6_3::PoseMatrixType&gt; ();</span><br><span class="line">    <span class="comment">// 6*3 的参数</span></span><br><span class="line">    g2o::BlockSolver_6_3* block_solver = <span class="keyword">new</span> g2o::BlockSolver_6_3( linearSolver );</span><br><span class="line">    <span class="comment">// L-M 下降</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg* algorithm = <span class="keyword">new</span> g2o::OptimizationAlgorithmLevenberg( block_solver );</span><br><span class="line"></span><br><span class="line">    optimizer.setAlgorithm( algorithm );</span><br><span class="line">    optimizer.setVerbose( <span class="literal">false</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加节点</span></span><br><span class="line">    <span class="comment">// 两个位姿节点</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::VertexSE3Expmap* v = <span class="keyword">new</span> g2o::VertexSE3Expmap();</span><br><span class="line">        v-&gt;setId(i);</span><br><span class="line">        <span class="keyword">if</span> ( i == <span class="number">0</span>)</span><br><span class="line">            v-&gt;setFixed( <span class="literal">true</span> ); <span class="comment">// 第一个点固定为零</span></span><br><span class="line">        <span class="comment">// 预设值为单位Pose，因为我们不知道任何信息</span></span><br><span class="line">        v-&gt;setEstimate( g2o::SE3Quat() );</span><br><span class="line">        optimizer.addVertex( v );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 很多个特征点的节点</span></span><br><span class="line">    <span class="comment">// 以第一帧为准</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;pts1.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::VertexSBAPointXYZ* v = <span class="keyword">new</span> g2o::VertexSBAPointXYZ();</span><br><span class="line">        v-&gt;setId( <span class="number">2</span> + i );</span><br><span class="line">        <span class="comment">// 由于深度不知道，只能把深度设置为1了</span></span><br><span class="line">        <span class="keyword">double</span> z = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> x = ( pts1[i].x - cx ) * z / fx;</span><br><span class="line">        <span class="keyword">double</span> y = ( pts1[i].y - cy ) * z / fy;</span><br><span class="line">        v-&gt;setMarginalized(<span class="literal">true</span>);</span><br><span class="line">        v-&gt;setEstimate( Eigen::Vector3d(x,y,z) );</span><br><span class="line">        optimizer.addVertex( v );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备相机参数</span></span><br><span class="line">    g2o::CameraParameters* camera = <span class="keyword">new</span> g2o::CameraParameters( fx, Eigen::Vector2d(cx, cy), <span class="number">0</span> );</span><br><span class="line">    camera-&gt;setId(<span class="number">0</span>);</span><br><span class="line">    optimizer.<span class="built_in">addParameter</span>( camera );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备边</span></span><br><span class="line">    <span class="comment">// 第一帧</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;g2o::EdgeProjectXYZ2UV*&gt; edges;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;pts1.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::EdgeProjectXYZ2UV*  edge = <span class="keyword">new</span> g2o::EdgeProjectXYZ2UV();</span><br><span class="line">        edge-&gt;setVertex( <span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSBAPointXYZ*&gt;   (optimizer.vertex(i+<span class="number">2</span>)) );</span><br><span class="line">        edge-&gt;setVertex( <span class="number">1</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSE3Expmap*&gt;     (optimizer.vertex(<span class="number">0</span>)) );</span><br><span class="line">        edge-&gt;setMeasurement( Eigen::Vector2d(pts1[i].x, pts1[i].y ) );</span><br><span class="line">        edge-&gt;setInformation( Eigen::Matrix2d::Identity() );</span><br><span class="line">        edge-&gt;setParameterId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 核函数</span></span><br><span class="line">        edge-&gt;setRobustKernel( <span class="keyword">new</span> g2o::RobustKernelHuber() );</span><br><span class="line">        optimizer.addEdge( edge );</span><br><span class="line">        edges.push_back(edge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二帧</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;pts2.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::EdgeProjectXYZ2UV*  edge = <span class="keyword">new</span> g2o::EdgeProjectXYZ2UV();</span><br><span class="line">        edge-&gt;setVertex( <span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSBAPointXYZ*&gt;   (optimizer.vertex(i+<span class="number">2</span>)) );</span><br><span class="line">        edge-&gt;setVertex( <span class="number">1</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSE3Expmap*&gt;     (optimizer.vertex(<span class="number">1</span>)) );</span><br><span class="line">        edge-&gt;setMeasurement( Eigen::Vector2d(pts2[i].x, pts2[i].y ) );</span><br><span class="line">        edge-&gt;setInformation( Eigen::Matrix2d::Identity() );</span><br><span class="line">        edge-&gt;setParameterId(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 核函数</span></span><br><span class="line">        edge-&gt;setRobustKernel( <span class="keyword">new</span> g2o::RobustKernelHuber() );</span><br><span class="line">        optimizer.addEdge( edge );</span><br><span class="line">        edges.push_back(edge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"开始优化"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    optimizer.setVerbose(<span class="literal">true</span>);</span><br><span class="line">    optimizer.initializeOptimization();</span><br><span class="line">    optimizer.optimize(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"优化完毕"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们比较关心两帧之间的变换矩阵</span></span><br><span class="line">    g2o::VertexSE3Expmap* v = <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSE3Expmap*&gt;( optimizer.vertex(<span class="number">1</span>) );</span><br><span class="line">    Eigen::Isometry3d pose = v-&gt;estimate();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Pose="</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;pose.matrix()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以及所有特征点的位置</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;pts1.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::VertexSBAPointXYZ* v = <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSBAPointXYZ*&gt; (optimizer.vertex(i+<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"vertex id "</span>&lt;&lt;i+<span class="number">2</span>&lt;&lt;<span class="string">", pos = "</span>;</span><br><span class="line">        Eigen::Vector3d pos = v-&gt;estimate();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;pos(<span class="number">0</span>)&lt;&lt;<span class="string">","</span>&lt;&lt;pos(<span class="number">1</span>)&lt;&lt;<span class="string">","</span>&lt;&lt;pos(<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 估计inlier的个数</span></span><br><span class="line">    <span class="keyword">int</span> inliers = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> e:edges )</span><br><span class="line">    &#123;</span><br><span class="line">        e-&gt;computeError();</span><br><span class="line">        <span class="comment">// chi2 就是 error*\Omega*error, 如果这个数很大，说明此边的值与其他边很不相符</span></span><br><span class="line">        <span class="keyword">if</span> ( e-&gt;chi2() &gt; <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"error = "</span>&lt;&lt;e-&gt;chi2()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            inliers++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"inliers in total points: "</span>&lt;&lt;inliers&lt;&lt;<span class="string">"/"</span>&lt;&lt;pts1.<span class="built_in">size</span>()+pts2.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    optimizer.save(<span class="string">"ba.g2o"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>     <span class="title">findCorrespondingPoints</span><span class="params">( <span class="keyword">const</span> cv::Mat&amp; img1, <span class="keyword">const</span> cv::Mat&amp; img2, <span class="built_in">vector</span>&lt;cv::Point2f&gt;&amp; points1, <span class="built_in">vector</span>&lt;cv::Point2f&gt;&amp; points2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::ORB orb;</span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::KeyPoint&gt; kp1, kp2;</span><br><span class="line">    cv::Mat desp1, desp2;</span><br><span class="line">    orb( img1, cv::Mat(), kp1, desp1 );</span><br><span class="line">    orb( img2, cv::Mat(), kp2, desp2 );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"分别找到了"</span>&lt;&lt;kp1.<span class="built_in">size</span>()&lt;&lt;<span class="string">"和"</span>&lt;&lt;kp2.<span class="built_in">size</span>()&lt;&lt;<span class="string">"个特征点"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    cv::Ptr&lt;cv::DescriptorMatcher&gt;  matcher = cv::DescriptorMatcher::create( <span class="string">"BruteForce-Hamming"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> knn_match_ratio=<span class="number">0.8</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;cv::DMatch&gt; &gt; matches_knn;</span><br><span class="line">    matcher-&gt;knnMatch( desp1, desp2, matches_knn, <span class="number">2</span> );</span><br><span class="line">    <span class="built_in">vector</span>&lt; cv::DMatch &gt; matches;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;matches_knn.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matches_knn[i][<span class="number">0</span>].distance &lt; knn_match_ratio * matches_knn[i][<span class="number">1</span>].distance )</span><br><span class="line">            matches.push_back( matches_knn[i][<span class="number">0</span>] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matches.<span class="built_in">size</span>() &lt;= <span class="number">20</span>) <span class="comment">//匹配点太少</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> m:matches )</span><br><span class="line">    &#123;</span><br><span class="line">        points1.push_back( kp1[m.queryIdx].pt );</span><br><span class="line">        points2.push_back( kp2[m.trainIdx].pt );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四-Ceres"><a href="#四-Ceres" class="headerlink" title="四 Ceres"></a>四 Ceres</h2><h2 id="五-ROS"><a href="#五-ROS" class="headerlink" title="五 ROS"></a>五 ROS</h2><h2 id="六-DBOW"><a href="#六-DBOW" class="headerlink" title="六 DBOW"></a>六 DBOW</h2><h3 id="训练字典"><a href="#训练字典" class="headerlink" title="训练字典"></a>训练字典</h3><p>实际 BoW 使用时,字典往往是从更大的数据集中生成的,而且最好是来自目标应该环境类似的地方。我们通常使用较大规模的字典——越大代表字典单词量越丰富,容易找到与当前图像对应的单词,但也不能大到超过我们计算能力和内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read the image</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"reading images... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt; images;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">string</span> path = <span class="string">"./data/"</span>+to_string(i+<span class="number">1</span>)+<span class="string">".png"</span>;</span><br><span class="line">    images.push_back( imread(path) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// detect ORB features</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"detecting ORB features ... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Ptr&lt; Feature2D &gt; detector = ORB::create();</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt; descriptors;</span><br><span class="line">    <span class="keyword">for</span> ( Mat&amp; <span class="built_in">image</span>:images )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints;</span><br><span class="line">    Mat descriptor;</span><br><span class="line">    detector-&gt;detectAndCompute( <span class="built_in">image</span>, Mat(), keypoints, descriptor );</span><br><span class="line">    descriptors.push_back( descriptor );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create vocabulary</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"creating vocabulary ... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    DBoW3::Vocabulary vocab;</span><br><span class="line">    vocab.create( descriptors );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"vocabulary info: "</span>&lt;&lt;vocab&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    vocab.save( <span class="string">"vocabulary.yml.gz"</span> );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"done"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DBoW3 的使用方式非常容易。我们对十张目标图像提取 ORB 特征并存放至 vector容器中,然后调用 DBoW3 的字典生成接口即可。在 DBoW3::Vocabulary 对象的构造函数中,我们能够指定树的分叉数量以及深度,不过这里使用了默认构造函数,也就是 k =10, d = 5。这是一个小规模的字典,最大能容纳 10000 个单词。对于图像特征,我们亦使用默认参数,即每张图像 500 个特征点。最后我们把字典存储为一个压缩文件。</p>
<h1 id="十-开放问题"><a href="#十-开放问题" class="headerlink" title="十 开放问题"></a>十 开放问题</h1><h2 id="一-自己的项目"><a href="#一-自己的项目" class="headerlink" title="一 自己的项目"></a>一 自己的项目</h2><h3 id="1-你做的工作在本质上有什么不同，贡献，创新本质上在哪里？"><a href="#1-你做的工作在本质上有什么不同，贡献，创新本质上在哪里？" class="headerlink" title="1. 你做的工作在本质上有什么不同，贡献，创新本质上在哪里？"></a>1. 你做的工作在本质上有什么不同，贡献，创新本质上在哪里？</h3><ol>
<li>给定几个连续帧的带有位姿的帧，如何去测量车道线相对于世界坐标系的坐标。</li>
<li>给一张图片，知道相机与地面之间的相对关系，计算出图的俯视图。</li>
</ol>
<h3 id="2-说一个自己熟悉的SLAM算法，Lidar-Visual-slam，说优缺点。"><a href="#2-说一个自己熟悉的SLAM算法，Lidar-Visual-slam，说优缺点。" class="headerlink" title="2. 说一个自己熟悉的SLAM算法，Lidar/Visual slam，说优缺点。"></a>2. 说一个自己熟悉的SLAM算法，Lidar/Visual slam，说优缺点。</h3><h3 id="3-说一下VINS-Mono的优缺点"><a href="#3-说一下VINS-Mono的优缺点" class="headerlink" title="3. 说一下VINS-Mono的优缺点"></a>3. 说一下VINS-Mono的优缺点</h3><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h3><h2 id="二-设计系统"><a href="#二-设计系统" class="headerlink" title="二 设计系统"></a>二 设计系统</h2><p>机器人从超市门口出发，前往3公里外的小区送货。请你设计一个定位系统，包括传感器的配置、算法的流程，用伪代码写出来。</p>
<h2 id="三-其他问题"><a href="#三-其他问题" class="headerlink" title="三 其他问题"></a>三 其他问题</h2><h3 id="你还有什么问题？"><a href="#你还有什么问题？" class="headerlink" title="你还有什么问题？"></a>你还有什么问题？</h3><p>可以从以下方面进行提问：(1) 部门(2) 业务范围(3) 培养方式(4) 工作模式(5) 后续通知时间</p>
<h4 id="你的缺点"><a href="#你的缺点" class="headerlink" title="你的缺点"></a>你的缺点</h4><ol>
<li>喜欢熬夜</li>
</ol>
<h2 id="四-SLAM行业相关问题"><a href="#四-SLAM行业相关问题" class="headerlink" title="四 SLAM行业相关问题"></a>四 SLAM行业相关问题</h2><h4 id="1-大家都是SLAM方向的研究者，不管是学生还是已经工作，以后都面临找（换）工作的问题，那么你知道哪些做SLAM技术的公司？"><a href="#1-大家都是SLAM方向的研究者，不管是学生还是已经工作，以后都面临找（换）工作的问题，那么你知道哪些做SLAM技术的公司？" class="headerlink" title="1. 大家都是SLAM方向的研究者，不管是学生还是已经工作，以后都面临找（换）工作的问题，那么你知道哪些做SLAM技术的公司？"></a>1. 大家都是SLAM方向的研究者，不管是学生还是已经工作，以后都面临找（换）工作的问题，那么你知道哪些做SLAM技术的公司？</h4><h4 id="2-讨论一下SLAM应用场景及落地的问题。大家觉得SLAM技术最适合的应用场景是什么？在哪个场景能够最快技术落地呢？"><a href="#2-讨论一下SLAM应用场景及落地的问题。大家觉得SLAM技术最适合的应用场景是什么？在哪个场景能够最快技术落地呢？" class="headerlink" title="2. 讨论一下SLAM应用场景及落地的问题。大家觉得SLAM技术最适合的应用场景是什么？在哪个场景能够最快技术落地呢？"></a>2. 讨论一下SLAM应用场景及落地的问题。大家觉得SLAM技术最适合的应用场景是什么？在哪个场景能够最快技术落地呢？</h4><h1 id="十一-大疆笔试题"><a href="#十一-大疆笔试题" class="headerlink" title="十一 大疆笔试题"></a>十一 大疆笔试题</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><ol>
<li><p>以下哪一种情况，可以认为双目视觉系统内参和双目间的相对旋转标定正确</p>
<p>A. 计算标定时采集的pattern重投影误差，数值相对较小</p>
<p>B. 使用双目拍摄远处的雪山，无论怎么移动相机，在recify图像上，雪山在左右成像位置相同，但亮度差异较大</p>
<p>C. 使用双目拍摄远处的车辆，无论怎么移动相机，在recify图像上，车辆在左右成像尽在x方向有disparity；</p>
<p>D. 使用双目拍摄远处的彩虹，无论怎么移动相机，在recify图像上，彩虹在左右成像的亮度没有差异</p>
</li>
</ol>
<p>   答：C</p>
<ol start="2">
<li><p>以下哪些相机模型不适用与FOV约180度鱼眼相机投影关系（r为像高，f为焦距，$\theta$为光线到光心的理想入射角）</p>
<p>A.  针孔相机模型 像高表示为$r=f\tan(\theta)$</p>
<p>B.  等距投影模型 像高表示为$r=f\theta$</p>
<p>C.  等立体角投影 像高表示为$r=2 f\sin(\theta)$</p>
<p>D.  正交投影模型 像高表示为$r=f\sin(\theta)$</p>
</li>
</ol>
<ol start="3">
<li><p>以下哪些做法有助于神经网络过拟合</p>
<p>A. 使用更深的网络以提升泛华性</p>
<p>B. 进行数据增强以增加数据的多样性</p>
<p>C. 加入dropout模块以增加训练过程的随机性</p>
<p>D. 使用leaky relu 取代relu避免特征损失过多</p>
<p>答：BCD </p>
</li>
</ol>
<ol start="4">
<li><p>以下哪些手段可以提升重复纹理环境的定位感知能力</p>
<p>A.  调整SGBM的参数，增大平滑项的权重</p>
<p>B.  VIO后端增加robust norm 降低feature误匹配带来的误差</p>
<p>C. 对原图进行高斯滤波，降低重复纹理的梯度</p>
<p>D. 对depth增加时域的滤波，降低depth误匹配的影响</p>
<p>答：获取更多的训练数据;    减小网络容量; 添加权重正则化;  添加dropout.</p>
</li>
</ol>
<h2 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h2><ol>
<li><p>SIFT是图像的全局特征，具有尺度不变和旋转不变性（错）</p>
</li>
<li><p>训练卷积神经网络时，可以对输入进行旋转、平移、缩放、翻转等预处理提高模型泛化能力（对）</p>
</li>
<li><p>Hough变换可以用来在图像中进行形状提取（）</p>
</li>
<li><p>牛顿迭代法的基本思想是使用泰勒技术展开式去近似地代替非线性回归函数，然后通过多次迭代，多次修正回归系数，使回归系数不断逼近非线性回归模型的最佳系数，最后使原模型的残差平方和达到最小（）</p>
</li>
</ol>
<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><p>一：</p>
<p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200818000618164.png" alt="image-20200818000618164"></p>
<p>二： 卡尔曼滤波</p>
<p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200818000645583.png" alt="image-20200818000645583"></p>
<p>三 </p>
<p><img src="/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200818000939557.png" alt="image-20200818000939557"></p>
<h1 id="面试经历"><a href="#面试经历" class="headerlink" title="面试经历"></a>面试经历</h1><h2 id="一-美团"><a href="#一-美团" class="headerlink" title="一 美团"></a>一 美团</h2>
      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://grobenis.github.io/2020/08/06/SLAM%E9%9D%A2%E8%AF%95%E9%A2%98/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SLAM/" rel="tag">SLAM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VIO/" rel="tag">VIO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/08/10/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%E5%8E%9F%E7%90%86/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            相机标定原理
          
        </div>
      </a>
    
    
      <a href="/2020/08/06/SLAM-%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">SLAM-三维空间刚体运动</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2021
        guoben
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/cat.ico" alt="曾是少年"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/project">项目</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/pay/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/share.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['曾梦想仗剑走天涯', '愿你出走半生，归来仍是少年', '一杯敬朝阳，一杯敬月光'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>




<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/js/ayer.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>